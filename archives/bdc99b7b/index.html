<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>堆基础知识 | SkYe231 Blog</title><meta name="keywords" content="堆"><meta name="author" content="SkYe231"><meta name="copyright" content="SkYe231"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="堆概述 内容绝大部分来自ctf-wiki，文章用于自己学习记录  什么是堆在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存^1。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。 堆管理器处于用户程序与内核中间，主要做以下工作  响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持">
<meta property="og:type" content="article">
<meta property="og:title" content="堆基础知识">
<meta property="og:url" content="https://www.mrskye.cn/archives/bdc99b7b/index.html">
<meta property="og:site_name" content="SkYe231 Blog">
<meta property="og:description" content="堆概述 内容绝大部分来自ctf-wiki，文章用于自己学习记录  什么是堆在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存^1。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。 堆管理器处于用户程序与内核中间，主要做以下工作  响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.mrskye.cn/img/default_cover2.png">
<meta property="article:published_time" content="2020-07-04T16:16:26.000Z">
<meta property="article:modified_time" content="2021-04-08T05:57:16.819Z">
<meta property="article:author" content="SkYe231">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.mrskye.cn/img/default_cover2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.mrskye.cn/archives/bdc99b7b/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="cEoYWheDVkHH-Yp4JSBTTpaID2pIW7q58RgTg6h1iOs"/><meta name="baidu-site-verification" content="code-Xeczgxl48H"/><meta name="360-site-verification" content="95a7ddcc661de175b37bc99a62cf5c9e"/><meta name="yandex-verification" content="fc0ae24e23c94b47"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?8184ae9371af7cedfa47d27c247e16b8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-154693872-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-154693872-1');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"这篇文章距离上次更新已经","messageNext":"天，内容可能已经过时了。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: SkYe231","link":"链接: ","source":"来源: SkYe231 Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-08 13:57:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="SkYe231 Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">140</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-wrench"></i><span> 工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://mrskye.gitee.io/cyberchef/"><i class="fa-fw fas fa-key"></i><span> cyberchef</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://travellings.now.sh/"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_cover2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">SkYe231 Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-wrench"></i><span> 工具</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://mrskye.gitee.io/cyberchef/"><i class="fa-fw fas fa-key"></i><span> cyberchef</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://travellings.now.sh/"><i class="fa-fw fas fa-subway"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/atom.xml"><i class="fa-fw fas fa-rss"></i><span> RSS</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">堆基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-07-04T16:16:26.000Z" title="发表于 2020-07-05 00:16:26">2020-07-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-08T05:57:16.819Z" title="更新于 2021-04-08 13:57:16">2021-04-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>116分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="堆基础知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h1><blockquote>
<p>内容绝大部分来自ctf-wiki，文章用于自己学习记录</p>
</blockquote>
<h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>在程序运行过程中，<strong>堆可以提供动态分配的内存</strong>，允许程序申请大小未知的内存<a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。</p>
<p>堆管理器处于用户程序与内核中间，主要做以下工作</p>
<ol>
<li>响应用户的申请内存请求，向操作系统<strong>申请内存</strong>，然后将其返回给用户程序。同时，为了保持内存管理的高效性，<strong>内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互</strong>。</li>
<li><strong>管理用户所释放的内存</strong>。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li>
</ol>
<p>Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。</p>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p>
<p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><p>这里我们主要介绍</p>
<ul>
<li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用</li>
<li>介绍堆目前的多线程支持。</li>
</ul>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>在 glibc 的 <a target="_blank" rel="noopener" href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448">malloc.c</a> 中，malloc 的说明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  malloc(size_t n)</span><br><span class="line">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span><br><span class="line">  if no space is available. Additionally, on failure, errno is</span><br><span class="line">  set to ENOMEM on ANSI C systems.</span><br><span class="line">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span><br><span class="line">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span><br><span class="line">  systems.)  On most systems, size_t is an unsigned type, so calls</span><br><span class="line">  with negative arguments are interpreted as requests for huge amounts</span><br><span class="line">  of space, which will often fail. The maximum supported value of n</span><br><span class="line">  differs across systems, but is in all cases less than the maximum</span><br><span class="line">  representable value of a size_t.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>可以看出，malloc 函数返回对应大小字节的内存块的<strong>指针</strong><a href="%E5%AE%9E%E9%99%85%E4%B8%8A%E8%BF%98%E9%9C%80%E8%BF%9B%E8%A1%8C%E5%AF%B9%E9%BD%90%E7%AD%89%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%86%85%E5%AD%98%E5%9D%97%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E5%AF%B9%E5%BA%94%E5%A4%A7%E5%B0%8F%E7%9A%84">^2</a>。此外，该函数还对一些异常情况进行了处理</p>
<ul>
<li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是<code>无符号数</code>（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>在 glibc 的 <a target="_blank" rel="noopener" href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465">malloc.c</a> 中，free 的说明如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">      free(void* p)</span><br><span class="line">      Releases the chunk of memory pointed to by p, that had been previously</span><br><span class="line">      allocated using malloc or a related routine such as realloc.</span><br><span class="line">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span><br><span class="line">      effects if p has already been freed.</span><br><span class="line">      Unless disabled (using mallopt), freeing very large spaces will</span><br><span class="line">      when possible, automatically trigger operations that give</span><br><span class="line">      back unused memory to the system, thus reducing program footprint.</span><br><span class="line">    *&#x2F;</span><br></pre></td></tr></table></figure>

<p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p>
<p>此外，该函数也同样对异常情况进行了处理</p>
<ul>
<li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li>
<li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li>
<li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。<a href="%E8%BF%98%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE%E5%86%85%E5%AD%98%E5%9D%97%E7%9A%84%E7%89%A9%E7%90%86%E4%BD%8D%E7%BD%AE%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%BF%98%E7%BB%99%E7%B3%BB%E7%BB%9F">^3</a></li>
</ul>
<h3 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h3><p>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。[^4]</p>
<p>[^4]:也就是相当于 malloc 是一个整合包，打包好实现申请堆块需要用到的所有函数。类似的函数还有 system 等</p>
<p>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p>
<p><img src= "/img/loading.gif" data-lazy-src="img/brk&mmap.png" alt="brk&amp;mmap.png"></p>
<h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sbrk">brk</a> 的大小来向操作系统申请内存。</p>
<p>初始时，堆的起始地址 <a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">start_brk</a> 以及堆的当前末尾 <a target="_blank" rel="noopener" href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a> 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li>
</ul>
<p>具体效果如下图（这个图片与网上流传的基本一致，这里是因为要画一张大图，所以自己单独画了下）所示</p>
<p><img src= "/img/loading.gif" data-lazy-src="img/program_virtual_address_memory_space.png" alt="program_virtual_address_memory_space.png"></p>
<p><strong>例子</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc sbrk_brk_example.c -m32 -o ./sbrk_brk_example</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在每一次执行完操作后，都执行了 getchar() 函数，这是为了我们方便我们查看程序真正的映射。</p>
<p><strong>在第一次调用 brk 之前</strong></p>
<p>从下面的输出可以看出，并没有出现堆。因此</p>
<ul>
<li>start_brk = brk = end_data = 0x806c000</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="img/chunk0.png" alt="chunk0.png"></p>
<p><strong>第一次增加 brk 后</strong></p>
<p>从下面的输出可以看出，已经出现了堆段</p>
<ul>
<li>start_brk = end_data = 0x806c000</li>
<li>brk = 0x806d000</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="img/chunk1.png" alt="chunk1.png"></p>
<p>其中，关于堆的那一行</p>
<ul>
<li>0x806c000是相应堆的起始地址</li>
<li>rw-p 表明堆具有可读可写权限，并且属于隐私数据。</li>
<li>00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
<li>00:00 是主从 (Major/mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为 0。</li>
<li>0 表示着 Inode 号。由于这部分内容并不是从文件中映射得到的，所以为 0。</li>
</ul>
<p>然后通过 <code>brk(tmp_brk);</code> 将指针归位回到 0x806c000 ，新出现的 heap 消失。具体和第一步图一样，不贴图了。</p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285">mmap</a> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p>
<p><strong>例子</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private anonymous mapping example using mmap syscall */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">errExit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">char</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">        addr = mmap(<span class="literal">NULL</span>, (<span class="keyword">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">                errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unmap mapped region. */</span></span><br><span class="line">        ret = munmap(addr, (<span class="keyword">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After munmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在执行 mmap 之前</strong></p>
<p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<p><strong>mmap 后</strong></p>
<p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e00000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure>

<p><strong>munmap</strong></p>
<p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;syscalls$ cat &#x2F;proc&#x2F;6067&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;syscalls&#x2F;mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;syscalls&#x2F;mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;syscalls&#x2F;mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;syscalls$</span><br></pre></td></tr></table></figure>

<h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p>
<p>这里给出一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Per thread arena example. *&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"></span><br><span class="line">void* threadFunc(void* arg) &#123;</span><br><span class="line">        printf(&quot;Before malloc in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        char* addr &#x3D; (char*) malloc(1000);</span><br><span class="line">        printf(&quot;After malloc and before free in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(addr);</span><br><span class="line">        printf(&quot;After free in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">        pthread_t t1;</span><br><span class="line">        void* s;</span><br><span class="line">        int ret;</span><br><span class="line">        char* addr;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Welcome to per thread arena example::%d\n&quot;,getpid());</span><br><span class="line">        printf(&quot;Before malloc in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        addr &#x3D; (char*) malloc(1000);</span><br><span class="line">        printf(&quot;After malloc and before free in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(addr);</span><br><span class="line">        printf(&quot;After free in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        ret &#x3D; pthread_create(&amp;t1, NULL, threadFunc, NULL);</span><br><span class="line">        if(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;Thread creation error\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ret &#x3D; pthread_join(t1, &amp;s);</span><br><span class="line">        if(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;Thread join error\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure>

<p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000=0x21000 个字节的堆。<strong>这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;lsploits&#x2F;hof&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure>

<p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;lsploits&#x2F;hof&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure>

<p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure>

<p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为 mmap 函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 thread arena。</p>
<p>注意：</p>
<blockquote>
<p>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure>

<p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">After free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure>

<h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><blockquote>
<p>内容绝大部分来自ctf-wiki，文章用于自己学习记录</p>
</blockquote>
<p>堆的操作就这么复杂，那么在 glibc 内部必然也有精心设计的数据结构来管理它。与堆相应的数据结构主要分为</p>
<ul>
<li>宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。</li>
<li>微观结构，用于具体处理堆的分配与回收中的内存块。</li>
</ul>
<h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><h3 id="32位内存布局"><a href="#32位内存布局" class="headerlink" title="32位内存布局"></a>32位内存布局</h3><p><img src= "/img/loading.gif" data-lazy-src="img%5C32mem.png" alt="32位内存布局"></p>
<p>从高地址到低地址为：不可访问的内核空间，栈空间（由高地址向低地址生长），内存布局区，堆空间（由低地址向高地址生长），BSS，数据段，文本段。本报告讨论进程的栈空间和堆空间的具体结构。</p>
<h3 id="64位内存布局"><a href="#64位内存布局" class="headerlink" title="64位内存布局"></a>64位内存布局</h3><p>用户空间的布局和32位差别很小。</p>
<p><img src= "/img/loading.gif" data-lazy-src="img%5C64mem.png" alt="64位内存布局"></p>
<h3 id="堆管理介绍"><a href="#堆管理介绍" class="headerlink" title="堆管理介绍"></a>堆管理介绍</h3><h4 id="3-种数据结构"><a href="#3-种数据结构" class="headerlink" title="3 种数据结构"></a>3 种数据结构</h4><p>在 <code>glibc</code> 的 <code>malloc</code> 中针对堆管理，主要涉及到以下 3 种数据结构：</p>
<ul>
<li>heap_info（即Heap Header）对应管理 heap</li>
<li>malloc_state（即Arena Header） 对应管理 area</li>
<li>malloc_chunk（即Chunk Header） 对应管理 chunk</li>
</ul>
<blockquote>
<p>这里堆管理会出现在多线程，一般pwn题不会涉及多线程操作，也就是都是在 main_area 上操作，因此可选择性阅读 heap_info、malloc_state。</p>
</blockquote>
<h5 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h5><p>heap_info: 即Heap Header，因为一个<strong>thread arena</strong>（注意：不包含<strong>main thread</strong>）可以包含多个heaps，所以为了便于管理，就给每个 heap 分配一个 heap  header。那么在什么情况下一个thread arena会包含多个 heaps 呢?在当前 heap 不够用的时候，malloc 会通过系统调用 mmap 申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>

<h6 id="Arena-数量限制"><a href="#Arena-数量限制" class="headerlink" title="Arena 数量限制"></a>Arena 数量限制</h6><p>主线程和子线程有自己独立的 <em>arena</em>，那么是不是无论有多少个线程，每个线程都有自己独立的 <em>arena</em> 呢？答案是否定的。事实上，<em>arena</em>的个数是跟系统中处理器核心个数相关的，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">systems</th>
<th align="center">number of arena</th>
</tr>
</thead>
<tbody><tr>
<td align="center">32bits</td>
<td align="center">2 x number of cpu cores + 1</td>
</tr>
<tr>
<td align="center">64bits</td>
<td align="center">8 x number of cpu cores + 1</td>
</tr>
</tbody></table>
<h6 id="Arena-管理"><a href="#Arena-管理" class="headerlink" title="Arena 管理"></a>Arena 管理</h6><p>假设有如下情景：一台只含有一个处理器核心的机器安装有 32 位操作系统，其上运行了一个多线程应用程序，共含有 4 个线程——主线程和三个子线程。显然线程个数大于系统能维护的最大 <em>arena</em> 个数（2 x 核心数 + 1= 3），那么此时 <code>glibc</code> 的 <code>malloc</code> 就需要确保这 4 个线程能够正确地共享这 3 个 <em>arena</em>，那么它是如何实现的呢？</p>
<p>当主线程首次调用 <code>malloc</code> 的时候会直接为它分配一个 <em>main arena</em>，而不需要任何附加条件。</p>
<p>当子线程 1 和子线程 2 首次调用 <code>malloc</code> 的时候，<code>glibc</code> 实现的 <code>malloc</code> 会分别为每个子线程创建一个新的 <em>thread arena</em>。此时，各个线程与 <em>arena</em> 是一一对应的。但是，当用户线程 3 调用 <code>malloc</code> 的时候就出现问题了。因为此时 <code>glibc</code> 的 <code>malloc</code> 能维护的 <em>arena</em> 个数已经达到上限，无法再为子线程 3 分配新的 <em>arena</em> 了，那么就需要重复使用已经分配好的 3 个 <em>arena</em> 中的一个（<em>main arena</em>, <em>arena1</em> 或者 <em>arena2</em>）。那么该选择哪个 <em>arena</em> 进行重复利用呢？<code>glibc</code> 的 <code>malloc</code> 遵循以下规则：</p>
<ol>
<li>首先循环遍历所有可用的 <em>arena</em>，在遍历的过程中，它会尝试加锁该 <em>arena</em>。如果成功加锁（该 <em>arena</em> 当前对应的线程并未使用堆内存则表示可加锁），比如将 <em>main arena</em> 成功锁住，那么就将 <em>main arena</em> 返回给用户，即表示该 <em>arena</em> 被子线程 3 共享使用。</li>
<li>如果没能找到可用的 <em>arena</em>，那么就将子线程 3 的 <code>malloc</code> 操作阻塞，直到有可用的 <em>arena</em> 为止。</li>
<li>现在，如果子线程 3 再次调用 <code>malloc</code> 的话，<code>glibc</code> 的 <code>malloc</code> 就会先尝试使用最近访问的 <em>arena</em>（此时为 <em>main arena</em>）。如果此时 <em>main arena</em> 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 <em>main arena</em> 再次可用为止。</li>
</ol>
<p>这样子线程 3 与主线程就共享 <em>main arena</em> 了。至于其他更复杂的情况，以此类推。</p>
<h5 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h5><p>malloc_state: 即Arena Header，用于表示 area 的信息，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等(这些概念会在后文详细介绍):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h5><p>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size_t size)传递的size参数“就是”chunk的大小(这里给“就是”加上引号，说明这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文)。每个chunk都由一个结构体malloc_chunk表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. 这两个指针只在free chunk中存在*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关于上述的结构（malloc_chunk主线程也用到），针对子线程的，主线程和子线程有一些不同：</p>
<ol>
<li>主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 <em>heap</em> 所以也就不含有 <code>heap_info</code> 结构体。当需要更多堆空间的时候，直接通过增长 <code>brk</code> 指针来获取更多的空间，直到它碰到内存映射区域（mapping）为止。</li>
<li>不同于 <em>thread arena</em>，主线程的 <em>main arena</em> 的 <em>arena header</em> 并不在堆区中，而是一个全局变量，因此它属于 <code>libc.so</code> 的 data segment 区域。</li>
</ol>
<h4 id="heap-segment与arena关系"><a href="#heap-segment与arena关系" class="headerlink" title="heap segment与arena关系"></a>heap segment与arena关系</h4><p>首先，通过内存分布图理清malloc_state与heap_info之间的组织关系。</p>
<p>下图是只有一个heap segment的main arena和thread arena的内存分布图：</p>
<p>![heap segment](img\heap segment.png)</p>
<p>下图是一个thread arena中含有多个heap segments的情况：</p>
<p>![heap segments](img\heap segments.png)</p>
<p>从上图可以看出，thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p>
<h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><h3 id="chunk-介绍"><a href="#chunk-介绍" class="headerlink" title="chunk 介绍"></a>chunk 介绍</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在 glibc malloc 中将整个堆内存空间分成了连续的、大小不一的 chunk ，即对于堆内存管理而言 chunk 就是最小操作单位。<em>chunk</em> 总共分为 4 大类：</p>
<ul>
<li><em>allocated chunk</em></li>
<li><em>free chunk</em></li>
<li><em>top chunk</em></li>
<li><em>last remainder chunk</em></li>
</ul>
<p>从本质上来说，所有类型的 <em>chunk</em> 都是内存中一块连续的区域，只是通过该区域中特定位置的某些标识符加以区分。为了简便，也可以将这 4 大类 <em>chunk</em> 简化为 2 类：<em>allocated chunk</em> 以及 <em>free chunk</em>，前者表示已经分配给用户使用的 <em>chunk</em>，后者表示未使用的 <em>chunk</em>。</p>
<p>任何堆内存管理器都是以 <em>chunk</em> 为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已分配块和空闲块。大多数堆内存管理器都将这些边界信息作为 <em>chunk</em> 的一部分嵌入到 <em>chunk</em> 内部。</p>
<p><strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构（malloc_chunk）。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</strong></p>
<h4 id="malloc-chunk-allocated-chunk"><a href="#malloc-chunk-allocated-chunk" class="headerlink" title="malloc_chunk (allocated chunk)"></a>malloc_chunk (allocated chunk)</h4><p>malloc_chunk 的结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p>
<p>每个字段的具体的解释如下</p>
<ul>
<li><p><strong>prev_size</strong></p>
<p>如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</p>
</li>
<li><p><strong>size</strong></p>
<p>该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</p>
<ul>
<li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li>
<li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li>
<li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li>
</ul>
</li>
<li><p><strong>fd，bk</strong></p>
<p>chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<ul>
<li>fd 指向下一个（非物理相邻）空闲的 chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的 chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
</ul>
</li>
<li><p><strong>fd_nextsize， bk_nextsize</strong></p>
<p>也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p>
<ul>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul>
</li>
</ul>
<p>一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</strong></p>
<p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p>
<p>已经被分配使用的 <em>chunk</em> 结构如下两个图：（图一图二 size 位 A 与 N 相同含义只是表示不同）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">chunk-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line"><span class="meta">  mem-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line"><span class="meta">chunk-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="img%5Callocated-chunk.png" alt="allocated chunk"></p>
<h4 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free_chunk"></a>free_chunk</h4><p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">chunk-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line"><span class="meta">  mem-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line"><span class="meta">chunk-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">`foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>

<p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ol>
<li>本身的 size 字段会记录。（图中最后一行 size 位）</li>
<li>它后面的 chunk 会记录。（图中倒数第二行 nextchunk 的 prevsize 位） </li>
</ol>
<p><strong>一般情况下</strong>（fastbin中存在特例），物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p>
<p><strong>！！！一些关于堆的约束，后面详细考虑！！！</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The three exceptions to all this are:</span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">    trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">    that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">    is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">    MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">    bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">    allocated one-by-one, each must contain its own trailing size</span></span><br><span class="line"><span class="comment">    field.  If the M bit is set, the other bits are ignored</span></span><br><span class="line"><span class="comment">    (because mmapped chunks are neither in an arena, nor adjacent</span></span><br><span class="line"><span class="comment">    to a freed chunk).  The M bit is also used for chunks which</span></span><br><span class="line"><span class="comment">    originally came from a dumped heap via malloc_set_state in</span></span><br><span class="line"><span class="comment">    hooks.c.</span></span><br><span class="line"><span class="comment">     3. Chunks in fastbins are treated as allocated chunks from the</span></span><br><span class="line"><span class="comment">    point of view of the chunk allocator.  They are consolidated</span></span><br><span class="line"><span class="comment">    with their neighbors only in bulk, in malloc_consolidate.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>glibc 中对于 top chunk 的描述如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure>

<p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。<strong>top chunk 不属于任何一个 bin</strong>，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果 <em>top chunk</em> 大小不小于用户请求的大小，就将该 <em>top chunk</em> 分作两部分：用户请求的 <em>chunk</em> 和 剩余的部分（成为新的 <em>top chunk</em>）。否则，就对 heap 进行扩展后再进行分配。在 <em>main arena</em> 中通过 <code>sbrk</code> 扩展 <em>heap</em>，而在<em>thread arena</em> 中通过 <code>mmap</code> 分配新的 <em>heap</em>。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p>
<p><strong>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</strong></p>
<h4 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h4><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk （bin中的chunk）可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为 last remainder。</p>
<h4 id="chunk-相关宏"><a href="#chunk-相关宏" class="headerlink" title="chunk 相关宏"></a>chunk 相关宏</h4><p>这里主要介绍 chunk 的大小、对齐检查以及一些转换的宏。</p>
<p><strong>chunk 与 mem 指针头部的转换</strong></p>
<p>mem 指向用户得到的内存的起始位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span></span><br></pre></td></tr></table></figure>

<p><strong>最小的 chunk 大小</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>

<p>这里，offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含 bk 指针。</p>
<p><strong>最小申请的堆内存大小</strong></p>
<p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p>
<p><strong>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的，个人认为之所以要添加两个宏是为了方便以后修改 malloc_chunk 时方便一些。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span><br><span class="line">                      ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure>

<p><strong>检查分配给用户的内存是否对齐</strong></p>
<p>2 * SIZE_SZ 大小对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line">    ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="line">     MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>

<p><strong>请求字节数判断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T)(<span class="number">-2</span> * MINSIZE))</span><br></pre></td></tr></table></figure>

<p><strong>将用户请求内存大小转为实际分配内存大小</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span><br><span class="line">        __set_errno(ENOMEM);                                                   \</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                                              \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">    (sz) = request2size(req);</span><br></pre></td></tr></table></figure>

<p>当一个 chunk 处于已分配状态时，它的物理相邻的下一个 chunk 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 chunk 使用。这就是 ptmalloc 中 chunk 间的复用。具体流程如下</p>
<ol>
<li>首先，利用 REQUEST_OUT_OF_RANGE 判断是否可以分配用户请求的字节大小的 chunk。</li>
<li>其次，需要注意的是用户请求的字节是用来存储数据的，即 chunk header 后面的部分。与此同时，由于 chunk 间复用，所以可以使用下一个 chunk 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ 大小即可以完全存储内容。</li>
<li>由于系统中所允许的申请的 chunk 最小是 MINSIZE，所以与其进行比较。如果不满足最低要求，那么就需要直接分配 MINSIZE 字节。</li>
<li>如果大于的话，因为系统中申请的 chunk 需要 2 * SIZE_SZ 对齐，所以这里需要加上 MALLOC_ALIGN_MASK 以便于对齐。</li>
</ol>
<p><strong>个人认为，这里在 request2size 的宏的第一行中没有必要加上 MALLOC_ALIGN_MASK。</strong></p>
<p><strong>需要注意的是，通过这样的计算公式得到的 size 最终一定是满足用户需要的。</strong></p>
<p><strong>标记位相关</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>

<p><strong>获取 chunk size</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>

<p><strong>获取下一个物理相邻的 chunk</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>

<p><strong>获取前一个 chunk 的信息</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure>

<p><strong>当前 chunk 使用状态相关操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)                                                           \</span></span><br><span class="line">    ((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p)                                                         \</span></span><br><span class="line">    ((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br></pre></td></tr></table></figure>

<p><strong>设置 chunk 的 size 字段</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="comment">// SIZE_BITS = 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head_size(p, s)                                                    \</span></span><br><span class="line">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s) ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)                                                         \</span></span><br><span class="line">    (((mchunkptr)((<span class="keyword">char</span> *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br></pre></td></tr></table></figure>

<p><strong>获取指定偏移的 chunk</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>

<p><strong>指定偏移处 chunk 使用状态相关操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span></span><br><span class="line">    (((mchunkptr)(((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                                          \</span></span><br><span class="line">    (((mchunkptr)(((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                                        \</span></span><br><span class="line">    (((mchunkptr)(((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br></pre></td></tr></table></figure>

<h3 id="bin-介绍"><a href="#bin-介绍" class="headerlink" title="bin 介绍"></a>bin 介绍</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>我们曾经说过，用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，相似大小的 chunk 会用双（单）向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk 。</p>
<p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure>

<p>一个 bin 相当于一个 chunk 链表，我们把每个链表的头节点 chunk 作为 bins 数组，但是由于这个头节点作为 bin 表头，其 prev_size 与 size 字段是没有任何实际作用的，因此我们在存储头节点 chunk 的时候仅仅只需要存储头节点 chunk 的 fd 和 bk 即可，而其中的 prev_size 与 size 字段被重用为另一个 bin 的头节点的 fd 与 bk，这样可以节省空间，并提高可用性。因此<strong>我们仅仅只需要 mchunkptr 类型的指针数组就足够存储这些头节点</strong>，那 prev_size 与 size 字段到底是怎么重用的呢？这里我们以 32 位系统为例</p>
<table>
<thead>
<tr>
<th align="left">含义</th>
<th align="left">bin1 的 fd/bin2 的 prev_size</th>
<th align="left">bin1 的 bk/bin2 的 size</th>
<th align="left">bin2 的 fd/bin3 的 prev_size</th>
<th align="left">bin2 的 bk/bin3 的 size</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bin 下标</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
</tbody></table>
<p>可以看出除了第一个 bin（unsorted bin）外，后面的每个 bin 的表头 chunk 会重用前面的 bin 表头 chunk 的 fd 与 bk 字段，将其视为其自身的 prev_size 和 size 字段。这里也说明了一个问题，<strong>bin 的下标和我们所说的第几个 bin 并不是一致的。同时，bin 表头的 chunk 头节点 的 prev_size 与 size 字段不能随便修改，因为这两个字段是其它 bin 表头 chunk 的 fd 和 bk 字段。</strong></p>
<p>数组中的 bin 依次介绍如下</p>
<ol>
<li>（索引）第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li>
</ol>
<blockquote>
<p>在 <code>glibc</code> 中用于记录 <em>bin</em> 的数据结构有两种，分别为：</p>
<ul>
<li><code>fastbinsY</code>: 这是一个数组，用于记录所有的 <em>fast bin</em></li>
<li><code>bin</code> 数组: 这也是一个数组，用于记录除 <em>fast bin</em> 之外的所有 <em>bin</em> 。事实上这个数组共有 126 个元素，分别是:<ul>
<li><code>[1]</code> 为 <em>unsorted bin</em></li>
<li><code>[2~63]</code> 为 <em>small bin</em></li>
<li><code>[64~126]</code> 为 <em>large bin</em></li>
</ul>
</li>
</ul>
<p>回顾 <code>malloc_chunk</code> 的数据结构，其中的 <code>fd</code> 和 <code>bk</code> 指针就是指向当前 <em>chunk</em> 所属的链表中 <code>forward chunk</code> 或者 <code>backward chunk</code>，<strong>因此一般的 bin 是一个双向链表</strong>（有例外）。</p>
</blockquote>
<p>此外，上述这些 bin 的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲 chunk 不能在一起</strong>。</p>
<p>需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内。<strong>而且，fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。</strong></p>
<p>bin 通用的宏如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i)                                                           \</span></span><br><span class="line">    (mbinptr)(((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[ ((i) <span class="number">-1</span>) * <span class="number">2</span> ])) -                        \</span><br><span class="line">              offsetof(struct malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">//获取下一个bin的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 这两个宏可以用来遍历bin</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表头的 chunk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表尾的 chunk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b) ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure>

<h4 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h4><p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中。</strong>因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Fastbins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of lists holding recently freed small chunks.  Fastbins</span></span><br><span class="line"><span class="comment">    are not doubly linked.  It is faster to single-link them, and</span></span><br><span class="line"><span class="comment">    since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment">    double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment">    are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment">    fastbins are normally used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This is in malloc_state.</span></span><br><span class="line"><span class="comment">    /* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>为了更加高效地利用 fast bin，glibc 采用<strong>单向链表</strong>对其中的每个 bin 进行组织(只使用 <code>fd</code> 指针)，并且<strong>每个 bin 采取 LIFO 策略（后进先出）</strong>，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc 才会做接下来的一系列操作。</p>
<blockquote>
<p><em>fast bin</em> 中无论是添加还是移除 <em>fast chunk</em>，都是对“链表尾”进行操作，而不会对某个中间的 <em>fast chunk</em> 进行操作。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="img%5Cfast-bin.png" alt="fast bin"></p>
<p>默认情况下（<strong>32 位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， <strong>fastbin 最多可以支持的 bin 的个数为 10 个</strong>，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 prev_size 和 size 字段部分的大小）定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Since the lowest 2 bits in max_fast don&#x27;t matter in size comparisons,</span></span><br><span class="line"><span class="comment">   they are used as flags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//判断分配区是否有 fast bin chunk，1表示没有</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// MORECORE是否返回连续的内存区域。</span></span><br><span class="line"><span class="comment">// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间</span></span><br><span class="line"><span class="comment">// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</span></span><br><span class="line"><span class="comment">// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Set value of max_fast.</span></span><br><span class="line"><span class="comment">   Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">   Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment">   Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s)                                                        \</span></span><br><span class="line">    global_max_fast =                                                          \</span><br><span class="line">        (((s) == <span class="number">0</span>) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure>

<p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</p>
<blockquote>
<p>那么 <code>malloc</code> 操作具体如何处理 <em>fast chunk</em> 呢？</p>
<p>当用户通过 <code>malloc</code> 请求的大小属于 <em>fast chunk</em> 的大小范围（注意：用户请求 size 加上 16 字节就是实际内存 <em>chunk size</em>）。在初始化的时候 <em>fast bin</em> 支持的最大内存大小以及所有 <em>fast bin</em> 链表都是空的，所以当最开始使用 <code>malloc</code> 申请内存的时候，即使申请的内存大小属于 <em>fast chunk</em> 的内存大小（即 16 到 80 字节），它也不会交由 <em>fast bin</em> 来处理，而是向下传递交由 <em>small bin</em> 来处理，如果 <em>small bin</em> 也为空的话就交给 <em>unsorted bin</em> 处理。那么 <em>fast bin</em> 是在哪？怎么进行初始化的呢？</p>
<p>当我们第一次调用 <code>malloc</code> 的时候，系统执行 <code>_int_malloc</code> 函数，该函数首先会发现当前 <em>fast bin</em> 为空，就转交给 <em>small bin</em> 处理，进而又发现 <em>small bin</em> 也为空，就调用 <code>malloc_consolidate</code> 函数对 <code>malloc_state</code> 结构体进行初始化，<code>malloc_consolidate</code> 函数主要完成以下几个功能：</p>
<ul>
<li>首先判断当前 <code>malloc_state</code> 结构体中的 <em>fast bin</em> 是否为空，如果为空就说明整个 <code>malloc_state</code> （<em>arena</em>）都没有完成初始化，需要对 <code>malloc_state</code> 进行初始化。</li>
<li><code>malloc_state</code> 的初始化操作由函数 <code>malloc_init_state(av)</code> 完成，该函数先初始化除 <em>fast bin</em> 之外的所有的 <em>bin</em> (构建双链表，详情见后文<code>small bins</code>介绍)，再初始化 <em>fast bins</em>。</li>
<li>当再次执行 <code>malloc</code> 函数的时候，此时 <em>fast bin</em> 相关数据不为空了，就开始使用 <em>fast bin</em>，这部分代码如下：</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//第一次执行malloc(fast chunk)时这里判断为false，因为此时get_max_fast ()为0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// use fast bin</span></span><br><span class="line">      idx = fastbin_index (nb);     </span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// remove chunk from fast bin    </span></span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))!= victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>得到第一个来自于 <em>fast bin</em> 的 <em>chunk</em> 之后，系统就将该 <em>chunk</em> 从对应的 <em>fast bin</em> 中移除，并将其地址返回给用户。</p>
</blockquote>
<p><strong>fastbin 的索引</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">// chunk size=2*size_sz*(2+idx)</span></span><br><span class="line"><span class="comment">// 这里要减2，否则的话，前两个bin没有办法索引到。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><strong>需要特别注意的是，fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的 chunk 合并。</strong></p>
<p>但是当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，内存碎片可能比较多了，我们就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">   that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">   fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">   matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">   compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">   to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">   consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">   if trimming is not used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure>

<p><strong>malloc_consolidate 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。具体地参见后续的详细函数的分析。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h4><p>small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p>
<table>
<thead>
<tr>
<th align="center">下标</th>
<th align="center">SIZE_SZ=4（32 位）</th>
<th align="center">SIZE_SZ=8（64 位）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2</td>
<td align="center">16</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">24</td>
<td align="center">48</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">32</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">40</td>
<td align="center">80</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">2*4*x</td>
<td align="center">2*8*x</td>
</tr>
<tr>
<td align="center">63</td>
<td align="center">504</td>
<td align="center">1008</td>
</tr>
</tbody></table>
<p>small bins 中一共有 62 个<strong>循环双向链表，每个链表中存储的 chunk 大小都一致</strong>。比如对于 32 位系统来说，下标 2 对应的双向链表中存储的 chunk 大小为均为 16 字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong>（先进先出），所以同一个链表中先被释放的 chunk 会先被分配出去。<strong>物理地址相邻的 <em>free chunk</em> 需要进行合并操作，即合并成一个大的 <em>free chunk</em></strong> 。</p>
<blockquote>
<p>当释放 <em>small chunk</em> 的时候，先检查该 <em>chunk</em> 相邻的 <em>chunk</em> 是否为 <em>free chunk</em>，如果是的话就进行合并操作：将这些 <em>chunk</em> 合并成新的 <em>chunk</em> ，然后将它们从 <em>small bin</em> 中移除，最后将新的 <em>chunk</em> 添加到 <em>unsorted bin</em> 中。</p>
</blockquote>
<p>small bin 相关的宏如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment">// 是否需要对small bin的下标进行纠正</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="comment">//判断chunk的大小是否在small bin范围内</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)                                                  \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"><span class="comment">// 根据chunk的大小得到small bin对应的索引。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz)                                                     \</span></span><br><span class="line">    ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>)                          \</span><br><span class="line">                           : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>)) +                       \</span><br><span class="line">     SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure>

<p><strong>或许，大家会很疑惑，那 fastbin 与 small bin 中 chunk 的大小会有很大一部分重合啊，那 small bin 中对应大小的 bin 是不是就没有什么作用啊？</strong> 其实不然，fast bin 中的 chunk 是有可能被放到 small bin 中去的，我们在后面分析具体的源代码时会有深刻的体会。</p>
<h4 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h4><p>large bins 中一共包括 63 个 bin，<strong>每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内</strong>。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th align="left">组</th>
<th align="left">数量</th>
<th align="left">公差</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">32</td>
<td align="left">64B</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">16</td>
<td align="left">512B</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">8</td>
<td align="left">4096B</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">32768B</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">262144B</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">不限制</td>
</tr>
</tbody></table>
<p>这里我们以 32 位平台的 large bin 为例，第一个 large bin 的起始 chunk 大小为 512 字节，位于第一组，所以该 bin 可以存储的 chunk 的大小范围为 [512,512+64)。</p>
<p>关于 large bin 的宏如下，这里我们以 32 位平台下，第一个 large bin 的起始 chunk 大小为例，为 512 字节，那么 512&gt;&gt;6 = 8，所以其下标为 56+8=64。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>)                                     \</span><br><span class="line">         ? <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                              \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>)                                     \</span><br><span class="line">         ? <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>)                                     \</span><br><span class="line">         ? <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz)                                                     \</span></span><br><span class="line">    (SIZE_SZ == <span class="number">8</span> ? largebin_index_64(sz) : MALLOC_ALIGNMENT == <span class="number">16</span>             \</span><br><span class="line">                                                ? largebin_index_32_big(sz)    \</span><br><span class="line">                                                : largebin_index_32(sz))</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>large chunk</em> 可以添加、删除在 <em>large bin</em> 的任何一个位置。</p>
</li>
<li><p>鉴于同一个 <em>large bin</em> 中每个 <em>chunk</em> 的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个 <em>large bin</em> 中的所有 <em>chunk</em> 按照 <em>chunk size</em> 进行从大到小的排列：最大的 <em>chunk</em> 放在链表的前端，最小的 <em>chunk</em> 放在尾端。</p>
</li>
<li><p><em>large bin</em> 的 <code>free</code> （合并）操作类似于 <em>small bin</em>。</p>
</li>
<li><p><em>large bin</em> malloc （部分）操作：</p>
<p>如果尾端最小的 <em>chunk</em> 大于用户请求的大小的话，就将该 <em>chunk</em> 拆分为两个 <em>chunk</em>：前者返回给用户，大小等同于用户请求的大小；剩余的部分做为一个新的 <em>chunk</em> 添加到 <em>unsorted bin</em> 中。</p>
</li>
</ul>
<h4 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h4><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p>
<p>其在 glibc 中具体的说明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>从下面的宏我们可以看出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure>

<p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源</p>
<ul>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考上面的介绍。</li>
</ul>
<p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p>
<p>下面附上各类上述三类 <em>bin</em> 的逻辑：</p>
<p><img src= "/img/loading.gif" data-lazy-src="img%5Cunsorted-small-large-bin.jpg" alt="unsorted-small-large-bin"></p>
<h4 id="common-macro"><a href="#common-macro" class="headerlink" title="common macro"></a>common macro</h4><p>这里介绍一些通用的宏</p>
<p><strong>根据 chunk 的大小统一地获得 chunk 所在的索引</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_index(sz)                                                          \</span></span><br><span class="line">    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://murphypei.github.io/blog/2019/01/linux-heap">Linux 堆内存管理深入分析</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux">CTF-WIKI</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AliMobileSecurity/article/details/51384912">Linux堆内存管理深入分析(上半部)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/AliMobileSecurity/article/details/51481718">Linux堆内存管理深入分析(下半部)</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.lao-yuan.com/2018/05/29/Linux%E4%B8%8B%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html">Linux下堆栈结构分析</a></p>
</li>
</ul>
<h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><blockquote>
<p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p>
</blockquote>
<h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>unlink 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用</p>
<ul>
<li><p>malloc</p>
<ul>
<li><p>从恰好大小合适的 large bin 中获取 chunk。</p>
<ul>
<li><p><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink<a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>，这就是为什么漏洞会经常出现在它们这里的原因。</strong></p>
<p><a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>: smallbin malloc 没有 unlink free 时会有，详细看图对比 largebin 和 smallbin，图片太大，放图片链接：<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/heap.png">head</a></p>
</li>
<li><p>依次<strong>遍历处理</strong> unsorted bin 时也没有使用 unlink 。</p>
</li>
</ul>
</li>
<li><p>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</p>
</li>
</ul>
</li>
<li><p>free</p>
<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li><p>malloc_consolidate</p>
<ul>
<li>后向合并，合并物理相邻低地址空闲 chunk。</li>
<li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
<li><p>realloc</p>
<ul>
<li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li>
</ul>
</li>
</ul>
<p>由于 unlink 使用非常频繁，所以 unlink 被实现为了一个宏，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="comment">// unlink p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    <span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line">    FD = P-&gt;fd;                                                                      \</span><br><span class="line">    BK = P-&gt;bk;                                                                      \</span><br><span class="line">    <span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                      \</span><br><span class="line">        FD-&gt;bk = BK;                                                              \</span><br><span class="line">        BK-&gt;fd = FD;                                                              \</span><br><span class="line">        <span class="comment">// 下面主要考虑 P 对应的 nextsize 双向链表的修改</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                              \</span><br><span class="line">            <span class="comment">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span></span><br><span class="line">            <span class="comment">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span></span><br><span class="line">            <span class="comment">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span></span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      \</span><br><span class="line">            <span class="comment">// 类似于小的 chunk 的检查思路</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);                                              \</span><br><span class="line">            <span class="comment">// 这里说明 P 已经在 nextsize 链表中了。</span></span><br><span class="line">            <span class="comment">// 如果 FD 没有在 nextsize 链表中</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      \</span><br><span class="line">                <span class="comment">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span></span><br><span class="line">                <span class="comment">// 令 FD 为 nextsize 串起来的</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \</span><br><span class="line">                <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                <span class="comment">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span></span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \</span><br><span class="line">                  &#125;                                                              \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                <span class="comment">// 如果在的话，直接拿走即可</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \</span><br><span class="line">              &#125;                                                                      \</span><br><span class="line">          &#125;                                                                      \</span><br><span class="line">      &#125;                                                                              \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们以 small bin 的 unlink 为例子介绍一下。对于 large bin 的 unlink，与其类似，只是多了一个 nextsize 的处理。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/figure/unlink_smallbin_intro.png" alt="img"></p>
<p>可以看出， <strong>P 最后的 fd 和 bk 指针并没有发生变化</strong>，但是当我们去遍历整个双向链表时，已经遍历不到对应的链表了。这一点没有变化还是很有用处的，因为我们有时候可以使用这个方法来泄漏地址</p>
<ul>
<li>libc 地址<ul>
<li>P 位于双向链表头部，bk 泄漏</li>
<li>P 位于双向链表尾部，fd 泄漏</li>
<li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li>
</ul>
</li>
<li>泄漏堆地址，双向链表包含多个空闲 chunk<ul>
<li>P 位于双向链表头部，fd 泄漏</li>
<li>P 位于双向链表中，fd 和 bk 均可以泄漏</li>
<li>P 位于双向链表尾部，bk 泄漏</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。</li>
<li>这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。</li>
</ul>
<p>同时，无论是对于 fd，bk 还是 fd_nextsize ，bk_nextsize，程序都会检测 fd 和 bk 是否满足对应的要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// next_size related</span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure>

<p>看起来似乎很正常。我们以 fd 和 bk 为例，P 的 forward chunk 的 bk 很自然是 P ，同样 P 的 backward chunk 的 fd 也很自然是 P 。如果没有做相应的检查的话，我们可以修改 P 的 fd 与 bk，从而可以很容易地达到任意地址写的效果。关于更加详细的例子，可以参见利用部分的 unlink 。</p>
<p><strong>注意：堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。</strong></p>
<h2 id="malloc-printerr"><a href="#malloc-printerr" class="headerlink" title="malloc_printerr"></a>malloc_printerr</h2><p>在 glibc malloc 时检测到错误的时候，会调用 <code>malloc_printerr</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_printerr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">  __libc_message(do_abort, <span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要会调用 <code>__libc_message</code> 来执行<code>abort</code> 函数，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((action &amp; do_abort)) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((action &amp; do_backtrace))</span><br><span class="line">    BEFORE_ABORT(do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Kill the application.  */</span></span><br><span class="line">  <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>abort</code> 函数里，在 glibc 还是 2.23 版本时，会 fflush stream。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Flush all streams.  We cannot close them now because the user</span></span><br><span class="line"><span class="comment">   might have registered a handler for SIGABRT.  */</span></span><br><span class="line"><span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ++stage;</span><br><span class="line">    fflush (<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h1><blockquote>
<p>Allocate Heap Memory</p>
<p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p>
</blockquote>
<h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><p>一般我们会使用 malloc 函数来申请内存块，可是当仔细看 glibc 的源码实现时，其实并没有 malloc 函数。其实该函数真正调用的是 __libc_malloc 函数。为什么不直接写个 malloc 函数呢，因为有时候我们可能需要不同的名称。此外，__libc_malloc 函数只是用来简单封装 _int_malloc 函数。_int_malloc 才是申请内存块的核心。下面我们来仔细分析一下具体的实现。</p>
<p>该函数会<strong>首先检查是否有内存分配函数的钩子函数（__malloc_hook）</strong>，这个主要用于用户自定义的堆分配函数，方便用户快速修改堆分配函数并进行测试。这里需要注意的是，<strong>用户申请的字节一旦进入申请内存函数中就变成了无符号整数</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wapper for int_malloc</span></span><br><span class="line"><span class="keyword">void</span> *__libc_malloc(<span class="keyword">size_t</span> bytes) &#123;<span class="comment">//size_t 为当前程序位数最长的无符号int型</span></span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">void</span> * victim;</span><br><span class="line">    <span class="comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span></span><br><span class="line">    <span class="keyword">void</span> *(*hook)(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">//钩子不为空</span></span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));<span class="comment">//调用钩子并返回</span></span><br></pre></td></tr></table></figure>

<p>接着会寻找一个 arena 来试图分配内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arena_get(ar_ptr, bytes);</span><br></pre></td></tr></table></figure>

<p>然后调用 _int_malloc 函数去申请对应的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim &#x3D; _int_malloc(ar_ptr, bytes);</span><br></pre></td></tr></table></figure>

<p>如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Retry with another arena only if we were able to find a usable arena</span><br><span class="line">   before.  *&#x2F;</span><br><span class="line">if (!victim &amp;&amp; ar_ptr !&#x3D; NULL) &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, 1, bytes);</span><br><span class="line">    ar_ptr &#x3D; arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    victim &#x3D; _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果申请到了 arena，那么在退出之前还得解锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (ar_ptr !&#x3D; NULL) __libc_lock_unlock(ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure>

<p>判断目前的状态是否满足以下条件</p>
<ul>
<li>要么没有申请到内存</li>
<li>要么是 mmap 的内存</li>
<li><strong>要么申请到的内存必须在其所分配的 arena 中</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">       ar_ptr &#x3D;&#x3D; arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure>

<p>最后返回内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>_int_malloc 是内存分配的核心函数，其核心思路有如下</p>
<ol>
<li>它根据用户申请的<strong>内存块大小</strong>以及<strong>相应大小 chunk 通常使用的频度</strong>（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li>
<li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</li>
<li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li>
<li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li>
</ol>
<p>在进入该函数后，函数立马定义了一系列自己需要的变量，并将用户申请的内存大小转换为内部的 chunk 大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void *_int_malloc(mstate av, size_t bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  &#x2F;* normalized request size *&#x2F;</span><br><span class="line">    unsigned int    idx; &#x2F;* associated bin index *&#x2F;</span><br><span class="line">    mbinptr         bin; &#x2F;* associated bin *&#x2F;</span><br><span class="line"></span><br><span class="line">    mchunkptr       victim;       &#x2F;* inspected&#x2F;selected chunk *&#x2F;</span><br><span class="line">    INTERNAL_SIZE_T size;         &#x2F;* its size *&#x2F;</span><br><span class="line">    int             victim_index; &#x2F;* its bin index *&#x2F;</span><br><span class="line"></span><br><span class="line">    mchunkptr     remainder;      &#x2F;* remainder from a split *&#x2F;</span><br><span class="line">    unsigned long remainder_size; &#x2F;* its size *&#x2F;</span><br><span class="line"></span><br><span class="line">    unsigned int block; &#x2F;* bit map traverser *&#x2F;</span><br><span class="line">    unsigned int bit;   &#x2F;* bit map traverser *&#x2F;</span><br><span class="line">    unsigned int map;   &#x2F;* current word of binmap *&#x2F;</span><br><span class="line"></span><br><span class="line">    mchunkptr fwd; &#x2F;* misc temp for linking *&#x2F;</span><br><span class="line">    mchunkptr bck; &#x2F;* misc temp for linking *&#x2F;</span><br><span class="line"></span><br><span class="line">    const char *errstr &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">       Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="line">       overhead plus possibly more to obtain necessary alignment and&#x2F;or</span><br><span class="line">       to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="line">       size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="line">       that are so large that they wrap around zero when padded and</span><br><span class="line">       aligned.</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    checked_request2size(bytes, nb);</span><br></pre></td></tr></table></figure>

<h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">   mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(av == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>如果申请的 chunk 的大小位于 fastbin 范围内，<strong>需要注意的是这里比较的是无符号整数</strong>。<strong>此外，是从 fastbin 的头结点开始取 chunk</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">   This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">   can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast())) &#123;<span class="comment">//申请大小小于等于fastbin上限</span></span><br><span class="line">    <span class="comment">// 得到对应的fastbin的下标</span></span><br><span class="line">    idx             = fastbin_index(nb);</span><br><span class="line">    <span class="comment">// 得到对应的fastbin的头指针</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin(av, idx);<span class="comment">//单链表</span></span><br><span class="line">    mchunkptr    pp = *fb;</span><br><span class="line">    <span class="comment">// 利用fd遍历对应的bin内是否有空闲的chunk块，</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd,</span><br><span class="line">                                                        victim)) != victim);</span><br><span class="line">    <span class="comment">// 存在可以利用的chunk</span></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。</span></span><br><span class="line">        <span class="comment">// 根据取得的 victim ，利用 chunksize 计算其大小。</span></span><br><span class="line">        <span class="comment">// 利用fastbin_index 计算 chunk 的索引。</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">        errout:</span><br><span class="line">            malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 细致的检查。。只有在 DEBUG 的时候有用</span></span><br><span class="line">        check_remalloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="comment">// 将获取的到chunk转换为mem模式</span></span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul>
<li>malloc 参数是无符号长整型</li>
<li>fastbin 是从头结点（最新进入）开始取 chunk ，符合“先进后出”</li>
</ul>
<h5 id="fast-bin-malloc-检查机制"><a href="#fast-bin-malloc-检查机制" class="headerlink" title="fast bin malloc 检查机制"></a>fast bin malloc 检查机制</h5><p><strong>不启动 DEBUG 时，只检查即将分配 chunk 对应的 idx 是否与申请时的 idx 一致</strong>，步骤如下：</p>
<ol>
<li><code>chunksize(victim)</code> ：提取 victim size</li>
<li><code>fastbin_index()</code> ：查找 victim size 对应的 idx</li>
<li><code>!= idx</code>：检查是否相等，如果不相等则调用 malloc_printerr 打印错误信息</li>
</ol>
<h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>如果获取的内存块的范围处于 small bin 的范围，那么执行如下流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">   hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">   (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">   processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">   anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            <span class="comment">// 细致的检查，非调试状态没有作用</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><ul>
<li>malloc 参数是无符号长整型</li>
<li>smallbin 是从最后结点（最先进入）开始取 chunk ，符合“先进先出”</li>
</ul>
<h5 id="small-bin-malloc-检查机制"><a href="#small-bin-malloc-检查机制" class="headerlink" title="small bin malloc 检查机制"></a>small bin malloc 检查机制</h5><p>步骤如下：</p>
<ol>
<li><code>bck = victim-&gt;bk;</code>  |  <code>(bck-&gt;fd != victim)</code> ：检查即将分配的的 victim 的上一个 chunk 的 fd 指针是否指向 victim 防止伪造</li>
<li><code>set_inuse_bit_at_offset(victim, nb);</code> ：修改 victim 的 size inuse 位</li>
<li><code>bin-&gt;bk = bck;</code>  |  <code>bck-&gt;fd = bin;</code> ：修改链表将 victime 取出来（small bin 最后一个）</li>
</ol>
<h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是<strong>先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中</strong>，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">       While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">       even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">       fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">       Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">       large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">       invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">       it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取large bin的下标。</span></span><br><span class="line">    idx = largebin_index(nb);</span><br><span class="line">    <span class="comment">// 如果存在fastbin的话，会处理 fastbin</span></span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大循环-遍历-unsorted-bin"><a href="#大循环-遍历-unsorted-bin" class="headerlink" title="大循环 - 遍历 unsorted bin"></a>大循环 - 遍历 unsorted bin</h3><blockquote>
<p>2020.07.08 largebin 分配机制不太明白</p>
</blockquote>
<p><strong>如果程序执行到了这里，那么说明 与 chunk 大小正好一致的 bin (fast bin， small bin) 中没有 chunk 可以直接满足需求 ，但是 large chunk 则是在这个大循环中处理</strong>。</p>
<p>在接下来的这个循环中，主要做了以下的操作</p>
<ul>
<li><strong>按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来</strong><ul>
<li>如果是 small request，则考虑是不是恰好满足，是的话，直接返回。</li>
<li>如果不是的话，放到对应的 bin 中。</li>
</ul>
</li>
<li>尝试从 large bin 中分配用户所需的内存</li>
</ul>
<p>该部分是一个大循环，这是为了尝试重新分配 small bin chunk，这是因为我们虽然会首先使用 large bin，top chunk 来尝试满足用户的请求，但是如果没有满足的话，由于我们在上面没有分配成功 small bin，我们并没有对 fast bin 中的 chunk 进行合并，所以这里会进行 fast bin chunk 的合并，进而使用一个大循环来尝试再次分配 small bin chunk。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">       it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">       the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">       bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">       chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">       near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">       do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">       otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="unsorted-bin-遍历"><a href="#unsorted-bin-遍历" class="headerlink" title="unsorted bin 遍历"></a>unsorted bin 遍历</h4><p>先考虑 unsorted bin，再考虑 last remainder ，但是对于 small bin chunk 的请求会有所例外。</p>
<p><strong>注意 unsorted bin 的遍历顺序为 bk。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 unsorted bin 不为空</span></span><br><span class="line"><span class="comment">// First In First Out</span></span><br><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">    <span class="comment">// victim 为 unsorted bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// bck 为 unsorted bin 的倒数第二个 chunk</span></span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="comment">// 判断得到的 chunk 是否满足要求，不能过小，也不能过大</span></span><br><span class="line">    <span class="comment">// 一般 system_mem 的大小为132K</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">    <span class="comment">// 得到victim对应的chunk大小。</span></span><br><span class="line">    size = chunksize(victim);</span><br></pre></td></tr></table></figure>

<h5 id="SMALL-REQUEST"><a href="#SMALL-REQUEST" class="headerlink" title="SMALL REQUEST"></a>SMALL REQUEST</h5><p>如果用户的请求为 small bin chunk ，那么我们首先考虑 last remainder，如果 last remainder 是 unsorted bin 中的唯一一块的话， 并且 last remainder 的大小分割后还可以作为一个 chunk ，<strong>为什么没有等号</strong>？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">               If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">               only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">               runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">               exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">               no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">               */</span>	</span><br><span class="line"><span class="comment">//是否是smallbin范围；bck是否是链首；remainder是（分配完）剩余部分</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    <span class="comment">// 获取新的 remainder 的大小</span></span><br><span class="line">    remainder_size          = size - nb;</span><br><span class="line">    <span class="comment">// 获取新的 remainder 的位置</span></span><br><span class="line">    remainder               = chunk_at_offset(victim, nb);</span><br><span class="line">    <span class="comment">// 更新 unsorted bin 的情况</span></span><br><span class="line">    <span class="comment">// av是被取出chunk的下一个chunk（fd）</span></span><br><span class="line">    unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">    <span class="comment">// 更新 av 中记录的 last_remainder</span></span><br><span class="line">    av-&gt;last_remainder                                = remainder;</span><br><span class="line">    <span class="comment">// 更新last remainder的指针</span></span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置victim的头部，inuse</span></span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 设置 remainder 的头部</span></span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    <span class="comment">// 设置记录 remainder 大小的 prev_size 字段，因为此时 remainder 处于空闲状态。</span></span><br><span class="line">    set_foot(remainder, remainder_size);</span><br><span class="line">    <span class="comment">// 细致的检查，非调试状态下没有作用</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// 将 victim 从 chunk 模式转化为mem模式</span></span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="初始取出"><a href="#初始取出" class="headerlink" title="初始取出"></a>初始取出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="comment">//修改 unsortedchunk 链表</span></span><br><span class="line">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd                 = unsorted_chunks(av);</span><br></pre></td></tr></table></figure>

<h5 id="取出-chunk-大小刚好合适-（EXACT-FIT）"><a href="#取出-chunk-大小刚好合适-（EXACT-FIT）" class="headerlink" title="取出 chunk 大小刚好合适 （EXACT FIT）"></a>取出 chunk 大小刚好合适 （EXACT FIT）</h5><p>如果从 unsorted bin 中取出来的 chunk 大小正好合适，就直接使用。这里应该已经把合并后恰好合适的 chunk 给分配出去了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb) &#123;<span class="comment">//大小正好合适</span></span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    <span class="comment">// 细致的检查，非调试状态下没有作用</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// 将 victim 从 chunk 模式转化为mem模式</span></span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="comment">//直接返回 chunk 指针</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="将取出来-chunk-放入到-smallbin-（PLACE-CHUNK-IN-SMALL-BIN）"><a href="#将取出来-chunk-放入到-smallbin-（PLACE-CHUNK-IN-SMALL-BIN）" class="headerlink" title="将取出来 chunk 放入到 smallbin （PLACE CHUNK IN SMALL BIN）"></a>将取出来 chunk 放入到 smallbin （PLACE CHUNK IN SMALL BIN）</h5><p>把取出来的 chunk 放到对应的 small bin 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">/* place chunk in bin */</span></span><br><span class="line"><span class="comment">//判断 size 是否在smallbin</span></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">             <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">             victim_index = smallbin_index(size);</span><br><span class="line">             <span class="comment">// 调整 small bin 的链表</span></span><br><span class="line">             bck          = bin_at(av, victim_index);</span><br><span class="line">             fwd          = bck-&gt;fd;</span><br></pre></td></tr></table></figure>

<h5 id="PLACE-CHUNK-IN-LARGE-BIN"><a href="#PLACE-CHUNK-IN-LARGE-BIN" class="headerlink" title="PLACE CHUNK IN LARGE BIN"></a>PLACE CHUNK IN LARGE BIN</h5><p>把取出来的 chunk 放到对应的 large bin 中。</p>
<blockquote>
<p>这里应该是获取正确插入位置的指针 bck、fwd。最后插入形式为：bck&lt;–&gt;victim&lt;–&gt;fwd。</p>
<p>链表构建在：[最终取出](# 最终取出)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// large bin 范围</span></span><br><span class="line">    victim_index = largebin_index(size);</span><br><span class="line">    bck          = bin_at(av, victim_index); <span class="comment">// 当前 large bin 的头部</span></span><br><span class="line">    fwd          = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="comment">/* 从这里我们可以总结出，largebin 以 fd_nextsize 递减排序。</span></span><br><span class="line"><span class="comment">       同样大小的 chunk，后来的只会插入到之前同样大小的 chunk 后，</span></span><br><span class="line"><span class="comment">       而不会修改之前相同大小的fd/bk_nextsize，这也很容易理解，</span></span><br><span class="line"><span class="comment">       可以减低开销。此外，bin 头不参与 nextsize 链接。*/</span></span><br><span class="line">    <span class="comment">// 如果 large bin 链表不空</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        <span class="comment">// 加速比较，应该不仅仅有这个考虑，因为链表里的 chunk 都会设置该位。</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        <span class="comment">// bck-&gt;bk 存储着相应 large bin 中最小的chunk。</span></span><br><span class="line">        <span class="comment">// 如果遍历的 chunk 比当前最小的还要小，那就只需要插入到链表尾部。</span></span><br><span class="line">        <span class="comment">// 判断 bck-&gt;bk 是不是在 main arena。</span></span><br><span class="line">        assert(chunk_main_arena(bck-&gt;bk));</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt;</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask(bck-&gt;bk)) &#123;</span><br><span class="line">            <span class="comment">// 令 fwd 指向 large bin 头</span></span><br><span class="line">            fwd = bck;</span><br><span class="line">            <span class="comment">// 令 bck 指向 largin bin 尾部 chunk</span></span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line">            <span class="comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            <span class="comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span></span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            <span class="comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span></span><br><span class="line">            <span class="comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span></span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize =</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前要插入的 victim 的大小大于最小的 chunk</span></span><br><span class="line">            <span class="comment">// 判断 fwd 是否在 main arena</span></span><br><span class="line">            assert(chunk_main_arena(fwd));</span><br><span class="line">            <span class="comment">// 从链表头部开始找到不比 victim 大的 chunk</span></span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask(fwd)) &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert(chunk_main_arena(fwd));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果找到了一个和 victim 一样大的 chunk，</span></span><br><span class="line">            <span class="comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size ==</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask(fwd))</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果找到的chunk和当前victim大小不一样</span></span><br><span class="line">                <span class="comment">// 那么就需要构造 nextsize 双向链表了</span></span><br><span class="line">                victim-&gt;fd_nextsize              = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize                 = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果空的话，直接简单使得 fd_nextsize 与 bk_nextsize 构成一个双向链表即可。</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="最终取出"><a href="#最终取出" class="headerlink" title="最终取出"></a>最终取出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放到对应的 bin 中，构成 bck&lt;--&gt;victim&lt;--&gt;fwd。</span></span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk    = victim;</span><br><span class="line">bck-&gt;fd    = victim;</span><br></pre></td></tr></table></figure>

<h5 id="WHILE-迭代次数"><a href="#WHILE-迭代次数" class="headerlink" title="WHILE 迭代次数"></a>WHILE 迭代次数</h5><p>while 最多迭代 10000 次后退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// #define MAX_ITERS 10000</span></span><br><span class="line">    <span class="keyword">if</span> (++iters &gt;= MAX_ITERS) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="large-chunk"><a href="#large-chunk" class="headerlink" title="large chunk"></a>large chunk</h4><p><strong>注： 或许会很奇怪，为什么这里没有先去看 small chunk 是否满足新需求了呢？这是因为 small bin 在循环之前已经判断过了，这里如果有的话，就是合并后的才出现 chunk。但是在大循环外，large chunk 只是单纯地找到其索引，所以觉得在这里直接先判断是合理的，而且也为了下面可以再去找较大的 chunk。</strong></p>
<p>如果请求的 chunk 在 large chunk 范围内，就在对应的 bin 中从小到大进行扫描，找到第一个合适的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="comment">//判断是否smallbin</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">          bin = bin_at(av, idx);</span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="comment">// 如果对应的 bin 为空或者其中的chunk最大的也很小，那就跳过</span></span><br><span class="line">          <span class="comment">// first(bin)=bin-&gt;fd 表示当前链表中最大的chunk</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask(victim) &gt;=</span><br><span class="line">                  (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)) &#123;</span><br><span class="line">              <span class="comment">// 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk</span></span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize(victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                  victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="comment">// 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk</span></span><br><span class="line">              <span class="comment">// 的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize</span></span><br><span class="line">              <span class="comment">//  链表。因为大小相同的chunk只有一个会被串在nextsize链上。</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last(bin) &amp;&amp;</span><br><span class="line">                  chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))</span><br><span class="line">                  victim = victim-&gt;fd;</span><br><span class="line">              <span class="comment">// 计算分配后剩余的大小</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              <span class="comment">// 进行unlink（宏操作）</span></span><br><span class="line">              unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="comment">// 剩下的大小不足以当做一个块</span></span><br><span class="line">              <span class="comment">// 很好奇接下来会怎么办？</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">                  set_inuse_bit_at_offset(victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="comment">//  剩下的大小还可以作为一个chunk，进行分割。</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 获取剩下那部分chunk的指针，称为remainder</span></span><br><span class="line">                  remainder = chunk_at_offset(victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  <span class="comment">// 插入unsorted bin中</span></span><br><span class="line">                  bck = unsorted_chunks(av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">                  <span class="comment">// 判断 unsorted bin 是否被破坏。</span></span><br><span class="line">                  <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                  &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd       = remainder;</span><br><span class="line">                  fwd-&gt;bk       = remainder;</span><br><span class="line">                  <span class="comment">// 如果不处于small bin范围内，就设置对应的字段</span></span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 设置分配的chunk的标记</span></span><br><span class="line">                  set_head(victim,</span><br><span class="line">                           nb | PREV_INUSE |</span><br><span class="line">                               (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 设置remainder的上一个chunk，即分配出去的chunk的使用状态</span></span><br><span class="line">                  <span class="comment">// 其余的不用管，直接从上面继承下来了</span></span><br><span class="line">                  set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  <span class="comment">// 设置remainder的大小</span></span><br><span class="line">                  set_foot(remainder, remainder_size);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 检查</span></span><br><span class="line">              check_malloced_chunk(av, victim, nb);</span><br><span class="line">              <span class="comment">// 转换为mem状态</span></span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">              <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">              alloc_perturb(p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="寻找较大-chunk"><a href="#寻找较大-chunk" class="headerlink" title="寻找较大 chunk"></a>寻找较大 chunk</h4><p><strong>如果走到了这里，那说明对于用户所需的 chunk，不能直接从其对应的合适的 bin 中获取 chunk</strong><a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>，所以我们需要来查找比当前 bin 更大的 fast bin ， small bin 或者 large bin。</p>
<p><a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>: 这里意思是去对应 bin 取，没有办法取到。比如需要一个 0x100 的chunk ，去到大小为 0x100 的bin 中取，而该 bin 中没有空闲 chunk 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">   bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">   (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">   that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">   The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">   when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">++idx;</span><br><span class="line"><span class="comment">// 获取对应的bin</span></span><br><span class="line">bin   = bin_at(av, idx);</span><br><span class="line"><span class="comment">// 获取当前索引在binmap中的block索引</span></span><br><span class="line"><span class="comment">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5</span></span><br><span class="line"><span class="comment">// Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在</span></span><br><span class="line"><span class="comment">// 所以这里是右移5</span></span><br><span class="line">block = idx2block(idx);</span><br><span class="line"><span class="comment">// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块</span></span><br><span class="line"><span class="built_in">map</span>   = av-&gt;binmap[ block ];</span><br><span class="line"><span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"><span class="comment">// 将idx对应的比特位设置为1，其它位为0</span></span><br><span class="line">bit   = idx2bit(idx);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br></pre></td></tr></table></figure>

<h5 id="找到一个合适的-MAP"><a href="#找到一个合适的-MAP" class="headerlink" title="找到一个合适的 MAP"></a>找到一个合适的 MAP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Skip rest of block if there are no more set bits in this block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果bit&gt;map，则表示该 map 中没有比当前所需要chunk大的空闲块</span></span><br><span class="line"><span class="comment">// 如果bit为0，那么说明，上面idx2bit带入的参数为0。</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找下一个block，直到其对应的map不为0。</span></span><br><span class="line">        <span class="comment">// 如果已经不存在的话，那就只能使用top chunk了</span></span><br><span class="line">        <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[ block ]) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且</span></span><br><span class="line">    <span class="comment">// map本身不为0，所以必然存在满足需求的chunk。</span></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="找到合适的-BIN"><a href="#找到合适的-BIN" class="headerlink" title="找到合适的 BIN"></a>找到合适的 BIN</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="comment">// 从当前map的最小的bin一直找，直到找到合适的bin。</span></span><br><span class="line"><span class="comment">// 这里是一定存在的</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="简单检查-CHUNK"><a href="#简单检查-CHUNK" class="headerlink" title="简单检查 CHUNK"></a>简单检查 CHUNK</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line"><span class="comment">// 获取对应的bin</span></span><br><span class="line">victim = last(bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span></span><br><span class="line"><span class="comment">// 这种情况发生的概率应该很小。</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">    av-&gt;binmap[ block ] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin                 = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="真正取出-CHUNK"><a href="#真正取出-CHUNK" class="headerlink" title="真正取出 CHUNK"></a>真正取出 CHUNK</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对应victim的大小</span></span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line">    <span class="comment">// 计算分割后剩余的大小</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="comment">// 如果分割后不够一个chunk怎么办？</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="comment">// 如果够，尽管分割</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算剩余的chunk的偏移</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">           have to perform a complete insert here.  */</span></span><br><span class="line">        <span class="comment">// 将剩余的chunk插入到unsorted bin中</span></span><br><span class="line">        bck = unsorted_chunks(av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd       = remainder;</span><br><span class="line">        fwd-&gt;bk       = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="comment">// 如果在small bin范围内，就将其标记为remainder</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置victim的使用状态</span></span><br><span class="line">        set_head(victim,</span><br><span class="line">                 nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置remainder的使用状态，这里是为什么呢？</span></span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">// 设置remainder的大小</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// chunk状态转换到mem状态</span></span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-top-chunk"><a href="#使用-top-chunk" class="headerlink" title="使用 top chunk"></a>使用 top chunk</h3><p><strong>如果所有的 bin 中的 chunk 都没有办法直接满足要求（即不合并），或者说都没有空闲的 chunk。</strong>那么我们就只能使用 top chunk 了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">       (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">       search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">       less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">       be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">       limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">       MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">       exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">       reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">       to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size   = chunksize(victim);</span><br><span class="line">    <span class="comment">// 如果分割之后，top chunk 大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">        av-&gt;top        = remainder;</span><br><span class="line">        <span class="comment">// 这里设置 PREV_INUSE 是因为 top chunk 前面的 chunk 如果不是 fastbin，就必然会和</span></span><br><span class="line">        <span class="comment">// top chunk 合并，所以这里设置了 PREV_INUSE。</span></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，判断是否有 fast chunk</span></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        <span class="comment">// 先执行一次fast bin的合并</span></span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="comment">// 判断需要的chunk是在small bin范围内还是large bin范围内</span></span><br><span class="line">        <span class="comment">// 并计算对应的索引</span></span><br><span class="line">        <span class="comment">// 等待下次再看看是否可以</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            idx = smallbin_index(nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆内存不够"><a href="#堆内存不够" class="headerlink" title="堆内存不够"></a>堆内存不够</h3><p>如果堆内存不够，我们就需要使用 <code>sysmalloc</code> 来申请内存了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 否则的话，我们就只能从系统中再次申请一点内存了。</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="_libc_calloc"></a>_libc_calloc</h2><p>calloc 也是 libc 中的一种申请内存块的函数。在 <code>libc</code>中的封装为 <code>_libc_calloc</code>，具体介绍如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  Returns a pointer to n_elements * element_size bytes, with all locations</span></span><br><span class="line"><span class="comment">  set to zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>*  __libc_calloc(<span class="keyword">size_t</span>, <span class="keyword">size_t</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2020.07.08 下面大概浏览一下未仔细品味</p>
</blockquote>
<h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h2><p>正如该函数头的注释所言，该函数用于当前堆内存不足时，需要向系统申请更多的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc handles malloc cases requiring more memory from the system.</span></span><br><span class="line"><span class="comment">   On entry, it is assumed that av-&gt;top does not have enough</span></span><br><span class="line"><span class="comment">   space to service request for nb bytes, thus requiring that av-&gt;top</span></span><br><span class="line"><span class="comment">   be extended or replaced.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span> </span>&#123;</span><br><span class="line">  mchunkptr old_top;        <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size; <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">char</span> *old_end;            <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> size; <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="keyword">char</span> *brk; <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> correction; <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="keyword">char</span> *snd_brk;   <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                  <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;          <span class="comment">/* remainder frOm allocation */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size; <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> pagesize = GLRO(dl_pagesize);</span><br><span class="line">  <span class="keyword">bool</span> tried_mmap = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以主要关注一下 <code>pagesize</code>，其</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXEC_PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXEC_PAGESIZE   4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> GLRO(name) _##name</span></span><br><span class="line"><span class="keyword">size_t</span> _dl_pagesize = EXEC_PAGESIZE;</span><br></pre></td></tr></table></figure>

<p>所以，<code>pagesize=4096=0x1000</code>。</p>
<h3 id="考虑-mmap"><a href="#考虑-mmap" class="headerlink" title="考虑 mmap"></a>考虑 mmap</h3><p>正如开头注释所言如果满足如下任何一种条件</p>
<ol>
<li>没有分配堆。</li>
<li>申请的内存大于 <code>mp_.mmap_threshold</code>，并且 mmap 的数量小于最大值，就可以尝试使用 mmap。</li>
</ol>
<p>默认情况下，临界值为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span> &#123;</span><br><span class="line">    .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">    .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">    .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">    .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line">    .arena_test = NARENAS_FROM_NCORES(<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">        ,</span><br><span class="line">    .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">    .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">    .tcache_max_bytes = tidx2usize(TCACHE_MAX_BINS - <span class="number">1</span>),</span><br><span class="line">    .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>DEFAULT_MMAP_THRESHOLD</code> 为 128*1024 字节，即 128 K。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically</span></span><br><span class="line"><span class="comment">  adjusted MMAP_THRESHOLD.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="comment">/* For 32-bit platforms we cannot increase the maximum mmap</span></span><br><span class="line"><span class="comment">   threshold much because it is also the minimum value for the</span></span><br><span class="line"><span class="comment">   maximum heap size and its alignment.  Going above 512k (i.e., 1M</span></span><br><span class="line"><span class="comment">   for new heaps) wastes too much address space.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>下面为这部分代码，目前不是我们关心的重点，可以暂时跳过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">   the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">   allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">   rather than expanding top.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span> ||</span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">     (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123;</span><br><span class="line">  <span class="keyword">char</span> *mm; <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">try_mmap:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Round up size to nearest page.  For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">     is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">     is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">     need for further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    size = ALIGN_UP(nb + SIZE_SZ, pagesize);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">  tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb)) &#123;</span><br><span class="line">    mm = (<span class="keyword">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm != MAP_FAILED) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">         in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">         returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">         and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">         address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ) &#123;</span><br><span class="line">        <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">           MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">           aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">        assert(((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">        front_misalign = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">      <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">        p = (mchunkptr)(mm + correction);</span><br><span class="line">        set_prev_size(p, correction);</span><br><span class="line">        set_head(p, (size - correction) | IS_MMAPPED);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (mchunkptr)mm;</span><br><span class="line">        set_prev_size(p, <span class="number">0</span>);</span><br><span class="line">        set_head(p, size | IS_MMAPPED);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* update statistics */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> <span class="keyword">new</span> = atomic_exchange_and_add(&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">      atomic_max(&amp;mp_.max_n_mmaps, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">long</span> sum;</span><br><span class="line">      sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">      atomic_max(&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">      check_chunk(av, p);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mmap-失败或者未分配堆"><a href="#mmap-失败或者未分配堆" class="headerlink" title="mmap 失败或者未分配堆"></a>mmap 失败或者未分配堆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* There are no usable arenas and mmap also failed.  *&#x2F;</span><br><span class="line">if (av &#x3D;&#x3D; NULL)</span><br><span class="line">  return 0;</span><br></pre></td></tr></table></figure>

<p>如果是这两种情况中的任何一种，其实就可以退出了。。</p>
<h3 id="记录旧堆信息"><a href="#记录旧堆信息" class="headerlink" title="记录旧堆信息"></a>记录旧堆信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize(old_top);</span><br><span class="line">old_end = (<span class="keyword">char</span> *)(chunk_at_offset(old_top, old_size));</span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="keyword">char</span> *)(MORECORE_FAILURE);</span><br></pre></td></tr></table></figure>

<h3 id="检查旧堆信息-1"><a href="#检查旧堆信息-1" class="headerlink" title="检查旧堆信息 1"></a>检查旧堆信息 1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">       ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top) &amp;&amp;</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<p>这个检查要求满足其中任何一个条件</p>
<ol>
<li><code>old_top == initial_top(av) &amp;&amp; old_size == 0</code>，即如果是第一次的话，堆的大小需要是 0。</li>
<li>新的堆，那么<ol>
<li><code>(unsigned long)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top)</code>，堆的大小应该不小于 <code>MINSIZE</code>，并且前一个堆块应该处于使用中。</li>
<li><code>((unsigned long)old_end &amp; (pagesize - 1)) == 0)</code>，堆的结束地址应该是页对齐的，由于页对齐的大小默认是 0x1000，所以低 12 个比特需要为 0。</li>
</ol>
</li>
</ol>
<h3 id="检查旧堆信息-2"><a href="#检查旧堆信息-2" class="headerlink" title="检查旧堆信息 2"></a>检查旧堆信息 2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE));</span><br></pre></td></tr></table></figure>

<p>根据 malloc 中的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_int_malloc(mstate av, <span class="keyword">size_t</span> bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  <span class="comment">/* normalized request size */</span></span><br></pre></td></tr></table></figure>

<p><code>nb</code> 应该是已经加上 chunk 头部的字节，为什么还要加上 <code>MINSIZE</code>呢？这是因为 top chunk 的大小应该至少预留 MINSIZE 空间，以便于合并。</p>
<h3 id="非-main-arena"><a href="#非-main-arena" class="headerlink" title="非 main_arena"></a>非 main_arena</h3><p>这里暂时不是关心的重点，暂且不分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (av != &amp;main_arena) &#123;</span><br><span class="line">  heap_info *old_heap, *heap;</span><br><span class="line">  <span class="keyword">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">  old_heap = heap_for_ptr(old_top);</span><br><span class="line">  old_heap_size = old_heap-&gt;size;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">long</span>)(MINSIZE + nb - old_size) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      grow_heap(old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>) &#123;</span><br><span class="line">    av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">    set_head(old_top,</span><br><span class="line">             (((<span class="keyword">char</span> *)old_heap + old_heap-&gt;size) - (<span class="keyword">char</span> *)old_top) |</span><br><span class="line">                 PREV_INUSE);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap(nb + (MINSIZE + <span class="keyword">sizeof</span>(*heap)), mp_.top_pad))) &#123;</span><br><span class="line">    <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">    heap-&gt;ar_ptr = av;</span><br><span class="line">    heap-&gt;prev = old_heap;</span><br><span class="line">    av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">    <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">    top(av) = chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap));</span><br><span class="line">    set_head(top(av), (heap-&gt;size - <span class="keyword">sizeof</span>(*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">       MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">    <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">       become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">       up, too, although the chunk is marked in use. */</span></span><br><span class="line">    old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">    set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ),</span><br><span class="line">             <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">      set_head(chunk_at_offset(old_top, old_size),</span><br><span class="line">               (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">      set_foot(chunk_at_offset(old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">      set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">      _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      set_head(old_top, (old_size + <span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">      set_foot(old_top, (old_size + <span class="number">2</span> * SIZE_SZ));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">    <span class="comment">/* We can at least try to use to mmap memory.  */</span></span><br><span class="line">    <span class="keyword">goto</span> try_mmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main-arena-处理"><a href="#Main-arena-处理" class="headerlink" title="Main_arena 处理"></a>Main_arena 处理</h3><h4 id="计算内存"><a href="#计算内存" class="headerlink" title="计算内存"></a>计算内存</h4><p>计算可以满足请求的内存大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">/* av == main_arena */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">    size = nb + mp_.top_pad + MINSIZE;</span><br></pre></td></tr></table></figure>

<p>默认情况下 <code>top_pad</code>定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_TOP_PAD</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DEFAULT_TOP_PAD 131072</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>即 131072 字节，0x20000 字节。</p>
<h4 id="是否连续"><a href="#是否连续" class="headerlink" title="是否连续"></a>是否连续</h4><p>如果我们希望堆的空间连续的话，那么其实可以复用之前的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">   combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">   we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contiguous(av))</span><br><span class="line">  size -= old_size;</span><br></pre></td></tr></table></figure>

<h4 id="对齐页大小"><a href="#对齐页大小" class="headerlink" title="对齐页大小"></a>对齐页大小</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">   If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">   with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">   this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">   previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">size = ALIGN_UP(size, pagesize);</span><br></pre></td></tr></table></figure>

<h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">   negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">   below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  brk = (<span class="keyword">char</span> *)(MORECORE(size));</span><br><span class="line">  LIBC_PROBE(memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可能成功"><a href="#可能成功" class="headerlink" title="可能成功"></a>可能成功</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">  <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*hook)(<span class="keyword">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    (*hook)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里竟然调用了一个 hook，有点意思。</p>
<h5 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h5><p>失败，考虑 mmap。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If have mmap, try using it as a backup when MORECORE fails or</span></span><br><span class="line"><span class="comment">         cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span></span><br><span class="line"><span class="comment">         address space, so sbrk cannot extend to give contiguous space, but</span></span><br><span class="line"><span class="comment">         space is available elsewhere.  Note that we ignore mmap max count</span></span><br><span class="line"><span class="comment">         and threshold limits, since the space will not be used as a</span></span><br><span class="line"><span class="comment">         segregated mmap region.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Cannot merge with old top, so add its size back in */</span></span><br><span class="line">      <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">        size = ALIGN_UP(size + old_size, pagesize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we are relying on mmap as backup, then use larger units */</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(MMAP_AS_MORECORE_SIZE))</span><br><span class="line">        size = MMAP_AS_MORECORE_SIZE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *mbrk = (<span class="keyword">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbrk != MAP_FAILED) &#123;</span><br><span class="line">          <span class="comment">/* We do not need, and cannot use, another sbrk call to find end */</span></span><br><span class="line">          brk = mbrk;</span><br><span class="line">          snd_brk = brk + size;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             Record that we no longer have a contiguous sbrk region.</span></span><br><span class="line"><span class="comment">             After the first time mmap is used as backup, we do not</span></span><br><span class="line"><span class="comment">             ever rely on contiguous space since this could incorrectly</span></span><br><span class="line"><span class="comment">             bridge regions.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          set_noncontiguous(av);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="内存可能申请成功"><a href="#内存可能申请成功" class="headerlink" title="内存可能申请成功"></a>内存可能申请成功</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">    mp_.sbrk_base = brk;</span><br><span class="line">  av-&gt;system_mem += size;</span><br></pre></td></tr></table></figure>

<h5 id="情况-1"><a href="#情况-1" class="headerlink" title="情况 1"></a>情况 1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If MORECORE extends previous space, we can likewise extend top size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="keyword">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">  set_head(old_top, (size + old_size) | PREV_INUSE);</span><br></pre></td></tr></table></figure>

<h5 id="情况-2-意外内存耗尽"><a href="#情况-2-意外内存耗尽" class="headerlink" title="情况 2 - 意外内存耗尽"></a>情况 2 - 意外内存耗尽</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (contiguous(av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">  <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">  malloc_printerr(<span class="string">&quot;break adjusted to free malloc space&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="处理其他意外情况"><a href="#处理其他意外情况" class="headerlink" title="处理其他意外情况"></a>处理其他意外情况</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">    just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">    request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">    combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">    which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">    So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">    which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  front_misalign = <span class="number">0</span>;</span><br><span class="line">  end_misalign = <span class="number">0</span>;</span><br><span class="line">  correction = <span class="number">0</span>;</span><br><span class="line">  aligned_brk = brk;</span><br></pre></td></tr></table></figure>

<h6 id="处理连续内存"><a href="#处理连续内存" class="headerlink" title="处理连续内存"></a>处理连续内存</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle contiguous cases */</span></span><br><span class="line"><span class="keyword">if</span> (contiguous(av)) &#123;</span><br><span class="line">  <span class="comment">/* Count foreign sbrk as system_mem.  */</span></span><br><span class="line">  <span class="keyword">if</span> (old_size)</span><br><span class="line">    av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line"></span><br><span class="line">  front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">       We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">       They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">       prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">       is always true after initialization.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">    aligned_brk += correction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">     be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  correction += old_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">  end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);</span><br><span class="line">  correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">  assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">  snd_brk = (<span class="keyword">char</span> *)(MORECORE(correction));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">     brk.  It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">     is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">     occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (snd_brk == (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    correction = <span class="number">0</span>;</span><br><span class="line">    snd_brk = (<span class="keyword">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">    <span class="keyword">void</span> (*hook)(<span class="keyword">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">      (*hook)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="处理不连续内存"><a href="#处理不连续内存" class="headerlink" title="处理不连续内存"></a>处理不连续内存</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">    assert(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    front_misalign =</span><br><span class="line">        (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">    <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">         We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">         They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">         prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">         is always true after initialization.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">  <span class="keyword">if</span> (snd_brk == (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    snd_brk = (<span class="keyword">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line">  <span class="keyword">if</span> (snd_brk != (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    av-&gt;top = (mchunkptr)aligned_brk;</span><br><span class="line">    set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">    av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">       gap due to foreign sbrk or a non-contiguous region.  Insert a</span></span><br><span class="line"><span class="comment">       double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">       we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">       marked as inuse and are in any case too small to use.  We need</span></span><br><span class="line"><span class="comment">       two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_size != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">         multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">         enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">      set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">         old_top when old_size was previously MINSIZE.  This is</span></span><br><span class="line"><span class="comment">         intentional. We need the fencepost, even if old_top otherwise</span></span><br><span class="line"><span class="comment">         gets lost.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      set_head(chunk_at_offset(old_top, old_size),</span><br><span class="line">               (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">      set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ),</span><br><span class="line">               (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">      <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">        _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在这里程序将旧的 top chunk 进行了释放，那么其会根据大小进入不同的 bin 或 tcache 中。</p>
<h4 id="更新最大内存"><a href="#更新最大内存" class="headerlink" title="更新最大内存"></a>更新最大内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)av-&gt;system_mem &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(av-&gt;max_system_mem))</span><br><span class="line">  av-&gt;max_system_mem = av-&gt;system_mem;</span><br><span class="line">check_malloc_state(av);</span><br></pre></td></tr></table></figure>

<h4 id="分配内存块"><a href="#分配内存块" class="headerlink" title="分配内存块"></a>分配内存块</h4><h5 id="获取大小"><a href="#获取大小" class="headerlink" title="获取大小"></a>获取大小</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* finally, do the allocation */</span></span><br><span class="line">p = av-&gt;top;</span><br><span class="line">size = chunksize(p);</span><br></pre></td></tr></table></figure>

<h5 id="切分-TOP"><a href="#切分-TOP" class="headerlink" title="切分 TOP"></a>切分 TOP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check that one of the above allocation paths succeeded */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">  remainder_size = size - nb;</span><br><span class="line">  remainder = chunk_at_offset(p, nb);</span><br><span class="line">  av-&gt;top = remainder;</span><br><span class="line">  set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">  set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">  check_malloced_chunk(av, p, nb);</span><br><span class="line">  <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="捕捉所有错误"><a href="#捕捉所有错误" class="headerlink" title="捕捉所有错误"></a>捕捉所有错误</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* catch all failure paths */</span></span><br><span class="line">__set_errno(ENOMEM);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h1 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h1><blockquote>
<p>Free Heap Memory</p>
<p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p>
</blockquote>
<h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><p>类似于 malloc，free 函数也有一层封装，命名格式与 malloc 基本类似。代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __libc_free(<span class="keyword">void</span> *mem) &#123;</span><br><span class="line">    mstate    ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">    <span class="comment">// 判断是否有钩子函数 __free_hook</span></span><br><span class="line">    <span class="keyword">void</span> (*hook)(<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__free_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//执行hook函数然后返回</span></span><br><span class="line">        (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// free NULL没有作用</span></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将mem转换为chunk状态</span></span><br><span class="line">    p = mem2chunk(mem);</span><br><span class="line">    <span class="comment">// 如果该块内存是mmap得到的</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment">       Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">        <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;</span><br><span class="line">            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;</span><br><span class="line">            !DUMPED_MAIN_ARENA_CHUNK(p)) &#123;</span><br><span class="line">            mp_.mmap_threshold = chunksize(p);</span><br><span class="line">            mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                       mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据chunk获得分配区的指针</span></span><br><span class="line">    ar_ptr = arena_for_chunk(p);</span><br><span class="line">    <span class="comment">// 执行释放</span></span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><p>函数初始时刻定义了一系列的变量，并且得到了用户想要释放的 chunk 的大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _int_free(mstate av, mchunkptr p, <span class="keyword">int</span> have_lock) &#123;</span><br><span class="line">    INTERNAL_SIZE_T size;      <span class="comment">/* its size */</span></span><br><span class="line">    mfastbinptr *   fb;        <span class="comment">/* associated fastbin */</span></span><br><span class="line">    mchunkptr       nextchunk; <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T nextsize;  <span class="comment">/* its size */</span></span><br><span class="line">    <span class="keyword">int</span>             nextinuse; <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">    INTERNAL_SIZE_T prevsize;  <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">    mchunkptr       bck;       <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    mchunkptr       fwd;       <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>         locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = chunksize(p);</span><br></pre></td></tr></table></figure>

<h3 id="简单的检查"><a href="#简单的检查" class="headerlink" title="简单的检查"></a>简单的检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">   allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">   Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">   here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="comment">// 指针不能指向非法的地址, 必须小于等于-size，为什么？？？</span></span><br><span class="line"><span class="comment">// 指针必须得对齐，2*SIZE_SZ 这个对齐得仔细想想</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>) ||</span><br><span class="line">    __builtin_expect(misaligned_chunk(p), <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">    malloc_printerr(check_action, errstr, chunk2mem(p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">   multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="comment">// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查该chunk是否处于使用状态，非调试状态下没有作用</span></span><br><span class="line">check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure>

<p>其中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line">    ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="line">     MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>

<h3 id="fast-bin-1"><a href="#fast-bin-1" class="headerlink" title="fast bin"></a>fast bin</h3><p>如果上述检查都合格的话，判断当前的 bin 是不是在 fast bin 范围内，在的话就插入到 <strong>fastbin 头部</strong>，即成为对应 fastbin 链表的<strong>第一个 free chunk</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">      and used quickly in malloc.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">      bordering top into fastbins</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//默认 #define TRIM_FASTBINS 0，因此默认情况下下面的语句不会执行</span></span><br><span class="line">       <span class="comment">// 如果当前chunk是fast chunk，并且下一个chunk是top chunk，则不能插入</span></span><br><span class="line">       <span class="comment">// 因为下一个chunk是topchunk 直接与 topchunk 合并</span></span><br><span class="line">        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            ) &#123;</span><br><span class="line">        <span class="comment">// 下一个chunk的大小不能小于两倍的SIZE_SZ,并且</span></span><br><span class="line">        <span class="comment">// 下一个chunk的大小不能大于system_mem， 一般为132k</span></span><br><span class="line">        <span class="comment">// 如果出现这样的情况，就报错。</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(</span><br><span class="line">                chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">            __builtin_expect(</span><br><span class="line">                chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">/* We might not have a lock at this point and concurrent</span></span><br><span class="line"><span class="comment">               modifications</span></span><br><span class="line"><span class="comment">               of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">               after getting the lock.  */</span></span><br><span class="line">            <span class="keyword">if</span> (have_lock || (&#123;</span><br><span class="line">                    assert(locked == <span class="number">0</span>);</span><br><span class="line">                    __libc_lock_lock(av-&gt;mutex);</span><br><span class="line">                    locked = <span class="number">1</span>;</span><br><span class="line">                    chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="number">2</span> * SIZE_SZ ||</span><br><span class="line">                        chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">                &#125;)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">                __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">                locked = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将chunk的mem部分全部设置为perturb_byte</span></span><br><span class="line">        free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">        <span class="comment">// 设置fast chunk的标记位</span></span><br><span class="line">        set_fastchunks(av);</span><br><span class="line">        <span class="comment">// 根据大小获取fast bin的索引</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">        <span class="comment">// 获取对应fastbin的头指针，被初始化后为NULL。</span></span><br><span class="line">        fb               = &amp;fastbin(av, idx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">        <span class="comment">// 使用原子操作将P插入到链表中</span></span><br><span class="line">        mchunkptr    old     = *fb, old2;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">               add</span></span><br><span class="line"><span class="comment">               (i.e., double free).  */</span></span><br><span class="line">            <span class="comment">// so we can not double free one fastbin chunk</span></span><br><span class="line">            <span class="comment">// 防止对 fast bin double free</span></span><br><span class="line">            <span class="comment">// 防御方法是通过检查上一个chunk是否和新释放的chunk地址相同</span></span><br><span class="line">            <span class="comment">// 绕过方法就是在中间夹杂一个其他chunk，比如需要doublefree A，释放顺序为：</span></span><br><span class="line">            <span class="comment">// free A、free B、free A</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">               size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">               only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">               deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">            <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">                old_idx = fastbin_index(chunksize(old));</span><br><span class="line">            p-&gt;fd = old2 = old;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) !=</span><br><span class="line">                 old2);</span><br><span class="line">        <span class="comment">// 确保fast bin的加入前与加入后相同</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并非-mmap-的空闲-chunk"><a href="#合并非-mmap-的空闲-chunk" class="headerlink" title="合并非 mmap 的空闲 chunk"></a>合并非 mmap 的空闲 chunk</h3><p><strong>只有不是 fast bin 的情况下才会触发 unlink</strong></p>
<p>首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p>
<ul>
<li>先考虑物理低地址空闲块</li>
<li>后考虑物理高地址空闲块</li>
</ul>
<p><strong>合并后的 chunk 指向合并的 chunk 的低地址。</strong></p>
<p>在没有锁的情况下，先获得锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">        __libc_lock_lock(av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br></pre></td></tr></table></figure>

<h4 id="轻量级的检测"><a href="#轻量级的检测" class="headerlink" title="轻量级的检测"></a>轻量级的检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">   top block.  */</span></span><br><span class="line"><span class="comment">// 当前free的chunk不能是top chunk</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前free的chunk的下一个chunk不能超过arena的边界</span></span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;</span><br><span class="line">                         (<span class="keyword">char</span> *) nextchunk &gt;=</span><br><span class="line">                             ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)),</span><br><span class="line">                     <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前要free的chunk的使用标记没有被标记，double free</span></span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下一个chunk的大小</span></span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="comment">// next chunk size valid check</span></span><br><span class="line"><span class="comment">// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者</span></span><br><span class="line"><span class="comment">// nextsize是否大于系统可提供的内存</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect(chunksize_nomask(nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">    __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放填充"><a href="#释放填充" class="headerlink" title="释放填充"></a>释放填充</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将指针的mem部分全部设置为perturb_byte</span></span><br><span class="line">free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure>

<h4 id="后向合并-合并低地址-chunk"><a href="#后向合并-合并低地址-chunk" class="headerlink" title="后向合并 - 合并低地址 chunk"></a>后向合并 - 合并低地址 chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="下一块不是-top-chunk-前向合并-合并高地址-chunk"><a href="#下一块不是-top-chunk-前向合并-合并高地址-chunk" class="headerlink" title="下一块不是 top chunk - 前向合并 - 合并高地址 chunk"></a>下一块不是 top chunk - 前向合并 - 合并高地址 chunk</h4><p>需要注意的是，如果下一块不是 top chunk ，则合并高地址的 chunk ，并将合并后的 chunk 放入到 unsorted bin 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果下一个chunk不是top chunk</span></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    <span class="comment">// 获取下一个 chunk 的使用状态</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">    <span class="comment">// 如果不在使用，合并，否则清空当前chunk的使用状态。</span></span><br><span class="line">    <span class="comment">/* consolidate forward */</span></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">  not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">  been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 把 chunk 放在 unsorted chunk 链表的头部</span></span><br><span class="line">    <span class="comment">// unsorted bin 链头</span></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    <span class="comment">// unsorted bin 顺数第一个（最新放入）</span></span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="comment">// 简单的检查</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;fd = fwd;</span><br><span class="line">    p-&gt;bk = bck;</span><br><span class="line">    <span class="comment">// 如果是 large chunk，那就设置nextsize指针字段为NULL。</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bck-&gt;fd = p;</span><br><span class="line">    fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    set_foot(p, size);</span><br><span class="line"></span><br><span class="line">    check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="下一块是-top-chunk-合并到-top-chunk"><a href="#下一块是-top-chunk-合并到-top-chunk" class="headerlink" title="下一块是 top chunk - 合并到 top chunk"></a>下一块是 top chunk - 合并到 top chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">  consolidate into top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="向系统返还内存"><a href="#向系统返还内存" class="headerlink" title="向系统返还内存"></a>向系统返还内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">          chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">          threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">          bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">          has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">          don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">          is reached.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         <span class="comment">// 如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line">         <span class="comment">// 一般合并到 top chunk 都会执行这部分代码。</span></span><br><span class="line">         <span class="comment">// 那就向系统返还内存</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果有 fast chunk 就进行合并</span></span><br><span class="line">            <span class="keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);</span><br><span class="line">            <span class="comment">// 主分配区</span></span><br><span class="line">            <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">                <span class="comment">// top chunk 大于当前的收缩阙值</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (chunksize(av-&gt;top)) &gt;=</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.trim_threshold))</span><br><span class="line">                    systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>      <span class="comment">// 非主分配区，则直接收缩heap</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">                   large, because the corresponding heap might go away.  */</span></span><br><span class="line">                heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">                assert(heap-&gt;ar_ptr == av);</span><br><span class="line">                heap_trim(heap, mp_.top_pad);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">            assert(locked);</span><br><span class="line">            __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放-mmap-的-chunk"><a href="#释放-mmap-的-chunk" class="headerlink" title="释放 mmap 的 chunk"></a>释放 mmap 的 chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//  If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a>systrim</h2><h2 id="heap-trim"><a href="#heap-trim" class="headerlink" title="heap_trim"></a>heap_trim</h2><h2 id="munmap-chunk"><a href="#munmap-chunk" class="headerlink" title="munmap_chunk"></a>munmap_chunk</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SkYe231</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.mrskye.cn/archives/bdc99b7b/">https://www.mrskye.cn/archives/bdc99b7b/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.mrskye.cn" target="_blank">SkYe231 Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A0%86/">堆</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/archives/fac29c2a/"><img class="prev-cover" data-lazy-src="/img/default_cover3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">linux系统调用号查询(pwn)</div></div></a></div><div class="next-post pull-right"><a href="/archives/21834a9f/"><img class="next-cover" data-lazy-src="/img/default_cover1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">静态链接程序利用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/archives/ed4b4a2a/" title="FSOP"><img class="cover" data-lazy-src="/img/default_cover0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-04-26</div><div class="title">FSOP</div></div></a></div><div><a href="/archives/dd6af626/" title="realloc学习"><img class="cover" data-lazy-src="/img/default_cover3.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2021-04-09</div><div class="title">realloc学习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">SkYe231</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">140</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:skye231@foxmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.mrskye.cn/atom.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">请修改默认公告</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">堆概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86"><span class="toc-number">1.1.</span> <span class="toc-text">什么是堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">堆的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc"><span class="toc-number">1.2.1.</span> <span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free"><span class="toc-number">1.2.2.</span> <span class="toc-text">free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%83%8C%E5%90%8E%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">内存分配背后的系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#s-brk"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">(s)brk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">mmap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">多线程支持</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">堆相关数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E8%A7%82%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">宏观结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E4%BD%8D%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.1.1.</span> <span class="toc-text">32位内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E4%BD%8D%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.1.2.</span> <span class="toc-text">64位内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.3.</span> <span class="toc-text">堆管理介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">3 种数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#heap-info"><span class="toc-number">2.1.3.1.1.</span> <span class="toc-text">heap_info</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Arena-%E6%95%B0%E9%87%8F%E9%99%90%E5%88%B6"><span class="toc-number">2.1.3.1.1.1.</span> <span class="toc-text">Arena 数量限制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Arena-%E7%AE%A1%E7%90%86"><span class="toc-number">2.1.3.1.1.2.</span> <span class="toc-text">Arena 管理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#malloc-state"><span class="toc-number">2.1.3.1.2.</span> <span class="toc-text">malloc_state</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#malloc-chunk"><span class="toc-number">2.1.3.1.3.</span> <span class="toc-text">malloc_chunk</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#heap-segment%E4%B8%8Earena%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">heap segment与arena关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E8%A7%82%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">微观结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.1.</span> <span class="toc-text">chunk 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-chunk-allocated-chunk"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">malloc_chunk (allocated chunk)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free-chunk"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">free_chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#top-chunk"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">top chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#last-remainder"><span class="toc-number">2.2.1.5.</span> <span class="toc-text">last remainder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chunk-%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-number">2.2.1.6.</span> <span class="toc-text">chunk 相关宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.2.2.</span> <span class="toc-text">bin 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fast-Bin"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">Fast Bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Small-Bin"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">Small Bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Large-Bin"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">Large Bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unsorted-Bin"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">Unsorted Bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#common-macro"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">common macro</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">2.3.</span> <span class="toc-text">参考资料</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#unlink"><span class="toc-number">3.1.</span> <span class="toc-text">unlink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-printerr"><span class="toc-number">3.2.</span> <span class="toc-text">malloc_printerr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%9D%97"><span class="toc-number">4.</span> <span class="toc-text">申请内存块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#libc-malloc"><span class="toc-number">4.1.</span> <span class="toc-text">__libc_malloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-malloc"><span class="toc-number">4.2.</span> <span class="toc-text">_int_malloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#arena"><span class="toc-number">4.2.1.</span> <span class="toc-text">arena</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin"><span class="toc-number">4.2.2.</span> <span class="toc-text">fast bin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">小总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fast-bin-malloc-%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text">fast bin malloc 检查机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#small-bin"><span class="toc-number">4.2.3.</span> <span class="toc-text">small bin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">小总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#small-bin-malloc-%E6%A3%80%E6%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.3.1.1.</span> <span class="toc-text">small bin malloc 检查机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#large-bin"><span class="toc-number">4.2.4.</span> <span class="toc-text">large bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%BE%AA%E7%8E%AF-%E9%81%8D%E5%8E%86-unsorted-bin"><span class="toc-number">4.2.5.</span> <span class="toc-text">大循环 - 遍历 unsorted bin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#unsorted-bin-%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.5.1.</span> <span class="toc-text">unsorted bin 遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SMALL-REQUEST"><span class="toc-number">4.2.5.1.1.</span> <span class="toc-text">SMALL REQUEST</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8F%96%E5%87%BA"><span class="toc-number">4.2.5.1.2.</span> <span class="toc-text">初始取出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%96%E5%87%BA-chunk-%E5%A4%A7%E5%B0%8F%E5%88%9A%E5%A5%BD%E5%90%88%E9%80%82-%EF%BC%88EXACT-FIT%EF%BC%89"><span class="toc-number">4.2.5.1.3.</span> <span class="toc-text">取出 chunk 大小刚好合适 （EXACT FIT）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E5%8F%96%E5%87%BA%E6%9D%A5-chunk-%E6%94%BE%E5%85%A5%E5%88%B0-smallbin-%EF%BC%88PLACE-CHUNK-IN-SMALL-BIN%EF%BC%89"><span class="toc-number">4.2.5.1.4.</span> <span class="toc-text">将取出来 chunk 放入到 smallbin （PLACE CHUNK IN SMALL BIN）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PLACE-CHUNK-IN-LARGE-BIN"><span class="toc-number">4.2.5.1.5.</span> <span class="toc-text">PLACE CHUNK IN LARGE BIN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%8F%96%E5%87%BA"><span class="toc-number">4.2.5.1.6.</span> <span class="toc-text">最终取出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WHILE-%E8%BF%AD%E4%BB%A3%E6%AC%A1%E6%95%B0"><span class="toc-number">4.2.5.1.7.</span> <span class="toc-text">WHILE 迭代次数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#large-chunk"><span class="toc-number">4.2.5.2.</span> <span class="toc-text">large chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E8%BE%83%E5%A4%A7-chunk"><span class="toc-number">4.2.5.3.</span> <span class="toc-text">寻找较大 chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84-MAP"><span class="toc-number">4.2.5.3.1.</span> <span class="toc-text">找到一个合适的 MAP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%90%88%E9%80%82%E7%9A%84-BIN"><span class="toc-number">4.2.5.3.2.</span> <span class="toc-text">找到合适的 BIN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%A3%80%E6%9F%A5-CHUNK"><span class="toc-number">4.2.5.3.3.</span> <span class="toc-text">简单检查 CHUNK</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9C%9F%E6%AD%A3%E5%8F%96%E5%87%BA-CHUNK"><span class="toc-number">4.2.5.3.4.</span> <span class="toc-text">真正取出 CHUNK</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-top-chunk"><span class="toc-number">4.2.6.</span> <span class="toc-text">使用 top chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8D%E5%A4%9F"><span class="toc-number">4.2.7.</span> <span class="toc-text">堆内存不够</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#libc-calloc"><span class="toc-number">4.3.</span> <span class="toc-text">_libc_calloc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sysmalloc"><span class="toc-number">4.4.</span> <span class="toc-text">sysmalloc</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">4.4.1.</span> <span class="toc-text">基本定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%99%91-mmap"><span class="toc-number">4.4.2.</span> <span class="toc-text">考虑 mmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmap-%E5%A4%B1%E8%B4%A5%E6%88%96%E8%80%85%E6%9C%AA%E5%88%86%E9%85%8D%E5%A0%86"><span class="toc-number">4.4.3.</span> <span class="toc-text">mmap 失败或者未分配堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%97%A7%E5%A0%86%E4%BF%A1%E6%81%AF"><span class="toc-number">4.4.4.</span> <span class="toc-text">记录旧堆信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%97%A7%E5%A0%86%E4%BF%A1%E6%81%AF-1"><span class="toc-number">4.4.5.</span> <span class="toc-text">检查旧堆信息 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%97%A7%E5%A0%86%E4%BF%A1%E6%81%AF-2"><span class="toc-number">4.4.6.</span> <span class="toc-text">检查旧堆信息 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E-main-arena"><span class="toc-number">4.4.7.</span> <span class="toc-text">非 main_arena</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Main-arena-%E5%A4%84%E7%90%86"><span class="toc-number">4.4.8.</span> <span class="toc-text">Main_arena 处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%86%85%E5%AD%98"><span class="toc-number">4.4.8.1.</span> <span class="toc-text">计算内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E8%BF%9E%E7%BB%AD"><span class="toc-number">4.4.8.2.</span> <span class="toc-text">是否连续</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E9%A1%B5%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.4.8.3.</span> <span class="toc-text">对齐页大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98"><span class="toc-number">4.4.8.4.</span> <span class="toc-text">申请内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%83%BD%E6%88%90%E5%8A%9F"><span class="toc-number">4.4.8.4.1.</span> <span class="toc-text">可能成功</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5"><span class="toc-number">4.4.8.4.2.</span> <span class="toc-text">失败</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8F%AF%E8%83%BD%E7%94%B3%E8%AF%B7%E6%88%90%E5%8A%9F"><span class="toc-number">4.4.8.5.</span> <span class="toc-text">内存可能申请成功</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5-1"><span class="toc-number">4.4.8.5.1.</span> <span class="toc-text">情况 1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5-2-%E6%84%8F%E5%A4%96%E5%86%85%E5%AD%98%E8%80%97%E5%B0%BD"><span class="toc-number">4.4.8.5.2.</span> <span class="toc-text">情况 2 - 意外内存耗尽</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%85%B6%E4%BB%96%E6%84%8F%E5%A4%96%E6%83%85%E5%86%B5"><span class="toc-number">4.4.8.5.3.</span> <span class="toc-text">处理其他意外情况</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98"><span class="toc-number">4.4.8.5.3.1.</span> <span class="toc-text">处理连续内存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%B8%8D%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98"><span class="toc-number">4.4.8.5.3.2.</span> <span class="toc-text">处理不连续内存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B0%83%E6%95%B4"><span class="toc-number">4.4.8.5.3.3.</span> <span class="toc-text">调整</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98"><span class="toc-number">4.4.8.6.</span> <span class="toc-text">更新最大内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E5%9D%97"><span class="toc-number">4.4.8.7.</span> <span class="toc-text">分配内存块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%A4%A7%E5%B0%8F"><span class="toc-number">4.4.8.7.1.</span> <span class="toc-text">获取大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%87%E5%88%86-TOP"><span class="toc-number">4.4.8.7.2.</span> <span class="toc-text">切分 TOP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%95%E6%8D%89%E6%89%80%E6%9C%89%E9%94%99%E8%AF%AF"><span class="toc-number">4.4.8.8.</span> <span class="toc-text">捕捉所有错误</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%9D%97"><span class="toc-number">5.</span> <span class="toc-text">释放内存块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#libc-free"><span class="toc-number">5.1.</span> <span class="toc-text">__libc_free</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-free"><span class="toc-number">5.2.</span> <span class="toc-text">_int_free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%A3%80%E6%9F%A5"><span class="toc-number">5.2.1.</span> <span class="toc-text">简单的检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fast-bin-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">fast bin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E9%9D%9E-mmap-%E7%9A%84%E7%A9%BA%E9%97%B2-chunk"><span class="toc-number">5.2.3.</span> <span class="toc-text">合并非 mmap 的空闲 chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">轻量级的检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E5%A1%AB%E5%85%85"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">释放填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%90%91%E5%90%88%E5%B9%B6-%E5%90%88%E5%B9%B6%E4%BD%8E%E5%9C%B0%E5%9D%80-chunk"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">后向合并 - 合并低地址 chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E5%9D%97%E4%B8%8D%E6%98%AF-top-chunk-%E5%89%8D%E5%90%91%E5%90%88%E5%B9%B6-%E5%90%88%E5%B9%B6%E9%AB%98%E5%9C%B0%E5%9D%80-chunk"><span class="toc-number">5.2.3.4.</span> <span class="toc-text">下一块不是 top chunk - 前向合并 - 合并高地址 chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E5%9D%97%E6%98%AF-top-chunk-%E5%90%88%E5%B9%B6%E5%88%B0-top-chunk"><span class="toc-number">5.2.3.5.</span> <span class="toc-text">下一块是 top chunk - 合并到 top chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E7%B3%BB%E7%BB%9F%E8%BF%94%E8%BF%98%E5%86%85%E5%AD%98"><span class="toc-number">5.2.3.6.</span> <span class="toc-text">向系统返还内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE-mmap-%E7%9A%84-chunk"><span class="toc-number">5.2.4.</span> <span class="toc-text">释放 mmap 的 chunk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#systrim"><span class="toc-number">5.3.</span> <span class="toc-text">systrim</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#heap-trim"><span class="toc-number">5.4.</span> <span class="toc-text">heap_trim</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#munmap-chunk"><span class="toc-number">5.5.</span> <span class="toc-text">munmap_chunk</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/cb381383/" title="2021 CVVD首届车联网漏洞挖掘赛线上初赛Writeup"><img data-lazy-src="/img/default_cover1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021 CVVD首届车联网漏洞挖掘赛线上初赛Writeup"/></a><div class="content"><a class="title" href="/archives/cb381383/" title="2021 CVVD首届车联网漏洞挖掘赛线上初赛Writeup">2021 CVVD首届车联网漏洞挖掘赛线上初赛Writeup</a><time datetime="2021-05-08T12:44:58.097Z" title="更新于 2021-05-08 20:44:58">2021-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/aa7945ba/" title="第五届蓝帽杯Writeup"><img data-lazy-src="/img/default_cover3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="第五届蓝帽杯Writeup"/></a><div class="content"><a class="title" href="/archives/aa7945ba/" title="第五届蓝帽杯Writeup">第五届蓝帽杯Writeup</a><time datetime="2021-05-07T16:26:42.079Z" title="更新于 2021-05-08 00:26:42">2021-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/38aa2360/" title="2021年全国网络空间安全技术大赛Writeup"><img data-lazy-src="/img/default_cover0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2021年全国网络空间安全技术大赛Writeup"/></a><div class="content"><a class="title" href="/archives/38aa2360/" title="2021年全国网络空间安全技术大赛Writeup">2021年全国网络空间安全技术大赛Writeup</a><time datetime="2021-05-07T16:26:42.076Z" title="更新于 2021-05-08 00:26:42">2021-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/7e703b17/" title="glibc2.24下IO_FILE的利用"><img data-lazy-src="/img/default_cover0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="glibc2.24下IO_FILE的利用"/></a><div class="content"><a class="title" href="/archives/7e703b17/" title="glibc2.24下IO_FILE的利用">glibc2.24下IO_FILE的利用</a><time datetime="2021-05-01T05:30:28.906Z" title="更新于 2021-05-01 13:30:28">2021-05-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/625c64bd/" title="House of orange"><img data-lazy-src="/img/default_cover0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="House of orange"/></a><div class="content"><a class="title" href="/archives/625c64bd/" title="House of orange">House of orange</a><time datetime="2021-05-01T05:10:47.058Z" title="更新于 2021-05-01 13:10:47">2021-05-01</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default_cover2.png')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By SkYe231</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="https://cloud.tencent.com/product/wh?from=12331" target="_blank">Hosted BY 云开发 Cloudbase</a>&nbsp;|&nbsp;<a href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target="_blank"><img src="https://mrskye.cn-gd.ufileos.com/img/2020-07-01-lGwrnPz3GuV4odmM.png" align="top" style="width:48px"></a><br /><div class="github-badge"><a rel="license" href="http://beian.miit.gov.cn/" target="_blank" title="粤ICP备20056619号"><span class="badge-subject">粤ICP备</span><span class="badge-value bg-black">20056619号</span></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>